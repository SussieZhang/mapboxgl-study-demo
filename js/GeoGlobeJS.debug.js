/**
 * @private
 */
window.GeoGlobe = {
    singleFile: true
};


//加载GeoGlobeJSAPI库文件
/**
 * @private
 */
(function(){
    /**
     * Namespace: GeoGlobe
     * GeoGlobe 是整个 GeoGlobeSDK 地图 API 的命名空间，本手册中介绍的所有类和对象都通过 GeoGlobe.XXX 的方式调用。
     * 如创建一个 LonLat 对象：new GeoGlobe.LonLat(121.123458,34.534227)。
     */
    window.GeoGlobe = window.GeoGlobe || {};
    window.GeoGlobe.LngLatBounds = {};
    window.GeoGlobe.LngLat = {};
    window.GeoGlobe.Point = mapboxgl.Point;
	window.GeoGlobe.BoxHandler = mapboxgl.BoxHandler;
    window.GeoGlobe.Class = {};
    window.GeoGlobe.Layer = {};
    window.GeoGlobe.Source = {};
    window.GeoGlobe.Event = {};
    window.GeoGlobe.Control = {};
    window.GeoGlobe.Marker = {};
    window.GeoGlobe.Popup = {};
    window.GeoGlobe.Filter = {};
    window.GeoGlobe.Format = {};
    window.GeoGlobe.Analysis = {};
    window.GeoGlobe.Protocol = {};
    window.GeoGlobe.Query = {};
    window.GeoGlobe.Statistic = {};
    window.GeoGlobe.HeatMap ={};
    window.GeoGlobe.LayerGroup ={};
    window.GeoGlobe.Protocol ={};
    window.GeoGlobe.Service = {};
	window.GeoGlobe.DynamicFeature ={};
    window.GeoGlobe.DynamicTrace = {};
    /**
     * Method: getScriptArg
     * 获取script src的参数。
     *
     * Parameters:
     * key - {String} 参数键。
     *
     * Returns:
     * {String} 参数键对应的值。
     */
    GeoGlobe.getScriptArg = function(key){
        var scripts = document.getElementsByTagName("script");
        var script = scripts[scripts.length-1];
        var src = script.src;
        return (src.match(new RegExp("(?:\\?|&)"+key+"=(.*?)(?=&|$)"))||['',null])[1];
    };

    if (!GeoGlobe.singleFile) {
        //导入js文件库
        var scriptName = "GeoGlobeJSAPI.js";
        var jsfiles = [
            "View2D/tool/Class.js",
            "View2D/tool/dom.js",
            "View2D/tool/Util.js",//sw
            "View2D/tool/Proj4cn.js",
            "View2D/tool/ProjAxisOrder.js",
            "View2D/tool/Projection.js",
			"View2D/BaseTypes/BaseTypes.js",//sw
            "View2D/BaseTypes/Pixel.js",//sw
            "View2D/BaseTypes/Size.js",//sw
            "View2D/BaseTypes/Date.js",
            "View2D/tool/Console.js",//sw
			"View2D/tool/Request/Request.js",
            "View2D/tool/Request/XMLHttpRequest.js",
			
            "View2D/map/Map.js",
            "View2D/geo/Lng_Lat_bounds_geo.js",
            "View2D/geo/Lng_Lat_geo.js",
            "View2D/Layer/Layer.js",
            "View2D/Layer/wmsLayer.js",
            "View2D/Layer/wmtsLayer.js",
			 "View2D/Layer/WMTS.js",
            "View2D/Layer/WMS.js",
			"View2D/Layer/GeoTileLayer.js",
			"View2D/Layer/GeoWMTSLayer.js",
            "View2D/Layer/vectortileLayer.js",
            "View2D/Layer/VTS.js",
            "View2D/Layer/RasterLayer.js",
            "View2D/Layer/FillLayer.js",
            "View2D/Layer/CircleLayer.js",
            "View2D/Layer/SymbolLayer.js",
            "View2D/Layer/FillExtrusionLayer.js",
            "View2D/Layer/LineLayer.js",
            "View2D/Layer/BackgroundLayer.js",
            "View2D/Layer/ThematicTileLayer.js",
            "View2D/Layer/CanvasLayer.js",
			"View2D/Layer/TDTLayer.js",
			"View2D/Layer/HotArea.js",
            "View2D/Source/Source.js",
            "View2D/Source/GeoJSONSource.js",
            "View2D/Source/RasterSource.js",
            "View2D/Source/ImageSource.js",
            "View2D/Source/VectorSource.js",
            "View2D/Source/VideoSource.js",
            "View2D/Source/CanvasSource.js",
            "View2D/Marker/Marker.js",
            "View2D/Popup/Popup.js",
            "View2D/control/Control.js",
            "View2D/control/Navigation.js",
            "View2D/control/Attribution.js",
            "View2D/control/Scale.js",
            "View2D/control/Geolocate.js",
            "View2D/control/MapContextMenu.js",
            "View2D/event/Event.js",
            "View2D/event/mapMouseEvent.js",
            "View2D/event/mapTouchEvent.js",
            "View2D/event/mapDataEvent.js",
            "View2D/event/mapBoxZoomEvent.js",
            "View2D/handler/Handler.js",
            "View2D/handler/BoxZoomHandler.js",
            "View2D/handler/DoubleClickZoomHandler.js",
            "View2D/handler/DragPanHandler.js",
            "View2D/handler/DragRotateHandler.js",
            "View2D/handler/KeyboardHandler.js",
            "View2D/handler/ScrollZoomHandler.js",
            "View2D/handler/TouchZoomRotateHandler.js",
            "View2D/AutoFeature/DynamicTrace.js",
            "View2D/AutoFeature/DynamicFeature.js",
			
			"View2D/Geometry/Geometry.js",//sw
            "View2D/Geometry/Collection.js",//sw
            "View2D/Geometry/Point.js",//sw
            "View2D/Geometry/MultiPoint.js",//sw
            "View2D/Geometry/Curve.js",//sw
            "View2D/Geometry/LineString.js",//sw
            "View2D/Geometry/LinearRing.js",//sw
            "View2D/Geometry/Polygon.js",//sw
            "View2D/Geometry/MultiLineString.js",//sw
            "View2D/Geometry/MultiPolygon.js",//sw
			"View2D/Feature/Feature.js",//sw
			//"OpenLayers/Strategy.js",
			"View2D/Filter/Filter.js",
			"View2D/Filter/FeatureId.js",
            "View2D/Filter/Logical.js",
            "View2D/Filter/Comparison.js",
            "View2D/Filter/Spatial.js",
            "View2D/Filter/Function.js",
			"View2D/Protocol/Protocol.js",
			"View2D/Protocol/HTTP.js",
			"View2D/Protocol/WFS.js",
            "View2D/Protocol/WFS/v1.js",
            "View2D/Protocol/WFS/v1_0_0.js",
            "View2D/Protocol/WFS/v1_1_0.js",
			"View2D/Protocol/CSW.js",
            "View2D/Protocol/CSW/v2_0_2.js",
			"View2D/Protocol/Script.js",
		
			"View2D/Format/Format.js",
            "View2D/Format/XML.js",
            "View2D/Format/XML/VersionedOGC.js",
	
			"View2D/Format/GML.js",
            "View2D/Format/GML/Base.js",
            "View2D/Format/GML/v2.js",
            "View2D/Format/GML/v3.js",
			"View2D/Format/KML.js",//sp
            "View2D/Format/OWSCommon.js",//sp
            "View2D/Format/OWSCommon/v1.js",//sp
            "View2D/Format/OWSCommon/v1_0_0.js",//sp
            "View2D/Format/OWSCommon/v1_1_0.js",//sp
			"View2D/Format/WFSCapabilities.js",
            "View2D/Format/WFSCapabilities/v1.js",
            "View2D/Format/WFSCapabilities/v1_0_0.js",
            "View2D/Format/WFSCapabilities/v1_1_0.js",
            "View2D/Format/WFSDescribeFeatureType.js",
            "View2D/Format/WKT.js",//sp
            "View2D/Format/CQL.js",
			"View2D/Format/Filter.js",
            "View2D/Format/Filter/v1.js",
            "View2D/Format/Filter/v1_0_0.js",
            "View2D/Format/Filter/v1_1_0.js",
			"View2D/Format/WFST.js",
            "View2D/Format/WFST/v1.js",
            "View2D/Format/WFST/v1_0_0.js",
            "View2D/Format/WFST/v1_1_0.js",
			"View2D/Format/JSON.js",
            "View2D/Format/GeoJSON.js",
			"View2D/Format/Util/WMTS.js",
            "View2D/Format/Util/WMS.js",
            "View2D/Format/Util/VTS.js",
			"View2D/Format/WMSCapabilities.js",
            "View2D/Format/WMSCapabilities/v1.js",
            "View2D/Format/WMSCapabilities/v1_1.js",
            "View2D/Format/WMSCapabilities/v1_1_0.js",
            "View2D/Format/WMSCapabilities/v1_1_1.js",
            "View2D/Format/WMSCapabilities/v1_1_1_WMSC.js",
            "View2D/Format/WMSCapabilities/v1_3.js",
            "View2D/Format/WMSCapabilities/v1_3_0.js",
            "View2D/Format/WMSUtil.js",
			
            "View2D/Format/WMTSCapabilities.js",
			"View2D/Format/WMTSCapabilities/v1_0_0.js",
            "View2D/Format/WMTSUtil.js",
			"View2D/Format/VTSCapabilities.js",
            "View2D/Format/VTSCapabilities/v1_0_0.js",
			
            "View2D/Format/WPSCapabilities.js",//sp
            "View2D/Format/WPSCapabilities/v1_0_0.js",//sp
			"View2D/Format/WCSGetCoverage.js",//sp
			"View2D/Format/WPSExecute.js",//sp
			"View2D/Format/OGCExceptionReport.js",//sw
			"View2D/Format/QueryStringFilter.js",//sp
			"View2D/Format/BusCapabilities.js",//sp
			"View2D/Format/XML2JSON.js",//sp
			"View2D/Format/CSWGetRecords.js",
            "View2D/Format/CSWGetRecords/v2_0_2.js",
            "View2D/Format/QueryStringFilter.js",
            "View2D/Format/X2JS.js",
			
			"View2D/Analysis/BufferAnalysis.js",//sp
			"View2D/Analysis/GetFeature.js",//sp
			"View2D/Analysis/SpatialAnalysis.js",//sp
			"View2D/Analysis/CoreBufferAnalysis.js",//sp
			"View2D/Query/Service.js",//sp
			"View2D/Query/RouteQuery.js",//sp
			"View2D/Query/RoutesResult.js",//sp
			"View2D/Query/RouteInfoResult.js",//sp
			"View2D/Query/BusQuery.js",//sp
			"View2D/Query/WFSQuery.js",
			"View2D/Query/GeoCodingQuery.js",
			"View2D/Query/GeoCodingQuery/v1.js",
			"View2D/Query/GeoCodingQuery/v1_0_0.js",
			"View2D/Query/GeoCodingQuery/v1_1_0.js",
			//"View2D/Query/GEFSQuery.js",
			//"View2D/Query/GEFSQuery/v1.js",
			//"View2D/Query/GEFSQuery/v1_0_0.js",
			"View2D/Heatmap/HeatMap.js",
			"View2D/BaseLayerGroup/BaseLayerGroup.js",
            "View2D/Service/Service.js",
            "View2D/Service/WFST.js",
			"View2D/Service/CTS.js",
			"View2D/Service/VTS.js",
            "View2D/Service/WMS.js",
            "View2D/Service/WMTS.js",
            "View2D/Service/DTJ.js",
            "View2D/Service/Fonts.js",
			"View2D/Statistics/GeoStatisticsService.js",

			"View2D/ElementContainer/ElementContainer.js",
			"View2D/ElementContainer/MaptalksEC.js",
			
			"View2D/tool/Lang.js",
            "View2D/tool/Lang/en.js",
            "View2D/tool/Lang/zh-CN.js"
        ];

        var scriptLocation = "";
        var isGlb = new RegExp("(^|(.*?\\/))(" + scriptName + ")(\\?|$)");

        var scripts = document.getElementsByTagName('script');
        for (var i = 0, len = scripts.length; i < len; i++) {
            var src = scripts[i].getAttribute('src');
            if (src) {
                var match = src.match(isGlb);
                if (match) {
                    scriptLocation = match[1];
                    break;
                }
            }
        }

        var allScriptTags = new Array(jsfiles.length);
        for (var i = 0, len = jsfiles.length; i < len; i++) {
            allScriptTags[i] = "<script src='" + scriptLocation + jsfiles[i] + "'></script>";
        }
        if (allScriptTags.length > 0) {
            document.write(allScriptTags.join(""));
        }
    }
    function removeNode(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }

    /**
     * Property: scriptName
     * {String} GeoGlobeJSAPI脚本文件名，默认值为"GeoGlobeJSAPI.js"。当前使用GeoGlobe.getScriptLocation方法
     * 时，该方法将依据本属性值获取GeoGlobeJSAPI所在目录路径。如果引入GeoGlobeJSAPI所用的脚本文件名
     * 不为默认值"GeoGlobeJSAPI.js"，用户可以根据实际情况自己修改。
     */
    GeoGlobe.scriptName = (!GeoGlobe.singleFile) ? "GeoGlobeJSAPI/GeoGlobeJSAPI.js" : "GeoGlobeJS.min.js";

    /**
     * Method: getScriptLocation
     * 获取GeoGlobeJSAPI脚本文件名库脚本文件所在路径。
     *
     * Returns:
     * {String} GeoGlobeJSAPI脚本文件所在路径。
     */
    GeoGlobe.getScriptLocation = function () {
        var scriptLocation = "";
        var isGV = new RegExp("(^|(.*?\\/))(" + GeoGlobe.scriptName + ")(\\?|$)");

        var scripts = document.getElementsByTagName('script');
        for (var i=0, len=scripts.length; i<len; i++) {
            var src = scripts[i].getAttribute('src');
            if (src) {
                var match = src.match(isGV);
                if(match) {
                    scriptLocation = match[1];
                    break;
                }
            }
        }
        return scriptLocation;
    };

    /**
     * Property: imagesPath
     * {String} 指定图片所在路径,三维插件只能接受绝对地址的图片，此处图片路径如:http:www.geostar.com.cn/images/ 或 c:\\images\\。
     */
    GeoGlobe.imagesPath = "";

    /**
     * Method: createNS
     * 创建名字空间,如果指定名字空间中的某一级已经存在不会覆盖已有内容。
     *
     * Parameters:
     * ns - {String} 名称空间。
     *
     */
    GeoGlobe.createNS = function(ns){
        var nsArr = ns.split(".");
        var currObj = window;
        for(var i=0; i<nsArr.length; i++){
            if(!currObj[nsArr[i]]){
                currObj[nsArr[i]] = {};
            }
            currObj = currObj[nsArr[i]];
        }
    };
	
	/**
	 * Property: VERSION_NUMBER
	 * GeoGlobeSDK JS API的版本号。
	 */
	GeoGlobe.VERSION_NUMBER = "GeoGlobeJSAPI 2018 -- $Version: 0.44.2 build-20181031 $";
})();


/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */
/**
 * @class GeoGlobe.Class
 * @classdesc Base class used to construct all other classes. Includes support for multiple inheritance.
 * This constructor is new in OpenLayers 2.5.  At OpenLayers 3.0, the old 
 *     syntax for creating classes and dealing with inheritance 
 *     will be removed.
 * @private
 * @example
 * To create a new OpenLayers-style class, use the following syntax:
 * (code)
 *     var MyClass = OpenLayers.Class(prototype);
 * (end)
 *
 * To create a new OpenLayers-style class with multiple inheritance, use the
 *     following syntax:
 * (code)
 *     var MyClass = OpenLayers.Class(Class1, Class2, prototype);
 * (end)
 * 
 * Note that instanceof reflection will only reveal Class1 as superclass.
 *
 */
GeoGlobe.Class = function() {
    var len = arguments.length;
    var P = arguments[0];
    var F = arguments[len-1];

    var C = typeof F.initialize == "function" ?
        F.initialize :
        function(){ P.prototype.initialize.apply(this, arguments); };

    if (len > 1) {
        var newArgs = [C, P].concat(
                Array.prototype.slice.call(arguments).slice(1, len-1), F);
        //GeoGlobe.inherit.apply(null, newArgs);
    } else {
        C.prototype = F;
    }
    return C;
};
GeoGlobe.Class4OL = function() {
    var len = arguments.length;
    var P = arguments[0];
    var F = arguments[len-1];

    var C = typeof F.initialize == "function" ?
        F.initialize :
        function(){ P.prototype.initialize.apply(this, arguments); };

    if (len > 1) {
        var newArgs = [C, P].concat(
                Array.prototype.slice.call(arguments).slice(1, len-1), F);
        GeoGlobe.inherit.apply(null, newArgs);
    } else {
        C.prototype = F;
    }
    return C;
};

/**
 * @memberof GeoGlobe.Class.prototype
 * @param {Object} C  - the class that inherits
 * @param {Object} P  - the superclass to inherit from
 *
 * In addition to the mandatory C and P parameters, an arbitrary number of
 * objects can be passed, which will extend C.
 */
GeoGlobe.inherit = function(C, P) {
   var F = function() {};
   F.prototype = P.prototype;
   C.prototype = new F;
   var i, l, o;
   for(i=2, l=arguments.length; i<l; i++) {
       o = arguments[i];
       if(typeof o === "function") {
           o = o.prototype;
       }
       GeoGlobe.Util.extend(C.prototype, o);
   }
};

/**
 * extend
 * Copy all properties of a source object to a destination object.  Modifies
 *     the passed in destination object.  Any properties on the source object
 *     that are set to undefined will not be (re)set on the destination object.
 * @memberof GeoGlobe.Class.prototype
 * @param {Object} destination  - The object that will be modified
 * @param {Object} source  - The object with properties to be set on the destination
 *
 * @returns {Object}  - The destination object.
 */
GeoGlobe.Util = GeoGlobe.Util || {};
GeoGlobe.Util.extend = function(destination, source) {
    destination = destination || {};
    if (source) {
        for (var property in source) {
            var value = source[property];
            if (value !== undefined) {
                destination[property] = value;
            }
        }

        /**
         * IE doesn't include the toString property when iterating over an object's
         * properties with the for(property in object) syntax.  Explicitly check if
         * the source has its own toString property.
         */

        /*
         * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
         * prototype object" when calling hawOwnProperty if the source object
         * is an instance of window.Event.
         */

        var sourceIsEvt = typeof window.Event == "function"
                          && source instanceof window.Event;

        if (!sourceIsEvt
           && source.hasOwnProperty && source.hasOwnProperty("toString")) {
            destination.toString = source.toString;
        }
    }
    return destination;
};
/**
 * 原生js实现$.extend深度继承，支持继承多个对象
 * @memberof GeoGlobe.Util
 * @param {Object} target 目标对象
 * @param {Object} obj1 源对象1
 * @param {Object} obj2 源对象2
 * @return {Object} target 目标对象
 */
GeoGlobe.Util.deepExtend = function (target) {
    for (var i = 1; i < arguments.length; i++) {
        for (var property in arguments[i]) {
            if (arguments[i].hasOwnProperty(property)) {
                switch (GeoGlobe.Util.getType(arguments[i][property])) {
                    case 'array':
                        if (target.hasOwnProperty(property) && GeoGlobe.Util.getType(target[property]) === 'array') {
                            GeoGlobe.Util.deepExtend(target[property], arguments[i][property]);
                        } else {
                            target[property] = GeoGlobe.Util.deepExtend([], arguments[i][property]);
                        }
                        break;
                    case 'object':
                        if (target.hasOwnProperty(property) && GeoGlobe.Util.getType(target[property]) === 'object') {
                            GeoGlobe.Util.deepExtend(target[property], arguments[i][property]);
                        } else {
                            target[property] = GeoGlobe.Util.deepExtend({}, arguments[i][property]);
                        }
                        break;
                    default:
                        target[property] = arguments[i][property];
                        break;
                }
            }
        }
    }
    return target;
};
/**
 * @private
 */
(function(){
	GeoGlobe.DOM = GeoGlobe.DOM || {};
	GeoGlobe.DOM.create = function (tagName, className, container) {
	    var el = window.document.createElement(tagName);
	    if (className) el.className = className;
	    if (container) container.appendChild(el);
	    return el;
	};
	
	var docStyle = window.document.documentElement.style;
	
	function testProp(props) {
	    for (var i = 0; i < props.length; i++) {
	        if (props[i] in docStyle) {
	            return props[i];
	        }
	    }
	    return props[0];
	}
	
	var selectProp = testProp(['userSelect', 'MozUserSelect', 'WebkitUserSelect', 'msUserSelect']),
	    userSelect;
	GeoGlobe.DOM.disableDrag = function () {
	    if (selectProp) {
	        userSelect = docStyle[selectProp];
	        docStyle[selectProp] = 'none';
	    }
	};
	GeoGlobe.DOM.enableDrag = function () {
	    if (selectProp) {
	        docStyle[selectProp] = userSelect;
	    }
	};
	
	var transformProp = testProp(['transform', 'WebkitTransform']);
	GeoGlobe.DOM.setTransform = function(el, value) {
	    el.style[transformProp] = value;
	};
	
	// Suppress the next click, but only if it's immediate.
	function suppressClick(e) {
	    e.preventDefault();
	    e.stopPropagation();
	    window.removeEventListener('click', suppressClick, true);
	}
	GeoGlobe.DOM.suppressClick = function() {
	    window.addEventListener('click', suppressClick, true);
	    window.setTimeout(function() {
	        window.removeEventListener('click', suppressClick, true);
	    }, 0);
	};
	
	GeoGlobe.DOM.mousePos = function (el, e) {
	    var rect = el.getBoundingClientRect();
	    e = e.touches ? e.touches[0] : e;
	    return new mapboxgl.Point(
	        e.clientX - rect.left - el.clientLeft,
	        e.clientY - rect.top - el.clientTop
	    );
	};
	
	GeoGlobe.DOM.touchPos = function (el, e) {
	    var rect = el.getBoundingClientRect(),
	        points = [];
	    var touches = (e.type === 'touchend') ? e.changedTouches : e.touches;
	    for (var i = 0; i < touches.length; i++) {
	        points.push(new mapboxgl.Point(
	            touches[i].clientX - rect.left - el.clientLeft,
	            touches[i].clientY - rect.top - el.clientTop
	        ));
	    }
	    return points;
	};
	
	GeoGlobe.DOM.remove = function(node) {
	    if (node.parentNode) {
	        node.parentNode.removeChild(node);
	    }
	};
})();/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * 常用的工具方法
 * @namespace  GeoGlobe.Util
 * @private
 */
GeoGlobe.Util = GeoGlobe.Util || {};

/** 
 *
 * This is the old $() from prototype
 * @memberof GeoGlobe.Util
 * @param  {String | DOMElement | Window} e
 *
 * @returns {Array(DOMElement)| DOMElement}
 */
GeoGlobe.Util.getElement = function() {
    var elements = [];

    for (var i=0, len=arguments.length; i<len; i++) {
        var element = arguments[i];
        if (typeof element == 'string') {
            element = document.getElementById(element);
        }
        if (arguments.length == 1) {
            return element;
        }
        elements.push(element);
    }
    return elements;
};

/**
 *
 * A cross-browser implementation of "e instanceof Element".
 * @memberof GeoGlobe.Util
 * @param {Object} o  - The object to test.
 *
 * @returns {Boolean}
 */
GeoGlobe.Util.isElement = function(o) {
    return !!(o && o.nodeType === 1);
};

/**
 *
 * Tests that the provided object is an array.
 * This test handles the cross-IFRAME case not caught
 * by "a instanceof Array" and should be used instead.
 * @memberof GeoGlobe.Util
 * @param {Object} a  - the object test.
 * 
 * @returns {Boolean}  - true if the object is an array.
 */
GeoGlobe.Util.isArray = function(a) {
    return (Object.prototype.toString.call(a) === '[object Array]');
};

/** 
 *
 * Remove an object from an array. Iterates through the array to find the item, then removes it.
 * @memberof GeoGlobe.Util
 * @param {Array} array
 * @param {Object} item
 * 
 * @returns {Array}  - A reference to the array
 */
GeoGlobe.Util.removeItem = function(array, item) {
    for(var i = array.length - 1; i >= 0; i--) {
        if(array[i] == item) {
            array.splice(i,1);
            //break;more than once??
        }
    }
    return array;
};

/** 
 *
 * Seems to exist already in FF, but not in MOZ.
 * @memberof GeoGlobe.Util
 * @param {Array} array
 * @param {Obj} item
 * 
 * @returns {Integer}  - The index at which the first object was found in the array.If not found, returns -1.
 */
GeoGlobe.Util.indexOf = function(array, obj) {
    // use the build-in function if available.
    if (typeof array.indexOf == "function") {
        return array.indexOf(obj);
    } else {
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] == obj) {
                return i;
            }
        }
        return -1;   
    }
};


/**
 * Compiled regular expression to match dots (".").  This is used for replacing
 *     dots in identifiers.  Because object identifiers are frequently used for
 *     DOM element identifiers by the library, we avoid using dots to make for
 *     more sensible CSS selectors.
 * @memberof GeoGlobe.Util
 *
 * TODO: Use a module pattern to avoid bloating the API with stuff like this.
 */
GeoGlobe.Util.dotless = /\./g;

/**
 *
 * Modifies many properties of a DOM element all at once.  Passing in 
 * null to an individual parameter will avoid setting the attribute.
 * @memberof GeoGlobe.Util
 * @param {DOMElement} element  - DOM element to modify.
 * @param {String} id  - The element id attribute to set.  Note that dots (".") will be
 *     replaced with underscore ("_") in setting the element id.
 * @param {GeoGlobe.Pixel|Object} px  -  The element left and top position,
 *                                  GeoGlobe.Pixel or an object with
 *                                  a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz  -  The element width and height,
 *                                 GeoGlobe.Size or an object with a
 *                                 'w' and 'h' properties.
 * @param {String} position  - The position attribute.  eg: absolute,relative, etc.
 * @param {String} border  -  The style.border attribute.  eg: solid black 2px
 * @param {String} overflow  -  The style.overview attribute.
 * @param {Float} opacity  -  Fractional value (0.0 - 1.0)
 */
/*
GeoGlobe.Util.modifyDOMElement = function(element, id, px, sz, position, 
                                            border, overflow, opacity) {

    if (id) {
        element.id = id.replace(GeoGlobe.Util.dotless, "_");
    }
    if (px) {
        element.style.left = px.x + "px";
        element.style.top = px.y + "px";
    }
    if (sz) {
        element.style.width = sz.w + "px";
        element.style.height = sz.h + "px";
    }
    if (position) {
        element.style.position = position;
    }
    if (border) {
        element.style.border = border;
    }
    if (overflow) {
        element.style.overflow = overflow;
    }
    if (parseFloat(opacity) >= 0.0 && parseFloat(opacity) < 1.0) {
        element.style.filter = 'alpha(opacity=' + (opacity * 100) + ')';
        element.style.opacity = opacity;
    } else if (parseFloat(opacity) == 1.0) {
        element.style.filter = '';
        element.style.opacity = '';
    }
};
*/
/** 
 *
 * Creates a new div and optionally set some standard attributes.
 * Null may be passed to each parameter if you do not wish to
 * set a particular attribute.
 * @memberof GeoGlobe.Util
 * Note - zIndex is NOT set on the resulting div.
 * 

 * @param {String} id  - An identifier for this element.  If no id is
 *               passed an identifier will be created 
 *               automatically.  Note that dots (".") will be replaced with
 *               underscore ("_") when generating ids.
 * @param {GeoGlobe.Pixel|Object} px   - The element left and top position,
 *                                  GeoGlobe.Pixel or an object with a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz  - The element width and height,
 *                                 GeoGlobe.Size or an object with a 'w' and 'h' properties.
 * @param {String} imgURL  -  A url pointing to an image to use as a background image.
 * @param {String} position  -  The style.position value. eg: absolute,relative etc.
 * @param {String} border  -  The the style.border value. eg: 2px solid black
 * @param {String} overflow -  The style.overflow value. Eg. hidden
 * @param {Float} opacity  - Fractional value (0.0 - 1.0)
 * 
 * @returns {DOMElement}   - A DOM Div created with the specified attributes.
 */
/*
GeoGlobe.Util.createDiv = function(id, px, sz, imgURL, position, 
                                     border, overflow, opacity) {

    var dom = document.createElement('div');

    if (imgURL) {
        dom.style.backgroundImage = 'url(' + imgURL + ')';
    }

    //set generic properties
    if (!id) {
        id = GeoGlobe.Util.createUniqueID("GeoGlobeDiv");
    }
    if (!position) {
        position = "absolute";
    }
    GeoGlobe.Util.modifyDOMElement(dom, id, px, sz, position, 
                                     border, overflow, opacity);

    return dom;
};
*/
/**
 *
 * Creates an img element with specific attribute values.
 *  @memberof GeoGlobe.Util

 * @param {String} id  - The id field for the img.  If none assigned one will be automatically generated.
 * @param {GeoGlobe.Pixel|Object} px -  The element left and top position,
 *                                  GeoGlobe.Pixel or an object with a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz -  The element width and height,
 *                                 GeoGlobe.Size or an object with a 'w' and 'h' properties.
 * @param {String} imgURL -The url to use as the image source.
 * @param {String} position - The style.position value.
 * @param {String} border  -  The border to place around the image.
 * @param {Float} opacity  -  Fractional value (0.0 - 1.0)
 * @param {Boolean} delayDisplay -If true waits until the image has been loaded.
 * 
 * @returns {DOMElement}  - A DOM Image created with the specified attributes.
/*
 * @example
GeoGlobe.Util.createImage = function(id, px, sz, imgURL, position, border,
                                       opacity, delayDisplay) {

    var image = document.createElement("img");

    //set generic properties
    if (!id) {
        id = GeoGlobe.Util.createUniqueID("OpenLayersDiv");
    }
    if (!position) {
        position = "relative";
    }
    GeoGlobe.Util.modifyDOMElement(image, id, px, sz, position, 
                                     border, null, opacity);

    if (delayDisplay) {
        image.style.display = "none";
        function display() {
            image.style.display = "";
            OpenLayers.Event.stopObservingElement(image);
        }
        OpenLayers.Event.observe(image, "load", display);
        OpenLayers.Event.observe(image, "error", display);
    }
    
    //set special properties
    image.style.alt = id;
    image.galleryImg = "no";
    if (imgURL) {
        image.src = imgURL;
    }
        
    return image;
};
*/

/**
 *How many times should we try to reload an image before giving up? Default is 0
 *  @memberof GeoGlobe.Util
 *   @type {Integer}
 */
GeoGlobe.IMAGE_RELOAD_ATTEMPTS = 0;

/**
 * true if the png alpha hack is necessary and possible, false otherwise.
 * @memberof GeoGlobe.Util
 * @type {Boolean}
 */
GeoGlobe.Util.alphaHackNeeded = null;

/**
 *
 * Checks whether it's necessary (and possible) to use the png alpha
 * hack which allows alpha transparency for png images under Internet
 * Explorer.
 *  @memberof GeoGlobe.Util
 * @returns {Boolean}   - true if the png alpha hack is necessary and possible, false otherwise.
 */
GeoGlobe.Util.alphaHack = function() {
    if (GeoGlobe.Util.alphaHackNeeded == null) {
        var arVersion = navigator.appVersion.split("MSIE");
        var version = parseFloat(arVersion[1]);
        var filter = false;
    
        // IEs4Lin dies when trying to access document.body.filters, because 
        // the property is there, but requires a DLL that can't be provided. This
        // means that we need to wrap this in a try/catch so that this can
        // continue.
    
        try { 
            filter = !!(document.body.filters);
        } catch (e) {}    
    
        GeoGlobe.Util.alphaHackNeeded = (filter && 
                                           (version >= 5.5) && (version < 7));
    }
    return GeoGlobe.Util.alphaHackNeeded;
};

/** 
 * @Function  modifyAlphaImageDiv
 * @memberof GeoGlobe.Util
 *
 * @param {DOMElement} div  - Div containing Alpha-adjusted Image
 * @param {String} id
 * @param {GeoGlobe.Pixel|Object} px  - GeoGlobe.Pixel or an object with a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz  -  GeoGlobe.Size or an object with a 'w' and 'h' properties.
 * @param {String} imgURL
 * @param {String} position
 * @param {String} border
 * @param {String} sizing   -  'crop', 'scale', or 'image'. Default is "scale"
 * @param {Float} opacity   -  Fractional value (0.0 - 1.0)
 */ 
/*
GeoGlobe.Util.modifyAlphaImageDiv = function(div, id, px, sz, imgURL, 
                                               position, border, sizing, 
                                               opacity) {

    GeoGlobe.Util.modifyDOMElement(div, id, px, sz, position,
                                     null, null, opacity);

    var img = div.childNodes[0];

    if (imgURL) {
        img.src = imgURL;
    }
    GeoGlobe.Util.modifyDOMElement(img, div.id + "_innerImage", null, sz, 
                                     "relative", border);
    
    if (GeoGlobe.Util.alphaHack()) {
        if(div.style.display != "none") {
            div.style.display = "inline-block";
        }
        if (sizing == null) {
            sizing = "scale";
        }
        
        div.style.filter = "progid:DXImageTransform.Microsoft" +
                           ".AlphaImageLoader(src='" + img.src + "', " +
                           "sizingMethod='" + sizing + "')";
        if (parseFloat(div.style.opacity) >= 0.0 && 
            parseFloat(div.style.opacity) < 1.0) {
            div.style.filter += " alpha(opacity=" + div.style.opacity * 100 + ")";
        }

        img.style.filter = "alpha(opacity=0)";
    }
};
*/
/**
 * @memberof GeoGlobe.Util
 *
 * @param {String} id
 * @param {GeoGlobe.Pixel|Object} px  -  GeoGlobe.Pixel or an object with a 'x' and 'y' properties.
 * @param {GeoGlobe.Size|Object} sz -GeoGlobe.Size or an object with a 'w' and 'h' properties.
 * @param {String} imgURL
 * @param {String} position
 * @param {String} border
 * @param {String} sizing   - 'crop', 'scale', or 'image'. Default is "scale"
 * @param {Float} opacity   - Fractional value (0.0 - 1.0)
 * @param {Boolean} delayDisplay -  If true waits until the image has been loaded.
 * 
 * @returns {DOMElement}  - A DOM Div created with a DOM Image inside it. If the hack is
 *              needed for transparency in IE, it is added.
 */
/*
GeoGlobe.Util.createAlphaImageDiv = function(id, px, sz, imgURL, 
                                               position, border, sizing, 
                                               opacity, delayDisplay) {
    
    var div = GeoGlobe.Util.createDiv();
    var img = GeoGlobe.Util.createImage(null, null, null, null, null, null, 
                                          null, delayDisplay);
    img.className = "olAlphaImg";
    div.appendChild(img);

    GeoGlobe.Util.modifyAlphaImageDiv(div, id, px, sz, imgURL, position, 
                                        border, sizing, opacity);
    
    return div;
};
*/

/** 
 *
 * Creates a new hashtable and copies over all the keys from the 
 *     passed-in object, but storing them under an uppercased
 *     version of the key at which they were stored.
 * @memberof GeoGlobe.Util
 * @param {Object} object
 * 
 * @returns {Object}  - A new Object with all the same keys but uppercased
 */
GeoGlobe.Util.upperCaseObject = function (object) {
    var uObject = {};
    for (var key in object) {
        uObject[key.toUpperCase()] = object[key];
    }
    return uObject;
};

/** 
 *
 * Takes an object and copies any properties that don't exist from
 *     another properties, by analogy with GeoGlobe.Util.extend() from
 *     Prototype.js.
 * @memberof GeoGlobe.Util
 * @param {Object} to  - The destination object.
 * @param {Object} from  -  The source object.  Any properties of this object that
 *     are undefined in the to object will be set on the to object.
 *
 * @returns {Object}  - A reference to the to object.  Note that the to argument is modified
 *     in place and returned by this function.
 */
GeoGlobe.Util.applyDefaults = function (to, from) {
    to = to || {};
    /*
     * FF/Windows < 2.0.0.13 reports "Illegal operation on WrappedNative
     * prototype object" when calling hawOwnProperty if the source object is an
     * instance of window.Event.
     */
    var fromIsEvt = typeof window.Event == "function"
                    && from instanceof window.Event;

    for (var key in from) {
        if (to[key] === undefined ||
            (!fromIsEvt && from.hasOwnProperty
             && from.hasOwnProperty(key) && !to.hasOwnProperty(key))) {
            to[key] = from[key];
        }
    }
    /**
     * IE doesn't include the toString property when iterating over an object's
     * properties with the for(property in object) syntax.  Explicitly check if
     * the source has its own toString property.
     */
    if(!fromIsEvt && from && from.hasOwnProperty
       && from.hasOwnProperty('toString') && !to.hasOwnProperty('toString')) {
        to.toString = from.toString;
    }
    
    return to;
};

/**
 * @memberof GeoGlobe.Util
 * @param {Object} params
 * 
 * @returns {String}   - A concatenation of the properties of an object in http parameter notation.
 *          (ex. i"key1=value1&key2=value2&key3=value3"/i)
 *          If a parameter is actually a list, that parameter will then
 *          be set to a comma-seperated list of values (foo,bar) instead
 *          of being URL escaped (foo%3Abar). 
 */
GeoGlobe.Util.getParameterString = function(params) {
    var paramsArray = [];
    
    for (var key in params) {
      var value = params[key];
      if ((value != null) && (typeof value != 'function')) {
        var encodedValue;
        if (typeof value == 'object' && value.constructor == Array) {
          /* value is an array; encode items and separate with "," */
          var encodedItemArray = [];
          var item;
          for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
            item = value[itemIndex];
            encodedItemArray.push(encodeURIComponent(
                (item === null || item === undefined) ? "" : item)
            );
          }
          encodedValue = encodedItemArray.join(",");
        }
        else {
          /* value is a string; simply encode */
          encodedValue = encodeURIComponent(value);
        }
        paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
      }
    }
    
    return paramsArray.join("&");
};

/**
 *
 * Appends a parameter string to a url. This function includes the logic for
 * using the appropriate character (none, & or ?) to append to the url before
 * appending the param string.
 *  @memberof GeoGlobe.Util
 * @param {String} url - The url to append to
 * @param {String} paramStr  -  The param string to append
 * 
 * @returns {String}  - The new url
 */
GeoGlobe.Util.urlAppend = function(url, paramStr) {
    var newUrl = url;
    if(paramStr) {
        var parts = (url + " ").split(/[?&]/);
        newUrl += (parts.pop() === " " ?
            paramStr :
            parts.length ? "&" + paramStr : "?" + paramStr);
    }
    return newUrl;
};

/**
 * @memberof GeoGlobe.Util
 * @returns {String}  - The fully formatted image location string
 */
GeoGlobe.Util.getImagesLocation = function() {
    return GeoGlobe.ImgPath || (GeoGlobe._getScriptLocation() + "img/");
};

/**
 * @memberof GeoGlobe.Util
 * @returns {String}   - The fully formatted location string for a specified image
 */
GeoGlobe.Util.getImageLocation = function(image) {
    return GeoGlobe.Util.getImagesLocation() + image;
};


/** 
 *
 * Execute functions until one of them doesn't throw an error. 
 *     Capitalized because "try" is a reserved word in JavaScript.
 *     Taken directly from GeoGlobe.Util.Try()
 * @memberof GeoGlobe.Util
 * @param {Function}[*]  - Any number of parameters may be passed to Try()
 *    It will attempt to execute each of them until one of them 
 *    successfully executes. 
 *    If none executes successfully, returns null.
 * 
 * @returns {*}  - The value returned by the first successfully executed function.
 */
GeoGlobe.Util.Try = function() {
    var returnValue = null;

    for (var i=0, len=arguments.length; i<len; i++) {
      var lambda = arguments[i];
      try {
        returnValue = lambda();
        break;
      } catch (e) {}
    }

    return returnValue;
};

/**
 * @memberof GeoGlobe.Util
 * @param {XMLNode} node
 * 
 * @returns {String}  - The text value of the given node, without breaking in firefox or IE
 */
GeoGlobe.Util.getXmlNodeValue = function(node) {
    var val = null;
    GeoGlobe.Util.Try( 
        function() {
            val = node.text;
            if (!val) {
                val = node.textContent;
            }
            if (!val) {
                val = node.firstChild.nodeValue;
            }
        }, 
        function() {
            val = node.textContent;
        }); 
    return val;
};

/**
 * @memberof GeoGlobe.Util
 * @param {Event} evt
 * @param {HTMLDivElement} div
 * 
 * @returns {Boolean}
 */
GeoGlobe.Util.mouseLeft = function (evt, div) {
    // start with the element to which the mouse has moved
    var target = (evt.relatedTarget) ? evt.relatedTarget : evt.toElement;
    // walk up the DOM tree.
    while (target != div && target != null) {
        target = target.parentNode;
    }
    // if the target we stop at isn't the div, then we've left the div.
    return (target != div);
};

/**
 *The number of significant digits to retain to avoid floating point precision errors.
 * @memberof GeoGlobe.Util
 *
 * We use 14 as a "safe" default because, although IEEE 754 double floats
 * (standard on most modern operating systems) support up to about 16
 * significant digits, 14 significant digits are sufficient to represent
 * sub-millimeter accuracy in any coordinate system that anyone is likely to
 * use with OpenLayers.
 *
 * If DEFAULT_PRECISION is set to 0, the original non-truncating behavior
 * of OpenLayers <2.8 is preserved. Be aware that this will cause problems
 * with certain projections, e.g. spherical Mercator.
 *
 */
GeoGlobe.Util.DEFAULT_PRECISION = 14;

/**
 *
 * Convenience method to cast an object to a Number, rounded to the
 * desired floating point precision.
 * n@Function toFloat
 * @memberof GeoGlobe.Util
 * @param {Number} number    - The number to cast and round.
 * @param {Number}  precision  - An integer suitable for use with
 *      Number.toPrecision(). Defaults to GeoGlobe.Util.DEFAULT_PRECISION.
 *      If set to 0, no rounding is performed.
 *
 * @returns {Number}  - The cast, rounded number.
 */
GeoGlobe.Util.toFloat = function (number, precision) {
    if (precision == null) {
        precision = GeoGlobe.Util.DEFAULT_PRECISION;
    }
    if (typeof number !== "number") {
        number = parseFloat(number);
    }
    return precision === 0 ? number :
                             parseFloat(number.toPrecision(precision));
};

/**
 *  @memberof GeoGlobe.Util
 * @param {Float} x
 *
 * @returns {Float}
 */
GeoGlobe.Util.rad = function(x) {return x*Math.PI/180;};

/**
 * @memberof GeoGlobe.Util
 * @param {Float} x
 *
 * @returns  {Float}
 */
GeoGlobe.Util.deg = function(x) {return x*180/Math.PI;};

/**
 * @Property {Object} VincentyConstants  - Constants for Vincenty functions.
 *  @memberof GeoGlobe.Util
 */
GeoGlobe.Util.VincentyConstants = {
    a: 6378137,
    b: 6356752.3142,
    f: 1/298.257223563
};

/**
 *
 * Given two objects representing points with geographic coordinates, this
 *     calculates the distance between those points on the surface of an
 *     ellipsoid.
 * @memberof GeoGlobe.Util
 * @param {GeoGlobe.LngLat} p1  -  (or any object with both .lat, .lng properties)
 * @param {GeoGlobe.LngLat} p2  -  (or any object with both .lat, .lng properties)
 *
 * @returns {Float}  - The distance (in km) between the two input points as measured on an
 *     ellipsoid.  Note that the input point objects must be in geographic
 *     coordinates (decimal degrees) and the return distance is in kilometers.
 */
GeoGlobe.Util.distVincenty = function(p1, p2) {
    var ct = GeoGlobe.Util.VincentyConstants;
    var a = ct.a, b = ct.b, f = ct.f;

    var L = GeoGlobe.Util.rad(p2.lng - p1.lng);
    var U1 = Math.atan((1-f) * Math.tan(GeoGlobe.Util.rad(p1.lat)));
    var U2 = Math.atan((1-f) * Math.tan(GeoGlobe.Util.rad(p2.lat)));
    var sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
    var sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);
    var lambda = L, lambdaP = 2*Math.PI;
    var iterLimit = 20;
    while (Math.abs(lambda-lambdaP) > 1e-12 && --iterLimit>0) {
        var sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);
        var sinSigma = Math.sqrt((cosU2*sinLambda) * (cosU2*sinLambda) +
        (cosU1*sinU2-sinU1*cosU2*cosLambda) * (cosU1*sinU2-sinU1*cosU2*cosLambda));
        if (sinSigma==0) {
            return 0;  // co-incident points
        }
        var cosSigma = sinU1*sinU2 + cosU1*cosU2*cosLambda;
        var sigma = Math.atan2(sinSigma, cosSigma);
        var alpha = Math.asin(cosU1 * cosU2 * sinLambda / sinSigma);
        var cosSqAlpha = Math.cos(alpha) * Math.cos(alpha);
        var cos2SigmaM = cosSigma - 2*sinU1*sinU2/cosSqAlpha;
        var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
        lambdaP = lambda;
        lambda = L + (1-C) * f * Math.sin(alpha) *
        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));
    }
    if (iterLimit==0) {
        return NaN;  // formula failed to converge
    }
    var uSq = cosSqAlpha * (a*a - b*b) / (b*b);
    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));
    var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
        B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
    var s = b*A*(sigma-deltaSigma);
    var d = s.toFixed(3)/1000; // round to 1mm precision
    return d;
};

/**
 *
 * Calculate destination point given start point lat/long (numeric degrees),
 * bearing (numeric degrees) & distance (in m).
 * Adapted from Chris Veness work, see
 * http://www.movable-type.co.uk/scripts/latlong-vincenty-direct.html
 * @memberof GeoGlobe.Util

 * @param {GeoGlobe.LngLat}  lonlat   - (or any object with both .lat, .lng
 *    properties) The start point.
 * @param {Float}  brng   - The bearing (degrees).
 * @param {Float}  dist   - The ground distance (meters).
 *
 * @returns {GeoGlobe.LngLat}  - The destination point.
 */
GeoGlobe.Util.destinationVincenty = function(lonlat, brng, dist) {
    var u = GeoGlobe.Util;
    var ct = u.VincentyConstants;
    var a = ct.a, b = ct.b, f = ct.f;

    var lon1 = lonlat.lng;
    var lat1 = lonlat.lat;

    var s = dist;
    var alpha1 = u.rad(brng);
    var sinAlpha1 = Math.sin(alpha1);
    var cosAlpha1 = Math.cos(alpha1);

    var tanU1 = (1-f) * Math.tan(u.rad(lat1));
    var cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1*cosU1;
    var sigma1 = Math.atan2(tanU1, cosAlpha1);
    var sinAlpha = cosU1 * sinAlpha1;
    var cosSqAlpha = 1 - sinAlpha*sinAlpha;
    var uSq = cosSqAlpha * (a*a - b*b) / (b*b);
    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));

    var sigma = s / (b*A), sigmaP = 2*Math.PI;
    while (Math.abs(sigma-sigmaP) > 1e-12) {
        var cos2SigmaM = Math.cos(2*sigma1 + sigma);
        var sinSigma = Math.sin(sigma);
        var cosSigma = Math.cos(sigma);
        var deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-
            B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));
        sigmaP = sigma;
        sigma = s / (b*A) + deltaSigma;
    }

    var tmp = sinU1*sinSigma - cosU1*cosSigma*cosAlpha1;
    var lat2 = Math.atan2(sinU1*cosSigma + cosU1*sinSigma*cosAlpha1,
        (1-f)*Math.sqrt(sinAlpha*sinAlpha + tmp*tmp));
    var lambda = Math.atan2(sinSigma*sinAlpha1, cosU1*cosSigma - sinU1*sinSigma*cosAlpha1);
    var C = f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));
    var L = lambda - (1-C) * f * sinAlpha *
        (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));

    var revAz = Math.atan2(sinAlpha, -tmp);  // final bearing

    return new GeoGlobe.LngLat(lon1+u.deg(L), u.deg(lat2));
};

/**
 *
 * Parse the parameters from a URL or from the current page itself into a 
 *     JavaScript Object. Note that parameter values with commas are separated
 *     out into an Array.
 * @memberof GeoGlobe.Util
 * @param {String} url - Optional url used to extract the query string.
 *                If url is null or is not supplied, query string is taken from the page location.
 * @param {Object} options  - Additional options. Optional.
 *
 * Valid options:
 * @param  {Boolean} splitArgs - Split comma delimited params into arrays? Default is true.
 * 
 * @returns Object}  - An object of key/value pairs from the query string.
 */
GeoGlobe.Util.getParameters = function(url, options) {
    options = options || {};
    // if no url specified, take it from the location bar
    url = (url === null || url === undefined) ? window.location.href : url;

    //parse out parameters portion of url string
    var paramsString = "";
    if (GeoGlobe.String.contains(url, '?')) {
        var start = url.indexOf('?') + 1;
        var end = GeoGlobe.String.contains(url, "#") ?
                    url.indexOf('#') : url.length;
        paramsString = url.substring(start, end);
    }

    var parameters = {};
    var pairs = paramsString.split(/[&;]/);
    for(var i=0, len=pairs.length; i<len; ++i) {
        var keyValue = pairs[i].split('=');
        if (keyValue[0]) {

            var key = keyValue[0];
            try {
                key = decodeURIComponent(key);
            } catch (err) {
                key = unescape(key);
            }
            
            // being liberal by replacing "+" with " "
            var value = (keyValue[1] || '').replace(/\+/g, " ");

            try {
                value = decodeURIComponent(value);
            } catch (err) {
                value = unescape(value);
            }
            
            // follow OGC convention of comma delimited values
            if (options.splitArgs !== false) {
                value = value.split(",");
            }

            //if there's only one value, do not return as array                    
            if (value.length == 1) {
                value = value[0];
            }                
            
            parameters[key] = value;
         }
     }
    return parameters;
};

/**
 * The ever-incrementing count variable. Used for generating unique ids.
 * @memberof GeoGlobe.Util
 * @type {Integer}
 */
GeoGlobe.Util.lastSeqID = 0;

/**
 *
 * Create a unique identifier for this session.  Each time this function
 *     is called, a counter is incremented.  The return will be the optional
 *     prefix (defaults to "id_") appended with the counter value.
 *  @memberof GeoGlobe.Util
 * @param {String} prefix  - Optional string to prefix unique id. Default is "id_".
 *     Note that dots (".") in the prefix will be replaced with underscore ("_").
 * 
 * @returns {String}  - A unique id string, built on the passed in prefix.
 */
GeoGlobe.Util.createUniqueID = function(prefix) {
    if (prefix == null) {
        prefix = "id_";
    } else {
        prefix = prefix.replace(GeoGlobe.Util.dotless, "_");
    }
    GeoGlobe.Util.lastSeqID += 1; 
    return prefix + GeoGlobe.Util.lastSeqID;        
};

/**
 * @Constant
 *  Constant inches per unit -- borrowed from MapServer mapscale.c
 * derivation of nautical miles from http://en.wikipedia.org/wiki/Nautical_mile
 * Includes the full set of units supported by CS-MAP (http://trac.osgeo.org/csmap/)
 * and PROJ.4 (http://trac.osgeo.org/proj/)
 * The hardcoded table is maintain in a CS-MAP source code module named CSdataU.c
 * The hardcoded table of PROJ.4 units are in pj_units.c.
 *  @memberof GeoGlobe.Util
 * @type {Object}
 */
GeoGlobe.INCHES_PER_UNIT = { 
    'inches': 1.0,
    'ft': 12.0,
    'mi': 63360.0,
    'm': 1/0.0254,//39.37,
    'km': 39370,
    'dd': 4374754,
    'yd': 36
};
GeoGlobe.INCHES_PER_UNIT["in"]= GeoGlobe.INCHES_PER_UNIT.inches;
GeoGlobe.INCHES_PER_UNIT["degrees"] = GeoGlobe.INCHES_PER_UNIT.dd;
GeoGlobe.INCHES_PER_UNIT["nmi"] = 1852 * GeoGlobe.INCHES_PER_UNIT.m;

// Units from CS-Map
GeoGlobe.METERS_PER_INCH = 0.02540005080010160020;
GeoGlobe.Util.extend(GeoGlobe.INCHES_PER_UNIT, {
    "Inch": GeoGlobe.INCHES_PER_UNIT.inches,
    "Meter": 1.0 / GeoGlobe.METERS_PER_INCH,   //EPSG:9001
    "Foot": 0.30480060960121920243 / GeoGlobe.METERS_PER_INCH,   //EPSG:9003
    "IFoot": 0.30480000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9002
    "ClarkeFoot": 0.3047972651151 / GeoGlobe.METERS_PER_INCH,   //EPSG:9005
    "SearsFoot": 0.30479947153867624624 / GeoGlobe.METERS_PER_INCH,   //EPSG:9041
    "GoldCoastFoot": 0.30479971018150881758 / GeoGlobe.METERS_PER_INCH,   //EPSG:9094
    "IInch": 0.02540000000000000000 / GeoGlobe.METERS_PER_INCH,
    "MicroInch": 0.00002540000000000000 / GeoGlobe.METERS_PER_INCH,
    "Mil": 0.00000002540000000000 / GeoGlobe.METERS_PER_INCH,
    "Centimeter": 0.01000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Kilometer": 1000.00000000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9036
    "Yard": 0.91440182880365760731 / GeoGlobe.METERS_PER_INCH,
    "SearsYard": 0.914398414616029 / GeoGlobe.METERS_PER_INCH,   //EPSG:9040
    "IndianYard": 0.91439853074444079983 / GeoGlobe.METERS_PER_INCH,   //EPSG:9084
    "IndianYd37": 0.91439523 / GeoGlobe.METERS_PER_INCH,   //EPSG:9085
    "IndianYd62": 0.9143988 / GeoGlobe.METERS_PER_INCH,   //EPSG:9086
    "IndianYd75": 0.9143985 / GeoGlobe.METERS_PER_INCH,   //EPSG:9087
    "IndianFoot": 0.30479951 / GeoGlobe.METERS_PER_INCH,   //EPSG:9080
    "IndianFt37": 0.30479841 / GeoGlobe.METERS_PER_INCH,   //EPSG:9081
    "IndianFt62": 0.3047996 / GeoGlobe.METERS_PER_INCH,   //EPSG:9082
    "IndianFt75": 0.3047995 / GeoGlobe.METERS_PER_INCH,   //EPSG:9083
    "Mile": 1609.34721869443738887477 / GeoGlobe.METERS_PER_INCH,
    "IYard": 0.91440000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9096
    "IMile": 1609.34400000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9093
    "NautM": 1852.00000000000000000000 / GeoGlobe.METERS_PER_INCH,   //EPSG:9030
    "Lat-66": 110943.316488932731 / GeoGlobe.METERS_PER_INCH,
    "Lat-83": 110946.25736872234125 / GeoGlobe.METERS_PER_INCH,
    "Decimeter": 0.10000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Millimeter": 0.00100000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Dekameter": 10.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Decameter": 10.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "Hectometer": 100.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "GermanMeter": 1.0000135965 / GeoGlobe.METERS_PER_INCH,   //EPSG:9031
    "CaGrid": 0.999738 / GeoGlobe.METERS_PER_INCH,
    "ClarkeChain": 20.1166194976 / GeoGlobe.METERS_PER_INCH,   //EPSG:9038
    "GunterChain": 20.11684023368047 / GeoGlobe.METERS_PER_INCH,   //EPSG:9033
    "BenoitChain": 20.116782494375872 / GeoGlobe.METERS_PER_INCH,   //EPSG:9062
    "SearsChain": 20.11676512155 / GeoGlobe.METERS_PER_INCH,   //EPSG:9042
    "ClarkeLink": 0.201166194976 / GeoGlobe.METERS_PER_INCH,   //EPSG:9039
    "GunterLink": 0.2011684023368047 / GeoGlobe.METERS_PER_INCH,   //EPSG:9034
    "BenoitLink": 0.20116782494375872 / GeoGlobe.METERS_PER_INCH,   //EPSG:9063
    "SearsLink": 0.2011676512155 / GeoGlobe.METERS_PER_INCH,   //EPSG:9043
    "Rod": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "IntnlChain": 20.1168 / GeoGlobe.METERS_PER_INCH,   //EPSG:9097
    "IntnlLink": 0.201168 / GeoGlobe.METERS_PER_INCH,   //EPSG:9098
    "Perch": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "Pole": 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    "Furlong": 201.1684023368046 / GeoGlobe.METERS_PER_INCH,
    "Rood": 3.778266898 / GeoGlobe.METERS_PER_INCH,
    "CapeFoot": 0.3047972615 / GeoGlobe.METERS_PER_INCH,
    "Brealey": 375.00000000000000000000 / GeoGlobe.METERS_PER_INCH,
    "ModAmFt": 0.304812252984505969011938 / GeoGlobe.METERS_PER_INCH,
    "Fathom": 1.8288 / GeoGlobe.METERS_PER_INCH,
    "NautM-UK": 1853.184 / GeoGlobe.METERS_PER_INCH,
    "50kilometers": 50000.0 / GeoGlobe.METERS_PER_INCH,
    "150kilometers": 150000.0 / GeoGlobe.METERS_PER_INCH
});

//unit abbreviations supported by PROJ.4
GeoGlobe.Util.extend(GeoGlobe.INCHES_PER_UNIT, {
    "mm": GeoGlobe.INCHES_PER_UNIT["Meter"] / 1000.0,
    "cm": GeoGlobe.INCHES_PER_UNIT["Meter"] / 100.0,
    "dm": GeoGlobe.INCHES_PER_UNIT["Meter"] * 100.0,
    "km": GeoGlobe.INCHES_PER_UNIT["Meter"] * 1000.0,
    "kmi": GeoGlobe.INCHES_PER_UNIT["nmi"],    //International Nautical Mile
    "fath": GeoGlobe.INCHES_PER_UNIT["Fathom"], //International Fathom
    "ch": GeoGlobe.INCHES_PER_UNIT["IntnlChain"],  //International Chain
    "link": GeoGlobe.INCHES_PER_UNIT["IntnlLink"], //International Link
    "us-in": GeoGlobe.INCHES_PER_UNIT["inches"], //U.S. Surveyor's Inch
    "us-ft": GeoGlobe.INCHES_PER_UNIT["Foot"], //U.S. Surveyor's Foot
    "us-yd": GeoGlobe.INCHES_PER_UNIT["Yard"], //U.S. Surveyor's Yard
    "us-ch": GeoGlobe.INCHES_PER_UNIT["GunterChain"], //U.S. Surveyor's Chain
    "us-mi": GeoGlobe.INCHES_PER_UNIT["Mile"],   //U.S. Surveyor's Statute Mile
    "ind-yd": GeoGlobe.INCHES_PER_UNIT["IndianYd37"],  //Indian Yard
    "ind-ft": GeoGlobe.INCHES_PER_UNIT["IndianFt37"],  //Indian Foot
    "ind-ch": 20.11669506 / GeoGlobe.METERS_PER_INCH  //Indian Chain
});


GeoGlobe.DOTS_PER_INCH = 96;

/**
 *  @memberof GeoGlobe.Util
 * 
 * @param {float} scale
 * 
 * @returns {Float}  - A normalized scale value, in 1 / X format.
 *         This means that if a value less than one ( already 1/x) is passed
 *         in, it just returns scale directly. Otherwise, it returns 1 / scale
 */
GeoGlobe.Util.normalizeScale = function (scale) {
    var normScale = (scale > 1.0) ? (1.0 / scale) 
                                  : scale;
    return normScale;
};

/**
 * @memberof GeoGlobe.Util
 *
 * @param {Float} scale
 * @param {String} units  -  Index into GeoGlobe.INCHES_PER_UNIT hashtable. Default is degrees
 * 
 * @returns {Float}  - The corresponding resolution given passed-in scale and unit
 *     parameters.  If the given scale is falsey, the returned resolution will be undefined.
 */
GeoGlobe.Util.getResolutionFromScale = function (scale, units) {
    var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = GeoGlobe.Util.normalizeScale(scale);
        resolution = 1 / (normScale * GeoGlobe.INCHES_PER_UNIT[units]
                                        * GeoGlobe.DOTS_PER_INCH);        
    }
    return resolution;
};

/**
 * @memberof GeoGlobe.Util
 *
 * @param {Float} resolution
 * @param {String}  units  - Index into GeoGlobe.INCHES_PER_UNIT hashtable. Default is degrees
 * 
 * @returns {Float}  - The corresponding scale given passed-in resolution and unit parameters.
 */
GeoGlobe.Util.getScaleFromResolution = function (resolution, units) {

    if (units == null) {
        units = "degrees";
    }

    var scale = resolution * GeoGlobe.INCHES_PER_UNIT[units] *
                    GeoGlobe.DOTS_PER_INCH;
    return scale;
};

/**
 *
 * Calculates the position of an element on the page (see
 * http://code.google.com/p/doctype/wiki/ArticlePageOffset)
 * @memberof GeoGlobe.Util
 * GeoGlobe.Util.pagePosition is based on Yahoo's getXY method, which is
 * Copyright (c) 2006, Yahoo! Inc.
 * All rights reserved.
 * 
 * Redistribution and use of this software in source and binary forms, with or
 * without modification, are permitted provided that the following conditions
 * are met:
 * 
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Yahoo! Inc. nor the names of its contributors may be
 *   used to endorse or promote products derived from this software without
 *   specific prior written permission of Yahoo! Inc.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * @param {DOMElement} forElement
 * 
 * @returns {Array}  - two item array, Left value then Top value.
 */
GeoGlobe.Util.pagePosition =  function(forElement) {
    // NOTE: If element is hidden (display none or disconnected or any the
    // ancestors are hidden) we get (0,0) by default but we still do the
    // accumulation of scroll position.

    var pos = [0, 0];
    var viewportElement = GeoGlobe.Util.getViewportElement();
    if (!forElement || forElement == window || forElement == viewportElement) {
        // viewport is always at 0,0 as that defined the coordinate system for
        // this function - this avoids special case checks in the code below
        return pos;
    }

    // Gecko browsers normally use getBoxObjectFor to calculate the position.
    // When invoked for an element with an implicit absolute position though it
    // can be off by one. Therefore the recursive implementation is used in
    // those (relatively rare) cases.
    var BUGGY_GECKO_BOX_OBJECT =
        GeoGlobe.IS_GECKO && document.getBoxObjectFor &&
        GeoGlobe.Element.getStyle(forElement, 'position') == 'absolute' &&
        (forElement.style.top == '' || forElement.style.left == '');

    var parent = null;
    var box;

    if (forElement.getBoundingClientRect) { // IE
        box = forElement.getBoundingClientRect();
        var scrollTop = window.pageYOffset || viewportElement.scrollTop;
        var scrollLeft = window.pageXOffset || viewportElement.scrollLeft;
        
        pos[0] = box.left + scrollLeft;
        pos[1] = box.top + scrollTop;

    } else if (document.getBoxObjectFor && !BUGGY_GECKO_BOX_OBJECT) { // gecko
        // Gecko ignores the scroll values for ancestors, up to 1.9.  See:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=328881 and
        // https://bugzilla.mozilla.org/show_bug.cgi?id=330619

        box = document.getBoxObjectFor(forElement);
        var vpBox = document.getBoxObjectFor(viewportElement);
        pos[0] = box.screenX - vpBox.screenX;
        pos[1] = box.screenY - vpBox.screenY;

    } else { // safari/opera
        pos[0] = forElement.offsetLeft;
        pos[1] = forElement.offsetTop;
        parent = forElement.offsetParent;
        if (parent != forElement) {
            while (parent) {
                pos[0] += parent.offsetLeft;
                pos[1] += parent.offsetTop;
                parent = parent.offsetParent;
            }
        }

        var browser = GeoGlobe.BROWSER_NAME;

        // opera & (safari absolute) incorrectly account for body offsetTop
        if (browser == "opera" || (browser == "safari" &&
              GeoGlobe.Element.getStyle(forElement, 'position') == 'absolute')) {
            pos[1] -= document.body.offsetTop;
        }

        // accumulate the scroll positions for everything but the body element
        parent = forElement.offsetParent;
        while (parent && parent != document.body) {
            pos[0] -= parent.scrollLeft;
            // see https://bugs.opera.com/show_bug.cgi?id=249965
            if (browser != "opera" || parent.tagName != 'TR') {
                pos[1] -= parent.scrollTop;
            }
            parent = parent.offsetParent;
        }
    }
    
    return pos;
};

/**
 *
 * Returns die viewport element of the document. The viewport element is
 * usually document.documentElement, except in IE,where it is either
 * document.body or document.documentElement, depending on the document's
 * compatibility mode (see
 * http://code.google.com/p/doctype/wiki/ArticleClientViewportElement)
 * @memberof GeoGlobe.Util
 * @returns {DOMElement}
 */
GeoGlobe.Util.getViewportElement = function() {
    var viewportElement = arguments.callee.viewportElement;
    if (viewportElement == undefined) {
        viewportElement = (GeoGlobe.BROWSER_NAME == "msie" &&
            document.compatMode != 'CSS1Compat') ? document.body :
            document.documentElement;
        arguments.callee.viewportElement = viewportElement;
    }
    return viewportElement;
};

/** 
 *
 * Test two URLs for equivalence.
 *  @memberof GeoGlobe.Util
 * Setting 'ignoreCase' allows for case-independent comparison.
 * 
 * Comparison is based on: 
 *  - Protocol
 *  - Host (evaluated without the port)
 *  - Port (set 'ignorePort80' to ignore "80" values)
 *  - Hash ( set 'ignoreHash' to disable)
 *  - Pathname (for relative <-> absolute comparison) 
 *  - Arguments (so they can be out of order)
 *  

 * @param {String} url1
 * @param {String} url2
 * @param {Object} options  -  Allows for customization of comparison:
 *                    'ignoreCase' - Default is True
 *                    'ignorePort80' - Default is True
 *                    'ignoreHash' - Default is True
 *
 * @returns {Boolean}  - Whether or not the two URLs are equivalent
 */
GeoGlobe.Util.isEquivalentUrl = function(url1, url2, options) {
    options = options || {};

    GeoGlobe.Util.applyDefaults(options, {
        ignoreCase: true,
        ignorePort80: true,
        ignoreHash: true,
        splitArgs: false
    });

    var urlObj1 = GeoGlobe.Util.createUrlObject(url1, options);
    var urlObj2 = GeoGlobe.Util.createUrlObject(url2, options);

    //compare all keys except for "args" (treated below)
    for(var key in urlObj1) {
        if(key !== "args") {
            if(urlObj1[key] != urlObj2[key]) {
                return false;
            }
        }
    }

    // compare search args - irrespective of order
    for(var key in urlObj1.args) {
        if(urlObj1.args[key] != urlObj2.args[key]) {
            return false;
        }
        delete urlObj2.args[key];
    }
    // urlObj2 shouldn't have any args left
    for(var key in urlObj2.args) {
        return false;
    }
    
    return true;
};

/**
 * @memberof GeoGlobe.Util
 *
 * @param {String} url1
 * @param {String} url2
 *
 * Valid options:
 * @param {Boolean}  ignoreCase  - lowercase url,
 * @param {Boolean} ignorePort80  -  don't include explicit port if port is 80,
 * @param {Boolean}  ignoreHash  - Don't include part of url after the hash (#).
 * @param {Boolean} splitArgs  - Split comma delimited params into arrays? Default is true.
 * 
 * @returns {Object}  - An object with separate url, a, port, host, and args parsed out
 *          and ready for comparison
 */
GeoGlobe.Util.createUrlObject = function(url, options) {
    options = options || {};

    // deal with relative urls first
    if(!(/^\w+:\/\//).test(url)) {
        var loc = window.location;
        var port = loc.port ? ":" + loc.port : "";
        var fullUrl = loc.protocol + "//" + loc.host.split(":").shift() + port;
        if(url.indexOf("/") === 0) {
            // full pathname
            url = fullUrl + url;
        } else {
            // relative to current path
            var parts = loc.pathname.split("/");
            parts.pop();
            url = fullUrl + parts.join("/") + "/" + url;
        }
    }
  
    if (options.ignoreCase) {
        url = url.toLowerCase(); 
    }

    var a = document.createElement('a');
    a.href = url;
    
    var urlObject = {};
    
    //host (without port)
    urlObject.host = a.host.split(":").shift();

    //protocol
    urlObject.protocol = a.protocol;  

    //port (get uniform browser behavior with port 80 here)
    if(options.ignorePort80) {
        urlObject.port = (a.port == "80" || a.port == "0") ? "" : a.port;
    } else {
        urlObject.port = (a.port == "" || a.port == "0") ? "80" : a.port;
    }

    //hash
    urlObject.hash = (options.ignoreHash || a.hash === "#") ? "" : a.hash;  
    
    //args
    var queryString = a.search;
    if (!queryString) {
        var qMark = url.indexOf("?");
        queryString = (qMark != -1) ? url.substr(qMark) : "";
    }
    urlObject.args = GeoGlobe.Util.getParameters(queryString,
            {splitArgs: options.splitArgs});

    // pathname
    //
    // This is a workaround for Internet Explorer where
    // window.location.pathname has a leading "/", but
    // a.pathname has no leading "/".
    urlObject.pathname = (a.pathname.charAt(0) == "/") ? a.pathname : "/" + a.pathname;
    
    return urlObject; 
};
 
/**
 * Takes a url and removes everything after the ? and #
 *  @memberof GeoGlobe.Util
 * @param {String} url  -  The url to process
 * 
 * @returns {String}  - The string with all queryString and Hash removed
 */
GeoGlobe.Util.removeTail = function(url) {
    var head = null;
    
    var qMark = url.indexOf("?");
    var hashMark = url.indexOf("#");

    if (qMark == -1) {
        head = (hashMark != -1) ? url.substr(0,hashMark) : url;
    } else {
        head = (hashMark != -1) ? url.substr(0,Math.min(qMark, hashMark)) 
                                  : url.substr(0, qMark);
    }
    return head;
};


GeoGlobe.IS_GECKO = (function() {
    var ua = navigator.userAgent.toLowerCase();
    return ua.indexOf("webkit") == -1 && ua.indexOf("gecko") != -1;
})();


GeoGlobe.CANVAS_SUPPORTED = (function() {
    var elem = document.createElement('canvas');
    return !!(elem.getContext && elem.getContext('2d'));
})();


GeoGlobe.BROWSER_NAME = (function() {
    var name = "";
    var ua = navigator.userAgent.toLowerCase();
    if (ua.indexOf("opera") != -1) {
        name = "opera";
    } else if (ua.indexOf("msie") != -1) {
        name = "msie";
    } else if (ua.indexOf("safari") != -1) {
        name = "safari";
    } else if (ua.indexOf("mozilla") != -1) {
        if (ua.indexOf("firefox") != -1) {
            name = "firefox";
        } else {
            name = "mozilla";
        }
    }
    return name;
})();

/**
 * @memberof GeoGlobe.Util
 * 
 * @returns {String}  - A string which specifies which is the current
 *          browser in which we are running. 
 * 
 *          Currently-supported browser detection and codes:
 *           * 'opera' -- Opera
 *           * 'msie'  -- Internet Explorer
 *           * 'safari' -- Safari
 *           * 'firefox' -- Firefox
 *           * 'mozilla' -- Mozilla
 * 
 *          If we are unable to property identify the browser, we 
 *           return an empty string.
 */
GeoGlobe.Util.getBrowserName = function() {
    return GeoGlobe.BROWSER_NAME;
};

/**
 * Renders the contentHTML offscreen to determine actual dimensions for
 *     popup sizing. As we need layout to determine dimensions the content
 *     is rendered -9999px to the left and absolute to ensure the 
 *     scrollbars do not flicker
 * @memberof GeoGlobe.Util

 * @param contentHTML
 * @param {GeoGlobe.Size} size  - If either the 'w' or 'h' properties is
 *     specified, we fix that dimension of the div to be measured. This is 
 *     useful in the case where we have a limit in one dimension and must 
 *     therefore meaure the flow in the other dimension.
 * @param {Object} options
 *
 * Allowed Options:
 *  @param {String} displayClass -  Optional parameter.  A CSS class name(s) string
 *         to provide the CSS context of the rendered content.
 * @param {DOMElement} containerElement  - Optional parameter. Insert the HTML to
 *         this node instead of the body root when calculating dimensions. 
 * 
 * @returns {GeoGlobe.Size}
 */
GeoGlobe.Util.getRenderedDimensions = function(contentHTML, size, options) {
    
    var w, h;
    
    // create temp container div with restricted size
    var container = document.createElement("div");
    container.style.visibility = "hidden";
        
    var containerElement = (options && options.containerElement) 
        ? options.containerElement : document.body;
    
    // Opera and IE7 can't handle a node with position:aboslute if it inherits
    // position:absolute from a parent.
    var parentHasPositionAbsolute = false;
    var superContainer = null;
    var parent = containerElement;
    while (parent && parent.tagName.toLowerCase()!="body") {
        var parentPosition = GeoGlobe.Element.getStyle(parent, "position");
        if(parentPosition == "absolute") {
            parentHasPositionAbsolute = true;
            break;
        } else if (parentPosition && parentPosition != "static") {
            break;
        }
        parent = parent.parentNode;
    }
    if(parentHasPositionAbsolute && (containerElement.clientHeight === 0 || 
                                     containerElement.clientWidth === 0) ){
        superContainer = document.createElement("div");
        superContainer.style.visibility = "hidden";
        superContainer.style.position = "absolute";
        superContainer.style.overflow = "visible";
        superContainer.style.width = document.body.clientWidth + "px";
        superContainer.style.height = document.body.clientHeight + "px";
        superContainer.appendChild(container);
    }
    container.style.position = "absolute";

    //fix a dimension, if specified.
    if (size) {
        if (size.w) {
            w = size.w;
            container.style.width = w + "px";
        } else if (size.h) {
            h = size.h;
            container.style.height = h + "px";
        }
    }

    //add css classes, if specified
    if (options && options.displayClass) {
        container.className = options.displayClass;
    }
    
    // create temp content div and assign content
    var content = document.createElement("div");
    content.innerHTML = contentHTML;
    
    // we need overflow visible when calculating the size
    content.style.overflow = "visible";
    if (content.childNodes) {
        for (var i=0, l=content.childNodes.length; i<l; i++) {
            if (!content.childNodes[i].style) continue;
            content.childNodes[i].style.overflow = "visible";
        }
    }
    
    // add content to restricted container 
    container.appendChild(content);
    
    // append container to body for rendering
    if (superContainer) {
        containerElement.appendChild(superContainer);
    } else {
        containerElement.appendChild(container);
    }
    
    // calculate scroll width of content and add corners and shadow width
    if (!w) {
        w = parseInt(content.scrollWidth);
    
        // update container width to allow height to adjust
        container.style.width = w + "px";
    }        
    // capture height and add shadow and corner image widths
    if (!h) {
        h = parseInt(content.scrollHeight);
    }

    // remove elements
    container.removeChild(content);
    if (superContainer) {
        superContainer.removeChild(container);
        containerElement.removeChild(superContainer);
    } else {
        containerElement.removeChild(container);
    }
    
    return new GeoGlobe.Size(w, h);
};

/**
 * This function has been modified by the OpenLayers from the original version,
 *     written by Matthew Eernisse and released under the Apache 2 license here:
 *     http://www.fleegix.org/articles/2006/05/30/getting-the-scrollbar-width-in-pixels
 * @memberof GeoGlobe.Util
 *     It has been modified simply to cache its value, since it is physically 
 *     impossible that this code could ever run in more than one browser at once.
 * 
 * @returns {Integer}
 */
GeoGlobe.Util.getScrollbarWidth = function() {
    
    var scrollbarWidth = GeoGlobe.Util._scrollbarWidth;
    
    if (scrollbarWidth == null) {
        var scr = null;
        var inn = null;
        var wNoScroll = 0;
        var wScroll = 0;
    
        // Outer scrolling div
        scr = document.createElement('div');
        scr.style.position = 'absolute';
        scr.style.top = '-1000px';
        scr.style.left = '-1000px';
        scr.style.width = '100px';
        scr.style.height = '50px';
        // Start with no scrollbar
        scr.style.overflow = 'hidden';
    
        // Inner content div
        inn = document.createElement('div');
        inn.style.width = '100%';
        inn.style.height = '200px';
    
        // Put the inner div in the scrolling div
        scr.appendChild(inn);
        // Append the scrolling div to the doc
        document.body.appendChild(scr);
    
        // Width of the inner div sans scrollbar
        wNoScroll = inn.offsetWidth;
    
        // Add the scrollbar
        scr.style.overflow = 'scroll';
        // Width of the inner div width scrollbar
        wScroll = inn.offsetWidth;
    
        // Remove the scrolling div from the doc
        document.body.removeChild(document.body.lastChild);
    
        // Pixel width of the scroller
        GeoGlobe.Util._scrollbarWidth = (wNoScroll - wScroll);
        scrollbarWidth = GeoGlobe.Util._scrollbarWidth;
    }

    return scrollbarWidth;
};

/**
 *
 * This function will return latitude or longitude value formatted as
 * @memberof GeoGlobe.Util
 * @param {Float} coordinate  - the coordinate value to be formatted
 * @param {String} axis  - value of either 'lat' or 'lon' to indicate which axis is to to be formatted (default = lat)
 * @param {String} dmsOption -  specify the precision of the output can be one of:
 *           'dms' show degrees minutes and seconds
 *           'dm' show only degrees and minutes
 *           'd' show only degrees
 * 
 * @returns {String}  - the coordinate value formatted as a string
 */
/*
GeoGlobe.Util.getFormattedLonLat = function(coordinate, axis, dmsOption) {
    if (!dmsOption) {
        dmsOption = 'dms';    //default to show degree, minutes, seconds
    }

    coordinate = (coordinate+540)%360 - 180; // normalize for sphere being round

    var abscoordinate = Math.abs(coordinate);
    var coordinatedegrees = Math.floor(abscoordinate);

    var coordinateminutes = (abscoordinate - coordinatedegrees)/(1/60);
    var tempcoordinateminutes = coordinateminutes;
    coordinateminutes = Math.floor(coordinateminutes);
    var coordinateseconds = (tempcoordinateminutes - coordinateminutes)/(1/60);
    coordinateseconds =  Math.round(coordinateseconds*10);
    coordinateseconds /= 10;

    if( coordinateseconds >= 60) { 
        coordinateseconds -= 60; 
        coordinateminutes += 1; 
        if( coordinateminutes >= 60) { 
            coordinateminutes -= 60; 
            coordinatedegrees += 1; 
        } 
    }
    
    if( coordinatedegrees < 10 ) {
        coordinatedegrees = "0" + coordinatedegrees;
    }
    var str = coordinatedegrees + "\u00B0";

    if (dmsOption.indexOf('dm') >= 0) {
        if( coordinateminutes < 10 ) {
            coordinateminutes = "0" + coordinateminutes;
        }
        str += coordinateminutes + "'";
  
        if (dmsOption.indexOf('dms') >= 0) {
            if( coordinateseconds < 10 ) {
                coordinateseconds = "0" + coordinateseconds;
            }
            str += coordinateseconds + '"';
        }
    }
    
    if (axis == "lon") {
        str += coordinate < 0 ? GeoGlobe.i18n("W") : GeoGlobe.i18n("E");
    } else {
        str += coordinate < 0 ? GeoGlobe.i18n("S") : GeoGlobe.i18n("N");
    }
    return str;
};
*/
//生成num个数的随机字符串
GeoGlobe.Util.randomStr = function (num) {
	var random = "";
	var randArr = [];
	for(var i=0;i<num;i++){
		var randNum = Math.ceil(Math.random() * 25);
		randArr.push(String.fromCharCode(97+randNum));
	}
	for(var i=0;i<num;i++){
		random += randArr[i];
	}
	return random;
};
//执行js
GeoGlobe.Util.globalEval = function(data) {
	if (data && GeoGlobe.String.trim(data)){
		// We use execScript on Internet Explorer
		// We use an anonymous function so that context is window
		// rather than in Firefox
		(window.execScript || function(data){
			window["eval"].call(window, data);
		})(data);
	}
};

//根据比例尺，单位和dpi获取分辨率
GeoGlobe.Util.getResolutionFromScale_DPI = function(scale, units, dpi){
	var resolution;
    if (scale) {
        if (units == null) {
            units = "degrees";
        }
        var normScale = GeoGlobe.Util.normalizeScale(scale);
        resolution = 1 / (normScale * GeoGlobe.INCHES_PER_UNIT[units] * dpi);
    }
    return resolution;
};

//根据分辨率，单位和dpi获取比例尺
GeoGlobe.Util.getScaleFromResolution_DPI = function(resolution, units, dpi){
	if (units == null) {
        units = "degrees";
    }

    var scale = resolution * GeoGlobe.INCHES_PER_UNIT[units] * dpi;
    return scale;
};

/**
 * 根据分辨率获取层级
 *  @memberof GeoGlobe.Util
 */
GeoGlobe.Util.getMapLevelFormResolution = function(map, resolution){
    if (!resolution) {
        return 0;
    }
	var zoom, i, diff;
	var minDiff = Number.POSITIVE_INFINITY;
	var resolutions = map.getResolutions();
	for (i = 0, len = resolutions.length; i < len; i++) {
		//判断当前分辨率与金字塔中分辨率最接近的
        diff = Math.abs(resolutions[i] - resolution);
        if (diff > minDiff) {
            break;
        }
        minDiff = diff;
	}
	zoom = Math.max(0, i - 1);//0和(i - 1)中取大数。
	return zoom ;
};

/**
 * 根据比例尺获取层级
 *  @memberof GeoGlobe.Util
 */
GeoGlobe.Util.getMapLevelFormScale = function(map, scale, units, dpi){
	////var lvl_arcgis_gd = getLevelFormScale(2.792281947544293E8); //1
	var units = units ? units : "degrees";
	var dpi = dpi ? dpi : 96;
	var resolution = GeoGlobe.Util.getResolutionFromScale_DPI(scale, units, dpi);
	var lvl = GeoGlobe.Util.getMapLevelFormResolution(map, resolution);
	return lvl;
};

/**
 * 这里返回一个函数，如果它被不间断地调用，它将不会得到执行。
 * 该函数在停止调用 N 毫秒后，再次调用它才会得到执行。
 * 如果有传递 ‘immediate’ 参数，会马上将函数安排到执行队列中，而不会延迟。
 * exam: 	var myEfficientFn = GeoGlobe.Util.delayFun (function() {
 * 				// 所有繁重的操作
 * 			}, 250);
 * 			window.addEventListener('resize', myEfficientFn);
 * @memberof GeoGlobe.Util
 */
GeoGlobe.Util.delayFun = function(func, wait, immediate) {
    var timeout;
    return function() {
        var context = this, args = arguments;
        var later = function() {
            timeout = null;
            if (!immediate) func.apply(context, args);
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
    };
};

/**
 * 深度克隆方法。
 * @memberof GeoGlobe.Util
 */
GeoGlobe.Util.clone = function(myObj){
    if (typeof(myObj) != 'object') 
        return myObj;
    if (myObj == null) 
        return myObj;
    //var myNewObj = new Object();
    var myNewObj = (myObj.constructor == Array) ? [] : {};
    
    for (var i in myObj) 
        myNewObj[i] = GeoGlobe.Util.clone(myObj[i]);
    
    return myNewObj;
};

/**
 * 获取对象的类型
 * @memberof GeoGlobe.Util
 * @param {Object} obj 目标对象
 * @return {String} type 对象类型
 */
GeoGlobe.Util.getType = function (obj) {
    var toString = Object.prototype.toString;
    var map = {
        '[object Boolean]': 'boolean',
        '[object Number]': 'number',
        '[object String]': 'string',
        '[object Function]': 'function',
        '[object Array]': 'array',
        '[object Date]': 'date',
        '[object RegExp]': 'regExp',
        '[object Undefined]': 'undefined',
        '[object Null]': 'null',
        '[object Object]': 'object'
    };
    if (obj instanceof Element) {
        return 'element';
    }
    return map[toString.call(obj)];
};

/**
 * 将数字转化为千位分隔与保留多少位小数num：数字，cent，保留小数位数，是否转化为千分位分隔（默认false）
 * @memberof GeoGlobe.Util
 * @param {Object} num 数字
 * @param {Number} cent 保留小数位数
 * @param {Boolean} isThousand 是否转化为千分位分隔（默认false）
 */
GeoGlobe.Util.formatNumberToThousands = function (num, cent, isThousand) {
    num = num.toString().replace(/\$|\,/g, '');

    // 检查传入数值为数值类型
    if (isNaN(num))
        num = "0";

    // 获取符号(正/负数)
    var sign = (num === (num = Math.abs(num)));

    num = Math.floor(num * Math.pow(10, cent) + 0.50000000001); // 把指定的小数位先转换成整数.多余的小数位四舍五入
    var cents = num % Math.pow(10, cent);       // 求出小数位数值
    num = Math.floor(num / Math.pow(10, cent)).toString();  // 求出整数位数值
    cents = cents.toString();        // 把小数位转换成字符串,以便求小数位长度

    // 补足小数位到指定的位数
    while (cents.length < cent)
        cents = "0" + cents;

    if (isThousand) {
        // 对整数部分进行千分位格式化.
        for (var i = 0; i < Math.floor((num.length - (1 + i)) / 3); i++)
            num = num.substring(0, num.length - (4 * i + 3)) + ',' + num.substring(num.length - (4 * i + 3));
    }

    if (cent > 0)
        return (((sign) ? '' : '-') + num + '.' + cents);
    else
        return (((sign) ? '' : '-') + num);
};

/**
 * 获取根据模板格式化后的字符串
 * @memberof GeoGlobe.Util
 * @param {Object} metadata 元数据，如：{a: '北京市', b: '统计数', c: 99.99}
 * @param {String} formatter 模板，如：'{a}<br/>{c} {c2}'
 * @returns {String} str 字符串
 */
GeoGlobe.Util.getFormattedString = function (metadata, formatter) {
    var str = formatter;
    str = str.replace(/{a}/g, metadata['a']);
    str = str.replace(/{b}/g, metadata['b']);

    if (str.contains('{c')) {
        var arrs = str.split('{c');
        var fixed = 0;
        for (var i = 0; i < arrs.length - 1; i++) {
            fixed = arrs[i + 1].split('}')[0];
            str = str.replace(new RegExp("{c" + fixed + "}", "g"), GeoGlobe.Util.formatNumberToThousands(parseFloat(metadata['c']), fixed === '' ? 2 : fixed, true));
        }
    }
    return str;
};

/**
 * 生成渐进色像素数据
 * @memberof GeoGlobe.Util
 * @param {Object} gradientColor 渐进色配置
 * @return {CanvasPixelArray} data 像素数据
 */
GeoGlobe.Util.getGradientImageData = function (gradientColor) {
    var cvs = document.createElement('canvas');
    var ctx = cvs.getContext('2d');
    cvs.width = 1;
    cvs.height = 256;

    var gradient = ctx.createLinearGradient(0, 0, 0, 256);
    for (var i in gradientColor) {
        if (gradientColor.hasOwnProperty(i)) {
            gradient.addColorStop(i, gradientColor[i]);
        }
    }
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 1, 256);
    return ctx.getImageData(0, 0, 1, 256).data;
};

/**
 * 转换为rgb|hsl颜色
 * @memberof GeoGlobe.Util
 * @param {String} color 颜色，支持：#f00|#ff0000、rgb(255,0,0)、rgba(255,0,0,1)、hsl(360,100%,50%)、hsla(360,100%,50%,1)
 * @returns {String} color rgb|hsl颜色
 */
GeoGlobe.Util.getRgbColor = function (color) {
    color = color.toLowerCase();

    //十六进制颜色值的正则表达式
    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
    if (color && reg.test(color)) {
        if (color.length === 4) {
            var tmp = "#";
            for (var i = 1; i < 4; i += 1) {
                tmp += color.slice(i, i + 1).concat(color.slice(i, i + 1));
            }
            color = tmp;
        }
        tmp = [];
        for (var i = 1; i < 7; i += 2) {
            tmp.push(parseInt("0x" + color.slice(i, i + 2)));
        }
        return "rgb(" + tmp.join(",") + ")";
    } else {
        if (color.startsWith("rgba") || color.startsWith("hsla")) {
            return color.substring(0, 3) + color.substring(4, color.lastIndexOf(',')) + ')';
        }
        if (color.startsWith("rgb") || color.startsWith("hsl")) {
            return color;
        }
        return '';
    }
};

/**
 * 获取颜色的明暗色
 * @memberof GeoGlobe.Util
 * @param {String} color 颜色
 * @param {Number} percent 明暗程度
 * @returns {String} color 计算后的颜色
 */
GeoGlobe.Util.getShadeColor = function (color, percent) {
    color = GeoGlobe.Util.getHexColor(color);
    color = color.substr(1);
    var num = parseInt(color, 16),
        amt = Math.round(2.55 * percent),
        R = (num >> 16) + amt,
        G = (num >> 8 & 0x00FF) + amt,
        B = (num & 0x0000FF) + amt;
    return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 + (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
};

/**
 * 转换为十六进制颜色
 * @memberof GeoGlobe.Util
 * @param {String} color 颜色，支持：#f00|#ff0000、rgb(255,0,0)|rgba(255,0,0,1)
 * @returns {String} color 十六进制颜色
 */
GeoGlobe.Util.getHexColor = function (color) {
    color = color.toLowerCase();

    if (/^(rgb|rgba)/.test(color)) {
        var colors = color.split('(')[1].split(')')[0].split(",");
        var strHex = "#";
        for (var i = 0; i < 3; i++) {
            var hex = Number(colors[i]).toString(16);
            if (hex === "0") {
                hex += hex;
            }
            if (hex.length ===1){
                hex = "0" + hex;
            }
            strHex += hex;
        }
        if (strHex.length !== 7) {
            strHex = color;
        }
        return strHex;
    } else if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(color)) {
        var aNum = color.replace(/#/, "").split("");
        if (aNum.length === 6) {
            return color;
        } else if (aNum.length === 3) {
            var numHex = "#";
            for (var i = 0; i < aNum.length; i += 1) {
                numHex += (aNum[i] + aNum[i]);
            }
            return numHex;
        }
    } else {
        return color;
    }
};

/**
 * 墨卡托转换标准经纬度坐标
 * @memberof GeoGlobe.Util
 * @param {Array} mercator 墨卡托坐标
 * @return {Array} lonLat 标准经纬度坐标
 */
GeoGlobe.Util.transferToLonLat = function (mercator) {
    if (mercator[1] === -238107693.23182276) {
        return [mercator[0] / 20037508.34 * 180, -90];
    } else {
        return [mercator[0] / 20037508.34 * 180, 180 / Math.PI * (2 * Math.atan(Math.exp(mercator[1] / 20037508.34 * 180 * Math.PI / 180)) - Math.PI / 2)];
    }
};

/**
 * 标准经纬度转换墨卡托坐标
 * @memberof GeoGlobe.Util
 * @param {Array} lonLat 标准经纬度坐标
 * @return {Array} mercator 墨卡托坐标
 */
GeoGlobe.Util.transferToMercator = function (lonLat) {
    if (lonLat[1] === -90) {
        return [lonLat[0] * 20037508.34 / 180, -238107693.23182276];
    } else {
        return [lonLat[0] * 20037508.34 / 180, Math.log(Math.tan((90 + lonLat[1]) * Math.PI / 360)) / (Math.PI / 180) * 20037508.34 / 180];
    }
};/**
 * @private
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.proj4cn = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var forEachPoint = require('../util').forEachPoint;
var gcj02 = require('./gcj-02');

var PI = Math.PI;
var X_PI = PI * 3000 / 180;

var toGCJ02 = exports.toGCJ02 = forEachPoint(function(input, output, offset) {
  var x = input[offset] - 0.0065;
  var y = input[offset + 1] - 0.006;
  var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * X_PI);
  var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * X_PI);
  output[offset] = z * Math.cos(theta);
  output[offset + 1] = z * Math.sin(theta);
  return output;
});

var fromGCJ02 = exports.fromGCJ02 = forEachPoint(function(input, output, offset) {
  var x = input[offset];
  var y = input[offset + 1];
  var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * X_PI);
  var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * X_PI);
  output[offset] = z * Math.cos(theta) + 0.0065;
  output[offset + 1] = z * Math.sin(theta) + 0.006;
  return output;
});

exports.toWGS84 = function(input, opt_output, opt_dimension) {
  var output = toGCJ02(input, opt_output, opt_dimension);
  return gcj02.toWGS84(output, output, opt_dimension);
};

exports.fromWGS84 = function(input, opt_output, opt_dimension) {
  var output = gcj02.fromWGS84(input, opt_output, opt_dimension);
  return fromGCJ02(output, output, opt_dimension);
};

},{"../util":8,"./gcj-02":2}],2:[function(require,module,exports){
var forEachPoint = require('../util').forEachPoint;

var PI = Math.PI;
var AXIS = 6378245.0;
var OFFSET = 0.00669342162296594323;  // (a^2 - b^2) / a^2

function delta(wgLon, wgLat) {
  var dLat = transformLat(wgLon - 105.0, wgLat - 35.0);
  var dLon = transformLon(wgLon - 105.0, wgLat - 35.0);
  var radLat = wgLat / 180.0 * PI;
  var magic = Math.sin(radLat);
  magic = 1 - OFFSET * magic * magic;
  var sqrtMagic = Math.sqrt(magic);
  dLat = (dLat * 180.0) / ((AXIS * (1 - OFFSET)) / (magic * sqrtMagic) * PI);
  dLon = (dLon * 180.0) / (AXIS / sqrtMagic * Math.cos(radLat) * PI);
  return [dLon, dLat];
}

function outOfChina(lon, lat) {
  if (lon < 72.004 || lon > 137.8347) {
    return true;
  }
  if (lat < 0.8293 || lat > 55.8271) {
    return true;
  }
  return false;
}

function transformLat(x, y) {
  var ret = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * Math.sqrt(Math.abs(x));
  ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(y * PI) + 40.0 * Math.sin(y / 3.0 * PI)) * 2.0 / 3.0;
  ret += (160.0 * Math.sin(y / 12.0 * PI) + 320 * Math.sin(y * PI / 30.0)) * 2.0 / 3.0;
  return ret;
}

function transformLon(x, y) {
  var ret = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * Math.sqrt(Math.abs(x));
  ret += (20.0 * Math.sin(6.0 * x * PI) + 20.0 * Math.sin(2.0 * x * PI)) * 2.0 / 3.0;
  ret += (20.0 * Math.sin(x * PI) + 40.0 * Math.sin(x / 3.0 * PI)) * 2.0 / 3.0;
  ret += (150.0 * Math.sin(x / 12.0 * PI) + 300.0 * Math.sin(x / 30.0 * PI)) * 2.0 / 3.0;
  return ret;
}

exports.toWGS84 = forEachPoint(function(input, output, offset) {
  var lng = input[offset];
  var lat = input[offset + 1];
  if (!outOfChina(lng, lat)) {
    var deltaD = delta(lng, lat);
    lng = lng - deltaD[0];
    lat = lat - deltaD[1];
  }
  output[offset] = lng;
  output[offset + 1] = lat;
});

exports.fromWGS84 = forEachPoint(function(input, output, offset) {
  var lng = input[offset];
  var lat = input[offset + 1];
  if (!outOfChina(lng, lat)) {
    var deltaD = delta(lng, lat);
    lng = lng + deltaD[0];
    lat = lat + deltaD[1];
  }
  output[offset] = lng;
  output[offset + 1] = lat;
});

},{"../util":8}],3:[function(require,module,exports){
exports.bd09 = require('./bd-09');
exports.gcj02 = require('./gcj-02');

},{"./bd-09":1,"./gcj-02":2}],4:[function(require,module,exports){
var projection = require('./projection/index');
var datum = require('./datum/index');

exports.smerc2bmerc = function(input, opt_output, opt_dimension) {
  var output = projection.sphericalMercator.inverse(input, opt_output, opt_dimension);
  output = datum.bd09.fromWGS84(output, output, opt_dimension);
  return projection.baiduMercator.forward(output, output, opt_dimension);
};

exports.bmerc2smerc = function(input, opt_output, opt_dimension) {
  var output = projection.baiduMercator.inverse(input, opt_output, opt_dimension);
  output = datum.bd09.toWGS84(output, output, opt_dimension);
  return projection.sphericalMercator.forward(output, output, opt_dimension);
};

exports.bmerc2ll = function(input, opt_output, opt_dimension) {
  var output = projection.baiduMercator.inverse(input, opt_output, opt_dimension);
  return datum.bd09.toWGS84(output, output, opt_dimension);
};

exports.ll2bmerc = function(input, opt_output, opt_dimension) {
  var output = datum.bd09.fromWGS84(input, opt_output, opt_dimension);
  return projection.baiduMercator.forward(output, output, opt_dimension);
};

exports.ll2smerc = projection.sphericalMercator.forward;
exports.smerc2ll = projection.sphericalMercator.inverse;
exports.datum = datum;
exports.projection = projection;

//note 20170807: add
exports.gcj02towgs84 = function(input, opt_output, opt_dimension){
	return datum.gcj02.toWGS84(input, opt_output, opt_dimension);
}
exports.wgs84togcj02 = function(input, opt_output, opt_dimension){
	return datum.gcj02.fromWGS84(input, opt_output, opt_dimension);
}

},{"./datum/index":3,"./projection/index":6}],5:[function(require,module,exports){
var forEachPoint = require('../util').forEachPoint;

var MCBAND = [12890594.86, 8362377.87,
    5591021, 3481989.83, 1678043.12, 0];

var LLBAND = [75, 60, 45, 30, 15, 0];

var MC2LL = [
    [1.410526172116255e-8, 0.00000898305509648872, -1.9939833816331,
        200.9824383106796, -187.2403703815547, 91.6087516669843,
        -23.38765649603339, 2.57121317296198, -0.03801003308653,
        17337981.2],
    [-7.435856389565537e-9, 0.000008983055097726239,
        -0.78625201886289, 96.32687599759846, -1.85204757529826,
        -59.36935905485877, 47.40033549296737, -16.50741931063887,
        2.28786674699375, 10260144.86],
    [-3.030883460898826e-8, 0.00000898305509983578, 0.30071316287616,
        59.74293618442277, 7.357984074871, -25.38371002664745,
        13.45380521110908, -3.29883767235584, 0.32710905363475,
        6856817.37],
    [-1.981981304930552e-8, 0.000008983055099779535, 0.03278182852591,
        40.31678527705744, 0.65659298677277, -4.44255534477492,
        0.85341911805263, 0.12923347998204, -0.04625736007561,
        4482777.06],
    [3.09191371068437e-9, 0.000008983055096812155, 0.00006995724062,
        23.10934304144901, -0.00023663490511, -0.6321817810242,
        -0.00663494467273, 0.03430082397953, -0.00466043876332,
        2555164.4],
    [2.890871144776878e-9, 0.000008983055095805407, -3.068298e-8,
        7.47137025468032, -0.00000353937994, -0.02145144861037,
        -0.00001234426596, 0.00010322952773, -0.00000323890364,
        826088.5]];

var LL2MC = [
    [-0.0015702102444, 111320.7020616939, 1704480524535203,
        -10338987376042340, 26112667856603880,
        -35149669176653700, 26595700718403920,
        -10725012454188240, 1800819912950474, 82.5],
    [0.0008277824516172526, 111320.7020463578, 647795574.6671607,
        -4082003173.641316, 10774905663.51142, -15171875531.51559,
        12053065338.62167, -5124939663.577472, 913311935.9512032,
        67.5],
    [0.00337398766765, 111320.7020202162, 4481351.045890365,
        -23393751.19931662, 79682215.47186455, -115964993.2797253,
        97236711.15602145, -43661946.33752821, 8477230.501135234,
        52.5],
    [0.00220636496208, 111320.7020209128, 51751.86112841131,
        3796837.749470245, 992013.7397791013, -1221952.21711287,
        1340652.697009075, -620943.6990984312, 144416.9293806241,
        37.5],
    [-0.0003441963504368392, 111320.7020576856, 278.2353980772752,
        2485758.690035394, 6070.750963243378, 54821.18345352118,
        9540.606633304236, -2710.55326746645, 1405.483844121726,
        22.5],
    [-0.0003218135878613132, 111320.7020701615, 0.00369383431289,
        823725.6402795718, 0.46104986909093, 2351.343141331292,
        1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]];


function getRange(v, min, max) {
  v = Math.max(v, min);
  v = Math.min(v, max);

  return v;
}

function getLoop(v, min, max) {
  var d = max - min;
  while (v > max) {
    v -= d;
  }
  while (v < min) {
    v += d;
  }

  return v;
}

function convertor(input, output, offset, table) {
  var px = input[offset];
  var py = input[offset + 1];
  var x = table[0] + table[1] * Math.abs(px);
  var d = Math.abs(py) / table[9];
  var y = table[2]
      + table[3]
      * d
      + table[4]
      * d
      * d
      + table[5]
      * d
      * d
      * d
      + table[6]
      * d
      * d
      * d
      * d
      + table[7]
      * d
      * d
      * d
      * d
      * d
      + table[8]
      * d
      * d
      * d
      * d
      * d
      * d;

  output[offset] = x * (px < 0 ? -1 : 1);
  output[offset + 1] = y * (py < 0 ? -1 : 1);
}

exports.forward = forEachPoint(function(input, output, offset) {
  var lng = getLoop(input[offset], -180, 180);
  var lat = getRange(input[offset + 1], -74, 74);

  var table = null;
  var j;
  for (j = 0; j < LLBAND.length; ++j) {
    if (lat >= LLBAND[j]) {
      table = LL2MC[j];
      break;
    }
  }
  if (table === null) {
    for (j = LLBAND.length - 1; j >= 0; --j) {
      if (lat <= -LLBAND[j]) {
        table = LL2MC[j];
        break;
      }
    }
  }
  output[offset] = lng;
  output[offset + 1] = lat;
  convertor(output, output, offset, table);
});

exports.inverse = forEachPoint(function(input, output, offset) {
  var y_abs = Math.abs(input[offset + 1]);

  var table = null;
  for (var j = 0; j < MCBAND.length; j++) {
    if (y_abs >= MCBAND[j]) {
      table = MC2LL[j];
      break;
    }
  }

  convertor(input, output, offset, table);
});

},{"../util":8}],6:[function(require,module,exports){
exports.baiduMercator = require('./baidu-mercator');
exports.sphericalMercator = require('./spherical-mercator');

},{"./baidu-mercator":5,"./spherical-mercator":7}],7:[function(require,module,exports){
var forEachPoint = require('../util').forEachPoint;

var RADIUS = 6378137;
var MAX_LATITUDE = 85.0511287798;
var RAD_PER_DEG = Math.PI / 180;

exports.forward = forEachPoint(function(input, output, offset) {
  var lat = Math.max(Math.min(MAX_LATITUDE, input[offset + 1]), -MAX_LATITUDE);
  var sin = Math.sin(lat * RAD_PER_DEG);

  output[offset] = RADIUS * input[offset] * RAD_PER_DEG;
  output[offset + 1] = RADIUS * Math.log((1 + sin) / (1 - sin)) / 2;
});

exports.inverse = forEachPoint(function(input, output, offset) {
  output[offset] = input[offset] / RADIUS / RAD_PER_DEG;
  output[offset + 1] = (2 * Math.atan(Math.exp(input[offset + 1] / RADIUS)) - (Math.PI / 2)) / RAD_PER_DEG;
});

},{"../util":8}],8:[function(require,module,exports){

exports.forEachPoint = function(func) {
  return function(input, opt_output, opt_dimension) {
    var len = input.length;
    var dimension = opt_dimension ? opt_dimension : 2;
    var output;
    if (opt_output) {
      output = opt_output;
    } else {
      if (dimension !== 2) {
        output = input.slice();
      } else {
        output = new Array(len);
      }
    }
    for (var offset = 0; offset < len; offset += dimension) {
      func(input, output, offset);
    }
    return output;
  };
};

},{}]},{},[4])(4)
});
if(GeoGlobe){GeoGlobe.Proj4cn = proj4cn};
/**
 * 本命名空间是对在GeoGlobe原生的基础上进行的扩展，用于定义常用投影坐标轴读取的方向。
 * 说明:
 * 目前WMS图层类的添加；WMTS能力描述信息的解析，以及WFS能力描述信息的解析需要用到本命名空间下的属性。
 * @namespace  GeoGlobe.ProjAxisOrder
 * @private
 */
GeoGlobe.ProjAxisOrder = {
	//East/North ordering (lat/lon)
	AXIS_ORDER_EN: true, //经度，纬度
	AXIS_ORDER_NE: false //纬度，经度
};
//
GeoGlobe.ProjAxisOrder.AxisOrder = {
	'EPSG:900913': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'WGS84': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'IGNF:WGS84G': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:4326': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,//纬度，经度
	"EPSG:4490": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,//纬度，经度
	'EPSG:4269': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:2361': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	'EPSG:27700': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:904490': GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
	
	'EPSG:4171'	: GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE, 
	
	'EPSG:32637': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32638': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32639': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32640': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:32641': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,			 
	
	'EPSG:28991': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:28992': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,					 
	
	'EPSG:31300': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:31370': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,			
	
	'EPSG:2176': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2177': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2178': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2179': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2180': GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	
	'EPSG:2154'	: GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN, 	
	
	'EPSG:3346' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:3857' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
	'EPSG:2065' : GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN
};GeoGlobe.SpatialReference = GeoGlobe.Class({

    /**
     * Proj4js.Proj instance.
     * @memberof GeoGlobe.SpatialReference.prototype
     * @type {Object}
     * @private
     */
    proj: null,
    
    /**
     * @memberof GeoGlobe.SpatialReference.prototype
     * @type {String}
     *
     */
    projCode: null,
    
    /**
     *  regular expression to strip the title from a proj4js definition
     *  @memberof GeoGlobe.SpatialReference.prototype
     *  @type {RegExp}
     */
    titleRegEx: /\+title=[^\+]*/,

    /**
     * @class GeoGlobe.Projection
     * @classdesc This class offers several methods for interacting with a wrapped pro4js projection object.
     *
     * @param {String} projCode  -  A string identifying the Well Known Identifier for
     *    the projection.
     * @param {Object}  options  - An optional object to set additional properties
     *     on the projection.
     *
     * @returns {GeoGlobe.Projection}  - A projection object.
     * @private
     */
    initialize: function(projCode, options) {
        GeoGlobe.Util.extend(this, options);
        this.projCode = projCode;
        if (typeof Proj4js == "object") {
            this.proj = new Proj4js.Proj(projCode);
        }
    },
    
    /**
     *  Get the string SRS code.
     * @memberof GeoGlobe.Projection.prototype
     * @returns {String}  - The SRS code.
     */
    getCode: function() {
        return this.proj ? this.proj.srsCode : this.projCode;
    },
   
    /**
     * Get the units string for the projection -- returns null if 
     *     proj4js is not available.
     * @memberof GeoGlobe.Projection.prototype
     * @returns {String}  - The units abbreviation.
     */
    getUnits: function() {
        return this.proj ? this.proj.units : null;
    },

    /**
     *  Convert projection to string (getCode wrapper).
     * @memberof GeoGlobe.Projection.prototype
     * @returns  {String}  - The projection code.
     */
    toString: function() {
        return this.getCode();
    },

    /**
     * Test equality of two projection instances.  Determines equality based
     *     soley on the projection code.
     * @memberof GeoGlobe.Projection.prototype
     * @returns {Boolean}  - The two projections are equivalent.
     */
    equals: function(projection) {
        var p = projection, equals = false;
        if (p) {
            if (!(p instanceof GeoGlobe.SpatialReference)) {
                p = new GeoGlobe.SpatialReference(p);
            }
            if ((typeof Proj4js == "object") && this.proj.defData && p.proj.defData) {
                equals = this.proj.defData.replace(this.titleRegEx, "") ==
                    p.proj.defData.replace(this.titleRegEx, "");
            } else if (p.getCode) {
                var source = this.getCode(), target = p.getCode();
                equals = source == target ||
                    !!GeoGlobe.SpatialReference.transforms[source] &&
                    GeoGlobe.SpatialReference.transforms[source][target] ===
                    GeoGlobe.SpatialReference.nullTransform;
            }
        }
        return equals;   
    },

    /* Method: destroy
     * Destroy projection object.
     */
    destroy: function() {
        delete this.proj;
        delete this.projCode;
    },
    
    CLASS_NAME: "GeoGlobe.SpatialReference"
});     

/**
 * Transforms is an object, with from properties, each of which may
 *      have a to property. This allows you to define projections without
 *      requiring support for proj4js to be included.
 *
 * This object has keys which correspond to a 'source' projection object.  The
 * keys should be strings, corresponding to the projection.getCode() value.
 * Each source projection object should have a set of destination projection
 * keys included in the object. 
 * 
 * Each value in the destination object should be a transformation function,
 * where the function is expected to be passed an object with a .x and a .y
 * property.  The function should return the object, with the .x and .y
 * transformed according to the transformation function.
 *
 * Note - Properties on this object should not be set directly.  To add a
 *     transform method to this object, use the <addTransform> method.  For an
 *     example of usage, see the OpenLayers.Layer.SphericalMercator file.
 * @memberof GeoGlobe.Projection.prototype
 * @type {Object}
 */
GeoGlobe.SpatialReference.transforms = {};

/**
 * Defaults for the SRS codes known to OpenLayers (currently
 *      EPSG:4326, CRS:84, urn:ogc:def:crs:EPSG:6.6:4326, EPSG:900913, EPSG:3857,
 *      EPSG:102113 and EPSG:102100). Keys are the SRS code, values are units,
 *      maxExtent (the validity extent for the SRS) and yx (true if this SRS is
 *      known to have a reverse axis order).
 * @memberof GeoGlobe.Projection.prototype
 * @type {Object}
 */
GeoGlobe.SpatialReference.defaults = {
    "EPSG:4326": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90],
        yx: true
    },
    "CRS:84": {
        units: "degrees",
        maxExtent: [-180, -90, 180, 90]
    },
    "EPSG:900913": {
        units: "m",
        maxExtent: [-20037508.34, -20037508.34, 20037508.34, 20037508.34]
    }
};

/**
 * Set a custom transform method between two projections.  Use this method in
 *     cases where the proj4js lib is not available or where custom projections
 *     need to be handled.
 * @memberof GeoGlobe.Projection.prototype
 * @param  {String} from  - The code for the source projection
 * @param {String} to  - the code for the destination projection
 * @param {Function} method  -  A function that takes a point as an argument and
 *     transforms that point from the source to the destination projection
 *     in place.  The original point should be modified.
 */
GeoGlobe.SpatialReference.addTransform = function(from, to, method) {
    if (method === GeoGlobe.SpatialReference.nullTransform) {
        var defaults = GeoGlobe.SpatialReference.defaults[from];
        if (defaults && !GeoGlobe.SpatialReference.defaults[to]) {
            GeoGlobe.SpatialReference.defaults[to] = defaults;
        }
    }
    if(!GeoGlobe.SpatialReference.transforms[from]) {
        GeoGlobe.SpatialReference.transforms[from] = {};
    }
    GeoGlobe.SpatialReference.transforms[from][to] = method;
};

/**
 * Transform a point coordinate from one projection to another.  Note that
 *     the input point is transformed in place.
 * @memberof GeoGlobe.Projection.prototype
 * @param {OpenLayers.Geometry.Point | Object}  point  - An object with x and y
 *     properties representing coordinates in those dimensions.
 * @param {OpenLayers.Projection} source  - Source map coordinate system
 * @param {OpenLayers.Projection} dest  - Destination map coordinate system
 *
 * @returns {object} point  -  A transformed coordinate.  The original point is modified.
 */
GeoGlobe.SpatialReference.transform = function(point, source, dest) {
    if (source && dest) {
        if (!(source instanceof GeoGlobe.SpatialReference)) {
            source = new GeoGlobe.SpatialReference(source);
        }
        if (!(dest instanceof GeoGlobe.SpatialReference)) {
            dest = new GeoGlobe.SpatialReference(dest);
        }
        if (source.proj && dest.proj) {
            point = Proj4js.transform(source.proj, dest.proj, point);
        } else {
            var sourceCode = source.getCode();
            var destCode = dest.getCode();
            var transforms = GeoGlobe.SpatialReference.transforms;
            if (transforms[sourceCode] && transforms[sourceCode][destCode]) {
                transforms[sourceCode][destCode](point);
            }
        }
    }
    return point;
};

/**
 * A null transformation - useful for defining projection aliases when
 * proj4js is not available:
 * @memberof GeoGlobe.Projection.prototype
 * @example
 * (code)
 * GeoGlobe.Projection.addTransform("EPSG:3857", "EPSG:900913",
 *     GeoGlobe.Projection.nullTransform);
 * GeoGlobe.Projection.addTransform("EPSG:900913", "EPSG:3857",
 *     GeoGlobe.Projection.nullTransform);
 * (end)
 */
GeoGlobe.SpatialReference.nullTransform = function(point) {
    return point;
};

/**
 * Note: Transforms for web mercator <-> geographic
 * OpenLayers recognizes EPSG:3857, EPSG:900913, EPSG:102113 and EPSG:102100.
 * OpenLayers originally started referring to EPSG:900913 as web mercator.
 * The EPSG has declared EPSG:3857 to be web mercator.
 * ArcGIS 10 recognizes the EPSG:3857, EPSG:102113, and EPSG:102100 as
 * equivalent.  See http://blogs.esri.com/Dev/blogs/arcgisserver/archive/2009/11/20/ArcGIS-Online-moving-to-Google-_2F00_-Bing-tiling-scheme_3A00_-What-does-this-mean-for-you_3F00_.aspx#12084.
 * For geographic, OpenLayers recognizes EPSG:4326, CRS:84 and
 * urn:ogc:def:crs:EPSG:6.6:4326. OpenLayers also knows about the reverse axis
 * order for EPSG:4326. 
 */
(function() {

    var pole = 20037508.34;

    function inverseMercator(xy) {
        xy.x = 180 * xy.x / pole;
        xy.y = 180 / Math.PI * (2 * Math.atan(Math.exp((xy.y / pole) * Math.PI)) - Math.PI / 2);
        return xy;
    }

    function forwardMercator(xy) {
        xy.x = xy.x * pole / 180;
        var y = Math.log(Math.tan((90 + xy.y) * Math.PI / 360)) / Math.PI * pole;
        xy.y = Math.max(-20037508.34, Math.min(y, 20037508.34));
        return xy;
    }

    function map(base, codes) {
        var add = GeoGlobe.SpatialReference.addTransform;
        var same = GeoGlobe.SpatialReference.nullTransform;
        var i, len, code, other, j;
        for (i=0, len=codes.length; i<len; ++i) {
            code = codes[i];
            add(base, code, forwardMercator);
            add(code, base, inverseMercator);
            for (j=i+1; j<len; ++j) {
                other = codes[j];
                add(code, other, same);
                add(other, code, same);
            }
        }
    }
    
    // list of equivalent codes for web mercator
    var mercator = ["EPSG:900913", "EPSG:3857", "EPSG:102113", "EPSG:102100"],
        geographic = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"],
        i;
    for (i=mercator.length-1; i>=0; --i) {
        map(mercator[i], geographic);
    }
    for (i=geographic.length-1; i>=0; --i) {
        map(geographic[i], mercator);
    }

})();
/**
 *  Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license.

 * */


/**
 * 包含对字符串方便操作的方法
 * @namespace GeoGlobe.String
 * @private
 *
 */
GeoGlobe.String = {

    /**
     * Test whether a string starts with another string.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param {String} str -  The string to test.
     * @param {String} sub -  The substring to look for.
     * @returns {Boolean} The first string starts with the second.
     */
    startsWith: function(str, sub) {
        return (str.indexOf(sub) == 0);
    },

    /**

     * Test whether a string contains another string.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param {String}  str - The string to test.
     *  @param {String}sub - The substring to look for.
     * 
     * @returns
     * {Boolean} The first string contains the second.
     */
    contains: function(str, sub) {
        return (str.indexOf(sub) != -1);
    },
    
    /**

     * Removes leading and trailing whitespace characters from a string.
     * @memberof GeoGlobe.BaseTypes.prototype

     * @param {String}str -  The (potentially) space padded string.  This string is not
     *     modified.
     * 
     * @returns {String} A trimmed version of the string with all leading and
     *     trailing spaces removed.
     */
    trim: function(str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    },
    
    /**

     * Camel-case a hyphenated string. 
     *     Ex. "chicken-head" becomes "chickenHead", and
     *     "-chicken-head" becomes "ChickenHead".
     *     @memberof GeoGlobe.BaseTypes.prototype


     * @param {String}str - The string to be camelized.  The original is not modified.
     * 
     * @returns {String} The string, camelized
     */
    camelize: function(str) {
        var oStringList = str.split('-');
        var camelizedString = oStringList[0];
        for (var i=1, len=oStringList.length; i<len; i++) {
            var s = oStringList[i];
            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);
        }
        return camelizedString;
    },
    
    /**

     * Given a string with tokens in the form ${token}, return a string
     *     with tokens replaced with properties from the given context
     *     object.  Represent a literal "${" by doubling it, e.g. "${${".
     *     @memberof GeoGlobe.BaseTypes.prototype

     * @param {String} template -  A string with tokens to be replaced.  A template
     *     has the form "literal ${token}" where the token will be replaced
     *     by the value of context["token"].
     * @param {Object}context -  An optional object with properties corresponding
     *     to the tokens in the format string.  If no context is sent, the
     *     window object will be used.
     *  @param {Array}args -  Optional arguments to pass to any functions found in
     *     the context.  If a context property is a function, the token
     *     will be replaced by the return from the function called with
     *     these arguments.
     *
     * @returns {String} A string with tokens replaced from the context object.
     */
    format: function(template, context, args) {
        if(!context) {
            context = window;
        }

        // Example matching: 
        // str   = ${foo.bar}
        // match = foo.bar
        var replacer = function(str, match) {
            var replacement;

            // Loop through all subs. Example: ${a.b.c}
            // 0 -> replacement = context[a];
            // 1 -> replacement = context[a][b];
            // 2 -> replacement = context[a][b][c];
            var subs = match.split(/\.+/);
            for (var i=0; i< subs.length; i++) {
                if (i == 0) {
                    replacement = context;
                }
                if (replacement === undefined) {
                    break;
                }
                replacement = replacement[subs[i]];
            }

            if(typeof replacement == "function") {
                replacement = args ?
                    replacement.apply(null, args) :
                    replacement();
            }

            // If replacement is undefined, return the string 'undefined'.
            // This is a workaround for a bugs in browsers not properly 
            // dealing with non-participating groups in regular expressions:
            // http://blog.stevenlevithan.com/archives/npcg-javascript
            if (typeof replacement == 'undefined') {
                return 'undefined';
            } else {
                return replacement; 
            }
        };

        return template.replace(GeoGlobe.String.tokenRegEx, replacer);
    },

    /**

     * Used to find tokens in a string.
     *  @memberof GeoGlobe.BaseTypes.prototype
     *  @param tokenRegEx
     * @example ${a}, ${a.b.c}, ${a-b}, ${5}
     */
    tokenRegEx:  /\$\{([\w.]+?)\}/g,
    
    /**
     *
     * Used to test strings as numbers
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param numberRegEx
     */
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,
    
    /**
     *  Determine whether a string contains only a numeric value.
     *  @memberof GeoGlobe.BaseTypes.prototype


     *
     * @example
     * (code)
     * GeoGlobe.String.isNumeric("6.02e23") // true
     * GeoGlobe.String.isNumeric("12 dozen") // false
     * GeoGlobe.String.isNumeric("4") // true
     * GeoGlobe.String.isNumeric(" 4 ") // false
     * (end)
     *
     * @returns
     * {Boolean} String contains only a number.
     */
    isNumeric: function(value) {
        return GeoGlobe.String.numberRegEx.test(value);
    },
    
    /**

     * Converts a string that appears to be a numeric value into a number.
     * @memberof GeoGlobe.BaseTypes.prototype


     * @param {String}value
     * @param {Boolean} trimWhitespace
     *
     * @returns
     * {Number|String} a Number if the passed value is a number, a String
     *     otherwise. 
     */
    numericIf: function(value, trimWhitespace) {
        var originalValue = value;
        if (trimWhitespace === true && value != null && value.replace) {
            value = value.replace(/^\s*|\s*$/g, "");
        }
        return GeoGlobe.String.isNumeric(value) ? parseFloat(value) : originalValue;
    }

};

/**
 * @namespace GeoGlobe.Number
 * @private
 */
GeoGlobe.Number = {

    /**

     * Decimal separator to use when formatting numbers.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param decimalSeparator
     */
    decimalSeparator: ".",
    
    /**
     *

     * Thousands separator to use when formatting numbers.
     * @memberof GeoGlobe.BaseTypes.prototype
     *  @param thousandsSeparator
     */
    thousandsSeparator: ",",
    
    /**
     *
     * Limit the number of significant digits on a float.
     * @memberof GeoGlobe.BaseTypes.prototype

     * @param {Float}num
     * @param {Integer} sig
     *
     * @returns
     * {Float} The number, rounded to the specified number of significant
     *     digits.
     */
    limitSigDigs: function(num, sig) {
        var fig = 0;
        if (sig > 0) {
            fig = parseFloat(num.toPrecision(sig));
        }
        return fig;
    },
    
    /**

     * Formats a number for output.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @param {Float}num
     *  @param {Integer} dec  - {Integer} Number of decimal places to round to.
     *        Defaults to 0. Set to null to leave decimal places unchanged.
     * @param {String}tsep -Thousands separator.
     *        Default is ",".
     * @param {String} dsep -  Decimal separator.
     *        Default is ".".
     *
     * @returns
     * {String} A string representing the formatted number.
     */
    format: function(num, dec, tsep, dsep) {
        dec = (typeof dec != "undefined") ? dec : 0; 
        tsep = (typeof tsep != "undefined") ? tsep :
            GeoGlobe.Number.thousandsSeparator; 
        dsep = (typeof dsep != "undefined") ? dsep :
            GeoGlobe.Number.decimalSeparator;

        if (dec != null) {
            num = parseFloat(num.toFixed(dec));
        }

        var parts = num.toString().split(".");
        if (parts.length == 1 && dec == null) {
            // integer where we do not want to touch the decimals
            dec = 0;
        }
        
        var integer = parts[0];
        if (tsep) {
            var thousands = /(-?[0-9]+)([0-9]{3})/; 
            while(thousands.test(integer)) { 
                integer = integer.replace(thousands, "$1" + tsep + "$2"); 
            }
        }
        
        var str;
        if (dec == 0) {
            str = integer;
        } else {
            var rem = parts.length > 1 ? parts[1] : "0";
            if (dec != null) {
                rem = rem + new Array(dec - rem.length + 1).join("0");
            }
            str = integer + dsep + rem;
        }
        return str;
    },

    /**

     * Create a zero padded string optionally with a radix for casting numbers.
     * @memberof GeoGlobe.BaseTypes.prototype

     * @param {Number}num -  The number to be zero padded.
     * @param {Number} len - The length of the string to be returned.
     * @param {Number} radix -  An integer between 2 and 36 specifying the base to use
     *     for representing numeric values.
     */
    zeroPad: function(num, len, radix) {
        var str = num.toString(radix || 10);
        while (str.length < len) {
            str = "0" + str;
        }
        return str;
    }    
};

/**

 * Contains convenience functions for function manipulation.
 * @namespace GeoGlobe.Function
 * @private
 */
GeoGlobe.Function = {
    /**

     * Bind a function to an object.  Method to easily create closures with
     *     'this' altered.
     *  @memberof GeoGlobe.BaseTypes.prototype
     * @param {Function}func - Input function.
     *  @param {Object}object -  The object to bind to the input function (as this).
     * 
     * @returns
     * {Function} A closure with 'this' set to the passed in object.
     */
    bind: function(func, object) {
        // create a reference to all arguments past the second one
        var args = Array.prototype.slice.apply(arguments, [2]);
        return function() {
            // Push on any additional arguments from the actual function call.
            // These will come after those sent to the bind call.
            var newArgs = args.concat(
                Array.prototype.slice.apply(arguments, [0])
            );
            return func.apply(object, newArgs);
        };
    },
    
    /**

     * Bind a function to an object, and configure it to receive the event
     *     object as first parameter when called.
     *     @memberof GeoGlobe.BaseTypes.prototype

     * @param {Function}func -  Input function to serve as an event listener.
     * @param {Object}object -  A reference to this.
     * 
     * @returns
     * {Function}
     */
    bindAsEventListener: function(func, object) {
        return function(event) {
            return func.call(object, event || window.event);
        };
    },
    
    /**

     * A simple function to that just does "return false". We use this to 
     * avoid attaching anonymous functions to DOM event handlers, which 
     * causes "issues" on IE<8.
     * @memberof GeoGlobe.BaseTypes.prototype
     * 
     * @returns
     * {Boolean}
     */
    False : function() {
        return false;
    },

    /**

     * A simple function to that just does "return true". We use this to 
     * avoid attaching anonymous functions to DOM event handlers, which 
     * causes "issues" on IE<8.
     *  @memberof GeoGlobe.BaseTypes.prototype
     * 
     * @returns
     * {Boolean}
     */
    True : function() {
        return true;
    },
    /**

     * A reusable function that returns ``undefined``.
     * @memberof GeoGlobe.BaseTypes.prototype
     * @returns
     * {undefined}
     */
    Void: function() {}

};

/**

 * Contains convenience functions for array manipulation.
 * @namespace GeoGlobe.Array
 * @private
 */
GeoGlobe.Array = {

    /**

     * Filter an array.  Provides the functionality of the
     *     Array.prototype.filter extension to the ECMA-262 standard.  Where
     *     available, Array.prototype.filter will be used.
     *
     * Based on well known example from http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter
     * @memberof GeoGlobe.BaseTypes.prototype


     * @param {Array}array -  The array to be filtered.  This array is not mutated.
     *     Elements added to this array by the callback will not be visited.
     *  @param {Function}callback - A function that is called for each element in
     *     the array.  If this function returns true, the element will be
     *     included in the return.  The function will be called with three
     *     arguments: the element in the array, the index of that element, and
     *     the array itself.  If the optional caller parameter is specified
     *     the callback will be called with this set to caller.
     * @param {Object}caller - Optional object to be set as this when the callback
     *     is called.
     *
     * @returns
     * {Array} An array of elements from the passed in array for which the
     *     callback returns true.
     */
    filter: function(array, callback, caller) {
        var selected = [];
        if (Array.prototype.filter) {
            selected = array.filter(callback, caller);
        } else {
            var len = array.length;
            if (typeof callback != "function") {
                throw new TypeError();
            }
            for(var i=0; i<len; i++) {
                if (i in array) {
                    var val = array[i];
                    if (callback.call(caller, val, i, array)) {
                        selected.push(val);
                    }
                }
            }        
        }
        return selected;
    }
    
};


/**

 * 处理浏览器兼容性问题的扩展函数endsWith
 *  @memberof GeoGlobe.BaseTypes.prototype
 * @param {Object} searchString
 * @param {Object} position
 * 
 * @example
 * 
 * var str = 'To be, or not to be, that is the question.';
 * 
 * console.log(str.endsWith('question.')); // true
 * console.log(str.endsWith('to be'));     // false
 * console.log(str.endsWith('to be', 19)); // true
 */
if (!String.prototype.endsWith) {
    String.prototype.endsWith = function(searchString, position){
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.lastIndexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    };
}/**
 *  Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Pixel

 *@classdesc  屏幕像素坐标类。
 */
GeoGlobe.Pixel = GeoGlobe.Class4OL({
    
    /**

     * x坐标。
     * @memberof GeoGlobe.Pixel.prototype
     * @type {Number}

     */
    x: 0.0,

    /**
     * y坐标。
     * @memberof GeoGlobe.Pixel.prototype
     * @type {Number}
     */
    y: 0.0,
    
    /**

     * 创造一个示例化对象。
     *@memberof GeoGlobe.Pixel.prototype

     * @param {Number} x -x坐标。
     * @param {Number}y -  y坐标。
     *
     * @returns
     * GeoGlobe.Pixel实例。
     */
    initialize: function(x, y) {
        this.x = parseFloat(x);
        this.y = parseFloat(y);
    },
    
    /**

     * 将此对象转换为字符串。
     * @memberof GeoGlobe.Pixel.prototype
     * @returns
     * {String} 像素的字符串表示. ex: "x=200.4,y=242.2"
     */
    toString:function() {
        return ("x=" + this.x + ",y=" + this.y);
    },

    /**

     * 返回这个像素对象的副本。
     *@memberof GeoGlobe.Pixel.prototype
     * @returns
     * {GeoGlobe.Pixel} 克隆后的像素值。
     */
    clone:function() {
        return new GeoGlobe.Pixel(this.x, this.y); 
    },
    
    /**

     * 确定一个像素是否等于另一个像素
     *@memberof GeoGlobe.Pixel.prototype

     * @param {GeoGlobe.Pixel|Object}GeoGlobe.Pixelpx -  一个GeoGlobe像素 或者 带有x、y属性的对象。
     *
     * @returns
     * {Boolean} 如果传入的PX为NULL，则返回false。
     */
    equals:function(px) {
        var equals = false;
        if (px != null) {
            equals = ((this.x == px.x && this.y == px.y) ||
                      (isNaN(this.x) && isNaN(this.y) && isNaN(px.x) && isNaN(px.y)));
        }
        return equals;
    },

    /**

     * 返回作为参数传递的像素点的距离。
     * @memberof GeoGlobe.Pixel.prototype

     * @param {GeoGlobe.Pixel}px - 像素坐标
     *
     * @returns
     * {Float} 将像素点作为参数传递到计算距离函数中。
     */
    distanceTo:function(px) {
        return Math.sqrt(
            Math.pow(this.x - px.x, 2) +
            Math.pow(this.y - px.y, 2)
        );
    },

    /**
     * {GeoGlobe.Pixel} 一个新像素，这个像素的x和y通过传入的值增加。
     *@memberof GeoGlobe.Pixel.prototype

     *@param {Integer}x -x坐标。
     *@param {Integer} y -y坐标。
     *

     */
    add:function(x, y) {
        if ( (x == null) || (y == null) ) {
            throw new TypeError('Pixel.add cannot receive null values');
        }
        return new GeoGlobe.Pixel(this.x + x, this.y + y);
    },

    /**

    * @memberof GeoGlobe.Pixel.prototype

    *@param {GeoGlobe.Pixel|Object}px - 一个GeoGlobe像素 或者 带有x、y属性的对象。
    * 
    * @returns
    * {GeoGlobe.Pixel}  一个新像素
    */
    offset:function(px) {
        var newPx = this.clone();
        if (px) {
            newPx = this.add(px.x, px.y);
        }
        return newPx;
    },

    CLASS_NAME: "GeoGlobe.Pixel"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Size

 * @classdesc   尺寸类，用宽和高表示一个矩形区域的尺寸大小。Instances of this class represent a width/height pair
 * @private
 */
GeoGlobe.Size = GeoGlobe.Class4OL({

    /**
     *  width
     * @memberof GeoGlobe.Size.prototype
     * @type {Number}
     *
     */
    w: 0.0,
    
    /**
     * height
     * @memberof GeoGlobe.Size.prototype
     * @type {Number}
     */
    h: 0.0,


    /**

     * Create an instance of GeoGlobe.Size
     * @memberof GeoGlobe.Size.prototype
     * @param {Number} w -  width
     * @param {Number}h - height
     */
    initialize: function(w, h) {
        this.w = parseFloat(w);
        this.h = parseFloat(h);
    },

    /**

     * Return the string representation of a size object
     * @memberof GeoGlobe.Size.prototype
     * @returns
     * {String} The string representation of GeoGlobe.Size object. 
     * (e.g. <i>"w=55,h=66"</i>)
     */
    toString:function() {
        return ("w=" + this.w + ",h=" + this.h);
    },

    /**

     * Create a clone of this size object
     * @memberof GeoGlobe.Size.prototype
     * @returns
     * {GeoGlobe.Size} A new GeoGlobe.Size object with the same w and h
     * values
     */
    clone:function() {
        return new GeoGlobe.Size(this.w, this.h);
    },

    /**
     *

     * Determine where this size is equal to another
     * @memberof GeoGlobe.Size.prototype
     *

     * @param {GeoGlobe.Size|Object} sz -  An GeoGlobe.Size or an object with
     *                                  a 'w' and 'h' properties.
     *
     * @returns
     * {Boolean} The passed in size has the same h and w properties as this one.
     * Note that if sz passed in is null, returns false.
     */
    equals:function(sz) {
        var equals = false;
        if (sz != null) {
            equals = ((this.w == sz.w && this.h == sz.h) ||
                      (isNaN(this.w) && isNaN(this.h) && isNaN(sz.w) && isNaN(sz.h)));
        }
        return equals;
    },

    CLASS_NAME: "GeoGlobe.Size"
});
/**
 *  Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**

 * Contains implementations of Date.parse and date.toISOString that match the
 *     ECMAScript 5 specification for parsing RFC 3339 dates.
 *     http://tools.ietf.org/html/rfc3339
 *      @namespace GeoGlobe.Date
 * @private
 */
GeoGlobe.Date = {

    /** 

     * The regex to be used for validating dates. You can provide your own
     * regex for instance for adding support for years before BC. Default
     * value is: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/
     * @memberof GeoGlobe.Date.prototype
     *  @param dateRegEx
     *
     */
    dateRegEx: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/,

    /**

     * Generates a string representing a date.  The format of the string follows
     *     the profile of ISO 8601 for date and time on the Internet (see
     *     http://tools.ietf.org/html/rfc3339).  If the toISOString method is
     *     available on the Date prototype, that is used.  The toISOString
     *     method for Date instances is defined in ECMA-262.
     *     @memberof GeoGlobe.Date.prototype

     *

     * @param  {Date} date -A date object.
     *
     * @returns
     * {String} A string representing the date (e.g.
     *     "2010-08-07T16:58:23.123Z").  If the date does not have a valid time
     *     (i.e. isNaN(date.getTime())) this method returns the string "Invalid
     *     Date".  The ECMA standard says the toISOString method should throw
     *     RangeError in this case, but Firefox returns a string instead.  For
     *     best results, use isNaN(date.getTime()) to determine date validity
     *     before generating date strings.
     */
    toISOString: (function() {
        if ("toISOString" in Date.prototype) {
            return function(date) {
                return date.toISOString();
            };
        } else {
            return function(date) {
                var str;
                if (isNaN(date.getTime())) {
                    // ECMA-262 says throw RangeError, Firefox returns
                    // "Invalid Date"
                    str = "Invalid Date";
                } else {
                    str =
                        date.getUTCFullYear() + "-" +
                        GeoGlobe.Number.zeroPad(date.getUTCMonth() + 1, 2) + "-" +
                        GeoGlobe.Number.zeroPad(date.getUTCDate(), 2) + "T" +
                        GeoGlobe.Number.zeroPad(date.getUTCHours(), 2) + ":" +
                        GeoGlobe.Number.zeroPad(date.getUTCMinutes(), 2) + ":" +
                        GeoGlobe.Number.zeroPad(date.getUTCSeconds(), 2) + "." +
                        GeoGlobe.Number.zeroPad(date.getUTCMilliseconds(), 3) + "Z";
                }
                return str;
            };
        }

    })(),

    /**

     * Generate a date object from a string.  The format for the string follows
     *     the profile of ISO 8601 for date and time on the Internet (see
     *     http://tools.ietf.org/html/rfc3339).  We don't call the native
     *     Date.parse because of inconsistency between implmentations.  In
     *     Chrome, calling Date.parse with a string that doesn't contain any
     *     indication of the timezone (e.g. "2011"), the date is interpreted
     *     in local time.  On Firefox, the assumption is UTC.
     *     @memberof GeoGlobe.Date.prototype
     *
     *

     * @param  {String}str -  A string representing the date (e.g.
     *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",
     *     "2010-08-07T11:58:23.123-06").
     *
     * @returns
     * {Date} A date object.  If the string could not be parsed, an invalid
     *     date is returned (i.e. isNaN(date.getTime())).
     */
    parse: function(str) {
        var date;
        var match = str.match(this.dateRegEx);
        if (match && (match[1] || match[7])) { // must have at least year or time
            var year = parseInt(match[1], 10) || 0;
            var month = (parseInt(match[2], 10) - 1) || 0;
            var day = parseInt(match[3], 10) || 1;
            date = new Date(Date.UTC(year, month, day));
            // optional time
            var type = match[7];
            if (type) {
                var hours = parseInt(match[4], 10);
                var minutes = parseInt(match[5], 10);
                var secFrac = parseFloat(match[6]);
                var seconds = secFrac | 0;
                var milliseconds = Math.round(1000 * (secFrac - seconds));
                date.setUTCHours(hours, minutes, seconds, milliseconds);
                // check offset
                if (type !== "Z") {
                    var hoursOffset = parseInt(type, 10);
                    var minutesOffset = parseInt(match[8], 10) || 0;
                    var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);
                    date = new Date(date.getTime() + offset);
                }
            }
        } else {
            date = new Date("invalid");
        }
        return date;
    }
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * The GeoGlobe.Console namespace is used for debugging and error logging.
 *      If the Firebug Lite (../Firebug/firebug.js) is included before this script,
 *      calls to GeoGlobe.Console methods will get redirected to window.console.
 *      This makes use of the Firebug extension where available and allows for
 *      cross-browser debugging Firebug style.
 *
 *
 * Note:
 * Note that behavior will differ with the Firebug extention and Firebug Lite.
 * Most notably, the Firebug Lite console does not currently allow for
 * hyperlinks to code or for clicking on object to explore their properties.
 * @namespace  GeoGlobe.Console
 * @private
 */
GeoGlobe.Console = {
    /**
     * Create empty functions for all console methods.  The real value of these
     * properties will be set if Firebug Lite (../Firebug/firebug.js script) is
     * included.  We explicitly require the Firebug Lite script to trigger
     * functionality of the GeoGlobe.Console methods.
     */
    
    /**
     * Log an object in the console.  The Firebug Lite console logs string
     * representation of objects.  Given multiple arguments, they will
     * be cast to strings and logged with a space delimiter.  If the first
     * argument is a string with printf-like formatting, subsequent arguments
     * will be used in string substitution.  Any additional arguments (beyond
     * the number substituted in a format string) will be appended in a space-
     * delimited line.
     * @function log
     * @memberof GeoGlobe.Console
     * @param {Object} object
     */
    log: function() {},

    /**
     * Writes a message to the console, including a hyperlink to the line
     * where it was called.
     * @function debug
     * @memberof GeoGlobe.Console
     *
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    debug: function() {},

    /**
     * Writes a message to the console with the visual "info" icon and color
     * coding and a hyperlink to the line where it was called.
     * @function info
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    info: function() {},

    /**
     * Writes a message to the console with the visual "warning" icon and
     * color coding and a hyperlink to the line where it was called.
     * @function warn
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    warn: function() {},

    /**
     * Writes a message to the console with the visual "error" icon and color
     * coding and a hyperlink to the line where it was called.
     * @function error
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    error: function() {},
    
    /**
     * A single interface for showing error messages to the user. The default
     * behavior is a Javascript alert, though this can be overridden by
     * reassigning GeoGlobe.Console.userError to a different function.
     * @function userError
     * @memberof GeoGlobe.Console
     * Expects a single error message
     *
     * @param  {Object} error
     */
    userError: function(error) {
        alert(error);
    },

    /**
     * Tests that an expression is true. If not, it will write a message to
     * the console and throw an exception.
     * @function assert
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object}  object
     */
    assert: function() {},

    /**
     * Prints an interactive listing of all properties of the object. This
     * looks identical to the view that you would see in the DOM tab.
     * @function dir
     * @memberof GeoGlobe.Console
     * @param {Object} object
     */
    dir: function() {},

    /**
     * Prints the XML source tree of an HTML or XML element. This looks
     * identical to the view that you would see in the HTML tab. You can click
     * on any node to inspect it in the HTML tab.
     * @function dirxml
     * @memberof GeoGlobe.Console
     * @param  {Object} object
     */
    dirxml: function() {},

    /**
     * Prints an interactive stack trace of JavaScript execution at the point
     * where it is called.  The stack trace details the functions on the stack,
     * as well as the values that were passed as arguments to each function.
     * You can click each function to take you to its source in the Script tab,
     * and click each argument value to inspect it in the DOM or HTML tabs.
     * @function trace
     *  @memberof GeoGlobe.Console
     */
    trace: function() {},

    /**
     * Writes a message to the console and opens a nested block to indent all
     * future messages sent to the console. Call GeoGlobe.Console.groupEnd()
     * to close the block.
     * @function group
     * @memberof GeoGlobe.Console
     * May be called with multiple arguments as with GeoGlobe.Console.log().
     *
     * @param {Object} object
     */
    group: function() {},

    /**
     * Closes the most recently opened block created by a call to
     * GeoGlobe.Console.group
     * @function groupEnd
     * @memberof GeoGlobe.Console
     */
    groupEnd: function() {},
    
    /**
     * Creates a new timer under the given name. Call
     * GeoGlobe.Console.timeEnd(name)
     * with the same name to stop the timer and print the time elapsed.
     * @function time
     * @memberof GeoGlobe.Console
     * @param {String} name
     */
    time: function() {},

    /**
     * Stops a timer created by a call to GeoGlobe.Console.time(name) and
     * writes the time elapsed.
     * @function timeEnd
     * @memberof GeoGlobe.Console
     * @param {String} name
     */
    timeEnd: function() {},

    /**
     * Turns on the JavaScript profiler. The optional argument title would
     * contain the text to be printed in the header of the profile report.
     * @function profile
     * @memberof GeoGlobe.Console
     * This function is not currently implemented in Firebug Lite.
     *
     * @param {String}  title - Optional title for the profiler
     */
    profile: function() {},

    /**
     * Turns off the JavaScript profiler and prints its report.
     * @function profileEnd
     *  @memberof GeoGlobe.Console
     * This function is not currently implemented in Firebug Lite.
     */
    profileEnd: function() {},

    /**
     * Writes the number of times that the line of code where count was called
     * was executed. The optional argument title will print a message in
     * addition to the number of the count.
     * @function count
     * @memberof GeoGlobe.Console
     * This function is not currently implemented in Firebug Lite.
     *
     * @param {String}  title - Optional title to be printed with count
     */
    count: function() {},

    CLASS_NAME: "GeoGlobe.Console"
};

/**
 * Execute an anonymous function to extend the GeoGlobe.Console namespace
 * if the firebug.js script is included.  This closure is used so that the
 * "scripts" and "i" variables don't pollute the global namespace.
 */
(function() {
    /**
     * If Firebug Lite is included (before this script), re-route all
     * GeoGlobe.Console calls to the console object.
     */
    var scripts = document.getElementsByTagName("script");
    for(var i=0, len=scripts.length; i<len; ++i) {
        if(scripts[i].src.indexOf("firebug.js") != -1) {
            if(console) {
                GeoGlobe.Util.extend(GeoGlobe.Console, console);
                break;
            }
        }
    }
})();
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * TODO: deprecate me
 * Use GeoGlobe.Request.proxy instead.
 */
GeoGlobe.ProxyHost = "";

/**
 * The GeoGlobe.Request namespace contains convenience methods for working
 *     with XMLHttpRequests.  These methods work with a cross-browser
 *     W3C compliant GeoGlobe.Request.XMLHttpRequest class.
 * @namespace GeoGlobe.Request
 * @private
 */
if (!GeoGlobe.Request) {
    /**
     * This allows for tool/Request/XMLHttpRequest.js to be included
     * before or after this script.
     */
    GeoGlobe.Request = {};
}
GeoGlobe.Util.extend(GeoGlobe.Request, {

    DEFAULT_CONFIG: {
        method: "GET",
        url: window.location.href,
        async: true,
        user: undefined,
        password: undefined,
        params: null,
        proxy: GeoGlobe.ProxyHost,
        headers: {},
        data: null,
        callback: function() {},
        success: null,
        failure: null,
        scope: null
    },
    

    URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/,
    
    /**
     * An events object that handles all events on the {GeoGlobe.Request} object.
     * @memberof GeoGlobe.Request
     *
     *
     * All event listeners will receive an event object with three properties:
     * @param {GeoGlobe.Request.XMLHttpRequest} request  -  The request object.
     * @param {Object} config  - The config object sent to the specific request method.
     * @param {String} requestUrl  - The request url.
     * 
     * Supported event types:
     * complete - Triggered when we have a response from the request, if a
     *     listener returns false, no further response processing will take
     *     place.
     * success - Triggered when the HTTP response has a success code (200-299).
     * failure - Triggered when the HTTP response does not have a success code.
     */
    //events: new GeoGlobe.Events(this),
    
    /**
     *  Using the specified proxy, returns a same origin url of the provided url.
     * @memberof GeoGlobe.Request
     * @param {String} url  - An arbitrary url
     * @param {String|Function} proxy   - The proxy to use to make the provided url a same origin url.
     *
     * @returns {String}
     * - the same origin url. If no proxy is provided, the returned url
     *     will be the same as the provided url.
     */
    makeSameOrigin: function(url, proxy) {
        var sameOrigin = url.indexOf("http") !== 0;
        var urlParts = !sameOrigin && url.match(this.URL_SPLIT_REGEX);
        if (urlParts) {
            var location = window.location;
            sameOrigin =
                urlParts[1] == location.protocol &&
                urlParts[3] == location.hostname;
            var uPort = urlParts[4], lPort = location.port;
            if (uPort != 80 && uPort != "" || lPort != "80" && lPort != "") {
                sameOrigin = sameOrigin && uPort == lPort;
            }
        }
        if (!sameOrigin) {
            if (proxy) {
                if (typeof proxy == "function") {
                    url = proxy(url);
                } else {
                      if(url.indexOf("cts?") >= 0){
                        url = proxy + url;
                    }else{
                        url = proxy + encodeURIComponent(url);
                    }
                }
            }
        }
        return url;
    },

    /**
     * Create a new XMLHttpRequest object, open it, set any headers, bind
     *     a callback to done state, and send any data.  It is recommended that
     *     you use one GET, POST, PUT, DELETE, OPTIONS, or HEAD.
     *     This method is only documented to provide detail on the configuration
     *     options available to all request methods.
     * @memberof GeoGlobe.Request
     * @param {Object} config  - Object containing properties for configuring the
     *     request.  Allowed configuration properties are described below.
     *     This object is modified and should not be reused.
     *
     * Allowed config properties:
     * @param {String} method  - One of GET, POST, PUT, DELETE, HEAD, or OPTIONS.  Default is GET.
     * @param  {String} url  - URL for the request.
     * @param {Boolean} async  - Open an asynchronous request.  Default is true.
     * @param {String}  user  - User for relevant authentication scheme.  Set to null to clear current user.
     * @param {String} password  - Password for relevant authentication scheme.
     *     Set to null to clear current password.
     * @param {String} proxy  - Optional proxy.  Defaults to GeoGlobe.ProxyHost.
     * @param {Object} params -  Any key:value pairs to be appended to the
     *     url as a query string.  Assumes url doesn't already include a query
     *     string or hash.  Typically, this is only appropriate for GET
     *     requests where the query string will be appended to the url.
     *     Parameter values that are arrays will be
     *     concatenated with a comma (note that this goes against form-encoding)
     *     as is done with GeoGlobe.Util.getParameterString.
     * @param {Object} headers - Object with header:value pairs to be set on the request.
     * @param {String | Document} data  - Optional data to send with the request.
     *     Typically, this is only used with POST and PUT requests.
     *     Make sure to provide the appropriate "Content-Type" header for your
     *     data.  For POST and PUT requests, the content type defaults to
     *     "application-xml".  If your data is a different content type, or
     *     if you are using a different HTTP method, set the "Content-Type"
     *     header to match your data type.
     * @param {Function} callback  - Function to call when request is done.
     *     To determine if the request failed, check request.status (200
     *     indicates success).
     * @param {Function} success  -  Optional function to call if request status is in
     *     the 200s.  This will be called in addition to callback above and
     *     would typically only be used as an alternative.
     * @param {Function} failure  - Optional function to call if request status is not
     *     in the 200s.  This will be called in addition to callback above and
     *     would typically only be used as an alternative.
     * @param {Object}  scope  - If callback is a public method on some object,
     *     set the scope to that object.
     *
     * @returns {XMLHttpRequest}  - Request object.  To abort the request before a response
     *     is received, call abort() on the request object.
     */
    issue: function(config) {        
        // apply default config - proxy host may have changed
        var defaultConfig = GeoGlobe.Util.extend(
            this.DEFAULT_CONFIG,
            {proxy: GeoGlobe.ProxyHost}
        );
        config = config || {};
        config.headers = config.headers || {};
        config = GeoGlobe.Util.applyDefaults(config, defaultConfig);
        config.headers = GeoGlobe.Util.applyDefaults(config.headers, defaultConfig.headers);
        // Always set the "X-Requested-With" header to signal that this request
        // was issued through the XHR-object. Since header keys are case 
        // insensitive and we want to allow overriding of the "X-Requested-With"
        // header through the user we cannot use applyDefaults, but have to 
        // check manually whether we were called with a "X-Requested-With"
        // header.
        var customRequestedWithHeader = false,
            headerKey;
        for(headerKey in config.headers) {
            if (config.headers.hasOwnProperty( headerKey )) {
                if (headerKey.toLowerCase() === 'x-requested-with') {
                    customRequestedWithHeader = true;
                }
            }
        }
        if (customRequestedWithHeader === false) {
            // we did not have a custom "X-Requested-With" header
            config.headers['X-Requested-With'] = 'XMLHttpRequest';
        }

        // create request, open, and set headers
        var request = new GeoGlobe.Request.XMLHttpRequest();
		config.url = encodeURI(config.url);//20170911，进行编码一次，解决带中文的url，无法请求的问题。
        var url = GeoGlobe.Util.urlAppend(config.url, 
            GeoGlobe.Util.getParameterString(config.params || {}));
        url = GeoGlobe.Request.makeSameOrigin(url, config.proxy);
        request.open(
            config.method, url, config.async, config.user, config.password
        );
        for(var header in config.headers) {
            request.setRequestHeader(header, config.headers[header]);
        }

        //var events = this.events;

        // we want to execute runCallbacks with "this" as the
        // execution scope
        var self = this;
        
        request.onreadystatechange = function() {
            if(request.readyState == GeoGlobe.Request.XMLHttpRequest.DONE) {
				/*
                var proceed = events.triggerEvent(
                    "complete",
                    {request: request, config: config, requestUrl: url}
                );
                */
				var proceed = null;//TODO by sw.2017.5.8 
                if(proceed !== false) {
                    self.runCallbacks(
                        {request: request, config: config, requestUrl: url}
                    );
                }
            }
        };
        
        // send request (optionally with data) and return
        // call in a timeout for asynchronous requests so the return is
        // available before readyState == 4 for cached docs
        if(config.async === false) {
            request.send(config.data);
        } else {
            window.setTimeout(function(){
                if (request.readyState !== 0) { // W3C: 0-UNSENT
                    request.send(config.data);
                }
            }, 0);
        }
        return request;
    },
    
    /**
     * Calls the complete, success and failure callbacks. Application
     *    can listen to the "complete" event, have the listener 
     *    display a confirm window and always return false, and
     *    execute GeoGlobe.Request.runCallbacks if the user
     *    hits "yes" in the confirm window.
     * @memberof GeoGlobe.Request
     * @param {Object} options  -  Hash containing request, config and requestUrl keys
     */
    runCallbacks: function(options) {
        var request = options.request;
        var config = options.config;
        
        // bind callbacks to readyState 4 (done)
        var complete = (config.scope) ?
            GeoGlobe.Function.bind(config.callback, config.scope) :
            config.callback;
        
        // optional success callback
        var success;
        if(config.success) {
            success = (config.scope) ?
                GeoGlobe.Function.bind(config.success, config.scope) :
                config.success;
        }

        // optional failure callback
        var failure;
        if(config.failure) {
            failure = (config.scope) ?
                GeoGlobe.Function.bind(config.failure, config.scope) :
                config.failure;
        }

        if (GeoGlobe.Util.createUrlObject(config.url).protocol == "file:" &&
                                                        request.responseText) {
            request.status = 200;
        }
        complete(request);

        if (!request.status || (request.status >= 200 && request.status < 300)) {
            //this.events.triggerEvent("success", options);//TODO
            if(success) {
                success(request);
            }
        }
        if(request.status && (request.status < 200 || request.status >= 300)) {                    
            //this.events.triggerEvent("failure", options);//TODO
            if(failure) {
                failure(request);
            }
        }
    },
    
    /**
     * Send an HTTP GET request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to GET.
     * @memberof GeoGlobe.Request
     * @param {Object} config  -  Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    GET: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "GET"});
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * Send a POST request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to POST and "Content-Type" header set to "application/xml".
     * @memberof GeoGlobe.Request
     * @param {Object} config   -  Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.  The
     *     default "Content-Type" header will be set to "application-xml" if
     *     none is provided.  This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    POST: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "POST"});
        // set content type to application/xml if it isn't already set
        config.headers = config.headers ? config.headers : {};
        if(!("CONTENT-TYPE" in GeoGlobe.Util.upperCaseObject(config.headers))) {
            config.headers["Content-Type"] = "application/xml";
        }
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * Send an HTTP PUT request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to PUT and "Content-Type" header set to "application/xml".
     * @memberof GeoGlobe.Request
     * @param {Object} config
     * - Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.  The
     *     default "Content-Type" header will be set to "application-xml" if
     *     none is provided.  This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    PUT: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "PUT"});
        // set content type to application/xml if it isn't already set
        config.headers = config.headers ? config.headers : {};
        if(!("CONTENT-TYPE" in GeoGlobe.Util.upperCaseObject(config.headers))) {
            config.headers["Content-Type"] = "application/xml";
        }
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * Send an HTTP DELETE request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to DELETE.
     * @memberof GeoGlobe.Request
     * @param {Object} config
     *  -  Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    DELETE: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "DELETE"});
        return GeoGlobe.Request.issue(config);
    },
  
    /**
     * Send an HTTP HEAD request.  Additional configuration properties are
     *     documented in the issue method, with the method property set
     *     to HEAD.
     * @memberof GeoGlobe.Request
     * @param {Object} config
     * - Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    HEAD: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "HEAD"});
        return GeoGlobe.Request.issue(config);
    },
    
    /**
     * Send an HTTP OPTIONS request.  Additional configuration properties are
     *     documented in the issue method, with the method property set to OPTIONS.
     * @memberof GeoGlobe.Request
     * @param {Object} config
     *  - Object with properties for configuring the request.
     *     See the issue method for documentation of allowed properties.
     *     This object is modified and should not be reused.
     * 
     * @returns {XMLHttpRequest}  - Request object.
     */
    OPTIONS: function(config) {
        config = GeoGlobe.Util.extend(config, {method: "OPTIONS"});
        return GeoGlobe.Request.issue(config);
    }

});


/**
 * @memberof GeoGlobe.Request
 * @param {} request
 */
GeoGlobe.nullHandler = function(request) {
    GeoGlobe.Console.userError(GeoGlobe.i18n("unhandledRequest", {'statusText':request.statusText}));
};

/**
 * Background load a document.
 * *Deprecated*.  Use GeoGlobe.Request.GET method instead.
 * @memberof GeoGlobe.Request
 * @param {String} uri  - URI of source doc
 * @param {String} or {Object}  params   -  GET params. Either a string in the form
 *     "?hello=world&foo=bar" (do not forget the leading question mark)
 *     or an object in the form {'hello': 'world', 'foo': 'bar}
 * @param {Object} caller  - object which gets callbacks
 * @param {Function} onComplete  - Optional callback for success.  The callback
 *     will be called with this set to caller and will receive the request
 *     object as an argument.  Note that if you do not specify an onComplete
 *     function, GeoGlobe.nullHandler will be called (which pops up a
 *     user friendly error message dialog).
 * @param {Function} onFailure   -  Optional callback for failure.  In the event of
 *     a failure, the callback will be called with this set to caller and will
 *     receive the request object as an argument.  Note that if you do not
 *     specify an onComplete function, GeoGlobe.nullHandler will be called
 *     (which pops up a user friendly error message dialog).
 *
 * @returns {GeoGlobe.Request.XMLHttpRequest}  - The request object. To abort loading,
 *     call request.abort().
 */
GeoGlobe.loadURL = function(uri, params, caller,
                                  onComplete, onFailure) {
    
    if(typeof params == 'string') {
        params = GeoGlobe.Util.getParameters(params);
    }
    var success = (onComplete) ? onComplete : GeoGlobe.nullHandler;
    var failure = (onFailure) ? onFailure : GeoGlobe.nullHandler;
    
    return GeoGlobe.Request.GET({
        url: uri, params: params,
        success: success, failure: failure, scope: caller
    });
};

/**
 * 设置代理地址,根据自己的代理器地址来配置
 * @memberof GeoGlobe.Request
 * @param {String} proxyHost  - 代理地址
 */
GeoGlobe.Request.setProxyHost = function(proxyHost){
	GeoGlobe.ProxyHost = proxyHost;
};

/**
 * 代理地址
 * @memberof GeoGlobe.Request
 * @returns  {String}  - 代理地址
 */
GeoGlobe.Request.getProxyHost = function(){
	return GeoGlobe.ProxyHost;
};

/**
 * 处理带中文的url
 * @memberof GeoGlobe.Request
 * @returns {String}  - 带代理地址的url
 */
GeoGlobe.appendToProxy = function(url){
	var arr = url.split("?");
	var u1 = GeoGlobe.ProxyHost + encodeURI(encodeURI(arr[0]));
	if(arr.length === 2){
		u1 += "?" + arr[1];
	}
	return u1;
};

/**
 * 加载javascript文件
 * @memberof GeoGlobe.Request
 * @param {String} url  - js文件路径。
 */
GeoGlobe.loadScript = function(url){
	GeoGlobe.Request.GET({
		url: url,
		async: false,
		headers: {
			"Accept": "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01"
		},
		//callback: callback,
		success: function(e){
			GeoGlobe.Util.globalEval(e.responseText);
			//if(typeof(callback) === "function"){
			//	callback(e);
			//}
		},
		failure: function(e){
			alert("加载:"+url+" 失败。");
		}
	});
};
// XMLHttpRequest.js Copyright (C) 2010 Sergey Ilinsky (http://www.ilinsky.com)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

    
/**
 * @private
 */
(function () {


    // Save reference to earlier defined object implementation (if any)
    var oXMLHttpRequest    = window.XMLHttpRequest;

    // Define on browser type
    var bGecko    = !!window.controllers,
        bIE        = window.document.all && !window.opera,
        bIE7    = bIE && window.navigator.userAgent.match(/MSIE 7.0/);

    // Enables "XMLHttpRequest()" call next to "new XMLHttpReques()"
    function fXMLHttpRequest() {
        this._object    = oXMLHttpRequest && !bIE7 ? new oXMLHttpRequest : new window.ActiveXObject("Microsoft.XMLHTTP");
        this._listeners    = [];
    };

    // Constructor
    function cXMLHttpRequest() {
        return new fXMLHttpRequest;
    };
    cXMLHttpRequest.prototype    = fXMLHttpRequest.prototype;

    // BUGFIX: Firefox with Firebug installed would break pages if not executed
    if (bGecko && oXMLHttpRequest.wrapped)
        cXMLHttpRequest.wrapped    = oXMLHttpRequest.wrapped;

    // Constants
    cXMLHttpRequest.UNSENT                = 0;
    cXMLHttpRequest.OPENED                = 1;
    cXMLHttpRequest.HEADERS_RECEIVED    = 2;
    cXMLHttpRequest.LOADING                = 3;
    cXMLHttpRequest.DONE                = 4;

    // Public Properties
    cXMLHttpRequest.prototype.readyState    = cXMLHttpRequest.UNSENT;
    cXMLHttpRequest.prototype.responseText    = '';
    cXMLHttpRequest.prototype.responseXML    = null;
    cXMLHttpRequest.prototype.status        = 0;
    cXMLHttpRequest.prototype.statusText    = '';

    // Priority proposal
    cXMLHttpRequest.prototype.priority        = "NORMAL";

    // Instance-level Events Handlers
    cXMLHttpRequest.prototype.onreadystatechange    = null;

    // Class-level Events Handlers
    cXMLHttpRequest.onreadystatechange    = null;
    cXMLHttpRequest.onopen                = null;
    cXMLHttpRequest.onsend                = null;
    cXMLHttpRequest.onabort                = null;

    // Public Methods
    cXMLHttpRequest.prototype.open    = function(sMethod, sUrl, bAsync, sUser, sPassword) {
        // Delete headers, required when object is reused
        delete this._headers;

        // When bAsync parameter value is omitted, use true as default
        if (arguments.length < 3)
            bAsync    = true;

        // Save async parameter for fixing Gecko bug with missing readystatechange in synchronous requests
        this._async        = bAsync;

        // Set the onreadystatechange handler
        var oRequest    = this,
            nState        = this.readyState,
            fOnUnload;

        // BUGFIX: IE - memory leak on page unload (inter-page leak)
        if (bIE && bAsync) {
            fOnUnload = function() {
                if (nState != cXMLHttpRequest.DONE) {
                    fCleanTransport(oRequest);
                    // Safe to abort here since onreadystatechange handler removed
                    oRequest.abort();
                }
            };
            window.attachEvent("onunload", fOnUnload);
        }

        // Add method sniffer
        if (cXMLHttpRequest.onopen)
            cXMLHttpRequest.onopen.apply(this, arguments);

        if (arguments.length > 4)
            this._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
        else
        if (arguments.length > 3)
            this._object.open(sMethod, sUrl, bAsync, sUser);
        else
            this._object.open(sMethod, sUrl, bAsync);

        /*
         * 解决在IE10下请求后返回的XML数据不是文档类型，从而无法使用selectNodes方法的问题。
         * 在此设置响应返回的数据类型为"msxml-document"，就可以得到XML document，也能使用selectNodes方法了。
         */
		try {
			this._object.responseType = "msxml-document";
		}catch(e){
			
		}
		this.readyState    = cXMLHttpRequest.OPENED;
        fReadyStateChange(this);

        this._object.onreadystatechange    = function() {
            if (bGecko && !bAsync)
                return;

            // Synchronize state
            oRequest.readyState        = oRequest._object.readyState;

            //
            fSynchronizeValues(oRequest);

            // BUGFIX: Firefox fires unnecessary DONE when aborting
            if (oRequest._aborted) {
                // Reset readyState to UNSENT
                oRequest.readyState    = cXMLHttpRequest.UNSENT;

                // Return now
                return;
            }

            if (oRequest.readyState == cXMLHttpRequest.DONE) {
                // Free up queue
                delete oRequest._data;
/*                if (bAsync)
                    fQueue_remove(oRequest);*/
                //
                fCleanTransport(oRequest);
// Uncomment this block if you need a fix for IE cache
/*
                // BUGFIX: IE - cache issue
                if (!oRequest._object.getResponseHeader("Date")) {
                    // Save object to cache
                    oRequest._cached    = oRequest._object;

                    // Instantiate a new transport object
                    cXMLHttpRequest.call(oRequest);

                    // Re-send request
                    if (sUser) {
                         if (sPassword)
                            oRequest._object.open(sMethod, sUrl, bAsync, sUser, sPassword);
                        else
                            oRequest._object.open(sMethod, sUrl, bAsync, sUser);
                    }
                    else
                        oRequest._object.open(sMethod, sUrl, bAsync);
                    oRequest._object.setRequestHeader("If-Modified-Since", oRequest._cached.getResponseHeader("Last-Modified") || new window.Date(0));
                    // Copy headers set
                    if (oRequest._headers)
                        for (var sHeader in oRequest._headers)
                            if (typeof oRequest._headers[sHeader] == "string")    // Some frameworks prototype objects with functions
                                oRequest._object.setRequestHeader(sHeader, oRequest._headers[sHeader]);

                    oRequest._object.onreadystatechange    = function() {
                        // Synchronize state
                        oRequest.readyState        = oRequest._object.readyState;

                        if (oRequest._aborted) {
                            //
                            oRequest.readyState    = cXMLHttpRequest.UNSENT;

                            // Return
                            return;
                        }

                        if (oRequest.readyState == cXMLHttpRequest.DONE) {
                            // Clean Object
                            fCleanTransport(oRequest);

                            // get cached request
                            if (oRequest.status == 304)
                                oRequest._object    = oRequest._cached;

                            //
                            delete oRequest._cached;

                            //
                            fSynchronizeValues(oRequest);

                            //
                            fReadyStateChange(oRequest);

                            // BUGFIX: IE - memory leak in interrupted
                            if (bIE && bAsync)
                                window.detachEvent("onunload", fOnUnload);
                        }
                    };
                    oRequest._object.send(null);

                    // Return now - wait until re-sent request is finished
                    return;
                };
*/
                // BUGFIX: IE - memory leak in interrupted
                if (bIE && bAsync)
                     window.detachEvent("onunload", fOnUnload);
            }

            // BUGFIX: Some browsers (Internet Explorer, Gecko) fire OPEN readystate twice
            if (nState != oRequest.readyState)
                fReadyStateChange(oRequest);

            nState    = oRequest.readyState;
        }
    };
    function fXMLHttpRequest_send(oRequest) {
        oRequest._object.send(oRequest._data);

        // BUGFIX: Gecko - missing readystatechange calls in synchronous requests
        if (bGecko && !oRequest._async) {
            oRequest.readyState    = cXMLHttpRequest.OPENED;

            // Synchronize state
            fSynchronizeValues(oRequest);

            // Simulate missing states
            while (oRequest.readyState < cXMLHttpRequest.DONE) {
                oRequest.readyState++;
                fReadyStateChange(oRequest);
                // Check if we are aborted
                if (oRequest._aborted)
                    return;
            }
        }
    };
    cXMLHttpRequest.prototype.send    = function(vData) {
        // Add method sniffer
        if (cXMLHttpRequest.onsend)
            cXMLHttpRequest.onsend.apply(this, arguments);

        if (!arguments.length)
            vData    = null;

        // BUGFIX: Safari - fails sending documents created/modified dynamically, so an explicit serialization required
        // BUGFIX: IE - rewrites any custom mime-type to "text/xml" in case an XMLNode is sent
        // BUGFIX: Gecko - fails sending Element (this is up to the implementation either to standard)
        if (vData && vData.nodeType) {
            vData    = window.XMLSerializer ? new window.XMLSerializer().serializeToString(vData) : vData.xml;
            if (!this._headers["Content-Type"])
                this._object.setRequestHeader("Content-Type", "application/xml");
        }

        this._data    = vData;
/*
        // Add to queue
        if (this._async)
            fQueue_add(this);
        else*/
            fXMLHttpRequest_send(this);
    };
    cXMLHttpRequest.prototype.abort    = function() {
        // Add method sniffer
        if (cXMLHttpRequest.onabort)
            cXMLHttpRequest.onabort.apply(this, arguments);

        // BUGFIX: Gecko - unnecessary DONE when aborting
        if (this.readyState > cXMLHttpRequest.UNSENT)
            this._aborted    = true;

        this._object.abort();

        // BUGFIX: IE - memory leak
        fCleanTransport(this);

        this.readyState    = cXMLHttpRequest.UNSENT;

        delete this._data;
/*        if (this._async)
            fQueue_remove(this);*/
    };
    cXMLHttpRequest.prototype.getAllResponseHeaders    = function() {
        return this._object.getAllResponseHeaders();
    };
    cXMLHttpRequest.prototype.getResponseHeader    = function(sName) {
        return this._object.getResponseHeader(sName);
    };
    cXMLHttpRequest.prototype.setRequestHeader    = function(sName, sValue) {
        // BUGFIX: IE - cache issue
        if (!this._headers)
            this._headers    = {};
        this._headers[sName]    = sValue;

        return this._object.setRequestHeader(sName, sValue);
    };

    // EventTarget interface implementation
    cXMLHttpRequest.prototype.addEventListener    = function(sName, fHandler, bUseCapture) {
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
                return;
        // Add listener
        this._listeners.push([sName, fHandler, bUseCapture]);
    };

    cXMLHttpRequest.prototype.removeEventListener    = function(sName, fHandler, bUseCapture) {
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == sName && oListener[1] == fHandler && oListener[2] == bUseCapture)
                break;
        // Remove listener
        if (oListener)
            this._listeners.splice(nIndex, 1);
    };

    cXMLHttpRequest.prototype.dispatchEvent    = function(oEvent) {
        var oEventPseudo    = {
            'type':            oEvent.type,
            'target':        this,
            'currentTarget':this,
            'eventPhase':    2,
            'bubbles':        oEvent.bubbles,
            'cancelable':    oEvent.cancelable,
            'timeStamp':    oEvent.timeStamp,
            'stopPropagation':    function() {},    // There is no flow
            'preventDefault':    function() {},    // There is no default action
            'initEvent':        function() {}    // Original event object should be initialized
        };

        // Execute onreadystatechange
        if (oEventPseudo.type == "readystatechange" && this.onreadystatechange)
            (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [oEventPseudo]);

        // Execute listeners
        for (var nIndex = 0, oListener; oListener = this._listeners[nIndex]; nIndex++)
            if (oListener[0] == oEventPseudo.type && !oListener[2])
                (oListener[1].handleEvent || oListener[1]).apply(this, [oEventPseudo]);
    };

    //
    cXMLHttpRequest.prototype.toString    = function() {
        return '[' + "object" + ' ' + "XMLHttpRequest" + ']';
    };

    cXMLHttpRequest.toString    = function() {
        return '[' + "XMLHttpRequest" + ']';
    };

    // Helper function
    function fReadyStateChange(oRequest) {
        // Sniffing code
        if (cXMLHttpRequest.onreadystatechange)
            cXMLHttpRequest.onreadystatechange.apply(oRequest);

        // Fake event
        oRequest.dispatchEvent({
            'type':            "readystatechange",
            'bubbles':        false,
            'cancelable':    false,
            'timeStamp':    new Date + 0
        });
    };

    function fGetDocument(oRequest) {
        var oDocument    = oRequest.responseXML,
            sResponse    = oRequest.responseText;
        // Try parsing responseText
        if (bIE && sResponse && oDocument && !oDocument.documentElement && oRequest.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/)) {
            oDocument    = new window.ActiveXObject("Microsoft.XMLDOM");
            oDocument.async                = false;
            oDocument.validateOnParse    = false;
            oDocument.loadXML(sResponse);
        }
        // Check if there is no error in document
        if (oDocument)
            if ((bIE && oDocument.parseError != 0) || !oDocument.documentElement || (oDocument.documentElement && oDocument.documentElement.tagName == "parsererror"))
                return null;
        return oDocument;
    };

    function fSynchronizeValues(oRequest) {
        try {    oRequest.responseText    = oRequest._object.responseText;    } catch (e) {}
        try {    oRequest.responseXML    = fGetDocument(oRequest._object);    } catch (e) {}
        try {    oRequest.status            = oRequest._object.status;            } catch (e) {}
        try {    oRequest.statusText        = oRequest._object.statusText;        } catch (e) {}
    };

    function fCleanTransport(oRequest) {
        // BUGFIX: IE - memory leak (on-page leak)
        oRequest._object.onreadystatechange    = new window.Function;
    };
/*
    // Queue manager
    var oQueuePending    = {"CRITICAL":[],"HIGH":[],"NORMAL":[],"LOW":[],"LOWEST":[]},
        aQueueRunning    = [];
    function fQueue_add(oRequest) {
        oQueuePending[oRequest.priority in oQueuePending ? oRequest.priority : "NORMAL"].push(oRequest);
        //
        setTimeout(fQueue_process);
    };

    function fQueue_remove(oRequest) {
        for (var nIndex = 0, bFound    = false; nIndex < aQueueRunning.length; nIndex++)
            if (bFound)
                aQueueRunning[nIndex - 1]    = aQueueRunning[nIndex];
            else
            if (aQueueRunning[nIndex] == oRequest)
                bFound    = true;
        if (bFound)
            aQueueRunning.length--;
        //
        setTimeout(fQueue_process);
    };

    function fQueue_process() {
        if (aQueueRunning.length < 6) {
            for (var sPriority in oQueuePending) {
                if (oQueuePending[sPriority].length) {
                    var oRequest    = oQueuePending[sPriority][0];
                    oQueuePending[sPriority]    = oQueuePending[sPriority].slice(1);
                    //
                    aQueueRunning.push(oRequest);
                    // Send request
                    fXMLHttpRequest_send(oRequest);
                    break;
                }
            }
        }
    };
*/
    // Internet Explorer 5.0 (missing apply)
    if (!window.Function.prototype.apply) {
        window.Function.prototype.apply    = function(oRequest, oArguments) {
            if (!oArguments)
                oArguments    = [];
            oRequest.__func    = this;
            oRequest.__func(oArguments[0], oArguments[1], oArguments[2], oArguments[3], oArguments[4]);
            delete oRequest.__func;
        };
    };

    // Register new object with window

    /**
     * @class GeoGlobe.Request.XMLHttpRequest
     * @classdesc Standard-compliant (W3C) cross-browser implementation of the
     *     XMLHttpRequest object.  From
     *     http://code.google.com/p/xmlhttprequest/.。
     *
     */
    if (!GeoGlobe.Request) {
        /**
         * This allows for tool/Request/Request.js to be included
         * before or after this script.
         */
        GeoGlobe.Request = {};
    }
    GeoGlobe.Request.XMLHttpRequest = cXMLHttpRequest;
})();
﻿/**
 * @class GeoGlobe.Map
 * @classdesc GeoGlobe.Map类。
 *
 * @param options - {Object} 地图对象相关选项设置。
 * @param options.mapCRS - {Object} 坐标参考系统
 * @param options.mapCRS.topTileExtent - {Array} 顶层瓦片范围
 * @param options.mapCRS.coordtransform - {Function} 自定义坐标变换函数
 * @param options.mapCRS.resolutions - {Array} 栅格瓦片金字塔分辨率，0-22级，不足以null补全，例：[null,null,105,52,23,...]
 * @param options.mapCRS.tileSize - {Int} 栅格瓦片大小，缺省则默认256
 * @param options.epsg - {String} 地图epsg号。默认"EPSG:3857"
 * @param options.units - {String} 地图单位。默认"degrees"。可能的值有"degrees","m"。Xian80、Beijing54地方坐标系设置"m"。
 * @param options.isIntScrollZoom - {Boolean} 缩放级别是否为整数处理模式
 * @param options.renderWorldCopies - {Boolean} 是否渲染世界多个副本
 * @param options.container - {(HTMLElement | string)} 将在其中呈现地图的HTML元素，或元素的字符串ID
 * @param options.style - {(Object | string)} 地图的样式。必须是符合样式规范中描述的模式的JSON对象，或者是此类JSON的URL
 * @param options.center - {(LngLat | Array)} 地图的初始地理中心点
 * @param options.zoom - {Number} 地图的初始缩放级别，默认为0
 * @param options.bearing - {Number} 地图的初始方位（旋转），默认为0
 * @param options.pitch - {Number} 地图的初始俯仰（倾斜），默认为0
 * @param options.xxx - 更多属性参见Members
 * 
 * @example
var simple = {
    "version": 8,
    "source": {
        "geostar": {
            "type": "raster",
            "tiles": ["http://t2.tianditu.com/DataServer?T=vec_w&x={x}&y={y}&l={z}"],
            "tileSize": 256
        },
        "layers": [
            {
                "id": "1",
                "type": "raster",
                "source": "geostar",
                "raster-opacity": 1
            }
        ]
    }
};
var map = new GeoGlobe.Map({
    style: simple,
    container: 'map',
    zoom: 4,
    center: [112.939, 31.377],
    isAttributionControl: false
});
     */
GeoGlobe.Map = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    /**
     * 地图的容器名称
     * @name container
     * @memberof GeoGlobe.Map.prototype
     * @type {String}
     * @default null
     */

    /**
     * 地图的最小级别
     * @name minzoom
     * @memberof GeoGlobe.Map.prototype
     * @type {Int}
     * @default 0
     */

    /**
     * 地图的最大级别
     * @name maxZoom
     * @memberof GeoGlobe.Map.prototype
     * @type {Int}
     * @default 22
     */

    /**
     * 地图的Mapbox样式。 这必须是符合Mapbox样式规范中描述的模式的JSON对象，或者是此类JSON的URL。
     * @name style
     * @memberof GeoGlobe.Map.prototype
     * @type {Object | String}
     */

    /**
     * 地图上的位置（缩放，中心纬度、经度和中心，轴承间距）将同步散列片段的页面的URL
     * @name hash
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default false
     */

    /**
     * 是否激活外部设备
     * @name Interactive
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 捕捉北方向的极限值，单位是度
     * @name bearingSnap
     * @memberof GeoGlobe.Map.prototype
     * @type {Int}
     * @default 7
     */

    /**
     * 如果为false，则会禁用“拖动旋转”交互的地图的俯仰（倾斜）控制
     * @name pitchWithRotate
     * @memberOf GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 如果为true，则会将AttributionControl添加到地图中
     * @name attributionControl
     * @memberOf GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * mapbox图标在地图上的相对位置
     * @name logoPosition
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default  bottom-left
     */

    /**
     * 如果为true，则如果Mapbox GL JS的性能明显低于预期（即将使用软件渲染器），则映射创建将失败
     * @name failIfMajorPerformanceCaveat
     * @memberOf GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default false
     */

    /**
     * 地图可以导出为PNG使用地图
     * @name preserveDrawingBuffer
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default false
     */

    /**
     * 如果为false，那么地图将不会尝试重新请求瓦片
     * @name refreshExpiredTiles
     * @memberOf GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 地图的最大地理范围
     * @name maxBounds
     * @memberof GeoGlobe.Map.prototype
     * @type {GeoGlobe.Bounds}
     * @default null
     */

    /**
     * 如果为true，则启用“滚动缩放”交互。Object值作为选项传递给ScrollZoomHandler＃enable
     * @name scrollZoom
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean | Object}
     * @default true
     */

    /**
     * 如果为true，则启用“框缩放”交互（请参阅BoxZoomHandler）
     * @name boxZoom
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 如果为true，则“拖动旋转”交互被启用（请参阅DragRotateHandler）
     * @name dragRotate
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 如果为true，则“拖动平移”交互被启用（请参阅DragPanHandler）
     * @name dragPan
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 如果为true，则启用键盘快捷键（请参阅KeyboardHandler）
     * @name keyboard
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 如果为true，则启用“双击放大”交互（请参阅DoubleClickZoomHandler）
     * @name doubleClickZoom
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 如果为true，则启用“点击缩放旋转”交互。 Object值作为选项传递给TouchZoomRotateHandler＃enable
     * @name touchZoomRotate
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean | Object}
     * @default true
     */

    /**
     *如果为true，则当浏览器窗口调整大小时，地图将自动调整大小
     * @name trackResize
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 地图的中心点坐标
     * @name center
     * @memberof GeoGlobe.Map.prototype
     * @type {GeoGlobe.LonLat}
     * @default [0,0]
     */

    /**
     * 地图的当前级别
     * @name zoom
     * @memberof GeoGlobe.Map.prototype
     * @type {Int}
     * @default 0
     */

    /**
     * 旋转程度
     * @name bearing
     * @memberof GeoGlobe.Map.prototype
     * @type {Int}
     * @default 0
     */

    /**
     * 倾斜程度
     * @name pitch
     * @memberof GeoGlobe.Map.prototype
     * @type {Int}
     * @default 0
     */

    /**
     * 绘制地图副本
     * @name renderWorldCopies
     * @memberOf GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 最大瓦片数量
     * @name maxTileCacheSize
     * @memberOf GeoGlobe.Map.prototype
     * @type {Number}
     * @default null
     */

    /**
     * 字体样式
     * @name localIdeographFontFamily
     * @memberOf GeoGlobe.Map.prototype
     * @type {String}
     * @default null
     */

    /**
     * 转换请求
     * @name transformRequest
     * @memberOf GeoGlobe.Map.prototype
     * @type {Function}
     * @default null
     */

    /**
     * 如果为true，则会收集由GeoJSON和Vector Tile Web发出的请求资源时间API信息
     * @name collectResourceTiming
     * @memberOf GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default false
     */

    /**
     * 是否在每一个瓦片周围绘制一个轮廓
     * @name showTileBoundaries
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default false
     */

    /**
     * 是否将不断重绘地图
     * @name repaint
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 是否渲染数据周围的边框
     * @name showCollisionBoxes
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default true
     */

    /**
     * 缩放级别是否为整数处理模式
     * @name isIntScrollZoom
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     * @default false
     */

    /**
     * 可选，3D倾斜层级,默认为16
     * @memberof GeoGlobe.Map.prototype
     * @type {Int}
     */

    pitch3Dzoom: 16,

    /**
     * 设置是否倾斜
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    is3Dpitching: true,

    /**
     * 地图中是否添加属性控件
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isAttributionControl: true,

    /**
     * 是否允许滚动缩放
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isScrollZoom: true,

    /**
     * 是否允许范围缩放
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isBooxZoom: true,

    /**
     * 是否允许旋转
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isDragRotate: true,

    /**
     * 是否允许拖拽移动
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isDragPan: true,

    /**
     * 是否开启键盘，默认为true
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isKeyboard: true,

    /**
     * 双击鼠标左键，是否进行放大地图操作
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isDoubleClickZoom: true,

    /**
     * 是否允许触摸旋转缩放
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isTouchZoomRotate: true,

    /**
     * 地图尺寸改变缩放自动响应
     * @memberof GeoGlobe.Map.prototype
     * @type {Boolean}
     */
    isTrackResize: true,

    /**
     * 获取地图epsg号。默认"EPSG:3857"
     * @memberof GeoGlobe.Map.prototype
     * @type {String}
     */
    epsg: "EPSG:3857",


    /**
     * 获取地图单位。默认"degrees"。可能的值有"degrees","m"
     * @memberof GeoGlobe.Map.prototype
     * @type {String}
     */
    units: null,


    initialize: function (options) {
        //map中属性的重定义
        this.options = options;
        if (options.isAttributionControl == false) {
            options.attributionControl = options.isAttributionControl;
        }
        if (options.isScrollZoom == false) {
            options.scrollZoom = options.isScrollZoom;
        }
        if (options.isBooxZoom == false) {
            options.boxZoom = options.isBooxZoom;
        }
        if (options.isDragRotate == false) {
            options.dragRotate = options.isDragRotate;
        }
        if (options.isDragPan == false) {
            options.dragPan = options.isDragPan;
        }
        if (options.isKeyboard == false) {
            options.keyboard = options.isKeyboard;
        }
        if (options.isDoubleClickZoom == false) {
            options.doubleClickZoom = options.isDoubleClickZoom;
        }
        if (options.isTouchZoomRotate == false) {
            options.touchZoomRotate = options.isTouchZoomRotate;
        }
        if (options.isTrackResize == false) {
            options.trackResize = options.isTrackResize;
        }
        if (!options.epsg) {
            options.epsg = "EPSG:3857";
        }
        if (!options.units) {
            options.units = "degrees";
        }
        if (!options.isConstrain) {
            options.isConstrain = false;//默认false
        }

        this.map = new mapboxgl.FreeCRSMap(options);

        if (window.GeoGlobe && options.mapCRS) {
            window.GeoGlobe.MapOptions = {
                map: this.map,
                topTileExtent: options.mapCRS.topTileExtent,
                units: options.units
            }
        }
        //设置epsg号
        this.map.epsg = options.epsg;
        //地图单位
        this.map.units = options.units;
        //设置地图是否在地图边界以内拖动,默认false
        this.map.setIsConstrain(options.isConstrain);

        this.map.pitch3Dzoom = this.options.pitch3Dzoom ? this.options.pitch3Dzoom : 16;
        this.map.setIs3DPZoom(this.options.is3Dpitching);
        return this.map;
    },

    /**
     * 用新值更新地图的Mapbox样式对象。 如果给定的值是样式JSON对象，则将其与地图当前状态进行比较，并仅执行必要的更改以使地图样式与所需状态匹配。
     * @method
     * @memberof GeoGlobe.Map.prototype
     * @name setStyle
     * @param {StyleSpecification | String | null} style 符合Mapbox样式规范中描述的模式的JSON对象，或者这样的JSON的URL
     * @param {Object} options 选项设置
     */


    /**
     * 获取指定地图样式对象。
     * @method
     * @memberof GeoGlobe.Map.prototype
     * @name getStyle
     * @returns {Object} style -地图样式对象
     */

    /**
     * 判断地图样式是否加载完毕
     * @method
     * @memberof GeoGlobe.Map.prototype
     * @name isStyleLoaded
     * @returns {Boolean} 布尔值，代表样式是否已完全加载。
     */

    /**
     * 添加单个控件
     * @method
     * @memberof GeoGlobe.Map.prototype
     * @name addControl
     * @param {Control} control - 控件对象.
     * @param {String} position - 添加的控件的位置，包括'top-left' , 'top-right' , 'bottom-left' , and 'bottom-right' . 默认 'top-right' .
     */

    /**
     * 删除控件
     * @method
     * @memberof GeoGlobe.Map.prototype
     * @name removeControl
     * @param {GeoGlobe.Control} control - 控件对象.
     */


    /**
     * 获取地图地理范围
     * @method
     * @name getBounds
     * @memberof GeoGlobe.Map.prototype
     * @returns {GeoGlobe.LngLatBounds} 地图的地理范围
     */

    /**
     * 获取地图最大地理范围
     * @method
     * @name getMaxBounds
     * @memberof GeoGlobe.Map.prototype
     * @returns {GeoGlobe.LngLatBounds | null} 地图限制的最大边界，如果没有设置，则返回null
     */

    /**
     * 设置地图最大地理范围
     * @method
     * @name setMaxBounds
     * @memberof GeoGlobe.Map.prototype
     * @param {GeoGlobe.LngLatBounds} lnglatbounds - 指定范围.
     */

    /**
     * 设置地图的最大级别
     * @method
     * @name setMaxzoom
     * @memberof GeoGlobe.Map.prototype
     * @param {Number | Null | Undefined} maxzoom - 最大级别.
     */

    /**
     * 获取地图的最大级别
     * @method
     * @name getMaxZoom
     * @memberof GeoGlobe.Map.prototype
     * @returns {Number} maxZoom -地图的最大级别
     */

    /**
     * 是否产生地图副本
     * @method
     * @name getRenderWorldCopies
     * @memberof GeoGlobe.Map.prototype
     * @returns {Boolean} true or false
     */

    /**
     * 设置当地图缩小时是否产生副本
     * @method
     * @name setRenderWorldCopies
     * @memberof GeoGlobe.Map.prototype
     * @param {Boolean} renderWorldCopies 如果为true，则在缩小时会呈现多个世界的副本
     */

    /**
     * 设置地图最小级别
     * @method
     * @name setMinZoom
     * @memberof GeoGlobe.Map.prototype
     * @param {Number | Null | Undefined} minzoom - 最小级别.
     *
     */


    /**
     * 获取地图的最小级别
     * @method
     * @name getMinZoom
     * @memberof GeoGlobe.Map.prototype
     * @returns {number} zoom -地图的最大级别
     */

    /**
     * 投影到指定位置的坐标点
     * @method
     * @name project
     * @memberof GeoGlobe.Map.prototype
     * @param {GeoGlobe.LngLat} lnglat - 经纬度投影坐标.
     * @returns {GeoGlobe.Point} Point -坐标像素点
     */


    /**
     * 像素点转换为经纬度
     * @method
     * @name unproject
     * @memberof GeoGlobe.Map.prototype
     * @param {GeoGlobe.Point} point - 坐标像素点.
     * @returns {GeoGlobe.LngLat} LngLat -经纬坐标
     */

    /**
     * 地图样式添加来源。
     * @method
     * @name addSource
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 源id.
     * @param {Object} source - 数据源对象.
     */


    /**
     * 判断数据源是否加载完全。
     * @method
     * @name isSourceLoaded
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 源id.
     *
     * @returns {Boolean} 数据源是否加载完全
     */

    /**
     * 判断瓦片是否加载完全。
     * @method
     * @name areTilesLoaded
     * @memberof GeoGlobe.Map.prototype
     * @returns {Boolean} 瓦片是否加载完全
     */

    /**
     * 获取地图样式中指定id的源
     * @method
     * @name getSource
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 源id.
     * @returns {Object} 获取指定id的数据源或者undefined
     */

    /**
     * 增加图片
     * @method
     * @name removeSource
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 源id.
     * @param {image}  image - 图片资源
     * @param {any} options - 图片像素设置等
     */

    /**
     * 图片是否增加
     * @method
     * @name hasImage
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 源id.
     * @return {Boolean} 返回判断结果
     */

    /**
     * 移除地图样式的来源。
     * @method
     * @name removeSource
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 源id.
     */

    /**
     * 添加图层。
     * @method
     * @name addLayer
     * @memberof GeoGlobe.Map.prototype
     * @param {Object} layer - 二维视图图层对象.
     * @param {String} before -指定图层顺序
     */

    /**
     * 删除图层
     * @method
     * @name removeLayer
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 要删除的图层id.
     */

    /**
     * 获取指定ID图层对象
     * @method
     * @name getLayer
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 要获取的图层id.
     * @returns {Object|Undefined} 指定ID的图层；如果该ID对应于不存在的层则返回未定义.
     */

    /**
     * 移动图层到不同的位置
     * @method
     * @name moveLayer
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id - 移动图层的id.
     * @param {String} beforeId -指定图层的顺序
     */

    /**
     * 设置图层的过滤
     * @method
     * @name setFilter
     * @memberof GeoGlobe.Map.prototype
     * @param {String} layer - 要过滤的图层id.
     * @param {Filter} filter - 要过滤的条件.
     */

    /**
     * 设置指定id图层的缩放范围
     * @method
     * @name setLayerZoomRange
     * @memberof GeoGlobe.Map.prototype
     * @param {String} layerId - 要过滤的图层id.
     * @param {Int} minzoom - 最小级别.
     * @param {Int} maxzoom - 最大级别.
     */

    /**
     * 获取图层过滤
     * @method
     * @name getFilter
     * @memberof GeoGlobe.Map.prototype
     * @param {String} layer - 要过滤的图层id.
     *
     * @returns {Filter} 图层过滤条件
     */

    /**
     * 在指定的样式层中设置一个绘画属性的值
     * @method
     * @name setPaintProperty
     * @memberof GeoGlobe.Map.prototype
     * @param {String} layer - 要过滤的图层id.
     * @param {String} name - 绘图属性名.
     * @param {String} value - 属性值.
     */

    /**
     * 获取指定样式层的绘画属性
     * @method
     * @name getPaintProperty
     * @memberof GeoGlobe.Map.prototype
     * @param {String} layer - 要过滤的图层id.
     * @param {String} name - 绘图属性名.
     *
     * @returns {Object} 图层绘画的属性
     */

    /**
     * 在指定的样式层中设置布局属性的值
     * @method
     * @name setLayoutProperty
     * @memberof GeoGlobe.Map.prototype
     * @param {String} layer - 要过滤的图层id.
     * @param {String} name - 布局属性名.
     * @param {String} value - 属性值.
     */

    /**
     * 获取指定样式层的布局属性
     * @method
     * @name getLayoutProperty
     * @memberof GeoGlobe.Map.prototype
     * @param {String} layer - 要过滤的图层id.
     * @param {String} name - 布局属性名.
     *
     * @returns {Object}  - 图层布局属性
     */

    /**
     * 获取绘制（可见）Featrues
     * @method
     * @name queryRenderedFeatures
     * @memberof GeoGlobe.Map.prototype
     * @returns {Object} 返回GeoJSON 特征对象
     */

    /**
     * 获取数据源（所有）Featrues
     * @method
     * @name querySourceFeatures
     * @memberof GeoGlobe.Map.prototype
     * @param {String} sourceID 要查询的矢量瓦片或GeoJSON源的ID
     * @returns {Object} 返回GeoJSON 特征对象
     */

    /**
     * 添加class
     * @method
     * @name addClass
     * @memberof GeoGlobe.Map.prototype
     * @param {String} class - 添加的class.
     */

    /**
     * 移除class
     * @method
     * @name removeClass
     * @memberof GeoGlobe.Map.prototype
     * @param {String} klass - 移除class.
     */

    /**
     * 替换class
     * @method
     * @name setClasses
     * @memberof GeoGlobe.Map.prototype
     * @param {String} klasses - 设置的class.
     */

    /**
     * 替换class
     * @method
     * @name hasClasses
     * @memberof GeoGlobe.Map.prototype
     * @param {String} klasses - 设置的class.
     *
     * @returns {Boolean} 判断map是否有指定的class
     */

    /**
     * 获取style的class
     * @method
     * @name getClasses
     * @memberof GeoGlobe.Map.prototype
     * @returns {String} 返回style的class
     */

    /**
     * 根据容器的大小来调整地图
     * @method
     * @name resize
     * @memberof GeoGlobe.Map.prototype
     * @param {Object}
     */

    /**
     * 判断地图是否加载完全
     * @method
     * @name isloaded
     * @memberof GeoGlobe.Map.prototype
     * @returns {Boolean} 地图是否加载完全.
     */

    /**
     * 判断地图是否完全加载
     * @method
     * @name loaded
     * @memberof GeoGlobe.Map.prototype
     * @returns {Boolean} 地图是否加载完全.
     */

    /**
     * 获取地图中心点坐标
     * @method
     * @name getCenter
     * @memberof GeoGlobe.Map.prototype
     * @returns {GeoGlobe.LngLat} 地图中心点坐标
     */

    /**
     * 改变地图中心点坐标.
     * @method
     * @name setCenter
     * @memberof GeoGlobe.Map.prototype
     * @param {LngLatLike} center - 中心点坐标.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     */

    /**
     * 获取亮度属性.
     * @method
     * @name getLight
     * @memberof GeoGlobe.Map.prototype
     * @returns {Object} 返回style中亮度属性
     */

    /**
     * 设置亮度属性的组合.
     * @method
     * @name setLight
     * @memberof GeoGlobe.Map.prototype
     * @param {Object} lightOptions - 亮度属性.
     */

    /**
     * 移除所有对象.
     * @method
     * @name remove
     * @memberof GeoGlobe.Map.prototype
     */

    /**
     * 平移指定像素
     * @method
     * @name panBy
     * @memberof GeoGlobe.Map.prototype
     * @param {PointLike} offset - x轴、y轴方向增量.
     * @param {AnimationOptions} options - 设置选项.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     */

    /**
     * 平移到指定地理坐标
     * @method
     * @name panTo
     * @memberof GeoGlobe.Map.prototype
     * @param {GeoGlobe.LngLat} lnglat - 地理坐标.
     * @param {AnimationOptions} options - 设置选项.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     */

    /**
     * 获取地图当前级别
     * @method
     * @name getZoom
     * @memberof GeoGlobe.Map.prototype
     * @returns {Int} 地图当前级别
     */

    /**
     * 设置地图到指定级别
     * @method
     * @name setZoom
     * @memberof GeoGlobe.Map.prototype
     * @param {Int} zoom - 缩放到指定级别.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     */

    /**
     * 缩放到指定地图级别
     * @method
     * @name zoomTo
     * @memberof GeoGlobe.Map.prototype
     * @param {Int} zoom - 缩放到指定级别.
     * @param {Object} options - 选项
     * @param {eventData} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 放大地图级别一级
     * @method
     * @name ZoomIn
     * @memberof GeoGlobe.Map.prototype
     * @param {Object} options - 选项
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 缩小地图级别一级
     * @method
     * @name ZoomOut
     * @memberof GeoGlobe.Map.prototype
     * param {Object} options - 选项
     * param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     */

    /**
     * 获取当前地图旋转程度
     * @method
     * @name getBearing
     * @memberof GeoGlobe.Map.prototype
     * @returns {Int} bearing -地图旋转程度
     *
     */

    /**
     * 设置地图旋转程度
     * @method
     * @name setBearing
     * @memberof GeoGlobe.Map.prototype
     * @param {Int} bearing - 旋转程度.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 旋转到指定程度
     * @method
     * @name rotateTo
     * @memberof GeoGlobe.Map.prototype
     * @param {Int} bearing - 旋转程度.
     * @param {Object} options - 旋转参数
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 获取当前地图的倾斜程度
     * @method
     * @name getPitch
     * @memberof GeoGlobe.Map.prototype
     * @returns {Int} pitch -倾斜程度
     *
     */

    /**
     * 设置地图倾斜程度
     * @method
     * @name setPitch
     * @memberof GeoGlobe.Map.prototype
     * @param {Int} pitch - 倾斜程度.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 平移和缩放地图到适合的范围.
     * @method
     * @name fitBounds
     * @memberof GeoGlobe.Map.prototype
     * @param {GeoGlobe.LngLatbounds} bounds - 适合的范围.
     * @param {Object} options - 平移、缩放参数选项
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     */

    /**
     * 旋转地图的方位（北）（动画过渡）
     * @method
     * @name resetNorth
     * @memberof GeoGlobe.Map.prototype
     * @param {Object} options -旋转参数选项
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 把地图的轴承为正北
     * @method
     * @name snapToNorth
     * @memberof GeoGlobe.Map.prototype
     * @param {Object} options - 参数选项
     * @param {Object} eventData -该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 获取地图容器的html元素
     * @method
     * @name getContainer
     * @memberof GeoGlobe.Map.prototype
     * @returns {HTMLElement} container -地图容器
     *
     */

    /**
     * 获取地图容器的html元素
     * @method
     * @name getCanvasContainer
     * @memberof GeoGlobe.Map.prototype
     * @returns {HTMLElement} container -地图容器中画布元素
     *
     */


    /**
     * 获取画布元素
     * @method
     * @name getCanvas
     * @memberof GeoGlobe.Map.prototype
     * @returns {HTMLElement} canvas -画布元素
     *
     */

    /**
     * 无过渡的改变地图属性
     * @method
     * @name jumpTo
     * @memberof GeoGlobe.Map.prototype
     * @param {Object} options  -中心点、缩放、旋转、倾斜等.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 有过渡的改变地图属性
     * @method
     * @name easeTo
     * @memberof GeoGlobe.Map.prototype
     * @param {Object} options  -中心点、缩放、旋转、倾斜等.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 沿着引起飞行的曲线对过渡进行动画处理
     * @method
     * @name flyTo
     * @memberof GeoGlobe.Map.prototype
     * @param {Object} options - 中心点、缩放、旋转、倾斜等.
     * @param {Object} eventData - 该参数对象的属性将被添加到，该方法触发的事件回调函数的参数事件对象中
     *
     */

    /**
     * 判断镜头是否移动
     * @method
     * @name isMoving
     * @memberof GeoGlobe.Map.prototype
     * @returns {Boolean} 镜头是否移动
     */

    /**
     * 判断镜头是否移动
     * @method
     * @name isZooming
     * @memberof GeoGlobe.Map.prototype
     * @returns {Boolean} 镜头是否缩放
     */

    /**
     * 判断镜头是否移动
     * @method
     * @name isRotating
     * @memberof GeoGlobe.Map.prototype
     * @returns {Boolean} 地图是否旋转
     */


    /**
     * 停止任何动画过渡
     * @method
     * @name stop
     * @memberof GeoGlobe.Map.prototype
     *
     */

    /**
     * 在指定类型图层上添加事件侦听器
     * @method
     * @name on
     * @memberof GeoGlobe.Map.prototype
     * @param {String} type 事件类型
     * @param {String} layer 指定图层
     * @param {Function} listener 事件触发函数
     */

    /**
     * 为指定类型的事件添加侦听器。
     * @method
     * @name on
     * @memberof GeoGlobe.Map.prototype
     * @param {String} type 事件类型
     * @param {Function} listener 事件触发函数
     */

    /**
     * 移除指定图层上的事件侦听器
     * @method
     * @name off
     * @memberof GeoGlobe.Map.prototype
     * @param {String} type 事件类型
     * @param {String} layer 指定图层
     * @param {Function} listener 事件触发函数
     */

    /**
     * 移除指定样式的图片
     * @method
     * @name removeImage
     * @memberof GeoGlobe.Map.prototype
     * @param {String} id 图片Id
     */

    /**
     * 从外部加载图片
     * @method
     * @name loadImage
     * @memberof GeoGlobe.Map.prototype
     * @param {String} URL 图片URL地址
     * @param {Function} callback 下载函数时触发的回调函数
     */


    /**
     * 调整地图后触发的事件
     * @event resize
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 移动地图时触发的事件
     * @event remove
     * @memberof GeoGlobe.Map.prototype
     */

    /**
     * 在地图上按下鼠标触发的事件
     * @event mousedown
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 在地图上按下并松开鼠标后触发的事件
     * @event mouseup
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数 -
     */

    /**
     * 鼠标移到地图上触发的事件
     * @event mouseover
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 单击地图触发的事件
     * @event click
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 双击地图触发的事件
     * @event dblclick
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 当鼠标进入指定图层区域触发事件
     * @event mouseenter
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 当鼠标离开指定图层区域触发事件
     * @event mouseleave
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 当鼠标离开地图画布时触发事件
     * @event mouseout
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 单击鼠标右键触发事件
     * @event contextmenu
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 鼠标滚轮滚动时触发事件
     * @event wheel
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 开始触摸地图时触发事件
     * @event touchstart
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 触摸地图时触发事件
     * @event touchend
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 移动触摸地图时触发事件
     * @event touchmove
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 不触摸地图时触发事件
     * @event touchcancel
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 开始移动地图时触发事件
     * @event movestart
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 移动地图过程中触发事件
     * @event move
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 移动地图结束后触发事件
     * @event moveend
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 开始拖拽地图时触发事件
     * @event dragstart
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 拖拽地图过程中触发事件
     * @event drag
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 拖拽地图结束后触发事件
     * @event dragend
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 点击缩放地图开始时触发事件
     * @event zoomstart
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 点击缩放地图过程中触发事件
     * @event zoom
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 点击缩放地图结束后触发事件
     * @event zoomend
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 旋转地图开始时触发事件
     * @event rotatestart
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 旋转地图过程中触发事件
     * @event rotate
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 旋转地图结束后触发事件
     * @event rotateend
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 倾斜地图开始时触发事件
     * @event pitchstart
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 倾斜地图过程中触发事件
     * @event pitch
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 倾斜地图结束后触发事件
     * @event pitchend
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 框选缩放地图开始时触发事件
     * @event boxzoomstart
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 框选缩放地图结束后触发事件
     * @event boxzoomend
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 框选缩放地图取消后触发事件
     * @event boxzoomcancel
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 当WebGL上下文丢失时触发事件
     * @event webglcontextlost
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 当WebGL上下文恢复时启动
     * @event webglcontextrestored
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 所有资源下载完成后触发事件
     * @event load
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 绘制地图时触发事件
     * @event render
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 发生错误时触发事件
     * @event error
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 地图数据更改或者加载时触发事件
     * @event data
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 地图样式更改或者加载时触发事件
     * @event styledata
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 地图的源数据更改或者加载时触发事件
     * @event sourcedata
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 地图数据下载时触发事件
     * @event dataloading
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 地图样式数据下载时触发事件
     * @event styledataloading
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    /**
     * 地图源数据下载时触发事件
     * @event sourcedataloading
     * @memberof GeoGlobe.Map.prototype
     * @property {Object} data - 事件触发时传递给回调函数的参数
     */

    CLASS_NAME: "GeoGlobe.Map"
});

/**
 * 添加canvas图层
 * @method addCanvasLayer
 * @memberof GeoGlobe.Map.prototype
 * @param {Object} canvaslayer - canvas图层
 *
 */
mapboxgl.FreeCRSMap.prototype.addCanvasLayer = function (canvaslayer) {
    canvaslayer.addTo(this);
};

/**
 * 移除canvas图层
 * @method removeCanvasLayer
 * @memberof GeoGlobe.Map.prototype
 * @param {Object} canvaslayer - canvas图层
 *
 */
mapboxgl.FreeCRSMap.prototype.removeCanvasLayer = function (canvaslayer) {
    canvaslayer.remove();
};

/**
 * 判断是否倾斜
 * @method setIs3DPZoom
 * @memberof GeoGlobe.Map.prototype
 * @param {Boolean} is3Dpitching - 是否倾斜，默认为false
 */
mapboxgl.FreeCRSMap.prototype.setIs3DPZoom = function (is3Dpitching) {
    if (is3Dpitching) {
        //this.setZoompitch = GeoGlobe.Function.bind(this.setZoompitch, this);
        this.on('zoom', this.setZoompitch);
    } else {
        this.off('zoom', this.setZoompitch);
    }
};

/**
 * 设置倾斜的层级
 * @method set3Dzoom
 * @memberof GeoGlobe.Map.prototype
 * @param {Int} zoom - 倾斜的层级,层级在zoom和zoom+1之间的情况下，都会自动倾斜
 */
mapboxgl.FreeCRSMap.prototype.set3Dzoom = function (zoom) {
    if (zoom) {
        this.pitch3Dzoom = zoom;
    }
};

/**
 * 设置地图倾斜
 * @method setZoompitch
 * @memberof GeoGlobe.Map.prototype
 *
 */
mapboxgl.FreeCRSMap.prototype.setZoompitch = function () {

    var currentzoom = this.getZoom();
    var zoom = this.pitch3Dzoom;

    if (parseInt(currentzoom) == zoom) {
        this.setPitch(60);
    }
};

/**
 * 添加多个图层
 * @method addLayers
 * @memberof GeoGlobe.Map.prototype
 * @param {Array} layers - 图层组
 */
mapboxgl.FreeCRSMap.prototype.addLayers = function (layers) {
    if (layers.length > 0) {
        for (var i = 0; i < layers.length; i++) {
            this.addLayer(layers[i]);
        }
    }
};

/**
 * 获取地图分辨率
 * @method getResolutions
 * @memberof GeoGlobe.Map.prototype
 */
mapboxgl.FreeCRSMap.prototype.getResolutions = function () {
    var resolutions = new Array();
    for (var i = 0; i <= 20; i++) {
        resolutions.push(this.getResolutionForLevel(i));
    }
    return resolutions;
};

/**
 * 根据层级获取分辨率
 * @method getResolutionForLevel
 * @memberof GeoGlobe.Map.prototype
 * @param {Int} level - 层级.
 * @param {Int} tileSize - 瓦片大小.
 */
mapboxgl.FreeCRSMap.prototype.getResolutionForLevel = function (level, tileSize) {
    var topTileWidth = Math.abs(this._tileExtent[2] - this._tileExtent[0]);//360
    var tileSize = tileSize ? tileSize : 256;//256
    var maxResolution = topTileWidth / tileSize; //(360 / 256);
    return maxResolution / Math.pow(2, level);
};

/**
 * 设置地图是否在地图边界以内拖动
 * @method setIsConstrain
 * @memberof GeoGlobe.Map.prototype
 * @param {Boolean} isConstrain - 判断地图是否在地图边界以内拖动.
 */
mapboxgl.FreeCRSMap.prototype.setIsConstrain = function (isConstrain) {
    this.isConstrain = isConstrain;
    this.transform._constraining = !this.isConstrain;
};

/**
 * 添加图层
 * @method addLayer
 * @memberof GeoGlobe.Map.prototype
 * @param {Object} layer - 图层.
 */
mapboxgl.FreeCRSMap.prototype.addLayer = function (layer, before) {

    if (layer.CLASS_NAME === "GeoGlobe.Layer.VTS" || layer.layerType === "VTS") {
        var vtsLayer = layer;

        var layers = vtsLayer.layers;
        this.addSource(vtsLayer.source_id, vtsLayer.source);
        if (layers.length > 0) {
            for (var i = 0; i < layers.length; i++) {
                this.addLayer(layers[i]);
            }
        }
        return this;
    }

    if (layer.layerOption && layer.layerOption.metadata.type === "wms" && layer.layerOption.metadata.isTile === false) {
        layer.addTo(this);

        this.style.addLayer(layer.layerOption, before);
        this._update(true);
        return this;
    }
    if (layer.layerOption && layer.layerOption.metadata.type === "hotarea") {
        layer.addTo(this);
        return this;
    }

    if (typeof layer.source === 'object') {
        if (this._mapCRS && layer.source && layer.source.type == "geojson" && layer.source.data && !layer.source.data.customprj) {
            layer.source.data.customprj = this._geojson_customprj;
        }
    }

    this.style.addLayer(layer, before);
    this._update(true);
    return this;
};

/**
 * 删除layer的同时删除与layerid一致的source
 * @method removeLayerAndSource
 * @memberof GeoGlobe.Map.prototype
 * @param {String} layerid - 图层id.
 */
mapboxgl.FreeCRSMap.prototype.removeLayerAndSource = function (layerid) {
    if (this.getLayer(layerid)) {
        this.removeLayer(layerid);
        this.removeSource(layerid);
    } else {
        throw new Error("Layer not found");
    }
};

/**
 * 加载sprite文件
 * @method loadSprite
 * @memberof GeoGlobe.Map.prototype
 * @param {String} sprite - 路径.
 * @param {String} imgPrefix - 可选sprite内小图片名称的前缀.
 */
mapboxgl.FreeCRSMap.prototype.loadSprite = function (sprite, imgPrefix) {
    this.style._loadSprite(sprite, imgPrefix);
};

/**
 * 删除所有的图片符号
 * @method removeAllImages
 * @memberof GeoGlobe.Map.prototype
 */
mapboxgl.FreeCRSMap.prototype.removeAllImages = function () {
    var imageManager = this.style.imageManager;
    for (var key in imageManager.images) {
        imageManager.removeImage(key);
    }
};

/**
 * 删除所有的图层
 * @method removeAllLayers
 * @memberof GeoGlobe.Map.prototype
 */
mapboxgl.FreeCRSMap.prototype.removeAllLayers = function () {
    var layers = this.style._layers;
    for (var key in layers) {
        this.removeLayer(key);
    }
};

/**
 * 删除所有的source
 * @method removeAllSources
 * @memberof GeoGlobe.Map.prototype
 */
mapboxgl.FreeCRSMap.prototype.removeAllSources = function () {
    var sourceCaches = this.style.sourceCaches;
    for (var key in sourceCaches) {
        this.removeSource(key);
    }
};

/**
 * 移动图层容器
 * @function moveLayer
 * @memberof GeoGlobe.Map.prototype
 * @param {String} className 图层容器className
 * @param {String} before 图层容器className
 */
mapboxgl.FreeCRSMap.prototype.moveLayerContainer = function (className, before) {
    var layer_container = this.getLayerContainer(className);
    if (!layer_container) {
        this.fire('error', {
            error: new Error(
                "The layer_container '" + className + "' does not exist in " +
                "the map's style and cannot be moved."
            )
        });
        return;
    }

    var order = [];
    this.eleContainer.childNodes.forEach(function (item) {
        order.push(item.className)
    });
    var index = order.indexOf(className);
    order.splice(index, 1);

    var newIndex = before ? order.indexOf(before) : order.length;
    if (before && newIndex === -1) {
        this.fire('error', {error: new Error(("layer_container with id \"" + before + "\" does not exist on this map."))});
        return;
    }
    order.splice(newIndex, 0, className);
    for(var j = 0; j < order.length; j++) {
        for (var i = 0; i < this.eleContainer.childNodes.length; i++) {
            if (order[j] === this.eleContainer.childNodes[i].className) {
                this.eleContainer.childNodes[i].style.zIndex = j
            }
        }
    }
};

/**
 * 选择图层容器
 * @function moveLayer
 * @memberof GeoGlobe.Map.prototype
 * @param {String} className 图层容器className
 */
mapboxgl.FreeCRSMap.prototype.getLayerContainer = function (className) {
    for (var i = 0; i < this.eleContainer.childNodes.length; i++) {
        if (className === this.eleContainer.childNodes[i].className) {
            return this.eleContainer.childNodes[i];
        }
    }
}/**
 * @class  GeoGlobe.LngLatBounds
 * @classdesc LngLatBounds是以西南和东北点的经度和纬度，来表示的地理边界。
 *
 * 继承:
 *  - GeoGlobe.LngLatBounds

 */


/**
 * 西南边界。
 * @name sw
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @type {object}
 * @default null
 */

/**
 * 东北边界。
 * @name ne
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @type {object}
 * @default null
 */

/**
 * GeoGlobe.LngLatBounds构造函数。
 * @method initialize
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {Object}options - LngLatBounds相关选项设置。
 *
 * @example
 * var sw = new GeoGlobe.LngLat(-73.9876, 40.7661);
 * var ne = new GeoGlobe.LngLat(-73.9397, 40.8002);
 * var llb = new GeoGlobe.LngLatBounds(sw, ne);
 *
 */


/**

* 将两个坐标的数组转换为LngLatBounds对象返回。
* @method convert
* @memberof GeoGlobe.LngLatBounds.prototype
* @param {Array}arr -  数组坐标。
* @returns {Array} LngLat - {GeoGlobe.LngLat} 数组转成的坐标对象.
*
* @example
* var arr = [[-73.9876, 40.7661], [-73.9397, 40.8002]];
* var llb = GeoGlobe.LngLatBounds.convert(arr);
* llb;   // = LngLatBounds {_sw: LngLat {lng: -73.9876, lat: 40.7661}, _ne: LngLat {lng: -73.9397, lat: 40.8002}}
*/

/**
 * 设置西南边界。
 * @method setNorthEast
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {Array} ne -  西南边界坐标。
 *
 */


/**
 * 设置东北边界。
 * @method setSouthWest
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {Array}sw -  东北边界。
 */


/**

    * 扩展到指定范围。
    * @method extend
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @param {GeoGlobe.LngLatBounds}obj -  指定范围。
    *
    */

/**

    * 返回边界框地理坐标。
    * @method getCenter
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns
    * LngLat - {GeoGlobe.LngLat} 边界框地理坐标
    * 
    * @example
    * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
    * llb.getCenter(); // = LngLat {lng: -73.96365, lat: 40.78315}
    *
    */


/**

    * 返回边界的西南角。
    * @method getSouthWest
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns
    * LngLat - {GeoGlobe.LngLat} 边界的西南角
    *
    */


/**

    * 返回边界的东北角。
    * @method getNorthEast
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns
    * LngLat - {GeoGlobe.LngLat} 边界的东北角
    *
    */


/**

    * 返回边界的西北角。
    * @method getNorthWest
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat} LngLat - 边界的西北角
    */


/**

    * 返回边界的东南角。
    * @method getSouthEast
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat}LngLat -边界的东南角
    */


/**

    * 返回西边界的边缘。
    * @method getWest
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat}LngLat -  西边界的边缘
    *
    */

/**

    * 返回东边界的边缘。
    * @method getEast
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat}LngLat -  东边界的边缘
    *
    */

/**
 * 返回南边界的边缘。
 * @method getSouth
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @returns {GeoGlobe.LngLat}LngLat -  南边界的边缘
 *
 */

/**

    * 返回北边界的边缘。
    * @method getNorth
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {GeoGlobe.LngLat}LngLat -  返回北边界的边缘
    */

/**

    * 返回边界的一个数组。
    * @method toArray
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns {Array}Array - 边界的一个数组
    *
    * @example
    * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
    * llb.toArray(); // = [[-73.9876, 40.7661], [-73.9397, 40.8002]]
    */

/**
 * 返回边界为字符串。
 * @method toString
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @returns {string}string -  边界为字符串
 *
 * @example
 * var llb = new GeoGlobe.LngLatBounds([-73.9876, 40.7661], [-73.9397, 40.8002]);
 *  llb.toString(); // = "LngLatBounds(LngLat(-73.9876, 40.7661), LngLat(-73.9397, 40.8002))"
 *
 */

/**
 * 返回边界为字符串。
 * @method isEmpty
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @returns {Boolean}   边界如果被定义则为true
 *
 */ 

GeoGlobe.LngLatBounds = mapboxgl.LngLatBounds;

//因为GeoGlobe.class此方法存在问题，造成类定义的接口无法调用，
//现在临时使用原型对象来扩展接口，达到外部可以调用的效果。

/**
    * 创建这个边界的克隆实例。
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @returns
    * {GeoGlobe.LngLatBounds} 一个新的边界副本
    */
mapboxgl.LngLatBounds.prototype.clone = function(){
	return new mapboxgl.LngLatBounds(this._sw, this._ne);
};

/**
    * 返回边界对象是否包含给定的x和y。
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @param {Float} x

    * @param {Float}y
    * @param {Boolean} inclusive -  是否包含边框。 默认值是true。
    *
    * @returns
    * {Boolean} 传入的坐标是否在这个范围内。
    */
mapboxgl.LngLatBounds.prototype.contains = function(x, y, inclusive){
	//set default
    if (inclusive == null) {
        inclusive = true;
    }

    if (x == null || y == null) {
        return false;
    }

    x = GeoGlobe.Util.toFloat(x);
    y = GeoGlobe.Util.toFloat(y);

    var contains = false;
    if (inclusive) {
        contains = ((x >= this._sw.lng) && (x <= this._ne.lng) && 
                    (y >= this._sw.lat) && (y <= this._ne.lat));
    } else {
        contains = ((x > this._sw.lng) && (x < this._ne.lng) && 
                    (y > this._sw.lat) && (y < this._ne.lat));
    }              
    return contains;
};
/**
* 返回边界的宽度。
* @memberof GeoGlobe.LngLatBounds.prototype
* @returns {Float} 边界的宽度（右减左）。
*/
mapboxgl.LngLatBounds.prototype.getWidth = function(){
	return (this._ne.lng - this._sw.lng);
};
/**

    * 返回边界对象是否包含给定的<GeoGlobe.LngLat>。
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @param {GeoGlobe.LngLat|Object}ll - GeoGlobe.LngLat或具有'lon'和'lat'属性的对象。
    * @param {Object}options -  可选参数。
    *
    *可接受的选项：
    * @param {Boolean} inclusive -  是否包含边界。默认是真的。
    * @param {GeoGlobe.LngLatBounds}  worldBounds -如果提供了worldBounds，
    * 如果它超出了世界范围，则ll将被视为包含，
    * 但可以包裹在日期线中，以便它包含在此范围内。
    *
    * @returns
    * {Boolean} 传入的lonlat在这个界限内。
    */
mapboxgl.LngLatBounds.prototype.containsLonLat = function(ll, options){
	if (typeof options === "boolean") {
        options =  {inclusive: options};
    }
    options = options || {};
    var contains = this.contains(ll.lng, ll.lat, options.inclusive),
        worldBounds = options.worldBounds;
    if (worldBounds && !contains) {
        var worldWidth = worldBounds.getWidth();
        var worldCenterX = (worldBounds._sw.lng + worldBounds._ne.lng) / 2;
        var worldsAway = Math.round((ll.lng - worldCenterX) / worldWidth);
        contains = this.containsLonLat({
            lng: ll.lng - worldsAway * worldWidth,
            lat: ll.lat
        }, {inclusive: options.inclusive});
    }
    return contains;

};
/**
    * 判断地理范围是否相同
    * @memberof GeoGlobe.LngLatBounds.prototype
    * @param {GeoGlobe.LngLatBounds}bounds -
    *
    * @returns{Boolean} 返回值为true，则相等，否则不等
    */
mapboxgl.LngLatBounds.prototype.equals = function(bounds){
	var equals = false;
    if (bounds != null) {
		/*
        equals = ((this.left == bounds.left) && 
                  (this.right == bounds.right) &&
                  (this.top == bounds.top) && 
                  (this.bottom == bounds.bottom));
                  */
        equals = ((this._sw.lng == bounds._sw.lng) && 
                  (this._ne.lng == bounds._ne.lng) &&
                  (this._ne.lat == bounds._ne.lat) && 
                  (this._sw.lat == bounds._sw.lat));
    }
    return equals;
};
/** 

* 生成一个描述范围的字符串。
* @memberof GeoGlobe.LngLatBounds.prototype
* @param {Integer} decimal -  小数点的精度，默认精确到小数点后6位。
* reverseAxisOrder - {Boolean} 是否需要反转坐标。
* 
* @returns
* {String} 范围字符串(e.g. "5,42,10,45")
*/
mapboxgl.LngLatBounds.prototype.toBBOX = function(decimal, reverseAxisOrder){
	if (decimal== null) {
        decimal = 6; 
    }
    var mult = Math.pow(10, decimal);
    var xmin = Math.round(this._sw.lng * mult) / mult;
    var ymin = Math.round(this._sw.lat * mult) / mult;
    var xmax = Math.round(this._ne.lng * mult) / mult;
    var ymax = Math.round(this._ne.lat * mult) / mult;
    if (reverseAxisOrder === true) {
        return ymin + "," + xmin + "," + ymax + "," + xmax;
    } else {
        return xmin + "," + ymin + "," + xmax + "," + ymax;
    }
};
/**

* 基于这个范围对象创建一个新的几何面。
* @memberof GeoGlobe.LngLatBounds.prototype
* @returns
* {GeoGlobe.Geometry.Polygon} 新的几何面。
*/
mapboxgl.LngLatBounds.prototype.toGeometry = function() {
    return new GeoGlobe.Geometry.Polygon([
        new GeoGlobe.Geometry.LinearRing([
            new GeoGlobe.Geometry.Point(this._sw.lng, this._sw.lat),
            new GeoGlobe.Geometry.Point(this._ne.lng, this._sw.lat),
            new GeoGlobe.Geometry.Point(this._ne.lng, this._ne.lat),
            new GeoGlobe.Geometry.Point(this._sw.lng, this._ne.lat)
        ])
    ]);
};
/**
* 返回范围的中心点对象。
* @memberof GeoGlobe.LngLatBounds.prototype
* @returns
* {GeoGlobe.LngLat} 范围的中心点。
*/
mapboxgl.LngLatBounds.prototype.getCenterLonLat = function() {
	if(!this.centerLonLat) {
        this.centerLonLat = new GeoGlobe.LngLat(
            (this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2
        );
    }
    return this.centerLonLat;
};

mapboxgl.LngLatBounds.prototype.CLASS_NAME = "GeoGlobe.LngLatBounds";



/** 

 * 从以逗号分隔的bbox字符串创建GeoGlobe.LngLatBounds对象实例。
 *
 * (begin code)
 * GeoGlobe.LngLatBounds.fromString("5,42,10,45");
 * // => equivalent to ...
 * new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(5,42), new GeoGlobe.LngLat(10,45));
 * (end)
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {String}str - 逗号分隔的边界字符串。 （例如“5,42,10,45”）
 * @param {Boolean}reverseAxisOrder -  字符串是否反转顺序？
 *
 * @returns
 * {GeoGlobe.LngLatBounds} 根据传入的字符串构建的新边界对象。
 */
GeoGlobe.LngLatBounds.fromString = function(str, reverseAxisOrder) {
    var bounds = str.split(",");
    return GeoGlobe.LngLatBounds.fromArray(bounds, reverseAxisOrder);
};

/** 

 * 从数组中构建新的GeoGlobe.LngLatBounds的替代构造函数。
 *
 * (begin code)
 * GeoGlobe.LngLatBounds.fromArray( [5, 42, 10, 45] );
 * // => equivalent to ...
 * new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(5,42), new GeoGlobe.LngLat(10,45));
 * (end)
 * @memberof GeoGlobe.LngLatBounds.prototype
 * @param {Array(Float)}bbox -  边界值数组（例如[5,42,10,45]）
 * reverseAxisOrder - {Boolean} 数组是否反转顺序？
 *
 * @returns {GeoGlobe.LngLatBounds} 根据传入的数组构建的新边界对象。
 */
GeoGlobe.LngLatBounds.fromArray = function(bbox, reverseAxisOrder) {
    return reverseAxisOrder === true ?
           //new OpenLayers.Bounds(bbox[1], bbox[0], bbox[3], bbox[2]) :
           //new OpenLayers.Bounds(bbox[0], bbox[1], bbox[2], bbox[3]);
           new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(bbox[1],bbox[0]), new GeoGlobe.LngLat(bbox[3],bbox[2])) :
           new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(bbox[0],bbox[1]), new GeoGlobe.LngLat(bbox[2],bbox[3]));
};

/** 

 * 根据两个屏幕坐标点，得到bounds几何对象。
 *  @memberof GeoGlobe.LngLatBounds.prototype

 * @param {Array(Float)}p0 -  点1，屏幕坐标点，用数组表示(e.g. [100, 200])。类型也可是mapboxgl.Point
 * @param {Array(Float)}p1 -  点2，屏幕坐标点，用数组表示(e.g. [200, 400])。类型也可是mapboxgl.Point
 * @param {Array(Float)}map - {GeoGlobe.Map} 地图对象
 * 
 * @returns
 * {GeoGlobe.Geometry.Polygon} 返回新的几何面对象。
 */
GeoGlobe.LngLatBounds.toGeometryByTwoPixel = function(p0, p1, map) {
	var box = [mapboxgl.Point.convert(p0), mapboxgl.Point.convert(p1)];
    var glPoints = [
        box[0],
        new mapboxgl.Point(box[1].x, box[0].y),
        box[1],
        new mapboxgl.Point(box[0].x, box[1].y)
    ];
	//屏幕坐标转经纬度坐标
	var pointGeometries = [];
	for(var i =0; i< glPoints.length; i++){
		var lnglat = map.unproject(glPoints[i]);
		var pointGeometry = new GeoGlobe.Geometry.Point(lnglat.lng, lnglat.lat);
		pointGeometries.push(pointGeometry);
	}
	//var boxPixels = [p0, [p1.x, p0.y], [p0.x, p1.y], p1];
	var polygon = new GeoGlobe.Geometry.Polygon([
        new GeoGlobe.Geometry.LinearRing(pointGeometries)
    ]);
	return polygon;
};
﻿/**
 * @class GeoGlobe.LngLat
 * @classdesc 以经度和纬度表示的地理坐标点。
 *
 * 继承:
 *  - GeoGlobe.LngLat

 */



/**
 * 地图上的经度（X轴坐标）。
 * @name lon
 * @memberof GeoGlobe.LngLat.prototype
 * @type {number}
 * @default null
 */

/**
 * 地图上的纬度（Y轴坐标）。
 * @name lat
 * @memberof GeoGlobe.Lng_Lat_geo.prototype
 * @type {String}
 * @default null
 */

/**
 * GeoGlobe.LngLat构造函数。
 * @method initialize
 * @memberof GeoGlobe.LngLat.prototype
 * @param {Object}options -  LngLat相关选项设置。
 * @example
 * var var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
 *
 */

/**
 *将一个数组转换为坐标对象。
    *@method convert
    *@memberof GeoGlobe.LngLat.prototype
    *@param {array}arr -  数组坐标。
    *@returns {GeoGlobe.LngLat}LngLat -  数组转成的坐标对象。
    *@example
    * var arr = [-73.9749, 40.7736];
    * var ll = GeoGlobe.LngLat.convert(arr);
    * alert(ll);
    */

/**

    * 返回新经纬度对象,其经度范围（-180,180）。
    *@method wrap
    *@memberof GeoGlobe.LngLat.prototype
    *@returns {GeoGlobe.LngLat}LngLat -  新经纬度对象。
    *@example
    * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
    * var wrapped = ll.wrap();
    * wrapped.lng; // = -73.9749
    *
    */

/**
 * 返回坐标的一个数组。
 * @method toArray
 * @memberof GeoGlobe.LngLat.prototype
 * @returns {array}array -  坐标的一个数组。
 * @example
 * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
 * ll.toArray(); // = [-73.9749, 40.7736]
 *
 */

/**
 * 返回坐标为字符串。
 * @method toString
 * @memberof GeoGlobe.LngLat.prototype
 * @returns {string} string - 坐标为字符串。
 *
 * @example
 * var ll = new GeoGlobe.LngLat(286.0251, 40.7736);
 * ll.toString(); // = "LngLat(-73.9749, 40.7736)"
 */

/**
 * 返回坐标为字符串。
 * @method toBounds
 * @memberof GeoGlobe.LngLat.prototype
 * @param {Number} radius - 半径。
 * @returns {string} string - 返回一个经纬度范围对象。
 *
 * @example
 *var ll = new GeoGlobe.LngLat(-73.9749, 40.7736);
 *ll.toBounds(100).toArray(); // = [[-73.97501862141328, 40.77351016847229], [-73.97478137858673, 40.77368983152771]]
 */ 

GeoGlobe.LngLat = mapboxgl.LngLat;/**
 * @class GeoGlobe.Layer
 * @classdesc GeoGlobe.Layer类。
 *
 * @param options - {Object} 图层相关选项设置。
<<<<<<< .mine
||||||| .r8435
 * @private
=======
 * 
>>>>>>> .r8450
 */

    /**
     * 图层是否可见
     * @name visibility
     * @memberof GeoGlobe.Layer.prototype
     * @type {Boolean}
     * @default null
     */

    /**
     * 图层标志id
     * @name id
     * @memberof GeoGlobe.Layer.prototype
     * @type {string}
     * @default null
     */

    /**
     * 图层名称
     * @name name
     * @memberof GeoGlobe.Layer.prototype
     * @type {string}
     * @default null
     */

    /**
     * 图层别名
     * @name alias
     * @memberof GeoGlobe.Layer.prototype
     * @type {string}
     * @default null
     */

    /**
     * 引用另一图层
     * @name ref
     * @memberof GeoGlobe.Layer.prototype
     * @type {string}
     * @default null
     */

    /**
     * 规范的数据源id
     * @name sourceId
     * @memberof GeoGlobe.Layer.prototype
     * @type {string}
     * @default null
     */

    /**
     * 数据源中图层ID
     * @name sourceLayerId
     * @memberof GeoGlobe.Layer.prototype
     * @type {string}
     * @default null
     */

    /**
     * 图层的任意属性
     * @name metadata
     * @memberof GeoGlobe.Layer.prototype
     * @type {string}
     * @default null
     */

    /**
     * 图层指定的过滤条件
     * @name filter
     * @memberof GeoGlobe.Layer.prototype
     * @type {Array}
     * @default null
     */

    /**
     * 图层最大层级
     * @name maxZoom
     * @memberof GeoGlobe.Layer.prototype
     * @type {int}
     * @default 20
     */

    /**
     * 图层最小层级
     * @name minZoom
     * @memberof GeoGlobe.Layer.prototype
     * @type {int}
     * @default 0
     */
GeoGlobe.Layer = GeoGlobe.Class(mapboxgl.FreeCRSMap,{


    initialize: function(){
        //var paint = {}
        ////var url = options.url;
        //var layer = {
        //    id:options.id,
        //    layer:{
        //        "id": options.id,
        //        "type": "raster",
        //        "source":options.id,
        //        "paint":paint
        //    },
        //    source:{
        //        "type": "raster",
        //        "tiles": options.url,
        //        "tileSize": 256
        //    }
        //};
        return this;
    },
    CLASS_NAME: "GeoGlobe.Layer"
});
﻿/**
 * @class GeoGlobe.Layer.WMTS
 * @classdesc 网络地图切片服务图层类，网络地图切片服务图层类的实例是用来显示OGC网络地图服务上的瓦片数据。
 */
GeoGlobe.Layer.WMTS =  GeoGlobe.Class4OL({
    /**
     **网络服务地址..
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @type {String}
     * @default null
     */
    url: null,

    /**
     *  图层名称layer..
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @type {String}
     * @default null
     */
    layer: null,

    /**
     * 瓦片格式..
     *@memberof GeoGlobe.Layer.WMTS.prototype
     *@type {String}
     *@default null
     */
    format: null,

    /**
     *  VTS服务矩阵标志..
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @type {String}
     * @default null
     */
    matrixSet: null,

    /**
     * @property {String}  style -  样式标识..
     * @memberof GeoGlobe.WMTS.prototype
     * @type {String}
     * @default null
     */
    style: null,

    /**
     * 图层名称..
     *@memberof GeoGlobe.Layer.WMTS.prototype
     * @type {String}
     * @default null
     */
    name: null,

    /**
     *  图层分辨率..
     *@memberof GeoGlobe.Layer.WMTS.prototype
     *@type {String}
     *@default null
     */
    resolutions: null,

    /**
     * 级别偏移值..
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @type {Bounds}
     * @default null
     */
    zoomOffset: null,

    /**
     *矩阵的详细信息..
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @type {Int}
     * @default null
     */
    matrixIds: null,

    /**
     * 瓦片原点..
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @type {Array}
     * @default null
     */
    tileOrigin: null,

    /**
     * 图层范围..
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @type {Float}
     * @default null
     */
    tileFullExtent: null,

    /**
     * GeoGlobe.Layer.WMTS构造函数。
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @param {Object}options - WMTS相关选项设置。
     * @private
     */
    initialize: function(params){
        return this._getWMTSLayer(params);
    },

    /**

     * 创建WMTS图层对象。
     *@memberof GeoGlobe.Layer.WMTS.prototype
     * @returns {url} 图层的url
     * @private
     */
    _getWMTSLayer:function(options){
        var DEFAULT_PARAMS = {
            service: "WMTS",
            request: "GetTile"
        };
        var params = {};
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.matrixSet) {
            params.TILEMATRIXSET = options.matrixSet;
        }

        if( options.version ) {
            params.VERSION = options.version;
        }
 	if( !options.zoomOffset) {
            options.zoomOffset =0;
        }
        if( options.style ) {
            params.STYLE = options.style;
        }
        params.TILEMATRIX = '{z}';

        params.TILEROW ='{y}';

        params.TILECOL = '{x}';
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url =  this.urlAppend(options.url,
            this.getParameterString(params || {}));
			 url = GeoGlobe.appendToProxy(url);
        var id = "wmts_" + options.layer + "_" + GeoGlobe.Util.randomStr(8);
        return {
            "id": id,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [url],
 		"zoomOffset": options.zoomOffset,//wmts Capabilities信息中TileMatrix第一个对应的实际多少级
                "tileSize": 256
            }
        }
    },
    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @param {Object} params-参数对象
     * @returns {string} 参数字符串
     * @private
     */    
    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**

     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof GeoGlobe.Layer.WMTS.prototype
     *
     * @param {String} url - The url to append to
     * paramStr - {String} The param string to append
     *
     * @returns {String} The new url
     * @private
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },
    /**
     *
     * 复制图层对象。
     *@memberof GeoGlobe.Layer.WMTS.prototype
     * @returns {GeoGlobe.Layer.WMTS} 被克隆的图层对象。
     * @private
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.WMTS(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.name,
                this.url
            );
        }
        return obj;
    },

    /**
     * 获取矩阵。
     * @memberof GeoGlobe.Layer.WMTS.prototype
     * @private
     */
    getMatrix: function() {
        var matrix;
        if (!this.matrixIds || this.matrixIds.length === 0) {
            matrix = {identifier: this.getIdentifier()};
        } else {
            // get appropriate matrix given the map scale if possible
            if ("scaleDenominator" in this.matrixIds[0]) {
                // scale denominator calculation based on WMTS spec
                var denom =
                    GeoGlobe.METERS_PER_INCH *
                    GeoGlobe.INCHES_PER_UNIT[this.units] *
                    this.getServerResolution() / 0.28E-3;
                var diff = Number.POSITIVE_INFINITY;
                var delta;
                for (var i=0, ii=this.matrixIds.length; i<ii; ++i) {
                    delta = Math.abs(1 - (this.matrixIds[i].scaleDenominator / denom));
                    if (delta < diff) {
                        diff = delta;
                        matrix = this.matrixIds[i];
                    }
                }
            } else {
                // fall back on zoom as index
                matrix = this.matrixIds[this.getIdentifier()];
            }
        }
        return matrix;
    },
    CLASS_NAME: "GeoGlobe.Layer.WMTS"
});﻿/**
 * @class GeoGlobe.Layer.WMS
 * @classdesc 网络地图服务图层类，网络地图服务图层类的实例是用来显示OGC网络地图服务上的瓦片数据。
 */
GeoGlobe.Layer.WMS =  GeoGlobe.Class4OL({

    /**
     * 网络服务地址.
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @type {String}
     * @default null
     */
    url: null,


    /**
     * 图层名称layer..
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @type {String}
     * @default null
     */
    layer: null,


    /**
     * 瓦片格式..
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @type {String}
     * @default null
     */
    format: null,

    /**
     *  服务版本号..
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @type {String}
     * @default null
     */
    version: null,

    /**
     *瓦片宽..
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @type {Number}
     * @default 256
     */
    width: 256,

    /**
     * 瓦片高..
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @type {Number}
     * @default 256
     */
    height: 256,

    /**
     * 投影类型..
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @type {Int}
     * @default null 
     */
    SRS: null,

    /**

     * GeoGlobe.Layer.WMS构造函数。
     *@memberof GeoGlobe.Layer.WMS.prototype
     *@param {Object} options - WMS_相关选项设置.
     *@private
     */
    initialize: function(params){
        //GeoGlobe.Util.extend(this, params);
        if(params.isTile!=undefined && params.isTile === false){
            this.layerOption = this._getWMSLayer(params);
        }else{
            return this._getWMSTileLayer(params);
        }
    },
    /**
     * 添加至地图
     * @memberOf GeoGlobe.Layer.WMS.prototype
     * @param {Object} 地图对象
     * @private 
     */
    addTo:function(map){
        this.map = map;
        //this.move = GeoGlobe.Function.bind(this.moveend,this);
        this.move = GeoGlobe.Function.bind(GeoGlobe.Util.delayFun(this.moveend, 300),this);
        this.map.on('moveend',this.move);


        this.width = map.getCanvas().width;
        this.height = map.getCanvas().height;
        var bounds = map.getBounds();
        var maxx = bounds._ne.lng;
        var maxy = bounds._ne.lat;
        var minx = bounds._sw.lng;
        var miny = bounds._sw.lat;
        var bbox = minx + "," + miny + "," + maxx + "," + maxy;
        //var url =layer.url ;
        this.layerOption.source.url = this.layerOption.source.url
            .replace('{bbox}', bbox)
            .replace('{width}', this.width)
            .replace('{height}', this.height);
        var coordinates= [
            [minx, maxy],
            [maxx, maxy],
            [maxx, miny],
            [minx, miny]];
        this.layerOption.source.coordinates =coordinates;
    },

    /**

     * 创建WMS图层对象。
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @returns {url} 图层的信息
     * @private
     */
    _getWMSLayer:function(options){
     
        if(options.transparent || options.transparent === false ) {
             this.options.transparent = options.transparent;
        }else{
            options.transparent = true;
        }
        this.options = options;
        this.url = options.url;
        var param = this.getParamString({
            "SERVICE": "WMS",
            "REQUEST": "GetMap",
            "VERSION": options.version,
            "LAYERS": options.layer,
            "styles":options.styles,
            "FORMAT": options.format,
            "TRANSPARENT":options.transparent,
            "BBOX": '{bbox}',
            "WIDTH": '{width}',
            "HEIGHT": '{height}',
            "SRS":options.SRS
        });

        var wms_url ="";
        if(this.url.endsWith("?")){
            wms_url = this.url + param;
        }else{
            wms_url = this.url + "?" + param;
        }
        wms_url = GeoGlobe.appendToProxy(wms_url);
        var randomNum = GeoGlobe.Util.randomStr(10);

        //扩展图层的字段
        var metadata = {
            "name": options.layer,
            "srs": options.SRS,
            "type": "wms",
            "isTile": options.isTile,
            "format":options.formats
        };
        this.id = "layer_" + options.layer + "_" + randomNum;
        var layerOption = {
            "id": this.id,
            "source": {
                "type": "image",
                "url": wms_url,
                "coordinates": [
                ]
            },
            "metadata":metadata,
            "type": "raster"
        };

        return layerOption;
    },

    /**

     * 创建WMS图层对象。
     *@memberof GeoGlobe.Layer.WMS.prototype
     * @returns {url} 图层的信息
     * @private
     */
    _getWMSTileLayer:function(options){
        var DEFAULT_PARAMS = {
            service: "WMS",
            request: "GetMap"
            //TRANSPARENT: true
        };
        var params = {};
        if( options.layer ) {
            params.LAYERS = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.transparent || options.transparent === false ) {
            params.TRANSPARENT = options.transparent;
        }else{
            params.TRANSPARENT = true;
        }
        if( options.styles ) {
            params.styles = options.styles;
        }
           if(options.tileSize ) {
            params.HEIGHT = options.tileSize;
             params.WIDTH = options.tileSize;
        }else{
            options.tileSize = 256;
            params.HEIGHT = options.tileSize;
            params.WIDTH = options.tileSize;
        }
        if( options.version ) {
            params.VERSION = options.version;
        }
        if( options.SRS ) {
            params.SRS = options.SRS;
        }
        params.BBOX = '{bbox-epsg-3857}';
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        //扩展图层的字段
        var metadata = {
            "name": options.layer,
            "srs": options.SRS,
            "bbox": options.bbox,
            "format":options.format
        }
        //wms_url = GeoGlobe.appendToProxy(wms_url);
        var id = "wms_" + options.layer + "_" + GeoGlobe.Util.randomStr(8);
        var url =  this.urlAppend(options.url,
                this.getParameterString(params || {}));
        url = GeoGlobe.appendToProxy(url);
        return {
            "id": id,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [url],
                "tileSize": options.tileSize
            },
            "metadata":metadata
        }
    },
    /**
     * 移动结束时的方法调用
     * @memberOf GeoGlobe.Layer.WMS.prototype
     * @private
     */
    moveend:function(){

        if(this.map.style._layers[this.id]){
            var isvisible;
            if(this.map.style._layers[this.id].layout && this.map.style._layers[this.id].layout["visibility"] != "none" ){
                isvisible = true;
            }else if(this.map.style._layers[this.id].visibility && this.map.style._layers[this.id].visibility !="none"){
                isvisible = true;
            }else{
                isvisible = false;
            }
            if(isvisible){
                var metadata = this.map.style._layers[this.id].metadata;
                var paint = this.map.style._layers[this.id].paint;
                box = this.map.getBounds();
                var maxx = box._ne.lng;
                var maxy = box._ne.lat;
                var minx = box._sw.lng;
                var miny = box._sw.lat;
                var box = minx + "," + miny + "," + maxx + "," + maxy;
                this.width = this.map.getCanvas().width;
                this.height = this.map.getCanvas().height;
                var param = this.getParameterString({
                    "SERVICE": "WMS",
                    "REQUEST": "GetMap",
                    "VERSION": this.options.version,
                    "LAYERS": this.options.layer,
                    "styles":this.options.styles,
                    "FORMAT": this.options.format,
                    "TRANSPARENT":this.options.transparent,
                    "BBOX": box,
                    "WIDTH": this.width,
                    "HEIGHT": this.height,
                    "SRS":this.options.SRS
                });
                var wms_url ="";
                if(this.url.endsWith("?")){
                    wms_url = this.url + param;
                }else{
                    wms_url = this.url + "?" + param;
                }
                wms_url = GeoGlobe.appendToProxy(wms_url);
                var coordinates= [
                    [minx, maxy],
                    [maxx, maxy],
                    [maxx, miny],
                    [minx, miny]];

                var source = this.map.getSource(this.id);
                source.url = wms_url;
                source.options.url = wms_url;
                source.coordinates = coordinates;
                source.options.coordinates = coordinates;
                source.isReload = true;
                source.load();
            }
            //this.map.addLayer(layer);
        }
    },
    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @param {Object} params-参数对象
     * @returns {string} 参数字符串
     * @private
     */
    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**

     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     *@memberof GeoGlobe.Layer.WMS.prototype
     * @param {String}url - The url to append to
     * @param {String}url -The param string to append
     *
     * @returns {String} The new url
     * @private
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },
    /**

     * 复制图层对象。
     *@memberof GeoGlobe.Layer.WMS.prototype
     * @returns {GeoGlobe.Layer.WMS} 被克隆的图层对象。
     * @private
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.WMS(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.name,
                this.url
            );
        }
        return obj;
    },
    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Layer.WMS.prototype
     * @param {Object} params-参数对象
     * @returns {string} 参数字符串
     * @private
     */    
    getParamString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },
    CLASS_NAME: "GeoGlobe.Layer.WMS"
});/**
 * @class GeoGlobe.Layer.VTS
 * @classdesc 矢量切片服务图层类，矢量切片服务图层类的实例是用来显示OGC网络地图服务上的矢量瓦片数据。
 */
GeoGlobe.Layer.VTS =  GeoGlobe.Class4OL({


    /**
     *网络服务地址
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {String}
     * @default null
     */
    url: null,

    /**
    * 图层名称layer
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {String}
     * @default null
     */
    layer: null,

    /**
     * 瓦片格式r
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {String}
     * @default null
     */
    format: null,

    /**
     * VTS服务矩阵标志
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {String}
     * @default null
     */
    matrixSet: null,

    /**
     *  样式标识
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {String}
     * @default null
     */
    style: null,

    /**
     * 图层名称
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @default null
     */
    name: null,

    /**
     *  图层分辨率
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {String}
     * @default null
     */
    resolutions: null,

    /**
     *  级别偏移值
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {String}
     * @default null
     */
    zoomOffset: null,

    /**
     * 矩阵的详细信息
     *@memberof  GeoGlobe.Layer.VTS.prototype
     *@type {Int}
     *@default null
     */
    matrixIds: null,

    /**
     * 瓦片原点
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {Array}
     * @default null
     */
    tileOrigin: null,

    /**
     * 图层范围
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @type {Float}
     * @default null
     */
    tileFullExtent: null,

    /**

     * GeoGlobe.Layer.VTS构造函数
     *@memberof  GeoGlobe.Layer.VTS.prototype
     *@param {Object} options -VTS相关选项设置.
     *@private
     */
    initialize: function(params){
        this.source_id = "source_vts_"+GeoGlobe.Util.randomStr(6);
        this.layers = this._getVTSLayer(params);
        this.source = {
            "type":"vector",
            "tiles":[this.url_tmpl]
        };
    },

    /**

     * 创建VTS图层对象。
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @returns {url} 图层的url
     * @private
     */
    _getVTSLayer:function(options){
        var DEFAULT_PARAMS = {
            service: "WMTS",
            request: "GetTile"
        };
        this.url = options.url;
        var params = {};
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.matrixSet) {
            params.TILEMATRIXSET = options.matrixSet;
        }

        if(options.version) {
            params.VERSION = options.version;
        }
        //if(options.tileBBox) {
            //params.tileBBox = options.tileBBox;
        //}
        //if(options.minZoom !== undefined) {
            //params.minZoom = options.minZoom;
        //}
        //if(options.maxZoom !== undefined) {
            //params.maxZoom = options.maxZoom;
        //}
        if(options.tileSize) {
            params.WIDTH = options.tileSize;
            params.HEIGHT = options.tileSize;
        }

        params.TILEMATRIX = '{z}';

        params.TILEROW ='{y}';

        params.TILECOL = '{x}';
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = GeoGlobe.ProxyHost  + this.urlAppend(options.url,
                this.getParameterString(params || {}));
        //var style = this.GetStyle()
        this.url_tmpl = url;
        var source_id = "source_vts_"+GeoGlobe.Util.randomStr(6);
        this.source_id = source_id;
        var Layer_data = [];
        this.GetStyle(options.styleName, function(result){
                if(result.sprite){
                    var sprite = GeoGlobe.ProxyHost+result.sprite;
                }else{
                    var sprite = "";
                }

                if(result.glyphs){
                    var glyphs = GeoGlobe.ProxyHost+result.glyphs;
                }else{
                    var glyphs = "";
                }
                var metadata = {
                    "sprite":sprite,
                    "glyphs":glyphs,
                    "styleName":result.name,
                    "layerIdentifier": params.LAYER,
                    "matrixSet": params.TILEMATRIXSET,
                    "format": params.FORMAT,
                    "bbox": options.tileBBox ? options.tileBBox : "",
                    "minZoom": options.minZoom ? options.minZoom : "",
                    "maxZoom": options.maxZoom ? options.maxZoom : ""
                };
                if(result.styleData){
                    for(var i=0;i<result.styleData.layers.length;i++){
                        result.styleData.layers[i].metadata = metadata;
                        result.styleData.layers[i].source = source_id;
                        /*{
                         "type": "vector",
                         "tiles": [url]
                         };*/
                        Layer_data[i] =  result.styleData.layers[i];
                    }
                }else{
                    for(var i=0;i<result.layers.length;i++){
                        result.layers[i].source = source_id;
                        /*{
                         "type": "vector",
                         "tiles": [url]
                         };*/
                        result.layers[i].metadata = metadata;
                        Layer_data[i] =  result.layers[i];
                    }
                }

            },
            function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
            });

        return Layer_data;
    },
    /**
     * 获取参数字符串
     * @memberOf GeoGlobe.Layer.VTS.prototype
     * @param {Object} params-参数对象
     * @returns {String} 参数字符串
     * @private
     */
    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**

     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof  GeoGlobe.Layer.VTS.prototype

     * @param url - {String}The url to append to.
     * paramStr - {String} The param string to append
     *
     * @returns {String} The new url
     * @private
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    /**

     * 获取基于MapboxGL样式数据（用json描述）。
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @param successFn - {Function}请求成功的回调函数.
     * @param failFn  - {Function}请求失败的回调函数.

     */
    GetStyle: function(styleName,successFn, failFn){
        var url = this.url;
        if(styleName =="" || styleName == undefined){
            alert("请查看样式名称是否存在");
            return ;
        }
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0",
            STYLENAME:styleName
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(result){
                var obj = result.responseText;
                if(!obj){
                    failFn();
                    return false;
                }
                var jformat = new GeoGlobe.Format.JSON();
                var style = jformat.read(obj);
                //var style = geojson.style[0];
                successFn(style);
            },
            failure: failFn
        });
    },

    /**
     * 复制图层对象。
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @returns {GeoGlobe.Layer.VTS} 被克隆的图层对象。
     * @private
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.VTS(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.name,
                this.url
            );
        }
        return obj;
    },

    /**

     * 获取矩阵。
     * @memberof  GeoGlobe.Layer.VTS.prototype
     * @private
     */
    getMatrix: function() {
        var matrix;
        if (!this.matrixIds || this.matrixIds.length === 0) {
            matrix = {identifier: this.getIdentifier()};
        } else {
            // get appropriate matrix given the map scale if possible
            if ("scaleDenominator" in this.matrixIds[0]) {
                // scale denominator calculation based on VTS spec
                var denom =
                    GeoGlobe.METERS_PER_INCH *
                    GeoGlobe.INCHES_PER_UNIT[this.units] *
                    this.getServerResolution() / 0.28E-3;
                var diff = Number.POSITIVE_INFINITY;
                var delta;
                for (var i=0, ii=this.matrixIds.length; i<ii; ++i) {
                    delta = Math.abs(1 - (this.matrixIds[i].scaleDenominator / denom));
                    if (delta < diff) {
                        diff = delta;
                        matrix = this.matrixIds[i];
                    }
                }
            } else {
                // fall back on zoom as index
                matrix = this.matrixIds[this.getIdentifier()];
            }
        }
        return matrix;
    },
    CLASS_NAME: "GeoGlobe.Layer.VTS"
});﻿/**
 * @class GeoGlobe.Layer.Export
 * @classdesc 网络地图服务图层类，网络地图服务图层类的实例是用来显示OGC网络地图服务上的瓦片数据。
 */
GeoGlobe.Layer.Export = GeoGlobe.Class4OL({

    /**
     * 网络服务地址.
     * @memberof GeoGlobe.Layer.Export.prototype
     * @type {String}
     * @default null
     */
    url: null,

    /**
     * 瓦片格式.
     * @memberof GeoGlobe.Layer.Export.prototype
     * @type {String}
     * @default null
     */
    f: null,

    /**
     * 瓦片格式..
     * @memberof GeoGlobe.Layer.Export.prototype
     * @type {String}
     * @default null
     */
    format: null,

    /**
     *瓦片尺寸..
     * @memberof GeoGlobe.Layer.Export.prototype
     * @type {String}
     * @default "256,256"
     */
    size: "256,256",

    /**
     *瓦片透明度..
     * @memberof GeoGlobe.Layer.Export.prototype
     * @type {Boolean}
     * @default true
     */
    transparent: true,

    /**
     * GeoGlobe.Layer.Export构造函数。
     *@memberof GeoGlobe.Layer.Export.prototype
     *@param {Object} options - Export_相关选项设置.
     *@private
     */
    initialize: function (params) {
        return this._getExportTileLayer(params);
    },

    /**
     * 创建Export图层对象。
     *@memberof GeoGlobe.Layer.Export.prototype
     * @returns {url} 图层的信息
     * @private
     */
    _getExportTileLayer: function (options) {
        DEFAULT_PARAMS = {};
        var params = {};
        params.BBOX = "{bbox-epsg-3857}";
        if (options.format) {
            params.format = options.format;
        } else {
            params.format = "image/png";
        }
        if (options.transparent || options.transparent === false) {
            params.transparent = options.transparent;
        } else {
            params.transparent = true;
        }
        if (options.f) {
            params.f = options.f;
        } else {
            params.f = "image";
        }
        if (options.size) {
            params.size = options.size;
        } else {
            params.size = "256,256";
        }

        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        //扩展图层的字段
        var metadata = {
            "url": options.url,
            "transparent": params.transparent,
            "size": params.size,
            "bbox": params.BBOX,
            "format": params.format,
            "f": params.f
        }
        var url = this.urlAppend(options.url,
            this.getParameterString(params || {}));
        // url = GeoGlobe.appendToProxy(url);
        return {
            "id": "sz_wms_id",
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [url],
                "tileSize": 256
            },
            "metadata": metadata
        }
    },

    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Layer.Export.prototype
     * @param {Object} params-参数对象
     * @returns {string} 参数字符串
     * @private
     */
    getParameterString: function (params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex = 0, len = value.length; itemIndex < len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                            (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }
        return paramsArray.join("&");
    },

    /**
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof GeoGlobe.Layer.Export.prototype
     * @param {String}url - The url to append to
     * @param {String}url -The param string to append
     *
     * @returns {String} The new url
     * @private
     */
    urlAppend: function (url, paramStr) {
        var newUrl = url;
        if (paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },
    CLASS_NAME: "GeoGlobe.Layer.Export"
});﻿/**
 * @class GeoGlobe.Layer.WMS_
 * @classdesc WMS图层类，WMS图层类的实例是用来显示OGC网络地图服务上的数据。
 * @private
 */
GeoGlobe.Layer.WMS_ = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     *图层标志id.
     * @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type {string}
     */
    id: null,

    /**
     *
     *图层名称..
     * @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type {string}
     */
    name: null,

    /**
     * 瓦片大小.
     *  @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type {int}
     */

    tileSize: 256,

    /**
     *网络服务地址..
     *  @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type {string}
     *
     */
    url: null,
    /**
     * 图层指定的过滤条件..
     * @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type {Array}
     */
    filter: null,

    /**
     * 图层的透明度..
     *  @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type  {float}
     */

    opacity: 0,

    /**
     * 是否可见..
     *   @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type  {Boolean}
     */
    visible: true,

    /**
     * 图层最大层级..
     *  @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type  {int}
     */
    maxZoom: 20,

    /**
     *图层最小层级..
     *    @memberof  GeoGlobe.Layer.WMS_.prototype
     * @type  {int}
     */

    minZoom: 0,

    /**

     * GeoGlobe.Layer.WMS_构造函数。
     *  @memberof  GeoGlobe.Layer.WMS_.prototype
     * @param {Object}options - WMS_相关选项设置.
     */


    initialize: function(options){
        var paint = {}
        //var url = options.url;
        var layer = {
            id:options.id,
            layer:{
                "id": options.id,
                "type": "raster",
                "source":options.id
            },
            source:{
                "type": "raster",
                "tiles": options.url,
                "tileSize": 256
            }
        };
        return layer;
    },
    /**

     * 获取服务的URL。
     * @memberof  GeoGlobe.Layer.WMS_.prototype
     * @returns {url} 图层的url
     */
    getTileUrl:function(){
        var url;
        url = this.url;
        return url;
    },

    /**

     * 复制图层对象。
     *  @memberof  GeoGlobe.Layer.WMS_.prototype
     * @returns {GeoGlobe.Layer.WMS_} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.WMS_(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.maxZoom,
                this.minZoom,
                this.name,
                this.url
            );
        }
        return obj;
    },
    CLASS_NAME: "GeoGlobe.Layer.WMS_"
});﻿/**
 * @class GeoGlobe.Layer.WMTS_
 * @classdesc WMS图层类，WMTS图层类的实例是用来显示OGC网络地图服务上的瓦片数据。
 * Inherits from:
 *  - <GeoGlobe.Layer.WMTS_>
 * @private
 */
GeoGlobe.Layer.WMTS_ = GeoGlobe.Class(GeoGlobe.Layer,{
    /**

     * 图层标志id.
     * @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {string}
     */
    id: null,

    /**
     * 图层名称..
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {string}
     */
    name: null,

    /**
     * 级别偏移值..
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {bounds}
     */
    matrixSet: null,

    /**
     *  矩阵的详细信息..
     * @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {int}
     */
    matrixIds: null,

    /**
     *  瓦片集的最大范围..
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {bounds}
     */
    tileFullExtent: null,


    /**
     * 瓦片大小.
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {int}
     */
    tileSize: 256,

    /**
     * 网络服务地址..
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {string}
     */
    url: null,
    /**
     *图层指定的过滤条件..
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {Array}
     */
    filter: null,

    /**
     *  图层的透明度..
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {float}
     */
    opacity: 0,


    /**
     *  是否可见..
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @type {Boolean}
     */
    visible: true,

    /**

     * GeoGlobe.Layer.WMTS构造函数。
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     *@param {Object} options - WMTS相关选项设置。
     */
    initialize: function(options){
        //var url = options.url;
        var paint = {};
        var layer = {
            id:options.id,
            layer:{
                "id": options.id,
                "type": "raster",
                "source":options.id
            },
            source:{
                "type": "raster",
                "tiles": options.url,
                "tileSize": 256
            }
        };
        if (this.matrixIds) {
            var len = this.matrixIds.length;
            if (len && typeof this.matrixIds[0] === "string") {
                var ids = this.matrixIds;
                this.matrixIds = new Array(len);
                for (var i=0; i<len; ++i) {
                    this.matrixIds[i] = {identifier: ids[i]};
                }
            }
        }
        return layer;
    },

    /**

     * 获取服务的URL。
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     * @returns {url} 图层的url
     */
    getTileUrl:function(){
        var url;
        url = this.url;
        return url;
    },

    /**

     * 复制图层对象。
     * @memberof GeoGlobe.Layer.WMTS_.prototype
     * @returns {GeoGlobe.Layer.WMTS_} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.WMTS_(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.name,
                this.url
            );
        }
        return obj;
    },

    /**

     * 获取矩阵。
     *  @memberof GeoGlobe.Layer.WMTS_.prototype
     */
    getMatrix: function() {
        var matrix;
        if (!this.matrixIds || this.matrixIds.length === 0) {
            matrix = {identifier: this.getIdentifier()};
        } else {
            // get appropriate matrix given the map scale if possible
            if ("scaleDenominator" in this.matrixIds[0]) {
                // scale denominator calculation based on WMTS spec
                var denom =
                    OpenLayers.METERS_PER_INCH *
                    OpenLayers.INCHES_PER_UNIT[this.units] *
                    this.getServerResolution() / 0.28E-3;
                var diff = Number.POSITIVE_INFINITY;
                var delta;
                for (var i=0, ii=this.matrixIds.length; i<ii; ++i) {
                    delta = Math.abs(1 - (this.matrixIds[i].scaleDenominator / denom));
                    if (delta < diff) {
                        diff = delta;
                        matrix = this.matrixIds[i];
                    }
                }
            } else {
                // fall back on zoom as index
                matrix = this.matrixIds[this.getIdentifier()];
            }
        }
        return matrix;
    },
    CLASS_NAME: "GeoGlobe.Layer.WMTS_"
});/**
 * @class GeoGlobe.Layer.GeoTileLayer
 * @classdesc  GeoGlobe瓦片图层类，继承自GeoGlobe.Layer类，具有该类的所有属性与方法，并在此基础上进行了扩展。

 * @param {String} id   - GeoGlobe瓦片图层名称。
 * @param {String} url  - 瓦片服务地址。
 * @param {Object} options  - 对象构造参数。
 * @example
 * new GeoGlobe.Layer.GeoTileLayer( {
 *      id:"天地图矢量注记",
 *      url:"http://tile0.tianditu.com/services/AB0512_Anno",
 *      type:"raster",
 *      "tileSize":256
 *      minzoom: 2,
 *      maxzoom: 12,
 *      maxExtent: new GeoGlobe.LngLatBounds(-180, -90, 180, 90)
 * })
 */
GeoGlobe.Layer.GeoTileLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * 图层标志id。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @type {String}
     * @default null
     */
    id: null,
    
    /**
     * 瓦片大小。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @type {Int}
     * @default 256
     */
    tileSize: 256,

    /**
     * 网络服务地址。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @type {String}
     * @default null
     */
    url: null,

    /**
     * 图层顶层级别。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @type {Integer}
     * @default null
     */
    minzoom: null,

    /**
     *图层底层级别。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @type {Integer}
     * @default null
     */
    maxzoom: null,

    /**
     * 服务访问名称。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @type {String}
     * @default null
     * @private
     */
    serviceName : null,

    /**
     * 服务访问地址。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @type {String}
     * @default null
     * @private
     */
    accessUrl : null,


    initialize : function(options){
        this.url = options.url;
        var gturl =[];
        var extents ;
        this.extent = options.maxextent;
        convertUrl(this.url);
        exttolat(this.extent)
        var layer = {
            "id": options.id,
            "name": options.name,
            "type": options.type,
            "source":{
                "type": options.type,
                "tiles": [gturl[0]+"?T="+gturl[1]+"&X={x}&Y={y}&L={z}"],
                "tileSize": options.tileSize
            },
            "maxzoom": parseInt(options.maxzoom),
            "minzoom": parseInt(options.minzoom),
            "paint": {
            	"raster-opacity": options.opacity == null ? 1 : options.opacity
            },
            "layout": {
            	"visibility": options.visibility == null ? "visible" :  options.visibility
            }
        };
        //var layers ={
        //    layer:layer,
        //    extent:extents
        //}
        return layer;

        function convertUrl(url){
            var tmpUrl = url.split("/services/");
            if (tmpUrl[0] && tmpUrl[1]) {
                gturl.push(tmpUrl[0] + "/DataServer");
                gturl.push(tmpUrl[1]);
            } else {
                alert("解析服务地址错误:" + url);
                return;
            }
        }
        function exttolat(extent){
            extents = extent.split(",");
            for(var e = 0; e < extents.length;e++){
                extents[e] = parseInt(extents[e]);
            }
        }
    },

    /**
     * 将服务地址转换成实际瓦片图片访问地址。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @param {String} url   -服务地址。
     * @private
     */
    convertUrl: function(url){
        var tmpUrl = url.split("/services/");
        if (tmpUrl[0] && tmpUrl[1]) {
            this.accessUrl = tmpUrl[0] + "/DataServer";
            this.serviceName = tmpUrl[1];
        } else {
            OpenLayers.Console.error("解析服务地址错误:" + url);
            return;
        }
    },

    /**
     *镜像地址分布方法,行号(x)与镜像地址数量取余数。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @param {Integer} factor
     * @param {Array(String)} urls
     *
     * @returns {String}  -选择地址。
     * @private
     */
    selectUrl:function(factor, urls){
        var len = urls.length;
        var remainder = factor % len;
        return urls[remainder];

    },

    /**
     *获取获取图层范围。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @returns {GeoGlobe.LngLatBounds}  -图层范围。
     * @private
     */
    getDataExtent: function () {
        if (this.maxExtent){
            return this.maxExtent.clone();
        }
    },

    /**
     *复制图层对象。
     * @memberof GeoGlobe.Layer.GeoTileLayer.prototype
     * @returns {GeoGlobe.Layer.GeoTileLayer} -被克隆的图层对象。
     * @private
     */
    clone : function(obj){
        obj = new GeoGlobe.Layer.GeoTileLayer(this.name,
            this.url,
            this.options);
        return obj;
    },

    CLASS_NAME: "GeoGlobe.Layer.GeoTileLayer"
});/**
 * @class GeoGlobe.Layer.GeoWMTSLayer
 * @classdesc GeoGlobe 网络地图切片服务图层类，继承自GeoGlobe.Layer.WMTS类，具有该类的所有属性与方法，并在此基础上进行了扩展
 */
GeoGlobe.Layer.GeoWMTSLayer = GeoGlobe.Class(GeoGlobe.Layer.WMTS, {
    /**
    *图层标志
    * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
    * @type {String}
    * @default null
     */
    id: null,

    /**
     * 图层名称
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {String}
     * @default null
     */
    name: null,
    /**
     * WMTS服务矩阵标志
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {String}
     * @default null
     */
    matrixSet: null,

    /**
     * WMTS服务矩阵id
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {String}
     * @default null
     */
    matrixIds: null,

    /**
     * 瓦片集的最大范围
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {String}
     * @default null
     */
    tileFullExtent: null,

    /**
     * 瓦片大小
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {Int}
     * @default 256
     */
    tileSize: 256,

    /**
     * 网络服务地址
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {String}
     * @default null
     */
    url: null,

    /**
     *图层指定的过滤条件
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {Array}
     * @default null
     */
    filter: null,

    /**
     * 图层的透明度
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {Float}
     * @default 0
     */
    opacity: 0,

    /**
     * 是否可见
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * 时间版本。
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {String}
     * @default 9999-01-01 00:00:00
     */
    time: "9999-01-01 00:00:00",

    /**
     * 为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
     * 否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
     * 返回其中最新的瓦片数据。默认为true。
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @type {Boolean}
     * @default true
     */
    userecent: true,

    /**

     * 创建GeoWMTS图层对象实例。
     *  @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @Property {String} name -GeoGlobe瓦片图层名称。
     * @Property {String}url - 瓦片服务地址。
     * @param options - {Object} 对象构造参数。
     *
     * 示例:
     * (code)
     *
     * (end)
     * @private
     */
    initialize : function(options){
        var layer = {
            "id": options.id,
            "type": options.type,
            "source":{
                "type": options.type,
                "tiles":[options.url],
                "tileSize": options.tileSize
            },
            "maxzoom":parseInt(options.maxzoom),
            "minzoom":parseInt(options.minzoom)
        };
        return layer;
    },

    /**

     * 设置历史版本,设置版本后会重新绘制本图层。
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @param verstion - {String} 历史版本号,格式为"2010-06-23 18:48:23"。
     * @private
     */
    setVerstionTime: function(verstion){
        if(verstion){
            this.params.time = verstion;
            this.time = verstion;
            this.redraw();
        }
    },

    /**

     * 设置多时相相关参数。
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @param {String} time - 时间版本。
     * @param {Boolean}userecent
     *   为FALSE时只有存在指定时相的瓦片数据时，才返回瓦片数据，
     *   否则返回提示。为TRUE时，只要存在不晚于指定时相的瓦片数据时，
     *   返回其中最新的瓦片数据。默认为true。
     * @private
     */
    setParams: function(params) {
        if(params.time) {
            this.params.time = params.time;
            this.time = params.time;
            var userecent = typeof params.userecent == "boolean" ? params.userecent : true;
            this.params.USERECENT = userecent;
            this.userecent = userecent;
            this.redraw();
        }
    },

    /**

     * 复制图层对象。
     * @memberof GeoGlobe.Layer.GeoWMTSLayer.prototype
     * @returns {GeoGlobe.Layer.GeoWMTSLayer} 被克隆的图层对象
     * @private

     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.GeoWMTSLayer(this.options);
        }
        new GeoGlobe.Layer.GeoWMTSLayer(this.options);
        //obj = GeoGlobe.Layer.WMTS.prototype.clone.apply(this, [obj]);
        return obj;
    },

    CLASS_NAME: "GeoGlobe.Layer.GeoWMTSLayer"
});﻿/**
 * @class GeoGlobe.Layer.VectorTile
 * @classdesc WMS图层类，WMS图层类的实例是用来显示OGC网络地图服务上的数据。
 * Inherits from:
 *  - GeoGlobe.Layer.VectorTile
 * @private
 */
GeoGlobe.Layer.VectorTile = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     *  图层标志id..
     * @memberof GeoGlobe.Layer.VectorTile.prototype
     * @type {string}
     */
    id: null,

    /**
     * 图层名称..
     *@memberof GeoGlobe.Layer.VectorTile.prototype
     * @type {string}
     */
    name: null,
    /**
     * 网络服务地址..
     * @memberof GeoGlobe.Layer.VectorTile.prototype
     * @type {string}
     */
    url: null,

    /**
     * 图层指定的过滤条件..
     * @memberof GeoGlobe.Layer.VectorTile.prototype
     * @type {Array}
     */

    filter: null,


    /**
     *图层的透明度..
     * @memberof GeoGlobe.Layer.VectorTile.prototype
     * @type {float}
     */

    opacity: 0,
    /**
     * 是否可见.
     *  @memberof GeoGlobe.Layer.VectorTile.prototype
     * @type {Boolean}
     */
    visible: true,

    /**
     * 图层最大层级..
     * @memberof GeoGlobe.VectorTileLayer.prototype
     * @type {int}
     */
    maxZoom: 20,

    /**
     * 图层最小层级..
     *@memberof GeoGlobe.Layer.VectorTile.prototype
     * @type {int}
     */
    minZoom: 0,

    /**

     * GeoGlobe.Layer.WMS构造函数。
     * @memberof GeoGlobe.Layer.VectorTile.prototype
     * @param {Object}options -矢量图层相关选项设置.
     */
    initialize: function(options){
/**
        var layer = {
            id:options.id,
            layer:options.style,
            source:{
                "type": options.type,
                "tiles": options.url
            }
        };
*/
        return options;
    },

    /**

     * 获取服务的URL。
     * @memberof GeoGlobe.Layer.VectorTile.prototype
     *  @returns {url}图层的url
     */
    getTileUrl:function(){
        var url;
        url = this.url;
        return url;
    },

    /**

     * 复制图层对象。
     *  @memberof GeoGlobe.Layer.VectorTile.prototype
     * @returns {GeoGlobe.Layer.VectorTile} 被克隆的图层对象。
     */
    clone : function(obj){
        if (obj == null) {
            obj = new GeoGlobe.Layer.VectorTile(
                this.id,
                this.tileSize,
                this.filter,
                this.opacity,
                this.visible,
                this.maxZoom,
                this.minZoom,
                this.name,
                this.url
            );
        }
        return obj;
    },
    CLASS_NAME: "GeoGlobe.Layer.VectorTile"
});
/**
 * @class GeoGlobe.Layer.RasterLayer
 * @classdesc 矢量图层。
 */

/**
 *透明度
* @name raster-opacity
* @memberof  GeoGlobe.Layer.RasterLayer.prototype
* @type {number}
* @default null
*/

/**
 * 旋转颜色
 * @name raster-hue-rotate
 * @memberof  GeoGlobe.Layer.RasterLayer.prototype
 * @type {number}
 * @default null
 */

/**
 * 最小亮度
 * @name raster-brightness-min 
 * @memberof  GeoGlobe.Layer.RasterLayer.prototype
 * @type {number}
 * @default null
 */

/**
 * 最大亮度
 * @name raster-brightness-max
 * @memberof  GeoGlobe.Layer.RasterLayer.prototype
 * @type {number}
 * @default null
 */


/**
 * 增加或减少图像的饱和度
 * @name raster-saturation
 * @memberof  GeoGlobe.Layer.RasterLayer.prototype
 * @type {number}
 * @default null
 */

/**
 * 增加或减少图像的对比度
 * @name raster-contrast
 * @memberof  GeoGlobe.Layer.RasterLayer.prototype
 * @type {number}
 * @default null
 */


/**
 * 瓦片褪色的持续时间
 * @name raster-fade-duration
 * @memberof  GeoGlobe.Layer.RasterLayer.prototype
 * @type {number}
 * @default null
 */
GeoGlobe.Layer.RasterLayer = GeoGlobe.Class(GeoGlobe.Layer,{



    /**
     * GeoGlobe.Layer构造函数。
     *@memberof  GeoGlobe.Layer.RasterLayer.prototype

     * @param options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.RasterLayer"
});


/**
 * @class GeoGlobe.Layer.FillLayer
 * @classdesc  填充图层,继承GeoGlobe.FillLayer，具有该类的所有属性与方法
 */

/**
 * 图层颜色
 * @name fill-color
 * @memberof GeoGlobe.Layer.FillLayer.prototype
 * @type {color}
 * @default null
 */

/**
 * 用于绘制图像背景的图像中的图像的名称。
 * @name fill-pattern
 * @memberof GeoGlobe.Layer.FillLayer.prototype
 * @type {string}
 * @default null
 */

/**
 * 透明度。
 * @name fill-opacity
 * @memberof GeoGlobe.Layer.FillLayer.prototype
 * @type {number}
 * @default null
 */

/**
 * 是否有锯齿。
 * @name fill-antialias
 * @memberof GeoGlobe.Layer.FillLayer.prototype
 * @type {boolean}
 * @default null
 */

/**
 * 填充的轮廓颜色。
 * @name fill-outline-color
 * @memberof GeoGlobe.Layer.FillLayer.prototype
 * @type {color}
 * @default null
 */

/**
 * 几何偏移。
 * @name fill-translate
 * @memberof GeoGlobe.Layer.FillLayer.prototype
 * @type {array}
 * @default null
 */

/**

    *  几何偏移固定。
    * @name fill-translate-anchor
    * @memberof GeoGlobe.Layer.FillLayer.prototype
    * @type {enum}
    * @default null
    */
GeoGlobe.Layer.FillLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**

     * GeoGlobe.Layer构造函数。
     * @memberof GeoGlobe.Layer.FillLayer.prototype
     * @param {Object} options  - 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.FillLayer"
});


/**
 * @class GeoGlobe.Layer.CircleLayer
 * @classdesc 填充图层类。
 *
 * @param {Object} options  - 图层相关选项设置。
 */
GeoGlobe.Layer.CircleLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * 圆的半径
     * @memberof GeoGlobe.Layer.CircleLayer.prototype
     * @var {number} circle-radius
     */
    "circle-radius": null,

    /**
     * 图层颜色
     * @memberof GeoGlobe.Layer.CircleLayer.prototype
     * @Property {color} circle-color  -图层颜色。
     * @var {string} circle-color
     */
    "circle-color": null,

    /**
     * 圆的清晰度的数量
     * @memberof GeoGlobe.Layer.CircleLayer.prototype
     * @var {number} circle-blur
     */
    "circle-blur": null,

    /**
     * 透明度
     * @memberof GeoGlobe.Layer.CircleLayer.prototype
     * @var {number} circle-opacity
     */
    "circle-opacity": null,

    /**
     * 当地图倾斜时，控制圆圈的缩放行为
     * @memberof GeoGlobe.Layer.CircleLayer.prototype
     * @var {enum} circle-pitch-scale
     */
    "circle-pitch-scale": null,

    /**
     * 几何偏移
     * @memberof GeoGlobe.Layer.CircleLayer.prototype
     * @var {enum} circle-translate
     */
    "circle-translate": null,

    /**
     * 几何偏移固定
     * @memberof GeoGlobe.Layer.CircleLayer.prototype
     * @var {enum} circle-translate-anchor
     */
    "circle-translate-anchor": null,

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.CircleLayer"
});


/**
 * @class GeoGlobe.Layer.SymbolLayer
 * @classdesc 符号图层。
 */

    /**
     * 图层是否可见
     * @name visibility
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {Boolean}
     * @default null
     */

    /**
     *  标签放置位置。
     * @name symbol-placement
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */


    /**
     * 两个符号之间的距离。
     * @name symbol-spacing
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 符号避免边缘
     * @name symbol-avoid-edges
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {Boolean}
     * @default null
     */


    /**
     * 重叠可见
     * @name icon-allow-overlap 
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {Boolean}
     * @default null
     */


    /**
     * 符号可见
     * @name icon-ignore-placement
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {Boolean}
     * @default null
     */

    /**
     * 如果是真的，文本将显示相应的图标时，图标没有与其他符号和文字不碰撞。
     * @name icon-optional
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {Boolean}
     * @default null
     */


    /**
     * 在与符号放置的组合，确定图标的旋转行为
     * @name icon-rotation-alignment
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */

    /**
     * 图标大小
     * @name icon-size
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     *
     */

    /**
     * 尺度的图标。
     * @name icon-text-fit
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     *
     */


    /**
     * 图标文本大小适合。
     * @name icon-text-fit-padding
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {array}
     * @default null
     */


    /**
     *  图标图片
     * @name icon-image
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {string}
     * @default null
     */


    /**
     * 顺时针旋转图标
     * @name icon-rotate
     *  @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */


    /**
     * 用于检测符号冲突的图标边界范围的附加区域的大小。
     * @name icon-padding
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 图标偏移。
     * @name icon-offset
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */


    /**
     *  是否翻转。
     * @name icon-keep-upright
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {boolean}
     * @default null
     */


    /**
     * 文字倾斜方向
     * @name text-pitch-alignment
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null

     */

    /**
     * 文字旋转
     * @name text-rotate-alignment
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */


    /**
     * 文本标签的值
     * @name text-field
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {string}
     * @default null
     */


    /**
     * 文本字体。
     * @name text-font
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {array}
     * @default null
     */


    /**
     * 文本字体大小
     * @name text-size
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null

     */


    /**
     * 文本最大线宽
     * @name text-max-width
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     *文本最大线高
     *@name text-line-height
     *@memberof GeoGlobe.Layer.SymbolLayer.prototype
     *@type {number}
     *@default null
     */

    /**
     * 文本跟踪量
     * @name text-letter-spacing
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 文本对齐
     * @name text-justify
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */


    /**
     *文本偏移
     *@name text-anchor
     *@memberof GeoGlobe.Layer.SymbolLayer.prototype
     *@type {enum}
     *@default null
     */

    /**
     *相邻字符之间的最大角度变化。
     * @name text-max-angle
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */


    /**
     * 顺时针旋转文本
     * @name text-rotate
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */


    /**
     * 附加区域的大小
     * @name text-padding
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 是否翻转
     * @name text-keep-upright
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {boolean}
     * @default null
     */


    /**
     * 文本偏移
     * @name text-offset
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */


    /**
     * 文本变换
     * @name text-transform
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */


    /**
     * 重叠可见
     * @name text-allow-overlap
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {boolean}
     * @default null
     */


    /**
     * 符号可见
     * @name text-ignore-placement
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {boolean}
     * @default null
     */


    /**
     *如果是真的，文本将显示相应的图标时，图标没有与其他符号和文字不碰撞
     *@name text-optional
     *@memberof GeoGlobe.Layer.SymbolLayer.prototype
     *@type {boolean}
     *@default null 
     */


    /**
     * 图层颜色。
     * @name icon-color
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {color}
     * @default null
     *
     */


    /**

     * 图标的光环的颜色。
     * @name icon-halo-color
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {color}
     * @default null
     */

    /**
     * 透明度
     * @name icon-opacity
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null

     */


    /**
     * 图标轮廓的距离
     * @name icon-halo-width
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */


    /**
     * 图标光晕模糊度。
     * @name icon-halo-blur
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */

    /**

     * 几何偏移。
     * @name icon-translate
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {array}
     * @default null
     */

    /**
     * 几何偏移固定。
     * @name icon-translate-anchor
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */


    /**
     * 文字颜色
     * @name text-color
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {color}
     * @default null
     */


    /**
     * 文字的光环的颜色
     * @name text-halo-color
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {color}
     * @default null
     */


    /**
     * 透明度
     * @name text-opacity
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 文字轮廓的距离
     * @name text-halo-width
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */


    /**
     * 文字光晕模糊度。
     * @name text-halo-blur
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {number}
     * @default null
     */


    /**
     * 几何偏移
     * @name text-translate 
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {array}
     * @default null
     */


    /**
     * 几何偏移固定
     * @name text-translate-anchor
     * @memberof GeoGlobe.Layer.SymbolLayer.prototype
     * @type {enum}
     * @default null
     */
GeoGlobe.Layer.SymbolLayer = GeoGlobe.Class(GeoGlobe.Layer,{




    /**

     * GeoGlobe.Layer构造函数。
     *   @memberof GeoGlobe.Layer.SymbolLayer.prototype

     * @param options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.SymbolLayer"
});


/**
 * @class GeoGlobe.Layer.FillExtrusionLayer
 * @classdesc 填充图层类。继承GeoGlobe.FillExtrusionLayer，具有该类的所有属性与方法
 */

    /**
     * 高度。
     * @name fill-extrusion-height
     * @memberof GeoGlobe.Layer.FillExtrusionLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 用于绘制图像背景的图像中的图像的名称
     *@name fill-extrusion-pattern
     *@memberof GeoGlobe.Layer.FillExtrusionLayer.prototype
     *@type {string}
     *@default null
     */

    /**
     * 图层颜色
     * @name fill-extrusion-color
     * @memberof GeoGlobe.Layer.FillExtrusionLayer.prototype
     * @type {color}
     * @default null
     */

    /**
     * 图层的基底
     * @name fill-extrusion-base
     * @memberof GeoGlobe.Layer.FillExtrusionLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 图层的透明度
     * @name fill-extrusion-opacity
     * @memberof GeoGlobe.Layer.FillExtrusionLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 几何偏移
     * @name fill-extrusion-translate
     * @memberof GeoGlobe.Layer.FillExtrusionLayer.prototype
     * @type {array}
     * @default null
     */

    /**
     * 几何偏移固定
     * @name fill-extrusion-translate-anchor
     * @memberof GeoGlobe.Layer.FillExtrusionLayer.prototype
     * @type {enum}
     * @default null
     */
GeoGlobe.Layer.FillExtrusionLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * GeoGlobe.Layer构造函数。
     * @memberof GeoGlobe.Layer.FillExtrusionLayer.prototype
     * @param options - {Object}  图层相关选项设置
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.FillExtrusionLayer"
});


/**
 * @class GeoGlobe.Layer.LineLayer
 * @classdesc 线图层。
 */

/**
     * 图层颜色
     * @name line-color
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {color}
     * @default null
     */


    /**
     * 用于绘制图像背景的图像中的图像的名称
     * @name line-pattern
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {string}
     * @default null
     */


    /**
     * 透明度。
     * @name line-opacity
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 几何偏移。
     * @name line-translate
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {array}
     * @default null
     */


    /**
     *几何偏移固定
     *@name line-translate-anchor
     *@memberof  GeoGlobe.Layer.LineLayer.prototype
     *@type {enum}
     *@default null
     */

    /**
     * 线尾的显示
     * @name line-cap
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {enum}
     * @default null
     */


    /**
     * 连接时线的显示
     * @name line-join
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {enum}
     * @default null
     */

    /**
     * 用于自动转换人字加入锥连接的尖角
     * @name line-miter-limit
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 用于自动转换轮加入人字加入浅角
     * @name line-round-limit
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     *线宽
     *@name line-width
     *@memberof  GeoGlobe.Layer.LineLayer.prototype
     *@type {number}
     *@default null
     */

    /**
     * 绘制线条的实际路径以外的线框
     * @name line-gap-width
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     *  线偏移
     * @name line-offset
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {number}
     * @default null

     */

    /**

     * 线的清晰度。
     * @name line-blur
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {number}
     * @default null
     */

    /**
     * 虚线的间隔
     * @name line-dasharray
     * @memberof  GeoGlobe.Layer.LineLayer.prototype
     * @type {array}
     * @default null
     */

GeoGlobe.Layer.LineLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    

    /**

     * GeoGlobe.Layer构造函数。
     * @memberof  GeoGlobe.Layer.LineLayer.prototype

     * @param options - {Object} 图层相关选项设置。
     */

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.LineLayer"
});


/**
 * @class GeoGlobe.Layer.BackgroundLayer
 * @classdesc 背景图层类。
 *
 * @param options - {Object} 源相关选项设置。
 */
GeoGlobe.Layer.BackgroundLayer = GeoGlobe.Class(GeoGlobe.Layer,{

    /**
     * 图层颜色
     * @memberof GeoGlobe.Layer.BackgroundLayer.prototype
     * @var {string} background-color
     */
    "background-color": null,

    /**
     * 用于绘制图像背景的图像中的图像的名称
     * @memberof GeoGlobe.Layer.BackgroundLayer.prototype
     * @var {string} background-pattern
     */
    "background-pattern": null,

    /**
     * 透明度
     * @memberof GeoGlobe.Layer.BackgroundLayer.prototype
     * @var {string} background-opacity
     */
    "background-opacity": null,

    initialize: function(options){
        var layer = options;
        return layer;
    },
    CLASS_NAME: "GeoGlobe.Layer.BackgroundLayer"
});

﻿/**
 * @class GeoGlobe.Layer.ThematicTileLayer
 * @classdesc 基于专题图服务的专题图图层。
 *

    * @param {String} id - 图层名称.
    * @param {String} url  - 专题图服务地址。
    * @param {String} layerID - 图层ID。
    * @param {object} params - 专题图请求参数
    * @param {Boolean} hasLegend - 是否显示图例，放params中。
    * @param {Boolean} hasEdge - 是否绘制专题图符号的边线，放params中。
    * @param {Boolean}  hasLabel -是否绘制专题图符号的标注，放params中。
    * @param  {String} chartID - 专题符号标识。
    *
    * @example
    * (code)
    * 	//添加专题图图层
    *		var thmatic = new GeoGlobe.Layer.ThematicTileLayer({
    *	        id:"thematic"
    *			layerID: Cfg.map2DThematicLayerID_JS,
    *			params:{
    *		      "hasLegend": true,
    *            "legendType": 0,
    *            "hasEdge": true,
    *            "hasLabel": false,
    *            "hasBaseMap": true,
    *            "hasBaseMapLegend": true,
    *            "baseMapExampleColumnNums": 2
    *		}
    *			chartID:Cfg.map2DThematicchartID_JS,
    *		});
    * (end)
    */
GeoGlobe.Layer.ThematicTileLayer = GeoGlobe.Class4OL(GeoGlobe.Layer, {

    /**
     * 图层添加的map.
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {Object}
     * @default null
     */
    map: null,

    /**
     * 服务版本.
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {String}
     * @default 1.0.0
     */
    version:"1.0.0",

    /**
     * 专题图图层专属id..
     *@memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     *@type {String}
     *@default null
     */
    id:null,

    /**
     * 图层ID.
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {String}
     * @default null
     */
    layerID: null,

    /**
     *专题符号标识.
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {String}
     * @default null
     */
    chartID: null,

    /**
     * 图层的最大范围.
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {Object}
     * @default null
     */
    maxExtent: null,

    /**
     * 图片样式..
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {String}
     * @default png
     *
     */
    format: "png",

    /**
     * 色卡标识..
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {String}
     * @default null
     */
    colorSchemeID: null,

    /**
     * 是否显示图例，默认值为false..
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {Boolean}
     * @default false
     */
    hasLegend: false,

    legendType: 0,

    /**
     *图例显示方位，默认为右下角。左上角：tl、左下角：bl、右上角：tr、右下角：br.
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {String}
     * @default br
     * 
     */
    legendPosition:"br",

    /**
     *是否绘制专题图符号的边线，默认值为false..
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {Boolean}
     * @default false
     */
    hasEdge: false,

    /**
     * 是否绘制专题图符号的标注，默认值为false..
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @type {Boolean}
     * @default false
     *   
     */
    hasLabel: false,

    hasBaseMap: false,

    hasBaseMapLegend: false,

    baseMapExampleColumnNums: 2,


    initialize: function(map,options) {
        var box = options.box;
        var maxx = box._ne.lng;
        var maxy = box._ne.lat;
        var minx = box._sw.lng;
        var miny = box._sw.lat;
        var val = options.params;
        this.map = map;
        this.options = options;
        GeoGlobe.Function.bind(this.seturl, this);
        var setQueryConfig = this.seturl(val);
        var url =this.options.url +"/map"+ "/"+this.options.layerID+"/"+this.options.chartID+"/"+ minx + "/" + miny + "/" + maxx + "/" + maxy +"/"+this.options.width+"/"+this.options.height+".png?"+setQueryConfig;
        this.layer = {
            "id": this.options.id,
			"minzoom": options.minzoom ? this.options.minzoom : 0,
            "maxzoom": options.maxzoom ? this.options.maxzoom : 20,
            "source": {
                "type": "image",
                "url": url,
                "coordinates": [
                    [minx,maxy],
                    [maxx,maxy],
                    [maxx,miny],
                    [minx,miny]
                ]
            },
            "type": "raster"
        };
        this.zoome = $.proxy(this.zoomend,this);
        this.drage = $.proxy(this.dragend,this);
        this.map.on('zoomend',this.zoome);

        this.map.on('dragend',this.drage);
        GeoGlobe.Function.bind(this.remove, this);
        return this;
    },
    zoomend:function(){

        if(this.map.style._layers[this.options.id] && this.map.style._layers[this.options.id].layout["visibility"] != "none"){
            var metadata = this.map.style._layers[this.options.id].metadata;
            var paint = this.map.style._layers[this.options.id].paint;
            var layout = this.map.style._layers[this.options.id].layout;
            this.map.removeLayer(this.options.id);
            this.map.removeSource(this.options.id);
            box = this.map.getBounds();
            var val = this.options.params;
            maxx = box._ne.lng;
            maxy = box._ne.lat;
            minx = box._sw.lng;
            miny = box._sw.lat;
            var setQueryConfig = this.seturl(val);
			  this.options.width = this.map.getCanvas().width;
            this.options.height = this.map.getCanvas().height;
            url =this.options.url +"/map"+ "/"+this.options.layerID+"/"+this.options.chartID+"/"+ minx + "/" + miny + "/" + maxx + "/" + maxy +"/"+this.options.width+"/"+this.options.height+".png?"+setQueryConfig;
            layer = {
                "id": this.options.id,
                "name": this.options.name,
                "source": {
                    "type": "image",
                    "url": url,
                    "coordinates": [
                        [minx, maxy],
                        [maxx, maxy],
                        [maxx, miny],
                        [minx, miny]
                    ]
                },
                "type": "raster"
            };
            layer.paint = paint;
            layer.layout = layout;
            layer.metadata = metadata;
            this.map.addLayer(layer);
        }
    },
    dragend:function(){
        if(this.map.style._layers[this.options.id] && this.map.style._layers[this.options.id].layout["visibility"] != "none"){
            var metadata = this.map.style._layers[this.options.id].metadata;
            var paint = this.map.style._layers[this.options.id].paint;
            var layout = this.map.style._layers[this.options.id].layout;
            this.map.removeLayer(this.options.id);
            this.map.removeSource(this.options.id);
            box = this.map.getBounds();
            var val = this.options.params;
            maxx = box._ne.lng;
            maxy = box._ne.lat;
            minx = box._sw.lng;
            miny = box._sw.lat;
            var setQueryConfig = this.seturl(val);
			  this.options.width = this.map.getCanvas().width;
            this.options.height = this.map.getCanvas().height;
            url =this.options.url +"/map"+ "/"+this.options.layerID+"/"+this.options.chartID+"/"+ minx + "/" + miny + "/" + maxx + "/" + maxy +"/"+this.options.width+"/"+this.options.height+".png?"+setQueryConfig;
            layer = {
                "id": this.options.id,
                "name": this.options.name,
                "source": {
                    "type": "image",
                    "url": url,
                    "coordinates": [
                        [minx,maxy],
                        [maxx,maxy],
                        [maxx,miny],
                        [minx,miny]
                    ]
                },
                "type": "raster"
            };
            layer.paint = paint;
            layer.layout = layout;
            layer.metadata = metadata;
            this.map.addLayer(layer);
        }

    },


    seturl: function(val){
    var _str = "";
    for(var o in val){
        if(val[o] != -1){
            _str += o + "=" + val[o] + "&";
        }
    }
    var _str = _str.substring(0, _str.length-1);
    return _str;
},

    /**

     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype

     * @param {Function} successFn -  请求成功的回调函数。
     * @param {Function} failFn -请求失败的回调函数。
     */
    getCapabilities: function(url,successFn, failFn){
        var params = {
            // REQUEST: "GetCapabilities",
            // SERVICE: "TMS",
            f: "json"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("专题图服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        var datas;
        $.ajax({
            url: url,
            dataType:"json",
            cache:false,
            async:false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },

    /**

     * 移除图层。
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @private
     */
    remove: function(id) {
  
        this.map.off('zoomend',this.zoome);

        this.map.off('dragend',this.drage);
        this.map.removeLayer(id);
        this.map.removeSource(id);

    },

    /**

     * 显示图例。
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * TODO:属性中需要增加图例的显示方位，显示大小。
     * @private
     */
    showLegend: function() {
        var path = this.getLegend({
            layerID:this.layerID,
            chartID:this.chartID,
            colorSchemeID:this.colorSchemeID,
            drawLegend:"ThematicMap",
            legendType:this.legendType
        });
        //var lnglat = []
        //(id, px, sz, imgURL, position, border,opacity, delayDisplay)
        if(!this.imageLegend) {
            var  marker = new GeoGlobe.Marker(path)
                .setLngLat([lnglat.lng,lnglat.lat])
                .addTo(this.map);
        }
    },

    /**

     * 得到图例。
     *  @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * options {Object} 可选项。
     * @private
     */
    getLegend: function(options) {
        var location = this.url.indexOf("/",this.url.length - 1);
        if(location != -1) {
            this.url = this.url.substr(0,this.url.length - 1);
        }
        var path =  "${url}/legend/${layerID}/${chartID}.${format}?drawLegend=${drawLegend}&legendType=${legendType}";
        path = GeoGlobe.String.format(path, {
            'url': this.url,
            'layerID': options.layerID,
            'chartID': options.chartID,
            'format': options.format || "png",
            'drawLegend':options.drawLegend,
            'legendType':options.legendType
        });
        if(typeof options.colorSchemeID === "string") {
            path += ("&ColorSchemeID=" + options.colorSchemeID);
        }
        return path;
    },

    /**

     * 设置图例位置
     *  @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * TODO:属性中需要增加图例的显示方位，显示大小。
     * imageLegend  {DOM}
     * @private
     */
    setLegendLocation: function(imageLegend) {
        var size = this.map.getSize();
        switch(this.legendPosition) {
            case "br":
                var x = size.w - this.legendSize.w;
                var y = size.h - this.legendSize.h;
                imageLegend.style.left = x+"px";
                imageLegend.style.top = y+"px";
                break;
            case "bl":
                var y = size.h - this.legendSize.h;
                imageLegend.style.left = 0+"px";
                imageLegend.style.top = y+"px";
                break;
            case "tl":
                imageLegend.style.left = 0+"px";
                imageLegend.style.top = 0+"px";
                break;
            case "tr":
                var x = size.w - this.legendSize.w;
                imageLegend.style.left = x+"px";
                imageLegend.style.top = 0+"px";
                break;
        }
    },

    /**

     * 显示底图图例。
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * TODO:属性中需要增加底图图例的显示方位，显示大小。
     * @private
     */
    showBaseMapLegend: function() {
        var path = this.getBaseMapLegend({
            layerID:this.layerID,
            chartID:this.chartID,
            drawLegend:"BaseMap",
            baseMapExampleColumnNums: this.baseMapExampleColumnNums
        });
        //(id, px, sz, imgURL, position, border,opacity, delayDisplay)
        if(!this.imageBaseMapLegend) {
            var  marker = new GeoGlobe.Marker(path)
                .setLngLat([lnglat.lng,lnglat.lat])
                .addTo(this.map);
        }
    },

    /**

     * 得到底图图例。
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * options {Object} 可选项。
     * @private
     */
    getBaseMapLegend: function(options) {
        var location = this.url.indexOf("/",this.url.length - 1);
        if(location != -1) {
            this.url = this.url.substr(0,this.url.length - 1);
        }
        var path =  "${url}/legend/${layerID}/${chartID}.${format}?drawLegend=${drawLegend}&baseMapExampleColumnNums=${baseMapExampleColumnNums}";
        path = GeoGlobe.String.format(path, {
            'url': this.url,
            'layerID': options.layerID,
            'chartID': options.chartID,
            'format': options.format || "png",
            'drawLegend':options.drawLegend,
            'baseMapExampleColumnNums': options.baseMapExampleColumnNums
        });
        return path;
    },

    /**

     * 设置底图图例位置
     *  @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * TODO:属性中需要增加底图图例的显示方位，显示大小。
     * imageBaseMapLegend  {DOM}
     * @private
     */
    setBaseMapLegendLocation: function(imageBaseMapLegend) {
        var size = this.map.getSize();
        switch(this.baseMapLegendPosition) {
            case "br":
                var x = size.w - this.baseMapLegendSize.w;
                var y = size.h - this.baseMapLegendSize.h;
                imageBaseMapLegend.style.left = x+"px";
                imageBaseMapLegend.style.top = y+"px";
                break;
            case "bl":
                var y = size.h - this.baseMapLegendSize.h;
                imageBaseMapLegend.style.left = 0+"px";
                imageBaseMapLegend.style.top = y+"px";
                break;
            case "tl":
                imageBaseMapLegend.style.left = 50+"px";
                imageBaseMapLegend.style.top = 0+"px";
                break;
            case "tr":
                var x = size.w - this.baseMapLegendSize.w;
                imageBaseMapLegend.style.left = x+"px";
                imageBaseMapLegend.style.top = 0+"px";
                break;
        }
    },

    /**

     * 更新热区。
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * obj  {Object}
     * @private
     */
    updateHotArea: function(obj) {
        if(obj.zoomChanged) {
            this.vectorLayer.removeAllFeatures();
        }else {
            this.vectorLayer.redraw();
        }


    },

    /**

     * Create a clone of this layer
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @returns
     * {GeoGlobe.Layer.ThematicTileLayer} An exact clone of this layer
     * @private
     */
    clone: function (obj) {

        if (obj == null) {
            obj = new GeoGlobe.Layer.ThematicTileLayer(this.id,
                this.url,
                this.params,
                this.getOptions());
        }

        //get all additions from superclasses

        // copy/set any non-init, non-simple values here

        return obj;
    },

    /**

     * Return a GetMap query string for this layer
     * @memberof GeoGlobe.Layer.ThematicTileLayer.prototype
     * @param {GeoGlobe.Bounds} bounds -  A bounds representing the bbox for the
     *                                request.
     *
     * @returns
     * {String} A string with the layer's url and parameters and also the
     *          passed-in bounds and appropriate tile size specified as
     *          parameters.
     * @private
     */
    getURL: function (bounds) {
        bounds = this.adjustBounds(bounds);
        var imageSize = this.getImageSize();
//		this.getTileFeature(bounds,imageSize);
        var newParams = {};
        //http://192.168.42.76:7021/ThematicMapService/tms/map/0/020101/
        //87.6061172485352/20.0317935943604/126.643341064453/45.7414932250977/1024/1024.png?
        //ColorSchemeID=3&hasLegend=true&hasEdge=true&hasLabel=true
        //var requestString = this.getFullRequestString(newParams);
        var url = "${url}/map/${layerID}/${chartID}/${left}/${bottom}/${right}/${top}/${width}/${height}.${format}?"+
            "hasLegend=${hasLegend}&legendType=${legendType}&hasEdge=${hasEdge}&hasLabel=${hasLabel}&"+
            "hasBaseMap=${hasBaseMap}&hasBaseMapLegend=${hasBaseMapLegend}&baseMapExampleColumnNums=${baseMapExampleColumnNums}";
        url = GeoGlobe.String.format(url, {
            'url': this.url,
            'layerID': this.layerID,
            'chartID': this.chartID,
            'left': bounds.left,
            'bottom': bounds.bottom,
            'right':bounds.right,
            'top': bounds.top,
            'width': imageSize.w,
            'height': imageSize.h,
            'format': this.format,
            'hasLegend':this.hasLegend,
            'legendType':this.legendType,
            'hasEdge': this.hasEdge,
            'hasLabel': this.hasLabel,
            'hasBaseMap': this.hasBaseMap,
            'hasBaseMapLegend': this.hasBaseMapLegend,
            'baseMapExampleColumnNums': this.baseMapExampleColumnNums
        });
        if(typeof this.colorSchemeID === "string") {
            url += ("&ColorSchemeID=" + this.colorSchemeID);
        }
        //&ColorSchemaID=${ColorSchemaID}
        return url;
    },
    CLASS_NAME: "GeoGlobe.Layer.ThematicTileLayer"
});/**
 * @class GeoGlobe.CanvasLayer
 * @classdesc canvasLayer类
 *
 * @param options - {Object} 源相关选项设置。
 */
GeoGlobe.CanvasLayer = GeoGlobe.Class4OL({

    /**
     * 添加的地图容器
     * @memberof GeoGlobe.CanvasLayer.prototype
     * @type {string}
     */
    map: null,
	
    /**
     * canvas上下文对象.
     * @memberof GeoGlobe.CanvasLayer.prototype
     * @type {string}
     */
    context: null,

    initialize: function(options){
		this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
        this.options = options;
    },

    /**
     *  地图移动时执行的方法.
     * @memberof GeoGlobe.CanvasLayer.prototype
     */
	drawOnMove: null,

    /**
     * _drawLayer
     * @memberof GeoGlobe.CanvasLayer.prototype
     */
	_drawLayer: function(){
		this.clear();
		var args = this._prepareDrawParams();
        if (!args) {
            return;
        }
        this.draw.apply(this, args);
	},
	
    /**
     * prepareDrawParams
     *  @memberof GeoGlobe.CanvasLayer.prototype
     */
	_prepareDrawParams: function (context){
		var params = [];
		if(!this._drawContext){
	        this._drawContext = this.prepareToDraw.apply(this, [this.context].concat(params));
		}
		
		var args = [this.context];
        args.push.apply(args, this._drawContext);
		return args;
    },
	
    /**
     *
     * prepareToDraw
     *  @memberof GeoGlobe.CanvasLayer.prototype
     */
	prepareToDraw: function (context){
    },
	
    /**
     * draw
     *  @memberof GeoGlobe.CanvasLayer.prototype
     */
    draw: function (context){
    },
	
    /**
     *与地图对象关联.
     * @memberof GeoGlobe.CanvasLayer.prototype
     * @param {object} map - map对象.
     */
    addTo: function (map){
		this.map = map;
        var mapContainer = map.getCanvasContainer();
		//设置canvas的宽高
		this.canvas = document.createElement('canvas');
		this.canvas.id = this.id;
		this.canvas.style.width = map.getCanvas().style.width;
		this.canvas.style.height = map.getCanvas().style.height;
		this.canvas.style.position = "absolute";
		this.canvas.style.display = "none";
		this.canvas.width = map.getCanvas().width;
		this.canvas.height = map.getCanvas().height;
		mapContainer.appendChild(this.canvas);
		
		this.context = this.canvas.getContext("2d");
		
		//绑定事件
		this._bindEvent();
		
		var coordinates = this._boundsToCoordinates(map.getBounds());
		var source = {
			type: 'canvas',
			canvas: this.canvas.id,//'mycanvas',
			animate: true,
			/*coordinates: [
			    [110.177, 28.281],
			    [120.52, 28.281],
			    [120.52, 25.17],
			    [110.177, 25.17]
			],
			coordinates: [
			    [32, 57],
			    [150, 57],
			    [150, 0],
			    [32, 0]
			]*/
			coordinates: coordinates
		};
		var layer = {
			"id": this.id + "_layer",
            "source": this.id,
            "type": "raster",
            "paint": {
				"raster-opacity": 1
			}
		};
		map.addSource(this.id, source);
		map.addLayer(layer);
		
		this.source = map.getSource(this.id);
		this.layer = map.getLayer(this.id+ "_layer");
		mapContainer.removeChild(this.canvas);
		this._drawLayer();
    },
	

	_bindEvent: function(){
		
		var map = this.map;
		//this._zoomStart = GeoGlobe.Function.bind(function(e){}, this);
		//this._zoom = GeoGlobe.Function.bind(function(e){}, this);
		//this._zoomend = GeoGlobe.Function.bind(function(e){console.log("zoomend:" + e);}, this);
		this._move = GeoGlobe.Function.bind(function(e){
			//this.source.pause();
			if (typeof this.drawOnMove === "function") {
				this.drawOnMove(e);
			}
		}, this);
		//this._rotate = GeoGlobe.Function.bind(function(e){}, this);
		//this._movestart = GeoGlobe.Function.bind(function(e){}, this);
		this._moveend = GeoGlobe.Function.bind(function(e){
			//console.log("moveend:" + e);
			var coordinates = this._boundsToCoordinates(e.target.getBounds());
			this.source.setCoordinates(coordinates);
			//this.source.play();
			//this.source.prepare();
			this._drawLayer();
		}, this);
		
		//map.on('zoomstart', this._zoomStart);
        //map.on('zoom', this._zoom);
		//map.on("zoomend", this._zoomend);
        //map.on('rotate', this._rotate);
        //map.on('movestart', this._movestart);
        map.on('move', this._move);
        map.on('moveend', this._moveend);
		
	},
	
    /**
     * 暂停
     * @memberof GeoGlobe.CanvasLayer.prototype
     */
    pause: function(){
		this.source.pause();
    },
	
    /**
     * 播放
     * @memberof GeoGlobe.CanvasLayer.prototype
     */
    play: function(){
		this.source.play();
    },
	
    /**
     * 设置透明度
     * @memberof GeoGlobe.CanvasLayer.prototype
     */
    setOpacity: function(opacity){
		this.map.setPaintProperty(this.layer.id, 'raster-opacity', parseFloat(opacity));
    },

    /**
     * 清除
     * @memberof GeoGlobe.CanvasLayer.prototype
     */
    clear:function(){
		this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },

    /**
     * 移除并销毁。
     * @memberof GeoGlobe.CanvasLayer.prototype
     */
    remove: function(){
        this.clear();
		
		var map = this.map;
		//map.off('zoomstart', this._zoomStart);
        //map.off('zoom', this._zoom);
		//map.off("zoomend", this._zoomend);
        //map.off('rotate', this._rotate);
        //map.off('movestart', this._movestart);
        map.off('move', this._move);
        map.off('moveend', this._moveend);
		
		map.removeSource(this.source.id);
		map.removeLayer(this.layer.id);
		this.canvas = null;
		this.map = null;
    },
	
	_boundsToCoordinates: function(bounds){
		var barr = bounds.toArray();
		var minx = barr[0][0];
		var miny = barr[0][1];
		var maxx = barr[1][0];
		var maxy = barr[1][1];
		var coordinates = [
		    [minx, maxy],
		    [maxx, maxy],
		    [maxx, miny],
		    [minx, miny]
		];
		return coordinates;
	},
	
    CLASS_NAME: "GeoGlobe.CanvasLayer"
});﻿/**
 * @class GeoGlobe.TDTLayer
 * @classdesc GeoGlobe.TDTLayer天地图图层类。
 */
GeoGlobe.TDTLayer = GeoGlobe.Class4OL({

    /**

     * 创建天地图图层对象。
     * @memberof GeoGlobe.TDTLayer.prototype
     * @param {String}name -  天地图图层名称。值有四种选择："vec_w","cva_w","vec_c"或"cva_c"。
     * 					分别表示墨卡托底图，墨卡托注记层，经纬度底图，经纬度注记层。
     *
     * 示例:
     * (code)
     *  var layer = new GeoGlobe.TDTLayer("vec_w");
     *  map.addLayer(layer);
     * (end)
     */
    initialize: function(name){
		return this._getLayer(name);
    },
	
	_getLayer: function(name){
		var id = "tdt_" + name + "_" + GeoGlobe.Util.randomStr(8);
		var url = GeoGlobe.ProxyHost + this._getUrlTemplateByName(name);
		return {
            "id": id,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [url],
                "tileSize": 256
            }
        };
	},
	
	/**

	 * 获取天地图url模板
	 *@memberof GeoGlobe.TDTLayer.prototype
     * @param {String}name - 天地图图层名称。
     * 
     * @returns {String} 天地图url模板
     * @private
	 */
	_getUrlTemplateByName: function(name){
		//"http://t0.tianditu.com/vec_w/wmts"
		var urlTemplate = "http://t0.tianditu.com/"+name+"/wmts?" + this._getParameterString(this.tdtParams[name]);
		return urlTemplate;
	},
	
	tdtParams: {
		"vec_w": {
			SERVICE: "WMTS",
			REQUEST: "GetTile",
	        LAYER: "vec",
	        TILEMATRIXSET: "w",
	        FORMAT: "tiles",
	        VERSION: "1.0.0",
	        STYLE: "default",
	        TILEMATRIX: '{z}',
	        TILEROW: '{y}',
	        TILECOL: '{x}'
	    },
		"cva_w": {
			SERVICE: "WMTS",
			REQUEST: "GetTile",
	        LAYER: "cva",
	        TILEMATRIXSET: "w",
	        FORMAT: "tiles",
	        VERSION: "1.0.0",
	        STYLE: "default",
	        TILEMATRIX: '{z}',
	        TILEROW: '{y}',
	        TILECOL: '{x}'
	    },
		"vec_c": {
			SERVICE: "WMTS",
			REQUEST: "GetTile",
	        LAYER: "vec",
	        TILEMATRIXSET: "c",
	        FORMAT: "tiles",
	        VERSION: "1.0.0",
	        STYLE: "default",
	        TILEMATRIX: '{z}',
	        TILEROW: '{y}',
	        TILECOL: '{x}'
	    },
		"cva_c": {
			SERVICE: "WMTS",
			REQUEST: "GetTile",
	        LAYER: "cva",
	        TILEMATRIXSET: "c",
	        FORMAT: "tiles",
	        VERSION: "1.0.0",
	        STYLE: "default",
	        TILEMATRIX: '{z}',
	        TILEROW: '{y}',
	        TILECOL: '{x}'
	    },
        "img_w": {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "img",
            TILEMATRIXSET: "w",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: '{z}',
            TILEROW: '{y}',
            TILECOL: '{x}'
        },
        "cia_w": {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "cia",
            TILEMATRIXSET: "w",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: '{z}',
            TILEROW: '{y}',
            TILECOL: '{x}'
        },
        "img_c": {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "img",
            TILEMATRIXSET: "c",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: '{z}',
            TILEROW: '{y}',
            TILECOL: '{x}'
        },
        "cia_c": {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "cia",
            TILEMATRIXSET: "c",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: '{z}',
            TILEROW: '{y}',
            TILECOL: '{x}'
        }
	},
	
	/**

	 * 获取以&分割的参数字符串
	 *@memberof GeoGlobe.TDTLayer.prototype
     * @param {object} name - 参数选项
     * 
     * @returns {string} 参数字符串
     * @private
	 */
	_getParameterString: function(params) {
		var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key.toUpperCase() + "=" + value);
            }
        }
	    return paramsArray.join("&");
	},

    CLASS_NAME: "GeoGlobe.TDTLayer"
});/**
 * @class GeoGlobe.Layer.HotArea
 *@classdesc  热区图层类。
 *@private
 */
GeoGlobe.Layer.HotArea = GeoGlobe.Class4OL({
	
	url: null,
	
    layer: null,
	
    format: null,
	
    matrixSet: null,
	
    style: null,
	
	version: "1.0.0",
	
	 /**
     * 图层名称
      * @memberof GeoGlobe.Layer.HotArea.prototype
      * @type {string}

     */
    name: null,
	
	layerid: null,
	
	hotareaLayers: null,
	
	hotareaHighlightedLayers: null,
	
	tileUrls: null,

    /**
     *  构造函数
     *  @memberof GeoGlobe.Layer.HotArea.prototype

     * @param options - {Object} GeoGlobe.Layer.HotArea相关选项设置。
     */
    initialize: function(options){
		//GeoGlobe.Util.extend(this, options);
		this.name = options.name ? options.name: null;
		this.url = options.url;
		this.layer = options.layer;
		this.format = options.format;
		this.matrixSet = options.matrixSet;
		this.style = options.style;
		
		this.layerid = "geoglobe_layer_hotarea_" + GeoGlobe.Util.randomStr(8);
		this.layerOption = {
            "id": this.layerid,
            "type": "raster",
            "source": {
                "type": "raster",
				"rasterType": "hotarea",
				"tiles": [GeoGlobe.appendToProxy(options.url + "?SERVICE=WMTS&REQUEST=GetTile&LAYER="+this.layer+"&TILEMATRIXSET="+this.matrixSet+"&FORMAT="+this.format+"&VERSION="+this.version+"&STYLE="+this.style+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}")],
                //"tiles": [GeoGlobe.appendToProxy(options.url + "?SERVICE=WMTS&REQUEST=GetTile&LAYER=cvgb_hotarea&TILEMATRIXSET=Matrix_cvgb_hotarea_0&FORMAT=text/json&VERSION=1.0.0&STYLE=cvgb_hotarea&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}")],
                "tileSize": 256
            },
            "paint": {
                "raster-opacity": 1
            },
			"metadata": {
				"type": "hotarea"
			}
        };
		
		this.hotareaLayers = [];
		this.hotareaHighlightedLayers = [];
		this.tileUrls = [];
		
		this.onclick = (typeof options.onclick === 'function') ? options.onclick: this.onclick;
        //return this._getHotAreaLayer(params);
    },
	
	addTo: function(map){
		this.map = map;
		map.addLayer(this.layerOption);
		this._bindEvent();
	},
	
	_bindEvent: function(){
		var map = this.map;
		GeoGlobe.Layer.HotArea["callback_tileJSON_"+this.layerid] = GeoGlobe.Function.bind(this.callback_tile, this);
		
		//高亮方法
		var highlightFn = GeoGlobe.Function.bind(function(e){
	        // set bbox as 2px reactangle area around clicked point
	        var bbox = [[e.point.x - 2, e.point.y - 2], [e.point.x + 2, e.point.y + 2]];
			var layers = [];
			for(var i =0; i < this.hotareaLayers.length; i++){
				layers.push(this.hotareaLayers[i].id);
			}
	        var features = map.queryRenderedFeatures(bbox, {layers: layers});
			
			//每次只选取一个
			if(features.length > 0){
				features = [features[0]];
				this.map.getCanvas().style.cursor = 'pointer';
			}else{
				this.map.getCanvas().style.cursor = '';
			}
	        var filter = features.reduce(function(memo, feature) {
	            memo.push(feature.properties.displayname);
	            return memo;
	        }, ['==', 'displayname']);
			filter = (filter.length === 2) ? ['==', 'displayname', ""] : filter;
			
			for(var i =0; i < this.hotareaHighlightedLayers.length; i++){
		        map.setFilter(this.hotareaHighlightedLayers[i].id, filter);
			}
			if(e.type === "click"){
				e.features = features;
				this.onclick(e);
			}
	    },this);
		map.on('click', highlightFn);
		map.on('mousemove', highlightFn);
		
		//缩放时，清空热区数据
		var _zoomstart = GeoGlobe.Function.bind(function(e){
			for (var i = 0; i < this.hotareaHighlightedLayers.length; i++) {
				map.removeLayer(this.hotareaHighlightedLayers[i].id);
			};
			this.hotareaHighlightedLayers = [];
			for (var i = 0; i < this.hotareaLayers.length; i++) {
				map.removeLayer(this.hotareaLayers[i].id);
        		map.removeSource(this.hotareaLayers[i].id);
			};
			this.hotareaLayers = [];
			this.tileUrls = [];
		},this);
		map.on('zoomstart', _zoomstart);
	},
	
    /**

     * 热区tile数据的回调方法。
	 * @memberof GeoGlobe.Layer.HotArea.prototype
     * @param options - {Object}热区数据。
     */
	callback_tile: function(op){
		var tileUrl = op.tileUrl;
		
		var isExist = false;
        for (var i = 0; i < this.tileUrls.length; i++) {
            if (this.tileUrls[i] === tileUrl) {
                isExist = true;
            }
        }
		
		if (!isExist) {
			this.tileUrls.push(tileUrl);
			var data = op.data;
			var features = data.features;
			for (var i = 0; i < features.length; i++) {
				var picsymid = features[i].properties.picsymid;
				features[i].properties.overPicUrl = this.getPicURL(picsymid, true);
				features[i].properties.outPicUrl = this.getPicURL(picsymid, false);
			}
			
			var map = op.map;
			var layerid = op.layerid;
			//map.addSource("hotarea_source_id_", {
			//	 type: "geojson",
			//	 data: data
			//});
			
			var randomStr = GeoGlobe.Util.randomStr(8);
			//默认透明样式
			var hotareaLayer = {
				"id": "hotarea_id_" + randomStr,
				"type": "fill",
				"source": {
					"type": "geojson",
					"data": data
				},
				"paint": {
					'fill-color': '#088',
					'fill-opacity': 0
				}
			};
			map.addLayer(hotareaLayer);
			this.hotareaLayers.push(hotareaLayer);
			
			//高亮样式
			var hotareaHighlightedLayer = {
				"id": "hotarea_highlighted_id_" + randomStr,
				"type": "fill",
				"source": hotareaLayer.id,
				//"source-layer": "original",
				"paint": {
					"fill-outline-color": "#484896",
					"fill-color": "#6e599f",
					"fill-opacity": 0
				},
				"filter": ["==", "displayname", ""]
			};
			map.addLayer(hotareaHighlightedLayer);
			this.hotareaHighlightedLayers.push(hotareaHighlightedLayer);
		}
	},
	
	/**

     * @memberof GeoGlobe.Layer.HotArea.prototype

     * @param picid - {Number}
     * @param isanti - {Blooean}
     * 
     * @returns {String} A URL for the pic.

     */
    getPicURL: function(picid, isanti){
        // assemble all required parameters
        var params = {
            SERVICE: "WMTS",
            REQUEST: "GetIcon",
            VERSION: this.version,
            LAYER: this.layer,
            //STYLE: this.style,
            //TILEMATRIXSET: this.matrixSet,
            //TILEMATRIX: this.matrix.identifier,
            PICID: picid, //0
            ISANTI: isanti // 默认false
        };
        var url = this.url + "?" + this._getParameterString(params);
        return url;
    },
	
	/**
	 * 获取以&分割的参数字符串
     * @memberof GeoGlobe.Layer.HotArea.prototype
     * @param  {Object} 参数选项。
     * @returns {string} 参数字符串
	 */
	_getParameterString: function(params) {
		var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key.toUpperCase() + "=" + value);
            }
        }
	    return paramsArray.join("&");
	},
	
	/**

	 * 点击热区的回调函数
     * @memberof GeoGlobe.Layer.HotArea.prototype
     * @param - {Object} 事件对象。
	 */
	onclick: function(e){
	},
	
    CLASS_NAME: "GeoGlobe.Layer.HotArea"
});
/**
 * @class GeoGlobe.Source
 * @classdesc GeoGlobe.Source类。
 *
 * @param options - {Object} 源相关选项设置。
 * @deprecated
 */
GeoGlobe.Source = GeoGlobe.Class(mapboxgl.FreeCRSMap,{

    /**
     * 数据源id
     * @memberof GeoGlobe.Source.prototype
     * @type {string}
     * @default null
     */
    SourceId: null,

    initialize: function(){
        return this;
    },
    CLASS_NAME: "GeoGlobe.Source"
});

/**
 * @class GeoGlobe.Source.GeoJSONSource
 * @classdesc GeoJSON数据源

 * @param options - {Object} 源相关选项设置。
 * @deprecated
 */

    /**
     * 最小层级
     * @name minzoom
     * @memberof GeoGlobe.Source.GeoJSONSource.prototype
     * @type {number}
     * @default 0
     */

    /**
     * 最大层级
     * @name maxzoom
     * @memberof GeoGlobe.Source.GeoJSONSource.prototype
     * @type {number}
     * @default null
     */

    /**
     * GeoJSON文件或内联GeoJSON
     * @name data
     * @memberof GeoGlobe.Source.GeoJSONSource.prototype
     * @type {array}
     * @default null
     */


    /**
     * 每边的瓷砖缓冲区大小
     * @name buffer
     * @memberof GeoGlobe.Source.GeoJSONSource.prototype
     * @type {number}
     * @default null
     */


    /**
     * 容差
     * @name tolerance
     * @memberof GeoGlobe.Source.GeoJSONSource.prototype
     * @type {number}
     * @default null
     */


    /**
     * 聚合
     * @name cluster
     * @memberof GeoGlobe.Source.GeoJSONSource.prototype
     * @type {boolean}
     * @default null
     */


    /**
     * 聚合半径
     * @name clusterRadius
     * @memberof GeoGlobe.Source.GeoJSONSource.prototype
     * @type {number}
     * @default null
     */


    /**
     * 聚合最大级别
     * @name clusterMaxZoom
     * @memberof GeoGlobe.Source.GeoJSONSource.prototype
     * @type {number}
     * @default null
     */
GeoGlobe.Source.GeoJSONSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{


    initialize: function(id,options){
        var sour = {};
        sour.id = id;
        sour.source = options;
        return sour;
    },
    CLASS_NAME: "GeoGlobe.Source.GeoJSONSource"
});

/**
 * @class GeoGlobe.Source.RasterSource
 * @classdesc 栅格数据源
 *
 * @param options - {Object} 源相关选项设置。
 * @deprecated
 */

/**
 * 最小层级
 * @name minzoom
 * @memberof GeoGlobe.Source.RasterSource.prototype
 * @type {number}
 * @default null
 */

/**
 * 最大层级
 * @name maxzoom
 * @memberof GeoGlobe.Source.RasterSource.prototype
 * @type {number}
 * @default null
 */

/**
 * 瓦片数据源URL
 * @name tilesUrl
 * @memberof GeoGlobe.Source.RasterSource.prototype
 * @type {array}
 * @default null
 */


/**
 * 网络地图服务的url
 * @name url
 * @memberof GeoGlobe.Source.RasterSource.prototype
 * @type {string}
 * @default null
 */


/**
 * 瓦片大小
 * @name tileSize
 * @memberof GeoGlobe.Source.RasterSource.prototype
 * @type {number}
 * @default null
 */
GeoGlobe.Source.RasterSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{


    initialize: function(options){
        var source = {
            "id":options.id,
            "type": "raster",
            "tiles": options.url,
            "tileSize": 256
        };
        return source;
    },
    CLASS_NAME: "GeoGlobe.Source.RasterSource"
});

/**
 * @class GeoGlobe.Source.ImageSource
 * @classdesc 图片数据源
 * @param options - {Object} 源相关选项设置。
 * @deprecated
 */

/**
 * 图片指定的坐标
 * @name coordinates
 * @memberof GeoGlobe.Source.ImageSource.prototype
 * @type {array}
 * @default null
 */

/**
 * 图片的url
 * @name url
 * @memberof GeoGlobe.Source.ImageSource.prototype
 * @type {string}
 * @default null
 */
GeoGlobe.Source.ImageSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{

    initialize: function(id,source){
        //options.id = null;
        //var source = {
        //    "type": options.type,
        //    "url": options.url,
        //    "coordinates": options.coordinates
        //};
        var sour = {};
        sour.id = id;
        sour.source = source;
        return sour;
    },
    CLASS_NAME: "GeoGlobe.Source.ImageSource"
});

/**
 * @class GeoGlobe.Source.VectorSource
 * @classdesc 矢量数据源
 *
 * @param options - {Object} 源相关选项设置。
 * @deprecated
 */

    /**
     * 最小层级
     * @name minzoom
     * @memberof GeoGlobe.Source.VectorSource.prototype
     * @type {number}
     * @default null
     */

    /**
     * 最大层级
     * @name maxzoom
     * @memberof GeoGlobe.Source.VectorSource.prototype
     * @type {number}
     * @default null
     */


    /**
     * 瓦片数据源URL
     * @name tilesUrl
     * @memberof GeoGlobe.Source.VectorSource.prototype
     * @type {array}
     * @default null
     */


    /**
     * 网络地图服务的url
     * @name url
     * @memberof GeoGlobe.Source.VectorSource.prototype
     * @type {string}
     * @default null
     */

GeoGlobe.Source.VectorSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{


    initialize: function(options){
        var source ={
            "id": options.id,
            "type": options.type,
            "tiles": options.url
        };
        return source;
    },
    CLASS_NAME: "GeoGlobe.Source.VectorSource"
});

/**
 * @class GeoGlobe.Source.VideoSource
 * @classdesc 图片数据源
 *
 * @param options - {Object} 源相关选项设置。
 * @deprecated
 */

/**
 * 视频指定的坐标
 * @name coordinates
 * @memberof GeoGlobe.Source.VideoSource.prototype
 * @type {array}
 * @default null
 */

/**
 * 视频的url
 * @name url
 * @memberof GeoGlobe.Source.VideoSource.prototype
 * @type {string}
 * @default null
 */
GeoGlobe.Source.VideoSource = GeoGlobe.Class(mapboxgl.FreeCRSMap,{



    initialize: function(id,video){
        //options.id = null;
        //var source = {
        //    "type": options.type,
        //    "url": options.url,
        //    "coordinates": options.coordinates
        //};
        var vid = {};
        vid.id = id;
        vid.video = video;
        return vid;
    },
    CLASS_NAME: "GeoGlobe.Source.VideoSource"
});

/**
 * @class GeoGlobe.Marker
 * @classdesc 标记组件类,Marker类实例化一个标记组件，通常被添加到地图容器中。继承GeoGlobe.Marker类
 * @example
 * var marker = new mapboxgl.Marker()
 * .setLngLat([30.5, 50.5])
 * .addTo(map);
 */

/**
 * 指定标记的偏移位置
 * @name offset
 * @memberof GeoGlobe.Marker.prototype
 * @type {object}
 * @default null
 */

/**
 * 初始化函数
 * @method initialize
 * @memberof GeoGlobe.Marker.prototype
 * @param {HTMLElement=} element  - DOM元素用作标记（默认情况下创建一个div元素）。
 * @param {Object} options  - Marker相关选项设置。
 *
 */

/**
 * 添加标记
 * @method addTo
 * @memberof GeoGlobe.Marker.prototype
 * @param {GeoGlobe.Map} map  - 地图对象。
 */

/**
 * 移除标记。
 * @method remove
 * @memberof GeoGlobe.Marker.prototype
 * @example
 * var marker = new mapboxgl.Marker().addTo(map);
 * marker.remove();
 */

/**
 * 获取标记的坐标。
 * @method getLngLat
 * @memberof GeoGlobe.Marker.prototype
 * @returns {GeoGlobe.LngLat} LngLat  - 标记所在的位置坐标.
 */

/**
 * 设置标记的坐标。
 * @method setLngLat
 * @memberof GeoGlobe.Marker.prototype
 * @param {GeoGlobe.LngLat} LngLat  - 设置标记的位置坐标。
 */

/**
 * 设置弹框弹出的文本内容。
 * @method setPopup
 * @memberof GeoGlobe.Marker.prototype
 * @param {popup} popup  - 绑定标记弹框。
 */

/**
 * 获取绑定到标记的弹出框。
 * @method getPopup
 * @memberof GeoGlobe.Marker.prototype
 */

/**
 * 根据当前状态，判断打开或者关闭弹框。
 * @method togglePopup
 * @memberof GeoGlobe.Marker.prototype
 */
GeoGlobe.Marker = mapboxgl.Marker;
/**
 * @class GeoGlobe.Popup
 * @classdesc 弹出式组件类，Popup类实例化一个弹出窗口，通常被添加到地图容器中，继承GeoGlobe.Popup类。
 */


/**
 * 是否显示关闭按钮
 * @name closeButton
 * @memberof GeoGlobe.Popup.prototype
 * @type {Boolaen}
 * @default true
 */

/**
 * 点击地图时是否关闭弹出框
 * @name closeOnClick
 * @memberof GeoGlobe.Popup.prototype
 * @type {Boolaen}
 * @default true
 */

/**
 * 设置弹出位置
 * @name anchor
 * @memberof GeoGlobe.Popup.prototype
 * @type {String}
 * @default null
 */

/**
 * 指定弹框的偏移位置
 * @name offset
 * @memberof GeoGlobe.Popup.prototype
 * @type {object}
 * @default null
 */


/**
 * 是否显示箭头。默认为true
 * @name showArrow
 * @memberof GeoGlobe.Popup.prototype
 * @type {boolean}
 * @default true
 */


/**
 * GeoGlobe.Popup构造函数。
 * @method initialize
 * @memberof GeoGlobe.Popup.prototype
 * @param {Object} options   - Popup相关选项设置。
 */

/**
 * 添加弹出框。
 * @method addTo
 * @memberof GeoGlobe.Popup.prototype
 * @param {GeoGlobe.Map} map   - 地图对象。
 */

/**
 * 弹框是否打开。
 * @method isOpen
 * @memberof GeoGlobe.Popup.prototype
 * @returns {boolean} true   - true弹框打开，false弹框关闭.
 */

/**
 * 移除弹出框。
 * @method remove
 * @memberof GeoGlobe.Popup.prototype
 * @example
 * var popup = new GeoGlobe.Popup().addTo(map);
 * popup.remove();
 */

/**
 * 获取弹框的坐标。
 * @method getLngLat
 * @memberof GeoGlobe.Popup.prototype
 * @returns {GeoGlobe.LngLat} LngLat  - 返回弹框所在的位置坐标.
 */

/**
 * 设置弹框的坐标。
 * @method setLngLat
 * @memberof GeoGlobe.Popup.prototype
 * @param {GeoGlobe.LngLat} LngLat  - 设置弹框的位置坐标。
 */

/**
 * 设置弹框弹出的文本内容。
 * @method setText
 * @memberof GeoGlobe.Popup.prototype
 * @param {string} text  - 弹框弹出的文本内容。
 * @example
 * var popup = new mapboxgl.Popup()
 * .setLngLat(e.lngLat)
 * .setText('Hello, world!')
 * .addTo(map);
 */

/**
 * 设置控件。
 * @method setHTML
 * @memberof GeoGlobe.Popup.prototype
 * @param {string} html  - 弹框弹出的html内容。
 *
 * @example
 * var popup = new mapboxgl.Popup()
 *.setLngLat(e.lngLat)
    *.setHTML("<h1>Hello World!</h1>")
    *.addTo(map);
    */

/**
 * 设置控件。
 * @method setDOMContent
 * @memberof GeoGlobe.Popup.prototype
 * @param {Node} htmlNode  - 弹框弹出的html内容。
 *
 * @example
 * //创建弹出框元素内容
 * var div = window.document.createElement('div');
 * div.innerHTML = 'Hello, world!';
 *  var popup = new mapboxgl.Popup()
 * .setLngLat(e.lngLat)
 * .setDOMContent(div)
 * .addTo(map);
 */

GeoGlobe.Popup = mapboxgl.Popup;/**
 * @class GeoGlobe.Control
 * @classdesc 控件类，通过监听并响应用户操作来改变地图状态、操作图层数据或完成某一动作。

 */



/**
 * 控件位置。
 * @name position
 * @memberof GeoGlobe.Control.prototype
 * @type {String}
 * @default null
*/


/**
* GeoGlobe.Control构造函数。
* @method initialize
* @memberof GeoGlobe.Control.prototype
* @param {Object}  options - WMS相关选项设置。
*/

/**
* 添加控件。
* @method addTo
* @memberof GeoGlobe.Control.prototype
* @param {GeoGlobe.Map} map -  地图对象。
*/

/**
* 移除控件。
*@method remove
* @memberof GeoGlobe.Control.prototype
*/

GeoGlobe.Control = (mapboxgl.Control || {});/**
 * @class GeoGlobe.Control.Navigation
 * @classdesc 导航控件类，为二维地图提供导航件组合控件功能。
 */



/**
 * 控件位置。
 * @name position
 * @memberof GeoGlobe.Control.Navigation.prototype
 * @type {String}
 * @default null
*/


/**
* @method initialize
* GeoGlobe.Control构造函数。
* @memberof GeoGlobe.Control.Navigation.prototype

* @param {Object}options -  Navigation相关选项设置。
*/


GeoGlobe.Control.Navigation = mapboxgl.NavigationControl;
/**
 * @class GeoGlobe.Control.Attribution
 * @classdesc 属性控件类，为二维地图提供当前图层属性信息功能。
 *
 */



/**
 *  控件位置。
 * @name postion
 * @memberof GeoGlobe.Control.Attribution.prototype
 * @type {String}
 * @default null
 * 
 */


/**
* GeoGlobe.Control构造函数。
* @method initialize
* @memberof GeoGlobe.Control.Attribution.prototype
* @param {Object}options -  Attribution相关选项设置。
*/
GeoGlobe.Control.Attribution = mapboxgl.AttributionControl;

/**
 *@class GeoGlobe.Control.Scale
 *@classdesc 比例尺控件类，为二维地图提供比例尺功能，实例是显示当前地图的比例尺。
 */
GeoGlobe.Control.Scale = GeoGlobe.Class4OL({

    /**

     * GeoGlobe.Control构造函数。
     * @memberof GeoGlobe.Control.Scale.prototype

     * @param {Object} options -  Scale相关选项设置。属性可为:
	 * 	@param	{String} position -  (可选) 默认为"bottom-left"，表示左下。
	 * @param	{Integer}	maxWidth -  (可选) 比例尺宽度。
	 * 	 @param {String}	unit -  (可选) 比例尺单位。"metric"或"imperial"
     */
    initialize: function(options){
		this.options = options;
        mapboxgl.util.bindAll([
            '_onMove'
        ], this);
    },
	
	getDefaultPosition: function(){
        return 'bottom-left';
    },
	
	_onMove: function(){
        this._updateScale(this._map, this._container, this.options);
    },
	
	onAdd: function(map){
        this._map = map;
        this._container = GeoGlobe.DOM.create('div', 'mapboxgl-ctrl mapboxgl-ctrl-scale', map.getContainer());

        this._map.on('move', this._onMove);
        this._onMove();

        return this._container;
    },

    onRemove: function(){
        this._container.parentNode.removeChild(this._container);
        this._map.off('move', this._onMove);
        this._map = undefined;
    },
	
	
	
	
	_updateScale: function(map, container, options){
		// A horizontal scale is imagined to be present at center of the map
	    // container with maximum length (Default) as 100px.
	    // Using spherical law of cosines approximation, the real distance is
	    // found between the two coordinates.
	    var maxWidth = options && options.maxWidth || 100;
	
	    var y = map._container.clientHeight / 2;
	    var maxMeters = this._getDistance(map.unproject([0, y]), map.unproject([maxWidth, y]));
	    // The real distance corresponding to 100px scale length is rounded off to
	    // near pretty number and the scale length for the same is found out.
	    // Default unit of the scale is based on User's locale.
	    if (options && options.unit === 'imperial') {
	        var maxFeet = 3.2808 * maxMeters;
	        if (maxFeet > 5280) {
	            var maxMiles = maxFeet / 5280;
	            this._setScale(container, maxWidth, maxMiles, 'mi');
	        } else {
	            this._setScale(container, maxWidth, maxFeet, 'ft');
	        }
	    } else {
	        this._setScale(container, maxWidth, maxMeters, 'm');
	    }
	},
	
	_setScale: function(container, maxWidth, maxDistance, unit){
		//取整数，第一位不变，其他位全为0。比如1000000
		var distance = this._getRoundNum(maxDistance);
	    var ratio = distance / maxDistance;
	
	    if (unit === 'm' && distance >= 1000) {
	        distance = distance / 1000;
	        unit = 'km';
	    }
	    container.style.width = (maxWidth * ratio) + "px";
	    container.innerHTML = distance + unit;
	},
	
	_getDistance: function(latlng1, latlng2){
		var maxMeters = null;
		//单位的"m"的情况
		if(this._map.units === "m"){
			maxMeters = latlng2.lng - latlng1.lng;
		}else{
			//默认单位是度"degrees"的情况
			// Uses spherical law of cosines approximation.
		    var R = 6371000;
		
		    var rad = Math.PI / 180,
		        lat1 = latlng1.lat * rad,
		        lat2 = latlng2.lat * rad,
		        a = Math.sin(lat1) * Math.sin(lat2) +
		          Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);
		
		    maxMeters = R * Math.acos(Math.min(a, 1));
		}
		
	    return maxMeters;
	},
	
	_getRoundNum: function(num){
		var pow10 = Math.pow(10, (("" + (Math.floor(num)))).length - 1);
	    var d = num / pow10;
	
	    d = d >= 10 ? 10 :
	        d >= 5 ? 5 :
	        d >= 3 ? 3 :
	        d >= 2 ? 2 : 1;
	
	    return pow10 * d;
	},
	
    CLASS_NAME: "GeoGlobe.Control.Scale"
});

/**
 * @class GeoGlobe.Control.Geolocate
 * @classdesc 定位控件类，为二维地图提供地理定位功能。
 */



/**
 * 控件位置
 * @name position
 * @memberof GeoGlobe.Control.Geolocate.prototype
 * @type {String}
 * @default null
 */


/**
* GeoGlobe.Control构造函数。
* @method initialize
* @memberof GeoGlobe.Control.Geolocate.prototype
* @param {Object} options - Geolocate相关选项设置。
*/
GeoGlobe.Control.Geolocate = mapboxgl.GeolocateControl;


/**
 * @class GeoGlobe.Control.MapContextMenu
 * @classdesc 地图右键菜单控件类。
 *
 *
 */
GeoGlobe.Control.MapContextMenu = GeoGlobe.Class4OL({

    /** 
    
     * 地图右键菜单div
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     * @type {DOMElement}
     * @default null
     */
    menuDiv: null,
	
	/** 
     *  地图右键菜单menuDiv的样式名。
     *@memberof GeoGlobe.Control.MapContextMenu.prototype
     * @type {String}
     */
	className: null,
    
    /** 
     *鼠标右键地图菜单的内容
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     * @type {String}
     */
    contentHTML: null,
	
    /** 
     * 右键点击的地图坐标信息
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     * @type {GeoGlobe.LngLat}
     */
    lngLat: null,
	
    /** 
     *point右键点击的地图屏幕坐标信息。
     *@memberof GeoGlobe.Control.MapContextMenu.prototype
     * @type {GeoGlobe.Point}
     */
    point: null,
    
    /**

     * 鼠标右键地图菜单控件的构造函数。
     * @memberof GeoGlobe.Control.MapContextMenu.prototype

     *@param {Object} options -  构造参数选项。
     */
    initialize: function(options){
		GeoGlobe.Util.extend(this, options);
    },
	
	getDefaultPosition: function(map){
        return 'top-left';
    },
	
    onAdd: function(map){
		this._map = map;
		
		//绑定右键菜单事件
		//var mapdiv = this._map.getCanvasContainer();
		//this._onContextMenu = GeoGlobe.Function.bind(this._showContextMenu, this);
		//mapdiv.addEventListener('contextmenu', this._onContextMenu);//原生
		this._onContextMenu = GeoGlobe.Function.bind(this._showContextMenu, this);
		this._map.on("contextmenu", this._onContextMenu);
		this._onMouseDown = GeoGlobe.Function.bind(this.hide, this);
		this._map.on("mousedown", this._onMouseDown);
		
		//创建地图右键菜单div
		this._container = this._createContainer();
		return this._container;
	},
	
	/**

     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     * @returns
     * {DOMElement}
     */
    _createContainer: function(){
		var menu = window.document.createElement('div');
		menu.className = "mapboxgl-ctrl";
		if (this.className) {
			menu.classList.add(this.className);
		}
		
        menu.style.position = "absolute";
        menu.style.background = "white";
        menu.style.border = "1px solid #adbfe4";
        menu.style.zIndex = 2;
        menu.innerHTML = this.contentHTML ? this.contentHTML : "";
        this.menuDiv = menu;
		this.menuDiv.onmousedown = GeoGlobe.Function.bind(function(){
			//火狐事件对象event为arguments[0]。IE和chrome的事件对象则全局存在event。
        	var evt = arguments[0] || event;
			evt.preventDefault();
			if(event.stopPropagation){
	        	event.stopPropagation();
	        }
        }, this);
        this.hide();
        return menu;
    },
	
    /**

     * 点击右键在地图上显示菜单。
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     */
	_showContextMenu: function(evt){
		this.lngLat = evt.lngLat;
		this.point = evt.point;
		this.menuDiv.style.left = evt.point.x + "px";
        this.menuDiv.style.top = evt.point.y + "px";
        this.show();
	},
	/*
    _showContextMenu: function(evt){//原生
		var mapdiv = this._map.getCanvasContainer();
		this.point = this.mousePos(mapdiv, evt);
		this.lngLat = this._map.unproject(this.point);
        this.menuDiv.style.left = evt.layerX + "px";
        this.menuDiv.style.top = evt.layerY + "px";
        this.show();
    },*/
	
	onRemove: function(){
		this._container.parentNode.removeChild(this._container);
		//var mapdiv = this._map.getCanvasContainer();
		//mapdiv.removeEventListener('contextmenu', this._onContextMenu);//原生
		
		this._map.off('contextmenu', this._onContextMenu);
		this._map.off('mousedown', this._onMouseDown);
		
		this.menuDiv = null;
		this._container = null;
		this.contentHTML = null;
		this._map = undefined;
	},
	
	/**

     * 显示右键菜单。
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     */
    show: function(){
        if (this.menuDiv && this.menuDiv.style.display == "none") {
            this.menuDiv.style.display = "";
        }
    },
    
    /**

     * 隐藏右键菜单。
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     */
    hide: function(){
        if (this.menuDiv && this.menuDiv.style.display != "none") {
            this.menuDiv.style.display = "none";
        }
    },
    
    /**

     * 设置右键菜单的内容。
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     *

     * @param {String} contentHTML - 右键菜单的HTML字符串。
     */
    setContentHTML: function(contentHTML){
        if (contentHTML != null) {
            this.contentHTML = contentHTML;
        }
        if ((this.menuDiv != null) && (this.contentHTML != null) &&
        (this.contentHTML != this.menuDiv.innerHTML)) {
            this.menuDiv.innerHTML = this.contentHTML;
        }
    },
	
    /**

     * 添加菜单选项。
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     * 

     * @param {GeoGlobe.View2D.MenuItem}menuItem -  鼠标右键地图菜单选项。
     */
    addItem: function(menuItem){
        var itemDiv = document.createElement("div");
		itemDiv.id = menuItem.id;
        itemDiv.style.cssText = "padding-bottom: 2px; line-height: 17px; margin: 0px 2px; padding-left: 6px; width:" + menuItem.width + "px; padding-right: 6px; color: #000; font-size: 12px; cursor: pointer; padding-top: 2px;";
		itemDiv.innerHTML = "<span>" + menuItem.text + "</span>";
		itemDiv.onclick = GeoGlobe.Function.bind(function(){
			var evtObj = {
				target: menuItem,
				control: this,
				map: this._map,
				lngLat: this.lngLat,
				point: this.point
			};
			menuItem.callback(evtObj);
			this.hide();
        }, this);
		itemDiv.onmouseover = function(){
			itemDiv.style.color = "#6688cc";
		}
		itemDiv.onmouseout = function(){
			itemDiv.style.color = "#000";
		}
        this.menuDiv.appendChild(itemDiv);
		this.setContentHTML(this.menuDiv.innerHTML);
    },
	
    /**

     * 添加菜单的分割线。
     * @memberof GeoGlobe.Control.MapContextMenu.prototype
     */
	addSeparator: function(){
		var separatorDiv = document.createElement("div");
        separatorDiv.style.cssText = "border-bottom:#adbfe4 1px solid;margin:0px 6px;font-size:0px;padding:1px";
		this.menuDiv.appendChild(separatorDiv);
		this.setContentHTML(this.menuDiv.innerHTML);
	},
	
    /**
     * 鼠标事件对象转地图屏幕点。
     *@memberof GeoGlobe.Control.MapContextMenu.prototype

     * @param {DOMElement} el - mapdiv。
     *  @param {Object}e -  鼠标事件。
     */
	mousePos: function(el, e){
	    var rect = el.getBoundingClientRect();
	    return new GeoGlobe.Point(
	        e.clientX - rect.left - el.clientLeft,
	        e.clientY - rect.top - el.clientTop
	    );
	},
    
    CLASS_NAME: "GeoGlobe.View2D.Control.MapContextMenu"
});


/**
 * @class GeoGlobe.MenuItem
 *  @classdesc 地图右键菜单选项类。
 *
 *
 */
GeoGlobe.MenuItem = GeoGlobe.Class4OL({
	
    /**
     * id-唯一标识。
     * @memberof GeoGlobe.MenuItem.prototype
     * @type {String}

     */
	id: null,
	
    /**
     * 菜单项显示的文本
     * @memberof GeoGlobe.MenuItem.prototype
     * @type {String}
     *
     */
    text: null,

    /**
     * 回调函数
     * @memberof GeoGlobe.MenuItem.prototype
     * @type {Function}

     */
    callback: null,

    /**
     * 菜单项长度。默认值为100px。
     * @memberof GeoGlobe.MenuItem.prototype
     * @type {String}
     */
	width: 100,
	
    /**

     * 鼠标右键地图菜单选项的构造函数。
     * @memberof GeoGlobe.MenuItem.prototype
    :
     * @param {Object}options -  构造参数选项。
     */
    initialize: function(options){
		this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
		GeoGlobe.Util.extend(this, options);
    },
	
	
    /**

     * 设置菜单项显示的文本。
     * @memberof GeoGlobe.MenuItem.prototype

     * @param {String}  text - 菜单项显示的文本。
     */
	setText: function(text){
		this.text = text;
	},
	
    CLASS_NAME: "GeoGlobe.MenuItem"
});
/**
 * @class GeoGlobe.Control.MapCesium
 * @classdesc 二三维地图联动(MapboxGL - Cesium)。
 * @example  
//地图联动
var mc = new GeoGlobe.Control.MapCesium({
	map: map,
	viewer: viewer,
	isPitchChanged: true,
	isHeadingChanged: true
});
mc.setEnabled(true);  //开启同步
 */
GeoGlobe.Control.MapCesium = GeoGlobe.Class4OL({

    /** 
    
     * 二维地图（MapboxGL）
     * @memberof GeoGlobe.Control.MapCesium.prototype
     * @type {Object}
     * @default null
     */
    map: null,
	
	/** 
    
     * 三维地图（Cesium）
     * @memberof GeoGlobe.Control.MapCesium.prototype
     * @type {Object}
     * @default null
     */
    viewer: null,
	
	/** 
    
     * 是否倾斜
     * @memberof GeoGlobe.Control.MapCesium.prototype
     * @type {Boolean}
     * @default false
     */
    isPitchChanged: false,
	
	/** 
    
     * 是否旋转
     * @memberof GeoGlobe.Control.MapCesium.prototype
     * @type {Boolean}
     * @default false
     */
    isHeadingChanged: false,
    
	/** 
    
     * mapbox地图正在移动状态
     * @memberof GeoGlobe.Control.MapCesium.prototype
	 * @private
     * @type {String}
     */
    _MAPBOX_MOVE: "mapbox is moving",
	
	/** 
    
     * cesium地图正在移动状态
     * @memberof GeoGlobe.Control.MapCesium.prototype
	 * @private
     * @type {String}
     */
    _CESIUM_MOVE: "cesium is moving",
	
	/** 
    
     * 哪个地图处于移动状态
     * @memberof GeoGlobe.Control.MapCesium.prototype
	 * @private
     * @type {String}
     */
    _isMoving: null,
	
	/** 
    
     * cesium地图事件处理句柄
     * @memberof GeoGlobe.Control.MapCesium.prototype
	 * @private
     * @type {Object}
     */
    _handler: null,
	
	/** 
    
     * 保存Cesium的航向角状态
     * @memberof GeoGlobe.Control.MapCesium.prototype
	 * @private
     * @type {Number}
     */
    _currentCesiumHeading: 0,
	
	/** 
    
     * 保存Cesium的倾角状态
     * @memberof GeoGlobe.Control.MapCesium.prototype
	 * @private
     * @type {Number}
     */
    _currentCesiumPitch: 0,
    
    /**

     * 地图联动类的构造函数。
     * @memberof GeoGlobe.Control.MapCesium.prototype

     * @param {Object} options -  构造参数选项。
     */
    initialize: function(options){
		this.map                   = options.map ? options.map : this.map;
		this.viewer                = options.viewer ? options.viewer : this.viewer;
		this.isPitchChanged        = options.isPitchChanged !== undefined ? options.isPitchChanged : this.isPitchChanged;
		this.isHeadingChanged      = options.isHeadingChanged !== undefined ? options.isHeadingChanged : this.isHeadingChanged;
		this._isMoving             = this._MAPBOX_MOVE;
		this._isSync               = false;
		this._currentCesiumHeading = 0;
		this._currentCesiumPitch   = -Cesium.Math.PI_OVER_TWO;
		this._handler              = new Cesium.ScreenSpaceEventHandler(this.viewer.canvas);
		this._bindEvent();
		this._updateCesium();
   },
	
	/**
     * @method
     * @desc 绑定事件
     * @memberof GeoGlobe.Visuals.Three.MapCesium.prototype
     * @private 
     */
	_bindEvent: function(){
		if(!this.map) return;
		if(this._handler.getInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE)) return;
		var _this = this;
		this.map.on('move', function MAPCESIUM_MOVE_EVENT(e){
			if(!_this._isSync) return;
			_this._updateCesium();
		});
		this.map.on('mouseover', function MAPCESIUM_MOVEOVER_EVENT(e){
			_this._isMoving = _this._MAPBOX_MOVE;
		});
		
		this._handler.setInputAction(function(click) {
			_this._isMoving = _this._CESIUM_MOVE;
			_this._currentCesiumHeading = _this.viewer.camera.heading;
			_this._currentCesiumPitch = _this.viewer.camera.pitch;
			
		}, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
		
		this.viewer.canvas.addEventListener('mouseout', function() { _this._isMoving = _this._MAPBOX_MOVE; });
		this.viewer.scene.preRender.addEventListener(function CESIUM_RENDER_EVENT() {
			if(!_this._isSync) return;
			_this._updateMapbox();
		});
	},
	
	/**
     * @method
     * @desc 是否开启场景同步
     * @memberof GeoGlobe.Visuals.Three.MapCesium.prototype
	 * @param {Boolean} synchronous -  是否开启场景同步。
     */
	 setEnabled: function(synchronous) {
		 this._isSync = synchronous;
	 },
	
	/**
     * @method
     * @desc 解绑事件
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     * @private 
     */
	_unbindEvent: function(){
		if(!this.map) return;
		var _this = this;
		for(var i=0; i<this.map._listeners['move'].length; i++){
			if(this.map._listeners['move'][i].name && this.map._listeners['move'][i].name === 'MAPCESIUM_MOVE_EVENT'){
				this.map._listeners['move'].splice(i,1);
			}
		}
		for(var i=0; i<this.map._listeners['mouseover'].length; i++){
			if(this.map._listeners['mouseover'][i].name && this.map._listeners['mouseover'][i].name === 'MAPCESIUM_MOVEOVER_EVENT'){
				this.map._listeners['mouseover'].splice(i,1);
			}
		}
		for(var i=0; i<this.viewer.scene.preRender._listeners.length; i++) {
			if(this.viewer.scene.preRender._listeners[i].name === 'CESIUM_RENDER_EVENT'){
				this.viewer.scene.preRender._listeners.splice(i,1);
			}
		}
		this._handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
	},
	
	/**
     * @method
     * @desc 解绑事件，并销毁对象
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     */
	destroy: function() {
		if(!this.map) return;
		this._unbindEvent();
		this.map      = null;
		this._handler = null;
		this.viewer   = null;
	},
	
	/**
     * @method
     * @desc 计算相机到屏幕的地理距离（米）
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     * @private 
     */
	_calDistanceFromMapboxToCesium: function(){
		var extent = 20037508.3427892 * 2;
		var resolution = extent/512/Math.pow(2,(this.map.getZoom()+1.2));
		return this.map.transform.cameraToCenterDistance * resolution;
	},
	
	/**
     * @method
     * @desc 根据mapbox的方位角求取cesium对应的航向角
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     * @private 
     */
	_calHeadingFromMapboxToCesium: function(){
		var bearing = this.map.getBearing();
		return Cesium.Math.toRadians(bearing);
	},
	
	/**
     * @method
     * @desc 根据mapbox的倾角求取cesium对应的倾角
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     * @private 
     */
	_calPitchFromMapboxToCesium: function(){
		var pitch = this.map.getPitch();
		return Cesium.Math.toRadians(pitch - 90);
	},
	
	/**
     * @method
     * @desc 根据mapbox计算目标点
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     * @private 
     */
	_calDestinationFromMapboxToCesium: function(){
		var carto = new Cesium.Cartographic(Cesium.Math.toRadians(this.map.getCenter().lng), Cesium.Math.toRadians(this.map.getCenter().lat));
		return Cesium.Ellipsoid.WGS84.cartographicToCartesian(carto);
	},
	
	/**
     * @method
     * @desc 计算获得Cesium的中心点笛卡尔坐标
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     * @private 
     */
	_getCenterPoint: function(){
		var canvas = this.viewer.canvas;
	    var center = new Cesium.Cartesian2( canvas.clientWidth / 2, canvas.clientHeight / 2);
		var ray = this.viewer.camera.getPickRay(center);
	    var target = this.viewer.scene.globe.pick(ray, this.viewer.scene);
	    return target || this.viewer.camera.pickEllipsoid(center);
	},
	
	
	/**
     * @method
     * @desc 更新Cseium状态
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     * @private 
     */
	_updateCesium: function() {
		if(this._isMoving === this._CESIUM_MOVE) return;
		var distance = this._calDistanceFromMapboxToCesium();  
		var pitch,heading;
		
		if(this.isHeadingChanged) heading =  this._calHeadingFromMapboxToCesium();
		else heading =  this._currentCesiumHeading;
		if(this.isPitchChanged) pitch = this._calPitchFromMapboxToCesium();
		else pitch = this._currentCesiumPitch;
		
		var destination = this._calDestinationFromMapboxToCesium();
		this.viewer.camera.setView({
			destination : destination,
			orientation: {
				heading : heading,  
				pitch : pitch
			}
		});
		this.viewer.camera.moveBackward(distance);
	},
	
	/**
     * @method
     * @desc 更新Mapbox状态
     * @memberof GeoGlobe.Visuals.MapCesium.prototype
     * @private 
     */
	_updateMapbox: function() {
		if(!this.viewer) return;
		if(this._isMoving === this._MAPBOX_MOVE) return;
		
		var ellipsoid = Cesium.Ellipsoid.WGS84;
		var extent = 20037508.3427892 * 2;
		var bearing = 0, pitch = 0;
		
		var target = this._getCenterPoint();
		if(!target) {
			var globe = this.viewer.scene.globe;
		    var carto = this.viewer.camera.positionCartographic.clone();
		    var height = globe.getHeight(carto);
		    carto.height = height || 0;
		    target = ellipsoid.cartographicToCartesian(carto);
		}
		var distance = Cesium.Cartesian3.distance(target, this.viewer.camera.position);
		var resolution = distance / this.map.transform.cameraToCenterDistance;
		var level = Math.log2(extent/512/resolution) - 1.2;
		
		var targetCarto = ellipsoid.cartesianToCartographic(target);
		var targetLngLat = [Cesium.Math.toDegrees(targetCarto.longitude), Cesium.Math.toDegrees(targetCarto.latitude)];
		
		this.map.setZoom(level);
		this.map.setCenter(targetLngLat);
		
		if(target) {
			//bearing
			var up = viewer.camera.up;
			var right = viewer.camera.right;
			var normal = new Cesium.Cartesian3(-target.y, target.x, 0);
			var heading = Cesium.Cartesian3.angleBetween(right, normal);
			var cross = Cesium.Cartesian3.cross(target, up, new Cesium.Cartesian3());
			var orientation = cross.z;
			bearing = orientation < 0 ? -heading : heading;
			bearing = Cesium.Math.toDegrees(bearing);
			
			//pitch
			var pos = this.viewer.camera.position;
			var targetNormal = new Cesium.Cartesian3();
			ellipsoid.geocentricSurfaceNormal(target, targetNormal);
			
			var targetToCamera = new Cesium.Cartesian3();
			Cesium.Cartesian3.subtract(pos, target, targetToCamera);
			Cesium.Cartesian3.normalize(targetToCamera, targetToCamera);
			
			var tiltAngle = Math.acos(Cesium.Cartesian3.dot(targetNormal, targetToCamera));
			pitch = isNaN(tiltAngle) ? 0 : tiltAngle;
		}else {
			bearing = Cesium.Math.toDegrees(this.viewer.camera.heading);
			pitch   = Cesium.Math.PI_OVER_THREE;
		}
		
		if(this.isHeadingChanged) this.map.setBearing(bearing);
		if(this.isPitchChanged)   this.map.setPitch(Cesium.Math.toDegrees(pitch));
	},
    
    CLASS_NAME: "GeoGlobe.View2D.Control.MapCesium"
});/**
 * @class GeoGlobe.Event
 * @classdesc 事件管理类。

 */

/**
* GeoGlobe.Event构造函数。
*@method initialize
*@memberof GeoGlobe.Event.prototype
* @param {Object} options -  Event相关选项设置。
*/

GeoGlobe.Event = mapboxgl.Evented;/**
 * @class GeoGlobe.Event.mapMouseEvent
 * @classdesc 鼠标事件类，为二维地图提供地图鼠标事件。
 */



/**
 * 事件目标。
 * @name target
 * @memberof GeoGlobe.Event.mapMouseEvent.prototype
 * @type {String}
 * @default null
 */

/**
 * GeoGlobe.MapMouseEvent构造函数。
 * @method initialize
 * @memberof GeoGlobe.Event.mapMouseEvent.prototype
 * @param {Object} options -  MapMouseEvent相关选项设置。
 */

/**

    * 鼠标移出事件。
    * @method onMouseOut
    * @memberof GeoGlobe.Event.mapMouseEvent.prototype
    * @param {string}  ev - 鼠标移出。
    */

/**
 *鼠标按下事件。
    *@method onMouseDown
    *@memberof GeoGlobe.Event.mapMouseEvent.prototype
    *@param {string} ev - 鼠标按下。
    */


/**
 * 鼠标弹起事件。
 * @method onMouseUp
 * @memberof GeoGlobe.Event.mapMouseEvent.prototype
 * @param {string}  ev - 鼠标弹起。
 */

/**
 * 鼠标移动事件。
 * @method onMouseMove
 * @memberof GeoGlobe.Event.mapMouseEvent.prototype
 * @param {string} ev - 鼠标移动。
 */

/**

    * 鼠标单击事件。
    * @method sigleClick
    * @memberof GeoGlobe.Event.mapMouseEvent.prototype
    * @param {string} ev -鼠标单击。
    */

/**
 * 鼠标双击事件。
 * @method doubleClick
 *@memberof GeoGlobe.Event.mapMouseEvent.prototype
 * @param {string} ev - 鼠标双击。
    */


/**
 *鼠标事件移除。
    *@method remove
    *@memberof GeoGlobe.Event.mapMouseEvent.prototype
    *@param {string} mouseout - 鼠标移出
    *@param {string}mousemove - 鼠标移动
    *@param {string} mousedown - 鼠标按下
    *@param {string} mouseup - 鼠标弹起
    *@param {string}dblclick - 鼠标双击
    *@param {string}click - 鼠标单击
    */

GeoGlobe.Event.MapMouseEvent = mapboxgl.Event;


/**
 * @class GeoGlobe.Event.mapTouchEvent
 * @classdesc 触摸事件类，为二维地图提供地图触摸事件。
 *@class
 */


/**
 * @name target
 * @memberof GeoGlobe.mapTouchEvent.prototype
 * @type {String}
 * @default null
 */

/**
 * GeoGlobe.MapTouchEvent构造函数。
 * @method initialize
 * @memberof GeoGlobe.Event.mapTouchEvent.prototype
 * @param {Object} options -  MapTouchEvent相关选项设置。
 */

/**

    * 触摸开始事件。
    * @method onTouchStart
    *@memberof GeoGlobe.Event.mapTouchEvent.prototype
    * @param {string} ev - 触摸开始。
    */


/**

    * 触摸移动事件。
    * @method onTouchMove
    * @memberof GeoGlobe.Event.mapTouchEvent.prototype
    *
* @param {string}  ev - 触摸移动。
    */

/**
 * 触摸结束事件。
 * @method onTouchEnd
 *  @memberof GeoGlobe.Event.mapTouchEvent.prototype
 * @param {string} ev - 触摸结束。
 */

/**
 * 触摸取消事件。
 * @method onTouchCancel
 * @memberof GeoGlobe.Event.mapTouchEvent.prototype
 * @param {string} ev - 触摸取消。
 */

/**
* 触摸延时。
* @method onTouchTimeout
* @memberof GeoGlobe.Event.mapTouchEvent.prototype
*
*/

/**
 * 触摸事件移除。
 * @method remove
 * @memberof GeoGlobe.Event.mapTouchEvent.prototype
 * @param touchstart - 触摸开始
 * @param touchmove - 触摸移动
 * @param touchend - 触摸结束
 * @param touchcancel - 触摸取消
 * @param dblclick - 鼠标双击
 */

GeoGlobe.Event.MapTouchEvent = mapboxgl.Event;

/**
 * @class GeoGlobe.Event.mapDataEvent
 *@classdesc  鼠标事件类，为二维地图提供地图鼠标事件。

 */



/**
 * 事件类型。
 * @name type
 * @memberof  GeoGlobe.Event.mapDataEvent.prototype
 * @type {String}
 * @default null
 */

/**
 * 数据类型。
 * @name datatype
 * @memberof  GeoGlobe.Event.mapDataEvent.prototype
 * @type {String}
 * @default null
*/

/**
* GeoGlobe.MapMouseEvent构造函数。
* @method intialize
* @memberof GeoGlobe.Event.mapDataEvent.prototype
* @param {Object} options -  mapDataEvent相关选项设置。
*/

GeoGlobe.Event.mapDataEvent = mapboxgl.Event;/**
 * @class GeoGlobe.Event.mapBoxZoomEvent
 * @classdesc 鼠标事件类，为二维地图提供地图鼠标事件。

 */



/*
* 目标
* @name target
* @memberof  GeoGlobe.Event.mapBoxZoomEvent.prototype
* @type {String}
* @default null
*/

/**
 * 范围
 * @name boxZoomBounds
 * @memberof  GeoGlobe.Event.mapBoxZoomEvent.prototype
 * @type {LngLatbounds}
 * @default null
 */

/**

*GeoGlobe.MapMouseEvent构造函数。
*@method initialize
*@memberof  GeoGlobe.Event.mapBoxZoomEvent.prototype
*@param {Object}options -  mapBoxZoomEvent相关选项设置。
*/


/**
 * 鼠标按下事件。
 * @method onMouseDown
 * @memberof  GeoGlobe.Event.mapBoxZoomEvent.prototype
 */

/**
 * 鼠标弹起事件。
 * @method onMouseUp
 * @memberof  GeoGlobe.Event.mapBoxZoomEvent.prototype
 *
 */


/**

* 鼠标移动事件。
* @method onMouseMove
* @memberof  GeoGlobe.Event.mapBoxZoomEvent.prototype
*
* @param {string} ev - 鼠标移动事件。
*/


/**
* 事件移除。
*@method remove
*@memberof  GeoGlobe.Event.mapBoxZoomEvent.prototype
*@param {string} keydown - 键盘按下
*@param {string} mousemove - 鼠标移动
*@param {string}mousedown - 鼠标按下
*@param {string} mouseup - 鼠标弹起
*/



GeoGlobe.Event.mapBoxZoomEvent = mapboxgl.Event;

/**
 * @class GeoGlobe.Handler
 * @classdesc 监听器类，继承于GeoGlobe.Handler
 */
GeoGlobe.Handler = GeoGlobe.Class({

    /**
     *
     * GeoGlobe.Handler。
     *@memberof GeoGlobe.Handler.prototype
     * @param {Object}options -  Handeler相关选项设置。
     */
    initialize: function(options){
        
    },

    CLASS_NAME: "GeoGlobe.Handler"
});
/**
 * @class GeoGlobe.Handler.BoxZoomHandler
 * @classdesc 继承于GeoGlobe.Control 范围缩放监听，为二维地图提供范围缩放监听功能。
 */

/**
 * 地图对象
 * @name map
 * @memberof GeoGlobe.Handler.BoxZoomHandler.prototype
 * @type {GeoGlobe.Map}
 * @default null
 */




/**
 * 添加控件。
 * @method isActivate
 * @memberof GeoGlobe.Handler.BoxZoomHandler.prototype
 * @returns
 * active - {Boolean} 是否激活。
 */

/**

* 是否交互。
* @method isEnabled
* @memberof GeoGlobe.Handler.BoxZoomHandler.prototype
* @returns
* able - {Boolean} 是否交互。
*/

/**

* 能交互。
* @method enable
*  @memberof GeoGlobe.Handler.BoxZoomHandler.prototype
*/

/**

* 不能交互。
* @method disable
* @memberof GeoGlobe.Handler.BoxZoomHandler.prototype
*/

GeoGlobe.Handler.BoxZoomHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * GeoGlobe.Handler构造函数。
     *  @memberof GeoGlobe.Handler.BoxZoomHandler.prototype
     * @param {Object}options -  Handler.BoxZoomHandler相关选项设置。
     */
    initialize: function(options){
        //this.handler = new mapboxgl.BoxZoomHandler(options);
        this.handler = options['boxZoom' ];
        return this.handler;
    },
    CLASS_NAME: "GeoGlobe.Handler.BoxZoomHandler"
});


/**
 * @class GeoGlobe.Handler.DoubleClickZoomHandler
 * @classdesc  继承于GeoGlobe.Handler 双击缩放监听，为二维地图提供双击缩放监听功能。
 */

    /**
     * 地图对象。
     * @name map
     * @memberof GeoGlobe.Handler.DoubleClickZoomHandler.prototype
     * @type {GeoGlobe.Map}
     * @default null
     */

    /**
     * 是否交互。
     * @method isEnabled
     * @memberof GeoGlobe.Handler.DoubleClickZoomHandler.prototype
     * @returns
     * able - {Boolean} 是否交互。
     */

    /**

     * 能交互。
     *@method enable
     *@memberof GeoGlobe.Handler.DoubleClickZoomHandler.prototype
     */

    /**

     * 不能交互。
     * @method disable
     * @memberof GeoGlobe.Handler.DoubleClickZoomHandler.prototype
     */

GeoGlobe.Handler.DoubleClickZoomHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**

     * GeoGlobe.Handler构造函数。
     * @memberof GeoGlobe.GeoGlobe.Handler.DoubleClickZoomHandler.prototype
     * @param {Object}options -  Handler.DoubleClickZoomHandler相关选项设置。
     */
    initialize: function(options){
        this.handler = options['doubleClickZoom'];

        return this.handler;
    },

    CLASS_NAME: "GeoGlobe.Handler.DoubleClickZoomHandler"
});
/**
 * @class GeoGlobe.Handler.DragPanHandler

 * @classdesc  继承于GeoGlobe.Handler 平移拖拽，为二维地图提供平移拖拽功能。
 */

/**
 * 地图对象。
 * @name map
 * @memberof  GeoGlobe.Handler.DragPanHandler.prototype
 * @type {GeoGlobe.Map}
 * @default null
 */

/**

* 添加控件。
* @method isActivate
* @memberof  GeoGlobe.Handler.DragPanHandler.prototype
* @returns
* active - {Boolean} 是否激活。
*/

/**
 * 是否交互。
 * @method isEnabled
 * @memberof  GeoGlobe.Handler.DragPanHandler.prototype
 * @returns
 * able - {Boolean} 是否交互。
 */

/**

* 能交互。
* @method enable
* @memberof  GeoGlobe.Handler.DragPanHandler.prototype
*/

/**
 *不能交互。
*@method disable
*@memberof  GeoGlobe.Handler.DragPanHandler.prototype
*/
GeoGlobe.Handler.DragPanHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * GeoGlobe.Handler构造函数。
     * @memberof  GeoGlobe.Handler.DragPanHandler.prototype
     * @param {Object}options -  Handler.DragPanHandler相关选项设置。
     */
    initialize: function(options){
        this.handler = options['dragPan'];
        return this.handler;
    },

    CLASS_NAME: "GeoGlobe.Handler.DragPanHandler"
});



/**
 * @class GeoGlobe.Handler.DragRotateHandler
 *      @classdesc 继承于GeoGlobe.Handler 旋转拖拽监听，为二维地图提供旋转拖拽监听功能。
 * Inherits from:
 *  - <GeoGlobe.Handler>
 * @private
 */
GeoGlobe.Handler.DragRotateHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * 地图对象。
     * @memberof GeoGlobe.Handler.DragRotateHandler.prototype
     * @type {GeoGlobe.Map}

     */
    map: null,

    /**

     * GeoGlobe.Handler构造函数。
     *@memberof GeoGlobe.Handler.DragRotateHandler.prototype
     * @param {Object}options -  Handler.DragRotateHandler相关选项设置。
     */
    initialize: function(options){
        this.handler = options['dragRotate'];

        return this.handler;
    },

    /**

     * 添加控件。
     * @memberof GeoGlobe.Handler.DragRotateHandler.prototype
     * @returns
     * active - {Boolean} 是否激活。
     */
    isActivate:function(){
        return this.handler.isActive();
    },

    /**

     * 是否交互。
     *@memberof GeoGlobe.Handler.DragRotateHandler.prototype
     * @returns
     * able - {Boolean} 是否交互。
     */
    isEnabled :function(){
        return this.handler.isEnabled();
    },

    /**

     * 能交互。
     * @memberof GeoGlobe.Handler.DragRotateHandler.prototype
     */
    enable:function(){
        this.handler.enable();
    },

    /**

     * 不能交互。
     * @memberof GeoGlobe.Handler.DragRotateHandler.prototype
     */
    disable:function(){
        this.handler.disable();
    },
    CLASS_NAME: "GeoGlobe.Handler.DragRotateHandler"
});




/**
 * @class GeoGlobe.Handler.KeyboardHandler
 * @classdesc 继承于GeoGlobe.Handler 键盘操作监听，为二维地图提供键盘操作监听功能。
 */

    /**
     *  地图对象。
     * @name map
     * @memberof GeoGlobe.Handler.KeyboardHandler.prototype
     * @type {GeoGlobe.Map}
     * @default null
     */


    /**
     * 是否交互。
     * @method isEnabled
     * @memberof GeoGlobe.Handler.KeyboardHandler.prototype
     * @returns
     * able - {Boolean} 是否交互。
     */


    /**
     * 能交互。
     * @method enable
     * @memberof GeoGlobe.Handler.KeyboardHandler.prototype
     */

    /**
     * 不能交互。
     * @method disable
     * @memberof GeoGlobe.Handler.KeyboardHandler.prototype
     */

GeoGlobe.Handler.KeyboardHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**

     * GeoGlobe.Handler构造函数。
     * @memberof GeoGlobe.Handler.KeyboardHandler.prototype
     * @param {Object}options -  Handler.KeyboardHandler相关选项设置。
     */
    initialize: function(options){
        this.handler =options['keyboard'];

        return this.handler;
    },
    CLASS_NAME: "GeoGlobe.Handler.KeyboardHandler"
});




/**
 * @class GeoGlobe.Handler.ScrollZoomHandler
 * @classdesc   继承于GeoGlobe.Handler 滚动缩放，为二维地图提供滚动缩放功能。
 */

/**
 *  地图对象。
 * @name map
 * @memberof  GeoGlobe.Handler.ScrollZoomHandler.prototype
 * @type {GeoGlobe.Map}
 * @default null
 */


/**
 * 是否交互。
 * @method isEnabled
 * @memberof  GeoGlobe.Handler.ScrollZoomHandler.prototype
 * @returns
 * able - {Boolean} 是否交互。
 */
/**

    * 能交互。
    *@method enable
    *@memberof  GeoGlobe.Handler.ScrollZoomHandler.prototype
    */


/**
 *不能交互。
    *@method disable
    *@memberof  GeoGlobe.Handler.ScrollZoomHandler.prototype
    */

GeoGlobe.Handler.ScrollZoomHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * GeoGlobe.Handler构造函数。
     * @memberof  GeoGlobe.Handler.ScrollZoomHandler.prototype
     * @param {Object}options - Handler.ScrollZoomHandler相关选项设置。
     */
    initialize: function(options){
        this.handler =options['scrollZoom'];
        return this.handler;
    },
    CLASS_NAME: "GeoGlobe.Handler.ScrollZoomHandler"
});


/**
 * @class GeoGlobe.Handler.TouchZoomRotateHandler
 * @classdesc 继承于GeoGlobe.Handler 触摸旋转缩放监听，为二维地图提供触摸旋转缩放监听功能。
 */

 /**
 * 地图对象。
 * @name map
 * @memberof GeoGlobe.Handler.TouchZoomRotateHandler.prototype
 * @type {GeoGlobe.Map}
 * @default null
*/


/**

* 是否交互。
* @method isEnabled
* @memberof GeoGlobe.Handler.TouchZoomRotateHandler.prototype
* @returns
* able - {Boolean} 是否交互。
*/

/**
 * 能交互。
 * @method enable
 * @memberof GeoGlobe.Handler.TouchZoomRotateHandler.prototype
 */


/**
 * 不能交互。
 * @method disable
 *  @memberof GeoGlobe.Handler.TouchZoomRotateHandler.prototype
 */


/**

    * 禁用“捏”的相互作用，留下“捏放大缩小”的互动功能。
    * @method disableRotation
    * @memberof GeoGlobe.Handler.TouchZoomRotateHandler.prototype
    */

/**
    * 允许“捏”的相互作用
    * @method enableRotation
    * @memberof GeoGlobe.Handler.TouchZoomRotateHandler.prototype
    */
GeoGlobe.Handler.TouchZoomRotateHandler = GeoGlobe.Class(GeoGlobe.Handler,{

    /**
     * GeoGlobe.Handler构造函数。
     * @memberof GeoGlobe.Handler.TouchZoomRotateHandler.prototype
     * @param {Object}options -  Handler.TouchZoomRotateHandler相关选项设置。
     */
    initialize: function(options){
        this.handler = options['touchZoomRotate'];

        return this.handler;
    },
    CLASS_NAME: "GeoGlobe.Handler.TouchZoomRotateHandler"
});




/**
 * @class GeoGlobe.DynamicTrace
 *  @classdesc 动态轨迹运动类，通过该类可实现动态的轨迹运动。
 *
 *
 */
GeoGlobe.DynamicTrace = GeoGlobe.Class({

    /**
     * 轨迹运动帧数，默认为1000，值越小运动越快。
     * @memberof GeoGlobe.DynamicTrace.prototype
     * @type {String}
     * @default null

     */
    frame_num: 0,

    /**
     * 线轨迹的起点坐标数组。
     * @memberof GeoGlobe.DynamicTrace.prototype
     * @type {GeoGlobe.LonLat}

     */
    origons: [0,0],

    /**

     * 线轨迹的终点坐标数组。
     * @memberof GeoGlobe.DynamicTrace.prototype
     * @type {GeoGlobe.LonLat}
     */
    destinations: [0,0],

    /**
     * 线轨迹的终点坐标数组
     * @memberof GeoGlobe.DynamicTrace.prototype
     * @type {GeoGlobe.map}

     */
    map: null,

    /**
     * 轨迹运动的唯一id
     * @memberof GeoGlobe.DynamicTrace.prototype
     * @type {string}

     */
    id: null,

    /**

     * GeoGlobe.DynamicTrace构造函数。
     * @memberof GeoGlobe.DynamicTrace.prototype
     * @type {Object}


     */
    initialize: function(options){
        this.options = options;
        frame_num = options.frame_num;
        map = options.map;
        id = options.id;
        origins = options.origons;
        destinations = options.destinations;
        num = destinations.length;
        pointid = id+'point';
        routeid1 = id+'route1';
        routeid2 = id+'route2';
        point = {};
        route = {};
        route1 ={};
        route2 ={};
        counter =0;
        request = null;

        //this.DynamicTrace = new GeoGlobe.Control();
        //return this;
    },
    /**

     * 添加运动轨迹。
     * @memberof GeoGlobe.DynamicTrace.prototype

     * @param {number}fram - 可选，运动的帧数
     *  @param {object}style -  可选，运动点样式
     *
     */
    autotrace:function(fram,style){
        //var x = this.options;
        if( !frame_num){
            frame_num = 1000;
        }
        if(fram){
            frame_num = fram;
        }
        // 起点到终点形成的一条线
        route = {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        origins[0],
                        destinations[0]
                    ]
                }
            }]
        };
        for(var i=1;i<num;i++) {
            var g = {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        origins[i],
                        destinations[i]
                    ]
                }
            };
            route.features.push(g);
        }
        //沿着轨迹行走的点
        point = {
            "type": "FeatureCollection",
            "features": [{
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": origins[0]
                }
            }]
        };
        for(var i=1;i<num;i++) {
            var g = {
                "type": "Feature",
                "geometry": {
                    "type": "Point",
                    "coordinates": origins[i]
                }
            }
            point.features.push(g);
        }
        // 计算两点之间的距离
        var lineDistance = [];
        lineDistance.push(turf.lineDistance(route.features[0], 'kilometers'));

        for(var i=1;i<num;i++) {
            lineDistance.push(turf.lineDistance(route.features[i], 'kilometers'));
        }
        //将线路分成1000段
        for(var j=0;j<num;j++) {
            var arc = [];

            for (var i = 0; i < lineDistance[j]; i++) {
                var segment = turf.along(route.features[j], i / frame_num * lineDistance[j], 'kilometers');
                arc.push(segment.geometry.coordinates);
            }
            // Update the route with calculated arc coordinates
            route.features[j].geometry.coordinates = arc;
        }
        route1 = {
            "type": "FeatureCollection",
            "features": []
        };
        for(var j=0;j<num;j++) {
            var g = {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        origins[j],
                        origins[j]
                    ]
                }
            };
            route1.features.push(g);
        }

        route2 = {
            "type": "FeatureCollection",
            "features": []
        };
        for(var j=0;j<num;j++) {
            var g = {
                "type": "Feature",
                "geometry": {
                    "type": "LineString",
                    "coordinates": [
                        origins[j],
                        origins[j]
                    ]
                }
            };
            route2.features.push(g);
        }
        // Used to increment the value of the point measurement against the route.
        counter = 0;
        map.addSource(routeid1, {
            "type": "geojson",
            "data": route1
        });

        map.addSource(routeid2, {
            "type": "geojson",
            "data": route2
        });

        map.addSource(pointid, {
            "type": "geojson",
            "data": point
        });

        if(style){
            map.addLayer({
                "id": routeid1,
                "source": routeid1,//"route",
                "type": style.line.type,
                "paint": style.line.paint
            });

            map.addLayer({
                "id":routeid2,
                "source": routeid2,//"route",
                "type": style.line.type,
                "paint": style.line.paint
            });
            map.addLayer({
                "id": pointid,
                "source": pointid,
                "type": style.point.type,
                "paint": style.point.paint
            });
        }else{
            map.addLayer({
                "id": routeid1,
                "source": routeid1,//"route",
                "type": "line",
                "paint": {
                    "line-width": {
                        'base': 2,
                        'stops': [[12, 2], [22, 180]]
                    },
                    "line-color": "red"
                }
            });

            map.addLayer({
                "id":routeid2,
                "source": routeid2,//"route",
                "type": "line",
                "paint": {
                    "line-width": {
                        'base': 2,
                        'stops': [[12, 2], [22, 180]]
                    },
                    "line-color": "red"
                }
            });
            map.addLayer({
                "id": pointid,
                "source": pointid,
                "type": "circle",
                "paint": {
                    'circle-radius': {
                        'base': 2,
                        'stops': [[12, 2], [22, 180]]
                    },
                    "circle-color": "yellow",
                    "circle-opacity": 1
                }
            });
        }
    },

    /**

     * 运行。
     * @memberof GeoGlobe.DynamicTrace.prototype
     */
    run:function(){
        for(var i = 0;i<num;i++) {
            point.features[i].geometry.coordinates = route.features[i].geometry.coordinates[counter];
            route1.features[i].geometry.coordinates.push(route.features[i].geometry.coordinates[counter]);
            route2.features[i].geometry.coordinates.push(route.features[i].geometry.coordinates[counter]);
            if(route1.features[i].geometry.coordinates.length > 11) {
                route1.features[i].geometry.coordinates.shift();
            }
        }
        // Update the source with this new data.
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        if(counter % 10 == 0) {
            map.getSource(routeid2).setData(route2);
        }
        if (point.features[0].geometry.coordinates[0] !== destinations[0][0]) {
            request = requestAnimationFrame(run);
        }
        counter = counter + 1;
    },

    /**

     * 重置。
     * @memberof GeoGlobe.DynamicTrace.prototype
     */
    reset:function(){
        for(var i = 0;i<num;i++) {
            point.features[i].geometry.coordinates = origins[i];
            route1.features[i].geometry.coordinates = [];
            route2.features[i].geometry.coordinates = [];
            route1.features[i].geometry.coordinates.push(origins[i]);
            route2.features[i].geometry.coordinates.push(origins[i]);
        }
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        map.getSource(routeid2).setData(route2);
        // 重置counter
        counter = 0;
        cancelAnimationFrame(request);
    },
    /**

     * 重绘。
     * @memberof GeoGlobe.DynamicTrace.prototype
     */
    replay:function(){
        for(var i = 0;i<num;i++) {
            point.features[i].geometry.coordinates = origins[i];
            route1.features[i].geometry.coordinates = [];
            route2.features[i].geometry.coordinates = [];
            route1.features[i].geometry.coordinates.push(origins[i]);
            route2.features[i].geometry.coordinates.push(origins[i]);
        }
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        map.getSource(routeid2).setData(route2);
        // 重置counter
        // 重启运动
        counter = 0;
        run(counter);
    },

    /**

     * 暂停。
     * @memberof GeoGlobe.DynamicTrace.prototype
     */
    pause:function(){
        cancelAnimationFrame(request);
    },

    /**

     * 删除运动轨迹。
     * @memberof GeoGlobe.DynamicTrace.prototype
     */
    removetrace:function(){
        map.removeLayer(pointid);
        map.removeLayer(routeid1);
        map.removeLayer(routeid2);
        map.removeSource(pointid);
        map.removeSource(routeid1);
        map.removeSource(routeid2);
        //var x = 3000;
        //var style = {
        //    "type":"circle",
        //    "paint":{
        //        "circle-radius": 3,
        //        "circle-color": "green",
        //        "circle-opacity": 1
        //    }
        //};
        //this.autotrace(x,style);
        //run();

    },
    CLASS_NAME: "GeoGlobe.DynamicTrace"
});/**
 * @class GeoGlobe.DynamicFeature
 *  @classdesc 动态点运动类，通过该类可实现点的动态效果。
 *
 *
 *
 */
GeoGlobe.DynamicFeature = GeoGlobe.Class({

    /**
     *  数据
     * @memberof GeoGlobe.DynamicFeature.prototype
     * @type {GeoJSON}
     * @default null

     */
    data: null,

    /**
     * 动态点添加的地图。
     * @memberof GeoGlobe.DynamicFeature.prototype
     * @type {GeoGlobe.map}

     */
    map: null,

    /**
     * 动态要素添加的样式，包括颜色和透明度
     *  @memberof GeoGlobe.DynamicFeature.prototype
     *   @type {object}
     */
    style: null,

    /**
     * 是否立即绘制判断，true表示立即绘制，false表示通过添加函数立即绘制
     *  @memberof GeoGlobe.DynamicFeature.prototype
     *   @type {boolean}
     */
    isdraw: null,

    /**
     * 动态要素的唯一标识。
     * @memberof GeoGlobe.DynamicFeature.prototype
     *   @type {string}
     */

    id: null,

    /**
     * -数据中动态样式改变的属性名称
     * @memberof GeoGlobe.DynamicFeature.prototype
     *   @type {string}

     */
    property: null,

    /**

     * GeoGlobe.DynamicFeature构造函数。
     * @memberof GeoGlobe.DynamicFeature.prototype

     * @param {Object} options -  DynamicFeature相关选项设置。
     */
    initialize: function(options){
        this.options = options;
        map = options.map;
        feat_data = options.data;
        speed = 500;
        i =0;
        sourceid =null;
        style = options.style;
        property = style.property;
        val_property = feat_data.features[0].properties[property];
        sourceid = options.id;
        isdraw = options.isdraw;
        color_num =[];
        size_num =[];
        if(isdraw){
            this.setdata();
            this.setstyle();
        }
    },

    /**
     *
     * 添加动态要素的数据。
     *@memberof GeoGlobe.DynamicFeature.prototype

     */
    setdata:function(datas,start,end){
        if(datas){
            map.removeSource(sourceid);
            map.addSource(sourceid, {
                type: "geojson",
                data: datas
            });

        }else{
            map.addSource(sourceid, {
                type: "geojson",
                data: feat_data
            });
        }

    },
    /**

     * 添加动态要素图层。
     * @memberof GeoGlobe.DynamicFeature.prototype

     *
     */
    setstyle:function(){
        var start_num = 0;
        if(style.color) {
            color = style.color;
            var color_set =color[val_property];
            for(var c =0;c<color_set.length;c++){
                color_num.push([c,color_set[c]]);
            }
            opacity = style.opacity;
            if(style.size){
                size = style.size;
                var size_set =size[val_property];
                for(var s =0;s<size_set.length;s++){
                    size_num.push([s,size_set[s]]);
                }
            }else{
                size_num =[
                    [0, 7],
                    [1,5],
                    [2, 3]
                ]
            }

        }else{
            opacity = 0.3;
            color_num = [
                [0, 'red'],
                [1, '#FFC0CB'],
                [2, '#FFB6C1']
            ];
            size_num =[
                [0, 7],
                [1,5],
                [2, 3]
            ]
        }
        if(style.type === 'point'){
            //指定时间调用函数
            setInterval(function(){
                if(i % speed === 0){
                    map.addLayer({
                        "id": sourceid,
                        "type": "circle",
                        "source": sourceid,
                        "paint": {
                            "circle-color": {
                                "stops": [color_num[start_num]]
                            },
                            'circle-opacity': opacity,
                            "circle-radius": {
                                'stops':[size_num[start_num]]
                            }
                        }
                    });
                    start_num++;
                    if(start_num > 2) start_num = 0;
                }
                i+=5;
            }, 1);
        }else if(style.type === 'line'){
            setInterval(function(){
                if(i % speed === 0){
                    map.addLayer({
                        "id": sourceid,
                        "type": "line",
                        "source": sourceid,
                        "paint": {
                            "line-color": {
                                "stops": [color_num[start_num]]
                            },
                            'line-opacity': opacity,
                            'line-width':{
                                'stops':[size_num[start_num]]
                            }
                        }
                    });
                    start_num++;
                    if(start_num > 2) start_num = 0;
                }
                i+=5;
            }, 1);
        }else if(style.type === 'fill'){
            setInterval(function(){
                if(i % speed === 0){
                    map.addLayer({
                        "id": sourceid,
                        "type": "fill",
                        "source": sourceid,
                        "paint": {
                            "fill-color": {
                                "stops": [color_num[start_num]]
                            },
                            'fill-opacity': 0.3,
                            'fill-outline-color':{
                                "stops": [color_num[start_num]]
                            }
                        }
                    });
                    start_num++;
                    if(start_num > 2) start_num = 0;
                }
                i+=5;
            }, 1);
        }else{
            alert("请确定显示的要素的类型");
        }
    },
    CLASS_NAME: "GeoGlobe.DynamicFeature"
});/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */
 


/**
 * @class GeoGlobe.Geometry
 * @classdesc 几何对象基类。
 */
GeoGlobe.Geometry = GeoGlobe.Class4OL({

    /**
     * A unique identifier for this geometry.
     *  @memberof GeoGlobe.Geometry.prototype
     * @type {String}
     * @private


     */
    id: null,

    /**
     * This is set when a Geometry is added as component
     * of another geometry
     * @memberof GeoGlobe.Geometry.prototype
     * @type {String}
     * @private

     */
    parent: null,

    /**
     * The bounds of this geometry
     * @memberof GeoGlobe.Geometry.prototype
     * @type {GeoGlobe.LngLatBounds}
     * @private

     */
    bounds: null,

    /**

     * 创建一个几何对象。
     * @memberof GeoGlobe.Geometry.prototype
     */
    initialize: function() {
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
    },
    
    /**

     * Destroy this geometry.
     *  @memberof GeoGlobe.Geometry.prototype
     * @private
     */
    destroy: function() {
        this.id = null;
        this.bounds = null;
    },
    
    /**

     * 创建这个几何的副本。 不设置副本几何的任何非标准属性。
     *    @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {GeoGlobe.Geometry} 几何的副本。
     */
    clone: function() {
        return new GeoGlobe.Geometry();
    },
    
    /**

     * Set the bounds for this Geometry.
     * @memberof GeoGlobe.Geometry.prototype
     * @param {GeoGlobe.LngLatBounds}bounds
     * @private
     */
    setBounds: function(bounds) {
        if (bounds) {
            this.bounds = bounds.clone();
        }
    },
    
    /**

     * Nullify this components bounds and that of its parent as well.
     * @memberof GeoGlobe.Geometry.prototype
     * @private
     */
    clearBounds: function() {
        this.bounds = null;
        if (this.parent) {
            this.parent.clearBounds();
        }    
    },
    
    /**

     * Extend the existing bounds to include the new bounds. 
     * If geometry's bounds is not yet set, then set a new Bounds.
     * @memberof GeoGlobe.Geometry.prototype
     * @param {GeoGlobe.LngLatBounds}newBounds -
     * @private
     */
    extendBounds: function(newBounds){
        var bounds = this.getBounds();
        if (!bounds) {
            this.setBounds(newBounds);
        } else {
            this.bounds.extend(newBounds);
        }
    },
    
    /**
     * 获取这个几何体的界限。 如果未设置边界，则会再次进行计算，这会使查询更快。
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {GeoGlobe.LngLatBounds}
     */
    getBounds: function() {
        if (this.bounds == null) {
            this.calculateBounds();
        }
        return this.bounds;
    },
    
    /** 

     * 重新计算几何图形的边界。
     * @memberof GeoGlobe.Geometry.prototype
     */
    calculateBounds: function() {
        //
        // This should be overridden by subclasses.
        //
    },
    
    /**

     * 计算两个几何图形之间的最近距离（在x-y平面上）。
     * @memberof GeoGlobe.Geometry.prototype
     * @param {GeoGlobe.Geometry}geometry -  目标几何。
     *  @param {Object}options -  用于配置距离计算的可选属性。
     *
     * 有效的选项取决于特定的几何类型。
     * 
     * @returns
     * {Number | Object} 这个几何与目标之间的距离。 
     * 如果可选参数详细，则返回值将是具有距离x0，y0，x1和x2属性的对象。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
    },
    
    /**

     * 返回此几何中所有点的列表。
     * @memberof GeoGlobe.Geometry.prototype
     * @param {Boolean}nodes -  对于线条，只返回端点的顶点。 
     * 如果为false，则对于线条，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array} 几何中所有顶点的列表。
     */
    getVertices: function(nodes) {
    },

    /**

     * Note - This is only an approximation based on the bounds of the 
     * geometry.
     * @memberof GeoGlobe.Geometry.prototype
     * @param {GeoGlobe.LngLat|Object}lnglat -  GeoGlobe.LngLat or an
     *     object with a 'lng' and 'lat' properties.
     * @param {float} toleranceLon -  Optional tolerance in Geometric Coords
     *  @param {float}toleranceLat -  Optional tolerance in Geographic Coords
     * 
     * @returns
     * {Boolean} Whether or not the geometry is at the specified location
     * @private
     */
    atPoint: function(lnglat, toleranceLon, toleranceLat) {
        var atPoint = false;
        var bounds = this.getBounds();
        if ((bounds != null) && (lnglat != null)) {

            var dX = (toleranceLon != null) ? toleranceLon : 0;
            var dY = (toleranceLat != null) ? toleranceLat : 0;
    		
			var _sw = new GeoGlobe.LngLat(this.bounds._sw.lng - dX, this.bounds._sw.lat - dY);
			var _ne = new GeoGlobe.LngLat(this.bounds._ne.lng + dX, this.bounds._ne.lat + dY);
            var toleranceBounds = new GeoGlobe.LngLatBounds(_sw, _ne);
			/*
                new OpenLayers.Bounds(this.bounds.left - dX,
                                      this.bounds.bottom - dY,
                                      this.bounds.right + dX,
                                      this.bounds.top + dY);
            */

            atPoint = toleranceBounds.containsLonLat(lnglat);
        }
        return atPoint;
    },
    
    /**

     * Calculate the length of this geometry. This method is defined in
     * subclasses.
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {Float} The length of the collection by summing its parts
     * @private
     */
    getLength: function() {
        //to be overridden by geometries that actually have a length
        //
        return 0.0;
    },

    /**

     * Calculate the area of this geometry. This method is defined in subclasses.
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {Float} The area of the collection by summing its parts
     * @private
     */
    getArea: function() {
        //to be overridden by geometries that actually have an area
        //
        return 0.0;
    },
    
    /**

     * 计算这个几何的质心。 这个方法在子类中定义。
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {GeoGlobe.Geometry.Point} 集合的质心。
     */
    getCentroid: function() {
        return null;
    },

    /**

     * Returns a text representation of the geometry.  If the WKT format is
     *     included in a build, this will be the Well-Known Text 
     *     representation.
     * @memberof GeoGlobe.Geometry.prototype
     * @returns
     * {String} String representation of this geometry.
     * @private
     */
    toString: function() {
        var string;
        if (GeoGlobe.Format && GeoGlobe.Format.WKT) {
            string = GeoGlobe.Format.WKT.prototype.write(
                new GeoGlobe.Feature(this)
            );
        } else {
            string = Object.prototype.toString.call(this);
        }
        return string;
    },

    CLASS_NAME: "GeoGlobe.Geometry"
});

/**

 * Generate a geometry given a Well-Known Text string.  For this method to
 *     work, you must include the GeoGlobe.Format.WKT in your build 
 *     explicitly.
 * @memberof GeoGlobe.Geometry.prototype
 * @param {String}wkt -  A string representing the geometry in Well-Known Text.
 *
 * @returns
 * {GeoGlobe.Geometry} A geometry of the appropriate class.
 * @private
 */
GeoGlobe.Geometry.fromWKT = function(wkt) {
    var geom;
    if (GeoGlobe.Format && GeoGlobe.Format.WKT) {
        var format = GeoGlobe.Geometry.fromWKT.format;
        if (!format) {
            format = new GeoGlobe.Format.WKT();
            GeoGlobe.Geometry.fromWKT.format = format;
        }
        var result = format.read(wkt);
        if (result instanceof GeoGlobe.Feature) {
            geom = result.geometry;
        } else if (GeoGlobe.Util.isArray(result)) {
            var len = result.length;
            var components = new Array(len);
            for (var i=0; i<len; ++i) {
                components[i] = result[i].geometry;
            }
            geom = new GeoGlobe.Geometry.Collection(components);
        }
    }
    return geom;
};
    
/**

 * Determine whether two line segments intersect.  Optionally calculates
 *     and returns the intersection point.  This function is optimized for
 *     cases where seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1.  In those
 *     obvious cases where there is no intersection, the function should
 *     not be called.
 * @memberof GeoGlobe.Geometry.prototype
 * @param {Object}seg1 - Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 *  @param {Object}seg2 -  Object representing a segment with properties x1, y1, x2,
 *     and y2.  The start point is represented by x1 and y1.  The end point
 *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.
 *  @param {Object}options - Optional properties for calculating the intersection.
 *
 * Valid options:
 *@param {Boolean} point -  Return the intersection point.  If false, the actual
 *     intersection point will not be calculated.  If true and the segments
 *     intersect, the intersection point will be returned.  If true and
 *     the segments do not intersect, false will be returned.  If true and
 *     the segments are coincident, true will be returned.
 *@param {Number}  tolerance - If a non-null value is provided, if the segments are
 *     within the tolerance distance, this will be considered an intersection.
 *     In addition, if the point option is true and the calculated intersection
 *     is within the tolerance distance of an end point, the endpoint will be
 *     returned instead of the calculated intersection.  Further, if the
 *     intersection is within the tolerance of endpoints on both segments, or
 *     if two segment endpoints are within the tolerance distance of eachother
 *     (but no intersection is otherwise calculated), an endpoint on the
 *     first segment provided will be returned.
 *
 * @returns
 * {Boolean | GeoGlobe.Geometry.Point}  The two segments intersect.
 *     If the point argument is true, the return will be the intersection
 *     point or false if none exists.  If point is true and the segments
 *     are coincident, return will be true (and the instersection is equal
 *     to the shorter segment).
 * @private
 */
GeoGlobe.Geometry.segmentsIntersect = function(seg1, seg2, options) {
    var point = options && options.point;
    var tolerance = options && options.tolerance;
    var intersection = false;
    var x11_21 = seg1.x1 - seg2.x1;
    var y11_21 = seg1.y1 - seg2.y1;
    var x12_11 = seg1.x2 - seg1.x1;
    var y12_11 = seg1.y2 - seg1.y1;
    var y22_21 = seg2.y2 - seg2.y1;
    var x22_21 = seg2.x2 - seg2.x1;
    var d = (y22_21 * x12_11) - (x22_21 * y12_11);
    var n1 = (x22_21 * y11_21) - (y22_21 * x11_21);
    var n2 = (x12_11 * y11_21) - (y12_11 * x11_21);
    if(d == 0) {
        // parallel
        if(n1 == 0 && n2 == 0) {
            // coincident
            intersection = true;
        }
    } else {
        var along1 = n1 / d;
        var along2 = n2 / d;
        if(along1 >= 0 && along1 <= 1 && along2 >=0 && along2 <= 1) {
            // intersect
            if(!point) {
                intersection = true;
            } else {
                // calculate the intersection point
                var x = seg1.x1 + (along1 * x12_11);
                var y = seg1.y1 + (along1 * y12_11);
                intersection = new GeoGlobe.Geometry.Point(x, y);
            }
        }
    }
    if(tolerance) {
        var dist;
        if(intersection) {
            if(point) {
                var segs = [seg1, seg2];
                var seg, x, y;
                // check segment endpoints for proximity to intersection
                // set intersection to first endpoint within the tolerance
                outer: for(var i=0; i<2; ++i) {
                    seg = segs[i];
                    for(var j=1; j<3; ++j) {
                        x = seg["x" + j];
                        y = seg["y" + j];
                        dist = Math.sqrt(
                            Math.pow(x - intersection.x, 2) +
                            Math.pow(y - intersection.y, 2)
                        );
                        if(dist < tolerance) {
                            intersection.x = x;
                            intersection.y = y;
                            break outer;
                        }
                    }
                }
                
            }
        } else {
            // no calculated intersection, but segments could be within
            // the tolerance of one another
            var segs = [seg1, seg2];
            var source, target, x, y, p, result;
            // check segment endpoints for proximity to intersection
            // set intersection to first endpoint within the tolerance
            outer: for(var i=0; i<2; ++i) {
                source = segs[i];
                target = segs[(i+1)%2];
                for(var j=1; j<3; ++j) {
                    p = {x: source["x"+j], y: source["y"+j]};
                    result = GeoGlobe.Geometry.distanceToSegment(p, target);
                    if(result.distance < tolerance) {
                        if(point) {
                            intersection = new GeoGlobe.Geometry.Point(p.x, p.y);
                        } else {
                            intersection = true;
                        }
                        break outer;
                    }
                }
            }
        }
    }
    return intersection;
};

/**

 *@memberof GeoGlobe.Geometry.prototype
 * @param {Object}point -  An object with x and y properties representing the
 *     point coordinates.
 * @param {Object} segment -  An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * @returns
 * {Object} An object with distance, along, x, and y properties.  The distance
 *     will be the shortest distance between the input point and segment.
 *     The x and y properties represent the coordinates along the segment
 *     where the shortest distance meets the segment. The along attribute
 *     describes how far between the two segment points the given point is.
 * @private
 */
GeoGlobe.Geometry.distanceToSegment = function(point, segment) {
    var result = GeoGlobe.Geometry.distanceSquaredToSegment(point, segment);
    result.distance = Math.sqrt(result.distance);
    return result;
};

/**


 * Usually the distanceToSegment function should be used. This variant however
 * can be used for comparisons where the exact distance is not important.
 * @memberof GeoGlobe.Geometry.prototype

 * @param {Object}point - An object with x and y properties representing the
 *     point coordinates.
 * @param {Object}segment -  An object with x1, y1, x2, and y2 properties
 *     representing endpoint coordinates.
 *
 * @returns
 * {Object} An object with squared distance, along, x, and y properties.
 *     The distance will be the shortest distance between the input point and
 *     segment. The x and y properties represent the coordinates along the
 *     segment where the shortest distance meets the segment. The along
 *     attribute describes how far between the two segment points the given
 *     point is.
 * @private
 */
GeoGlobe.Geometry.distanceSquaredToSegment = function(point, segment) {
    var x0 = point.x;
    var y0 = point.y;
    var x1 = segment.x1;
    var y1 = segment.y1;
    var x2 = segment.x2;
    var y2 = segment.y2;
    var dx = x2 - x1;
    var dy = y2 - y1;
    //var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
    //            (Math.pow(dx, 2) + Math.pow(dy, 2));
	var along = (dx == 0 && dy == 0) ? 0 : ((dx * (x0 - x1)) + (dy * (y0 - y1))) /
                (Math.pow(dx, 2) + Math.pow(dy, 2));
    var x, y;
    if(along <= 0.0) {
        x = x1;
        y = y1;
    } else if(along >= 1.0) {
        x = x2;
        y = y2;
    } else {
        x = x1 + along * dx;
        y = y1 + along * dy;
    }
    return {
        distance: Math.pow(x - x0, 2) + Math.pow(y - y0, 2),
        x: x, y: y,
        along: along
    };
};

/**
 * @static
 * 根据geojson的geometry对象，获得GeoGlobe.Geometry对象。
 * @param {Object} json_geometry geojson中的geometry对象。
 * @returns {GeoGlobe.Geometry} 一个几何对象。
 */
GeoGlobe.Geometry.fromGeoJson = function(json_geometry) {
    var geom;
    if (GeoGlobe.Format && GeoGlobe.Format.GeoJSON) {
        format = new GeoGlobe.Format.GeoJSON();
		var result = null;
		try {
	    	//result = format.read(geojson, "Geometry");
            result = format.parseGeometry(json_geometry);
        } catch(err) {
            console.log(err);
        }
		geom = result;
    }
    return geom;
};/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Geometry.Collection
 * @classdesc 几何对象集合类。
 *      几何对象类类，继承GeoGlobe.Geometry
 *
 */
GeoGlobe.Geometry.Collection = GeoGlobe.Class4OL(GeoGlobe.Geometry, {

    /**

     * 这个几何的组成部分
     *  @memberof GeoGlobe.Geometry.Collection.prototype
     *  @type {Array(GeoGlobe.Geometry)}
     *
     */
    components: null,
    
    /**

     *  An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @type {Array(GeoGlobe.Geometry)}
     * @private
     */
    componentTypes: null,

    /**

     * 创建几何集合 - 几何列表。
     *  @memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Array(GeoGlobe.Geometry)} components -  可选几何数组。
     *
     */
    initialize: function (components) {
        GeoGlobe.Geometry.prototype.initialize.apply(this, arguments);
        this.components = [];
        if (components != null) {
            this.addComponents(components);
        }
    },

    /**

     * 搽除这个几何。
     *  @memberof GeoGlobe.Geometry.Collection.prototype
     */
    destroy: function () {
        this.components.length = 0;
        this.components = null;
        GeoGlobe.Geometry.prototype.destroy.apply(this, arguments);
    },

    /**

     *复制这个几何。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @returns
     * {GeoGlobe.Geometry.Collection} 这个集合的副本。
     */
    clone: function() {
        var geometry = eval("new " + this.CLASS_NAME + "()");
        for(var i=0, len=this.components.length; i<len; i++) {
            geometry.addComponent(this.components[i].clone());
        }
        
        // catch any randomly tagged-on properties
        GeoGlobe.Util.applyDefaults(geometry, this);
        
        return geometry;
    },

    /**

     * Get a string representing the components for this collection
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @returns
     * {String} A string representation of the components of this geometry
     * @private
     */
    getComponentsString: function(){
        var strings = [];
        for(var i=0, len=this.components.length; i<len; i++) {
            strings.push(this.components[i].toShortString()); 
        }
        return strings.join(",");
    },

    /**

     * 通过迭代组件和调用每个项目的extendBounds（）来重新计算边界。
     * @memberof GeoGlobe.Geometry.Collection.prototype
     */
    calculateBounds: function() {
        this.bounds = null;
        //var bounds = new OpenLayers.Bounds();
		//var sw = new GeoGlobe.LngLat(this.x, this.y);
		//var ne = new GeoGlobe.LngLat(this.x, this.y);
		//换成mapboxgl的bounds对象
        var bounds = new GeoGlobe.LngLatBounds();
        var components = this.components;
        if (components) {
            for (var i=0, len=components.length; i<len; i++) {
                bounds.extend(components[i].getBounds());
            }
        }
        // to preserve old behavior, we only set bounds if non-null
        // in the future, we could add bounds.isEmpty()
        //if (bounds.left != null && bounds.bottom != null && 
        //    bounds.right != null && bounds.top != null) {
        //    this.setBounds(bounds);
        //}
		
		if(bounds._sw != null && bounds._sw != null && 
			bounds._ne != null && bounds._ne != null){
			if(bounds._sw.lng != null && bounds._sw.lat != null && 
				bounds._ne.lng != null && bounds._ne.lat != null){
				this.setBounds(bounds);
			}
		}
    },

    /**

     *添加组件到这个几何中。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     *
     * @param {Array(GeoGlobe.Geometry)}components -  要添加的几何图形阵列。
     */
    addComponents: function(components){
        if(!(GeoGlobe.Util.isArray(components))) {
            components = [components];
        }
        for(var i=0, len=components.length; i<len; i++) {
            this.addComponent(components[i]);
        }
    },

    /**

     * Add a new component (geometry) to the collection.  If this.componentTypes
     * is set, then the component class name must be in the componentTypes array.
     *
     * The bounds cache is reset.
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @param {GeoGlobe.Geometry} component -  A geometry to add
     * @param {int} index -  Optional index into the array to insert the component
     *
     * @returns
     * {Boolean} The component geometry was successfully added
     * @private
     */    
    addComponent: function(component, index) {
        var added = false;
        if(component) {
            if(this.componentTypes == null ||
               (GeoGlobe.Util.indexOf(this.componentTypes,
                                        component.CLASS_NAME) > -1)) {

                if(index != null && (index < this.components.length)) {
                    var components1 = this.components.slice(0, index);
                    var components2 = this.components.slice(index, 
                                                           this.components.length);
                    components1.push(component);
                    this.components = components1.concat(components2);
                } else {
                    this.components.push(component);
                }
                component.parent = this;
                this.clearBounds();
                added = true;
            }
        }
        return added;
    },
    
    /**

     * 从这个几何中移除组件。
     * @memberof GeoGlobe.Geometry.Collection.prototype

     * @param {Array(GeoGlobe.Geometry)}components -  要删除的组件。
     *
     * @returns
     * {Boolean} 一个组件被删除。
     */
    removeComponents: function(components) {
        var removed = false;

        if(!(GeoGlobe.Util.isArray(components))) {
            components = [components];
        }
        for(var i=components.length-1; i>=0; --i) {
            removed = this.removeComponent(components[i]) || removed;
        }
        return removed;
    },
    
    /**

     * Remove a component from this geometry.
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @param {GeoGlobe.Geometry} component
     *
     * @returns
     * {Boolean} The component was removed.
     * @private
     */
    removeComponent: function(component) {
        
        GeoGlobe.Util.removeItem(this.components, component);
        
        // clearBounds() so that it gets recalculated on the next call
        // to this.getBounds();
        this.clearBounds();
        return true;
    },

    /**

     * 计算这个几何的长度
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @returns
     * {Float} 几何的长度
     */
    getLength: function() {
        var length = 0.0;
        for (var i=0, len=this.components.length; i<len; i++) {
            length += this.components[i].getLength();
        }
        return length;
    },
    

    getArea: function() {
        var area = 0.0;
        for (var i=0, len=this.components.length; i<len; i++) {
            area += this.components[i].getArea();
        }
        return area;
    },

    /** 

     * 计算投影面积。
     *@memberof GeoGlobe.Geometry.Collection.prototype

     * @param {GeoGlobe.Projection} projection -  几何坐标的空间参照系。 如果未提供，则假定为Geographic / WGS84。
     *
     * @returns
     * {float} 单位为平方米的投影面积。
     */
    getGeodesicArea: function(projection) {
        var area = 0.0;
        for(var i=0, len=this.components.length; i<len; i++) {
            area += this.components[i].getGeodesicArea(projection);
        }
        return area;
    },
    
    /**

     *
     * 计算几何的质心。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Boolean}weighted -  递归执行getCentroid计算，返回此集合中所有几何的面积加权平均值。
     *
     * @returns
     * {GeoGlobe.Geometry.Point} 集合的质心。
     */
    getCentroid: function(weighted) {
        if (!weighted) {
            return this.components.length && this.components[0].getCentroid();
        }
        var len = this.components.length;
        if (!len) {
            return false;
        }
        
        var areas = [];
        var centroids = [];
        var areaSum = 0;
        var minArea = Number.MAX_VALUE;
        var component;
        for (var i=0; i<len; ++i) {
            component = this.components[i];
            var area = component.getArea();
            var centroid = component.getCentroid(true);
            if (isNaN(area) || isNaN(centroid.x) || isNaN(centroid.y)) {
                continue;
            }
            areas.push(area);
            areaSum += area;
            minArea = (area < minArea && area > 0) ? area : minArea;
            centroids.push(centroid);
        }
        len = areas.length;
        if (areaSum === 0) {
            // all the components in this collection have 0 area
            // probably a collection of points -- weight all the points the same
            for (var i=0; i<len; ++i) {
                areas[i] = 1;
            }
            areaSum = areas.length;
        } else {
            // normalize all the areas where the smallest area will get
            // a value of 1
            for (var i=0; i<len; ++i) {
                areas[i] /= minArea;
            }
            areaSum /= minArea;
        }
        
        var xSum = 0, ySum = 0, centroid, area;
        for (var i=0; i<len; ++i) {
            centroid = centroids[i];
            area = areas[i];
            xSum += centroid.x * area;
            ySum += centroid.y * area;
        }
        
        return new GeoGlobe.Geometry.Point(xSum/areaSum, ySum/areaSum);
    },

    /**

     * 计算几何投影到地球上的近似长度。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * 几何坐标的空间参照系。 如果未提供，则假定为Geographic / WGS84。
     * @memberof GeoGlobe.Collection.prototype
     * @returns
     * {Float} 几何近似测地线长度（以米为单位）。
     */
    getGeodesicLength: function(projection) {
        var length = 0.0;
        for(var i=0, len=this.components.length; i<len; i++) {
            length += this.components[i].getGeodesicLength(projection);
        }
        return length;
    },

    /**

     * 将给定位移的几何图形沿正x和y轴移动。这将修改几何图形的位置并清除缓存边界。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Float}x - 在正x方向移动几何图形的距离。
     *@param {Float}y -  在正y方向移动几何图形的距离。
     */
    move: function(x, y) {
        for(var i=0, len=this.components.length; i<len; i++) {
            this.components[i].move(x, y);
        }
    },

    /**

     * 围绕某个原点旋转几何图形
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Float}angle -  以度为单位旋转角度（从正X轴逆时针测量）。
     *  @param {GeoGlobe.Geometry.Point}origin -  旋转的中心点。
     */
    rotate: function(angle, origin) {
        for(var i=0, len=this.components.length; i<len; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },

    /**

     * 调整相对于某个原点的几何尺寸。 使用此方法可以实现几何的均匀缩放。
     *@memberof GeoGlobe.Geometry.Collection.prototype

     * @param {Float}scale -  几何缩放的因素。 
     * 比例为2时，每个维度中几何体的大小加倍（例如，线条的长度是两倍，多边形的面积是四倍）。
     *@param {Float}scale -  几何缩放的因素。
      2个原点的比例 - {GeoGlobe.Geometry.Point}调整大小的原点
     * @param {Float} ratio -  x：y的可选比率。 默认比例是1。
     * 
     * @returns
     * {GeoGlobe.Geometry} - 缩放后的几何。
     */
    resize: function(scale, origin, ratio) {
        for(var i=0; i<this.components.length; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },

    /**

     * 计算两个几何图形之间的最近距离（在x-y平面上）。
     *@memberof GeoGlobe.Geometry.Collection.prototype

     * @param {GeoGlobe.Geometry} geometry -  目标几何。
     *  @param {Object} options -  用于配置距离计算的可选属性。
     *
     * 有效选项：
     * details - {Boolean} 详细信息 - {Boolean}根据距离计算返回详细信息。默认为false。
     * edge - {Boolean} 计算从此几何体到目标几何体最近边的距离。 默认值是true。 
     *如果为true，则从完全包含在其中的几何体调用distanceTo目标将导致非零距离。 
     *如果为false，则每当几何图形相交时，调用distanceTo将返回0.如果为false，则无法返回详细信息。
     *
     * @returns
     * {Number | Object} 这个几何与目标之间的距离。
     * 如果有细节要求，返回将是一个距离为x0，y0，x1和y1属性的对象。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result, best, distance;
        var min = Number.POSITIVE_INFINITY;
        for(var i=0, len=this.components.length; i<len; ++i) {
            result = this.components[i].distanceTo(geometry, options);
            distance = details ? result.distance : result;
            if(distance < min) {
                min = distance;
                best = result;
                if(min == 0) {
                    break;
                }
            }
        }
        return best;
    },

    /** 

     *确定另一个几何体是否与此相同。 如果所有组件具有相同的坐标，则几何图形被认为是等同的。
     * @memberof GeoGlobe.Geometry.Collection.prototype
     * @param {GeoGlobe.Geometry} geometry - 几何测试。
     *
     * @returns
     * {Boolean} 提供的几何图形等同于此几何图形。
     */
    equals: function(geometry) {
        var equivalent = true;
        if(!geometry || !geometry.CLASS_NAME ||
           (this.CLASS_NAME != geometry.CLASS_NAME)) {
            equivalent = false;
        } else if(!(GeoGlobe.Util.isArray(geometry.components)) ||
                  (geometry.components.length != this.components.length)) {
            equivalent = false;
        } else {
            for(var i=0, len=this.components.length; i<len; ++i) {
                if(!this.components[i].equals(geometry.components[i])) {
                    equivalent = false;
                    break;
                }
            }
        }
        return equivalent;
    },

    /**

     * 将组件几何图形从源对象重新映射到目标对象。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param  {GeoGlobe.Projection} source -源对象。
     * @param {GeoGlobe.Projection} dest - 目标对象。
     * 
     * @returns
     * {GeoGlobe.Geometry}
     */
    transform: function(source, dest) {
        if (source && dest) {
            for (var i=0, len=this.components.length; i<len; i++) {  
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },

    /**

     * 确定输入几何是否与此几何相交。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {GeoGlobe.Geometry}geometry -  任何类型的几何。
     *
     * @returns
     * {Boolean} 输入几何与此相交。
     */
    intersects: function(geometry) {
        var intersect = false;
        for(var i=0, len=this.components.length; i<len; ++ i) {
            intersect = geometry.intersects(this.components[i]);
            if(intersect) {
                break;
            }
        }
        return intersect;
    },

    /**

     * 返回此几何中所有点的列表。
     *@memberof GeoGlobe.Geometry.Collection.prototype
     * @param {Boolean}nodes -  对于线段，只返回端点的顶点。 
     * 如果为false，则对于线段，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array} 返回几何中所有顶点的列表。
     */
    getVertices: function(nodes) {
        var vertices = [];
        for(var i=0, len=this.components.length; i<len; ++i) {
            Array.prototype.push.apply(
                vertices, this.components[i].getVertices(nodes)
            );
        }
        return vertices;
    },


    CLASS_NAME: "GeoGlobe.Geometry.Collection"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.Point
 * @classdesc 几何点类。
 * 
 * 继承:
 *  - <GeoGlobe.Geometry>
 *      几何点类，继承于GeoGlobe.Geometry
 */
GeoGlobe.Geometry.Point = GeoGlobe.Class4OL(GeoGlobe.Geometry, {

    /** 
     *  x
     *  @memberof GeoGlobe.Geometry.Point.prototype
     *  @type {float}

     */
    x: null,

    /** 
     * y
     * @memberof GeoGlobe.Geometry.Point.prototype
     * @type {float}

     */
    y: null,

    /**

     * 构建点几何。
     *  @memberof GeoGlobe.Geometry.Point.prototype
     * @param {float}x - x坐标。
     * @param {float}y - y坐标。
     * 
     */
    initialize: function(x, y) {
        GeoGlobe.Geometry.prototype.initialize.apply(this, arguments);
        
        this.x = parseFloat(x);
        this.y = parseFloat(y);
    },

    /**

     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @returns
     * {GeoGlobe.Geometry.Point} 对GeoGlobe.Geometry.Point进行完全复制。
     */
    clone: function(obj) {
        if (obj == null) {
            obj = new GeoGlobe.Geometry.Point(this.x, this.y);
        }

        // catch any randomly tagged-on properties
        GeoGlobe.Util.applyDefaults(obj, this);

        return obj;
    },

    /** 

     * Create a new Bounds based on the lon/lat
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @private
     */
    calculateBounds: function () {
        //this.bounds = new OpenLayers.Bounds(this.x, this.y, this.x, this.y);
		var sw = new GeoGlobe.LngLat(this.x, this.y);
		var ne = new GeoGlobe.LngLat(this.x, this.y);
        this.bounds = new GeoGlobe.LngLatBounds(sw, ne);
											
    },

    /**

     * 计算两个点之间的最近距离（在x-y平面上）。
     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {GeoGlobe.Geometry}geometry -  目标几何。
     * @param {Object} options -  用于配置距离计算的可选属性。
     *
     * 有效选项：
     * details - {Boolean} 从距离计算中返回细节。默认为false。
     * edge - {Boolean} 计算从此点到目标点最近的距离。 默认值是true。 

     *
     * @returns
     * {Number | Object} 这个点与目标点之间的距离。
     * 如果细节是真的，返回将是一个距离为x0，y0，x1和x2属性的物体。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var distance, x0, y0, x1, y1, result;
        if(geometry instanceof GeoGlobe.Geometry.Point) {
            x0 = this.x;
            y0 = this.y;
            x1 = geometry.x;
            y1 = geometry.y;
            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
            result = !details ?
                distance : {x0: x0, y0: y0, x1: x1, y1: y1, distance: distance};
        } else {
            result = geometry.distanceTo(this, options);
            if(details) {
                // switch coord order since this geom is target
                result = {
                    x0: result.x1, y0: result.y1,
                    x1: result.x0, y1: result.y0,
                    distance: result.distance
                };
            }
        }
        return result;
    },
    
    /** 

     * 确定另一个点是否与此相同。 如果所有点具有相同的坐标，则这些点被认为是等同的。
     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {GeoGlobe.Geometry.Point}geom -  The geometry to test.
     *
     * @returns
     * {Boolean} 提供的点等同于此点。
     */
    equals: function(geom) {
        var equals = false;
        if (geom != null) {
            equals = ((this.x == geom.x && this.y == geom.y) ||
                      (isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y)));
        }
        return equals;
    },
    
    /**

     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @returns
     * {String} Shortened String representation of Point object. 
     *         (ex. <i>"5, 42"</i>)
     * @private
     */
    toShortString: function() {
        return (this.x + ", " + this.y);
    },
    
    /**

     * 将给定位移的点沿正x和y轴移动。这将修改点的位置并清除缓存边界。
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {Float}x -  Distance to move geometry in positive x direction.
     * @param {Float}y -  Distance to move geometry in positive y direction.
     */
    move: function(x, y) {
        this.x = this.x + x;
        this.y = this.y + y;
        this.clearBounds();
    },

    /**

     * 围绕另一个点进行旋转。
     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {Float}angle -  以度为单位旋转角度（从正X轴逆时针测量）
     * @param {GeoGlobe.Geometry.Point}origin -  旋转的中心点。
     */
    rotate: function(angle, origin) {
        angle *= Math.PI / 180;
        var radius = this.distanceTo(origin);
        var theta = angle + Math.atan2(this.y - origin.y, this.x - origin.x);
        this.x = origin.x + (radius * Math.cos(theta));
        this.y = origin.y + (radius * Math.sin(theta));
        this.clearBounds();
    },
    
    /**

     *@memberof GeGeoGlobe.Geometry.Point.prototype
     * @returns
     * {GeoGlobe.Geometry.Point} 集合的质心
     */
    getCentroid: function() {
        return new GeoGlobe.Geometry.Point(this.x, this.y);
    },

    /**

     * 调整相对于某个原点的点的大小。 
     * 对于点，这具有缩放矢量（从原点到点）的效果。 
     * 这个方法对几何集合子类更有用。
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {Float} scale -  从原点到原点距离的新距离之比。 2的刻度将点与原点之间的距离加倍。
     * @param {GeoGlobe.Geometry.Point} origin -  调整的原点的大小。
     * @param {Float}ratio -  用于调整大小的可选x：y比率。 默认比例是1。
     * 
     * @returns
     * {GeoGlobe.Geometry} - 当前点。
     */
    resize: function(scale, origin, ratio) {
        ratio = (ratio == undefined) ? 1 : ratio;
        this.x = origin.x + (scale * ratio * (this.x - origin.x));
        this.y = origin.y + (scale * (this.y - origin.y));
        this.clearBounds();
        return this;
    },
    
    /**

     * 确定输入的点是否与此重合。
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {GeoGlobe.Geometry}geometry -  任何类型的几何。
     *
     * @returns
     * {Boolean} 输入点与此是否重合。
     */
    intersects: function(geometry) {
        var intersect = false;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.equals(geometry);
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    
    /**

     * 将该点的x，y属性从源代码转换为目标代码。
     *  @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {GeoGlobe.SpatialReference} source
     * @param {GeoGlobe.SpatialReference} dest
     * 
     * @returns
     * {GeoGlobe.Geometry}
     */
    transform: function(source, dest) {
        if ((source && dest)) {
            GeoGlobe.SpatialReference.transform(
                this, source, dest); 
            this.bounds = null;
        }       
        return this;
    },

    /**

     * 返回此几何中所有点的列表。
     * @memberof GeGeoGlobe.Geometry.Point.prototype
     * @param {Boolean}nodes -  对于线条，只返回端点的顶点。 
     * 如果为false，则对于线条，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array} 几何体中所有顶点的列表。
     */
    getVertices: function(nodes) {
        return [this];
    },

    CLASS_NAME: "GeoGlobe.Geometry.Point"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.MultiPoint
 * @classdesc 点集合几何对象类。
 *
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection>
 *  - <GeoGlobe.Geometry>
 *  点集合几何对象类，继承于GeoGlobe.Geometry.Collection和GeoGlobe.Geometry
 */
GeoGlobe.Geometry.MultiPoint = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**
     * An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     * @memberof  GeoGlobe.Geometry.MultiPoint.prototype
     * @type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**
     * 创建一个新的多点几何。
     * @memberof  GeoGlobe.Geometry.MultiPoint.prototype
     * @param {Array(GeoGlobe.Geometry.Point)}components
     *
     * @returns
     * {GeoGlobe.Geometry.MultiPoint}
     */

    /**

     * 包装为 <GeoGlobe.Geometry.Collection.addComponent>
     *  @memberof  GeoGlobe.Geometry.MultiPoint.prototype
     * @param {GeoGlobe.Geometry.Point}point -  要添加的点。
     * @param {Integer} index -  可选索引。
     */
    addPoint: function(point, index) {
        this.addComponent(point, index);
    },
    
    /**

     * 包装为<GeoGlobe.Geometry.Collection.removeComponent>
     * @memberof  GeoGlobe.Geometry.MultiPoint.prototype
     * @param {GeoGlobe.Geometry.Point}point -  要删除的点。
     */
    removePoint: function(point){
        this.removeComponent(point);
    },

    CLASS_NAME: "GeoGlobe.Geometry.MultiPoint"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.Curve
 * @classdesc 曲线几何对象类，由多个几何点组成。
 * 
 * Inherits: 
 *  - <GeoGlobe.Geometry.MultiPoint>
 *      曲线对象类。继承于GeoGlobe.Geometry.MultiPoint
 */
GeoGlobe.Geometry.Curve = GeoGlobe.Class4OL(GeoGlobe.Geometry.MultiPoint, {

    /**

     *  An array of class names representing the types of
     *                 components that the collection can include.  A null 
     *                 value means the component types are not restricted.
     *@memberof GeoGlobe.Geometry.Curve.prototype
     *@type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**

     *  @memberof GeoGlobe.Geometry.Curve.prototype
     * @param {Array(GeoGlobe.Geometry.Point)}point
     */
    
    /**

     * @memberof GeoGlobe.Geometry.Curve.prototype
     * @returns
     * {Float} 曲线的长度。
     */
    getLength: function() {
        var length = 0.0;
        if ( this.components && (this.components.length > 1)) {
            for(var i=1, len=this.components.length; i<len; i++) {
                length += this.components[i-1].distanceTo(this.components[i]);
            }
        }
        return length;
    },

    /**

     * 计算几何投影长度。
     * @memberof GeoGlobe.Geometry.Curve.prototype
     * 几何坐标的空间参照系。 如果未提供，则假定为Geographic / WGS84。
     *  @memberof GeoGlobe.Geometry.Curve.prototype
     * @returns
     * {Float} 几何的投影长度（以米为单位）。
     */
    getGeodesicLength: function(projection) {
        var geom = this;  // so we can work with a clone if needed
        if(projection) {
            var gg = new GeoGlobe.SpatialReference("EPSG:4326");
            //var gg = new OpenLayers.Projection("EPSG:4326");
            if(!gg.equals(projection)) {
                geom = this.clone().transform(projection, gg);
            }
        }
        var length = 0.0;
        if(geom.components && (geom.components.length > 1)) {
            var p1, p2;
            for(var i=1, len=geom.components.length; i<len; i++) {
                p1 = geom.components[i-1];
                p2 = geom.components[i];
                // this returns km and requires lon/lat properties
                length += GeoGlobe.Util.distVincenty(
                    {lng: p1.x, lat: p1.y}, {lng: p2.x, lat: p2.y}
                );
            }
        }
        // convert to m
        return length * 1000;
    },

    CLASS_NAME: "GeoGlobe.Geometry.Curve"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Geometry.LineString
 * @classdesc 非闭合线几何对象类。
 * 
 * 继承:
 *  - <GeoGlobe.Geometry.Curve>
 *      非闭合线几何对象类，继承于GeoGlobe.Geometry.Curve
 */
GeoGlobe.Geometry.LineString = GeoGlobe.Class4OL(GeoGlobe.Geometry.Curve, {

    /**

     * 创建一个新的LineString几何
     *  @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {Array(GeoGlobe.Geometry.Point)}points -  用于生成线条的点集合。
     *
     */

    /**

     * 如果线串中有三个或更多点，则只允许删除一个点。 （否则结果将只是一个点）
     *   @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {GeoGlobe.Geometry.Point}point - 要删除的要点
     *
     * @returns
     * {Boolean} 该组件被删除。
     */
    removeComponent: function(point) {
        var removed = this.components && (this.components.length > 2);
        if (removed) {
            GeoGlobe.Geometry.Collection.prototype.removeComponent.apply(this, 
                                                                  arguments);
        }
        return removed;
    },
    
    /**

     *测试两个几何体之间的交叉。
     * @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {GeoGlobe.Geometry}geometry - 几何参数
     *
     * @returns
     * {Boolean} 输入几何体与该几何体相交。
     */
    intersects: function(geometry) {
        var intersect = false;
        var type = geometry.CLASS_NAME;
        if(type == "GeoGlobe.Geometry.LineString" ||
           type == "GeoGlobe.Geometry.LinearRing" ||
           type == "GeoGlobe.Geometry.Point") {
            var segs1 = this.getSortedSegments();
            var segs2;
            if(type == "GeoGlobe.Geometry.Point") {
                segs2 = [{
                    x1: geometry.x, y1: geometry.y,
                    x2: geometry.x, y2: geometry.y
                }];
            } else {
                segs2 = geometry.getSortedSegments();
            }
            var seg1, seg1x1, seg1x2, seg1y1, seg1y2,
                seg2, seg2y1, seg2y2;
            // sweep right
            outer: for(var i=0, len=segs1.length; i<len; ++i) {
                seg1 = segs1[i];
                seg1x1 = seg1.x1;
                seg1x2 = seg1.x2;
                seg1y1 = seg1.y1;
                seg1y2 = seg1.y2;
                inner: for(var j=0, jlen=segs2.length; j<jlen; ++j) {
                    seg2 = segs2[j];
                    if(seg2.x1 > seg1x2) {
                        // seg1 still left of seg2
                        break;
                    }
                    if(seg2.x2 < seg1x1) {
                        // seg2 still left of seg1
                        continue;
                    }
                    seg2y1 = seg2.y1;
                    seg2y2 = seg2.y2;
                    if(Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {
                        // seg2 above seg1
                        continue;
                    }
                    if(Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {
                        // seg2 below seg1
                        continue;
                    }
                    if(GeoGlobe.Geometry.segmentsIntersect(seg1, seg2)) {
                        intersect = true;
                        break outer;
                    }
                }
            }
        } else {
            intersect = geometry.intersects(this);
        }
        return intersect;
    },
    
    /**

     *   @memberof GeoGlobe.Geometry.LineString.prototype
     * @returns
     * {Array} An array of segment objects.  Segment objects have properties
     *     x1, y1, x2, and y2.  The start point is represented by x1 and y1.
     *     The end point is represented by x2 and y2.  Start and end are
     *     ordered so that x1 < x2.
     * @private
     */
    getSortedSegments: function() {
        var numSeg = this.components.length - 1;
        var segments = new Array(numSeg), point1, point2;
        for(var i=0; i<numSeg; ++i) {
            point1 = this.components[i];
            point2 = this.components[i + 1];
            if(point1.x < point2.x) {
                segments[i] = {
                    x1: point1.x,
                    y1: point1.y,
                    x2: point2.x,
                    y2: point2.y
                };
            } else {
                segments[i] = {
                    x1: point2.x,
                    y1: point2.y,
                    x2: point1.x,
                    y2: point1.y
                };
            }
        }
        // more efficient to define this somewhere static
        function byX1(seg1, seg2) {
            return seg1.x1 - seg2.x1;
        }
        return segments.sort(byX1);
    },
    
    /**

     * Split this geometry with the given segment.
     *  @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {Object}seg -An object with x1, y1, x2, and y2 properties referencing
     *     segment endpoint coordinates.
     * @param {Object}options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source segment must be within the
     *     tolerance distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of one of the source segment's
     *     endpoints will be assumed to occur at the endpoint.
     *
     * @returns
     * {Object} An object with *lines* and *points* properties.  If the given
     *     segment intersects this linestring, the lines array will reference
     *     geometries that result from the split.  The points array will contain
     *     all intersection points.  Intersection points are sorted along the
     *     segment (in order from x1,y1 to x2,y2).
     * @private
     */
    splitWithSegment: function(seg, options) {
        var edge = !(options && options.edge === false);
        var tolerance = options && options.tolerance;
        var lines = [];
        var verts = this.getVertices();
        var points = [];
        var intersections = [];
        var split = false;
        var vert1, vert2, point;
        var node, vertex, target;
        var interOptions = {point: true, tolerance: tolerance};
        var result = null;
        for(var i=0, stop=verts.length-2; i<=stop; ++i) {
            vert1 = verts[i];
            points.push(vert1.clone());
            vert2 = verts[i+1];
            target = {x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y};
            point = GeoGlobe.Geometry.segmentsIntersect(
                seg, target, interOptions
            );
            if(point instanceof GeoGlobe.Geometry.Point) {
                if((point.x === seg.x1 && point.y === seg.y1) ||
                   (point.x === seg.x2 && point.y === seg.y2) ||
                   point.equals(vert1) || point.equals(vert2)) {
                    vertex = true;
                } else {
                    vertex = false;
                }
                if(vertex || edge) {
                    // push intersections different than the previous
                    if(!point.equals(intersections[intersections.length-1])) {
                        intersections.push(point.clone());
                    }
                    if(i === 0) {
                        if(point.equals(vert1)) {
                            continue;
                        }
                    }
                    if(point.equals(vert2)) {
                        continue;
                    }
                    split = true;
                    if(!point.equals(vert1)) {
                        points.push(point);
                    }
                    lines.push(new GeoGlobe.Geometry.LineString(points));
                    points = [point.clone()];
                }
            }
        }
        if(split) {
            points.push(vert2.clone());
            lines.push(new GeoGlobe.Geometry.LineString(points));
        }
        if(intersections.length > 0) {
            // sort intersections along segment
            var xDir = seg.x1 < seg.x2 ? 1 : -1;
            var yDir = seg.y1 < seg.y2 ? 1 : -1;
            result = {
                lines: lines,
                points: intersections.sort(function(p1, p2) {
                    return (xDir * p1.x - xDir * p2.x) || (yDir * p1.y - yDir * p2.y);
                })
            };
        }
        return result;
    },

    /**

     * Use this geometry (the source) to attempt to split a target geometry.
     *  @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {GeoGlobe.Geometry}target -  The target geometry.
     * @param {Object} options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * @returns
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     * @private
     */
    split: function(target, options) {
        var results = null;
        var mutual = options && options.mutual;
        var sourceSplit, targetSplit, sourceParts, targetParts;
        if(target instanceof GeoGlobe.Geometry.LineString) {
            var verts = this.getVertices();
            var vert1, vert2, seg, splits, lines, point;
            var points = [];
            sourceParts = [];
            for(var i=0, stop=verts.length-2; i<=stop; ++i) {
                vert1 = verts[i];
                vert2 = verts[i+1];
                seg = {
                    x1: vert1.x, y1: vert1.y,
                    x2: vert2.x, y2: vert2.y
                };
                targetParts = targetParts || [target];
                if(mutual) {
                    points.push(vert1.clone());
                }
                for(var j=0; j<targetParts.length; ++j) {
                    splits = targetParts[j].splitWithSegment(seg, options);
                    if(splits) {
                        // splice in new features
                        lines = splits.lines;
                        if(lines.length > 0) {
                            lines.unshift(j, 1);
                            Array.prototype.splice.apply(targetParts, lines);
                            j += lines.length - 2;
                        }
                        if(mutual) {
                            for(var k=0, len=splits.points.length; k<len; ++k) {
                                point = splits.points[k];
                                if(!point.equals(vert1)) {
                                    points.push(point);
                                    sourceParts.push(new GeoGlobe.Geometry.LineString(points));
                                    if(point.equals(vert2)) {
                                        points = [];
                                    } else {
                                        points = [point.clone()];
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if(mutual && sourceParts.length > 0 && points.length > 0) {
                points.push(vert2.clone());
                sourceParts.push(new GeoGlobe.Geometry.LineString(points));
            }
        } else {
            results = target.splitWith(this, options);
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetSplit || sourceSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    /**

     * Split this geometry (the target) with the given geometry (the source).
     *  @memberof GeoGlobe.Geometry.LineString.prototype
     * @param {GeoGlobe.Geometry}geometry -  A geometry used to split this
     *     geometry (the source).
     * @param {Object} options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * @returns
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     * @private
     */
    splitWith: function(geometry, options) {
        return geometry.split(this, options);

    },

    /**

     *返回此几何中所有点的列表。
     * @memberof GeoGlobe.Geometry.LineString.prototype

     * @param {Boolean} nodes -  对于线条，只返回端点的顶点。 
     * 如果为false，则对于线条，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array} 几何中所有顶点的列表。
     */
    getVertices: function(nodes) {
        var vertices;
        if(nodes === true) {
            vertices = [
                this.components[0],
                this.components[this.components.length-1]
            ];
        } else if (nodes === false) {
            vertices = this.components.slice(1, this.components.length-1);
        } else {
            vertices = this.components.slice();
        }
        return vertices;
    },

    /**

     * 计算两个几何图形之间的最近距离（在x-y平面上）。
     *  @memberof GeoGlobe.Geometry.LineString.prototype

     * @param {GeoGlobe.Geometry}geometry -  目标几何。
     * @param {Object}options -  用于配置距离的可选属性计算。
     *
     * 有效选项：
     * details - {Boolean} 从距离计算中返回细节。默认为false。
     * edge - {Boolean} 计算从此几何体到目标几何体最近边的距离。 
     *
     * @returns
     * {Number | Object} 这个几何与目标之间的距离。 
     * 如果细节为真，则返回值将是具有距离x0，y0，x1和x2属性的对象。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var details = edge && options && options.details;
        var result, best = {};
        var min = Number.POSITIVE_INFINITY;
        if(geometry instanceof GeoGlobe.Geometry.Point) {
            var segs = this.getSortedSegments();
            var x = geometry.x;
            var y = geometry.y;
            var seg;
            for(var i=0, len=segs.length; i<len; ++i) {
                seg = segs[i];
                result = GeoGlobe.Geometry.distanceToSegment(geometry, seg);
                if(result.distance < min) {
                    min = result.distance;
                    best = result;
                    if(min === 0) {
                        break;
                    }
                } else {
                    // if distance increases and we cross y0 to the right of x0, no need to keep looking.
                    if(seg.x2 > x && ((y > seg.y1 && y < seg.y2) || (y < seg.y1 && y > seg.y2))) {
                        break;
                    }
                }
            }
            if(details) {
                best = {
                    distance: best.distance,
                    x0: best.x, y0: best.y,
                    x1: x, y1: y
                };
            } else {
                best = best.distance;
            }
        } else if(geometry instanceof GeoGlobe.Geometry.LineString) { 
            var segs0 = this.getSortedSegments();
            var segs1 = geometry.getSortedSegments();
            var seg0, seg1, intersection, x0, y0;
            var len1 = segs1.length;
            var interOptions = {point: true};
            outer: for(var i=0, len=segs0.length; i<len; ++i) {
                seg0 = segs0[i];
                x0 = seg0.x1;
                y0 = seg0.y1;
                for(var j=0; j<len1; ++j) {
                    seg1 = segs1[j];
                    intersection = GeoGlobe.Geometry.segmentsIntersect(seg0, seg1, interOptions);
                    if(intersection) {
                        min = 0;
                        best = {
                            distance: 0,
                            x0: intersection.x, y0: intersection.y,
                            x1: intersection.x, y1: intersection.y
                        };
                        break outer;
                    } else {
                        result = GeoGlobe.Geometry.distanceToSegment({x: x0, y: y0}, seg1);
                        if(result.distance < min) {
                            min = result.distance;
                            best = {
                                distance: min,
                                x0: x0, y0: y0,
                                x1: result.x, y1: result.y
                            };
                        }
                    }
                }
            }
            if(!details) {
                best = best.distance;
            }
            if(min !== 0) {
                // check the final vertex in this line's sorted segments
                if(seg0) {
                    result = geometry.distanceTo(
                        new GeoGlobe.Geometry.Point(seg0.x2, seg0.y2),
                        options
                    );
                    var dist = details ? result.distance : result;
                    if(dist < min) {
                        if(details) {
                            best = {
                                distance: min,
                                x0: result.x1, y0: result.y1,
                                x1: result.x0, y1: result.y0
                            };
                        } else {
                            best = dist;
                        }
                    }
                }
            }
        } else {
            best = geometry.distanceTo(this, options);
            // swap since target comes from this line
            if(details) {
                best = {
                    distance: best.distance,
                    x0: best.x1, y0: best.y1,
                    x1: best.x0, y1: best.y0
                };
            }
        }
        return best;
    },
    
    /**

     * 该函数将返回一个简化的LineString。
     * 简化基于Douglas-Peucker算法。
     * @memberof GeoGlobe.Geometry.LineString.prototype
     *
     * @param {number}tolerance -  地图单元简化的门槛。
     *
     * @returns
     * {GeoGlobe.Geometry.LineString} 简化的LineString。
     */
    simplify: function(tolerance){
        if (this && this !== null) {
            var points = this.getVertices();
            if (points.length < 3) {
                return this;
            }
    
            var compareNumbers = function(a, b){
                return (a-b);
            };
    
            /**
             * Private function doing the Douglas-Peucker reduction
             */
            var douglasPeuckerReduction = function(points, firstPoint, lastPoint, tolerance){
                var maxDistance = 0;
                var indexFarthest = 0;
    
                for (var index = firstPoint, distance; index < lastPoint; index++) {
                    distance = perpendicularDistance(points[firstPoint], points[lastPoint], points[index]);
                    if (distance > maxDistance) {
                        maxDistance = distance;
                        indexFarthest = index;
                    }
                }
    
                if (maxDistance > tolerance && indexFarthest != firstPoint) {
                    //Add the largest point that exceeds the tolerance
                    pointIndexsToKeep.push(indexFarthest);
                    douglasPeuckerReduction(points, firstPoint, indexFarthest, tolerance);
                    douglasPeuckerReduction(points, indexFarthest, lastPoint, tolerance);
                }
            };
    
            /**
             * Private function calculating the perpendicular distance
             * TODO: check whether GeoGlobe.Geometry.LineString::distanceTo() is faster or slower
             */
            var perpendicularDistance = function(point1, point2, point){
                //Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle
                //Base = v((x1-x2)²+(x1-x2)²)                               *Base of Triangle*
                //Area = .5*Base*H                                          *Solve for height
                //Height = Area/.5/Base
    
                var area = Math.abs(0.5 * (point1.x * point2.y + point2.x * point.y + point.x * point1.y - point2.x * point1.y - point.x * point2.y - point1.x * point.y));
                var bottom = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
                var height = area / bottom * 2;
    
                return height;
            };
    
            var firstPoint = 0;
            var lastPoint = points.length - 1;
            var pointIndexsToKeep = [];
    
            //Add the first and last index to the keepers
            pointIndexsToKeep.push(firstPoint);
            pointIndexsToKeep.push(lastPoint);
    
            //The first and the last point cannot be the same
            while (points[firstPoint].equals(points[lastPoint])) {
                lastPoint--;
                //Addition: the first point not equal to first point in the LineString is kept as well
                pointIndexsToKeep.push(lastPoint);
            }
    
            douglasPeuckerReduction(points, firstPoint, lastPoint, tolerance);
            var returnPoints = [];
            pointIndexsToKeep.sort(compareNumbers);
            for (var index = 0; index < pointIndexsToKeep.length; index++) {
                returnPoints.push(points[pointIndexsToKeep[index]]);
            }
            return new GeoGlobe.Geometry.LineString(returnPoints);
    
        }
        else {
            return this;
        }
    },

    CLASS_NAME: "GeoGlobe.Geometry.LineString"
});

/**

 * 创建一个弧线几何对象。
 *   @memberof GeoGlobe.Geometry.LineString.prototype
 * @param {Array(GeoGlobe.Geometry.Point)}points - 弧线的端点。
 */
GeoGlobe.Geometry.LineString.createCurveLine = function(points){
    var curvePoints = [];
	for (var i = 0; i < points.length - 1; i++) {
        var curveCoordinates = GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints(points[i], points[i + 1]);
        if (curveCoordinates && curveCoordinates.length > 0) {
            curvePoints = curvePoints.concat(curveCoordinates);
        }
    }
    var lineString = new GeoGlobe.Geometry.LineString(curvePoints);
    return lineString;
};

/**

 * 根据弧线的两个端点获取曲线的坐标。
 * @memberof GeoGlobe.Geometry.LineString.prototype
 * @param {GeoGlobe.Geometry.Point}point1 -  弧线的一端点。
 * @param {GeoGlobe.Geometry.Point}point2 - 弧线的另一端点。
 * @private
 */
GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints = function(point1, point2){
    if (!point1 || !point2 || !(point1 instanceof GeoGlobe.Geometry.Point) || !(point2 instanceof GeoGlobe.Geometry.Point)) {
        return null;
    }
    var o = function(h){
        return 1 - 2 * h + h * h;
    };
    var n = function(h){
        return 2 * h - 2 * h * h;
    };
    var m = function(h){
        return h * h;
    };
    curveCoordinates = [];
    var k = 30;
    var x = false;
    var r, y, l, e, A, u, p;
    var s = [];
    var v = 0;
    var q = 0;
    if (typeof(point2) == "undefined") {
        if (typeof(curveCoordinates) != "undefined") {
            curveCoordinates = [];
        }
        return;
    }
    var g = parseFloat(point1.y);
    var f = parseFloat(point2.y);
    var C = parseFloat(point1.x);
    var B = parseFloat(point2.x);
    if (B > C) {
        if (parseFloat(B - C) > 180) {
            if (C < 0) {
                C = parseFloat(180 + 180 + C);
            }
        }
    }
    if (C > B) {
        if (parseFloat(C - B) > 180) {
            if (B < 0) {
                B = parseFloat(180 + 180 + B);
            }
        }
    }
    u = 0;
    p = 0;
    if (f == g) {
        r = 0;
        y = C - B;
    }
    else {
        if (B == C) {
            r = Math.PI / 2;
            y = g - f;
        }
        else {
            r = Math.atan((f - g) / (B - C));
            y = (f - g) / Math.sin(r);
        }
    }
    if (p == 0) {
        p = (r + (Math.PI / 5));
    }
    l = y / 2;
    A = l * Math.cos(p) + C;
    e = l * Math.sin(p) + g;
    for (v = 0; v < k + 1; v++) {
        curveCoordinates.push(new GeoGlobe.Geometry.Point((C * o(q) + A * n(q)) + B * m(q), (g * o(q) + e * n(q) + f * m(q))));
        q = q + (1 / k);
    }
    return curveCoordinates;
};/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.LinearRing
 *
 * @classdesc 闭合线几何对象类(起点与终点重合的线)。
 * 
 * 继承:
 *  - <GeoGlobe.Geometry.LineString>
 *      闭合线几何对象类，继承于GeoGlobe.Geometry.LineString
 */
GeoGlobe.Geometry.LinearRing = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.LineString, {

    /**

     * An array of class names representing the types of
     *                 components that the collection can include.  A null 
     *                 value means the component types are not restricted.
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.Point"],

    /**

     * 线性环由一系列点构成。 这个数组可以表示一个封闭或开放的环。 
     * 如果环是开放的（最后一点不等于第一个点），构造函数将关闭环。 
     * 如果环已经关闭（最后一个点与第一个点相等），它将保持关闭。
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Array(GeoGlobe.Geometry.Point)}points -  点
     */

    /**

     * 向几何组件添加一个点。 
     * 如果要将点添加到组件数组的末尾，并且该点与该数组中已有的最后一个点相同，则不会添加重复点。 
     * 如果它尚未关闭，这将产生关闭环的效果，并且如果它已经关闭，则做正确的事情。 
     * 通过调用具有非空索引的方法作为第二个参数，可以覆盖此行为。
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.Geometry.Point}point - 插入点。
     * @param {Integer}index -  插入数组中的索引以插入组件。
     * 
     * @returns
     * {Boolean} 该点是否成功添加？
     */
    addComponent: function(point, index) {
        var added = false;

        //remove last point
        var lastPoint = this.components.pop();

        // given an index, add the point
        // without an index only add non-duplicate points
        if(index != null || !point.equals(lastPoint)) {
            added = GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                    arguments);
        }

        //append copy of first point
        var firstPoint = this.components[0];
        GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                [firstPoint]);
        
        return added;
    },
    
    /**

     * 从几何组件中移除一个点。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.Geometry.Point} point - 要插入的点。
     *
     * @returns
     * {Boolean} 该组件被删除。
     */
    removeComponent: function(point) {
        var removed = this.components && (this.components.length > 3);
        if (removed) {
            //remove last point
            this.components.pop();
            
            //remove our point
            GeoGlobe.Geometry.Collection.prototype.removeComponent.apply(this, 
                                                                    arguments);
            //append copy of first point
            var firstPoint = this.components[0];
            GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, 
                                                                [firstPoint]);
        }
        return removed;
    },
    
    /**

     * 将给定位移的几何图形沿正x和y轴移动。这将修改几何图形的位置并清除缓存边界。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Float}x -  在正x方向移动几何图形的距离。
     *  @param {Float}y - 在正y方向移动几何图形的距离。
     */
    move: function(x, y) {
        for(var i = 0, len=this.components.length; i<len - 1; i++) {
            this.components[i].move(x, y);
        }
    },

    /**

     * 围绕某个原点旋转几何图形。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Float}angle -  以度为单位旋转角度（从正X轴逆时针测量）。
     *  @param {GeoGlobe.Geometry.Point}origin -  旋转的中心点。
     */
    rotate: function(angle, origin) {
        for(var i=0, len=this.components.length; i<len - 1; ++i) {
            this.components[i].rotate(angle, origin);
        }
    },

    /**

     * 调整相对于某个原点的几何尺寸。 使用此方法可将几何均匀缩放。
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Float}scale -  几何缩放因子。 
     * 比例尺2是每个尺寸中几何体的尺寸的两倍（例如，线的长度是两倍，多边形的面积是四倍）。
     * @param {GeoGlobe.Geometry.Point} origin -  调整原点。
     *  @param {Float}ratio -  x：y比率。 默认比例是1。
     * 
     * @returns
     * {GeoGlobe.Geometry} - 调整后的几何。
     */
    resize: function(scale, origin, ratio) {
        for(var i=0, len=this.components.length; i<len - 1; ++i) {
            this.components[i].resize(scale, origin, ratio);
        }
        return this;
    },
    
    /**

     * 将组件几何图形从源对象重新映射到目标对象。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.SpatialReference}source - 源对象。
     * @param {GeoGlobe.SpatialReference}dest - 目标对象。
     * 
     * @returns
     * {GeoGlobe.Geometry}
     */
    transform: function(source, dest) {
        if (source && dest) {
            for (var i=0, len=this.components.length; i<len - 1; i++) {
                var component = this.components[i];
                component.transform(source, dest);
            }
            this.bounds = null;
        }
        return this;
    },
    
    /**
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @returns
     * {GeoGlobe.Geometry.Point} 集合的质心。
     */
    getCentroid: function() {
        if (this.components) {
            var len = this.components.length;
            if (len > 0 && len <= 2) {
                return this.components[0].clone();
            } else if (len > 2) {
                var sumX = 0.0;
                var sumY = 0.0;
                var x0 = this.components[0].x;
                var y0 = this.components[0].y;
                var area = -1 * this.getArea();
                if (area != 0) {
                    for (var i = 0; i < len - 1; i++) {
                        var b = this.components[i];
                        var c = this.components[i+1];
                        sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                        sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));
                    }
                    var x = x0 + sumX / (6 * area);
                    var y = y0 + sumY / (6 * area);
                } else {
                    for (var i = 0; i < len - 1; i++) {
                        sumX += this.components[i].x;
                        sumY += this.components[i].y;
                    }
                    var x = sumX / (len - 1);
                    var y = sumY / (len - 1);
                }
                return new GeoGlobe.Geometry.Point(x, y);
            } else {
                return null;
            }
        }
    },

    /**

     * 注 - 如果多边形是CW方向，则该区域为正值，否则为负值。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @returns
     * {Float} 环的标志区域。
     */
    getArea: function() {
        var area = 0.0;
        if ( this.components && (this.components.length > 2)) {
            var sum = 0.0;
            for (var i=0, len=this.components.length; i<len - 1; i++) {
                var b = this.components[i];
                var c = this.components[i+1];
                sum += (b.x + c.x) * (c.y - b.y);
            }
            area = - sum / 2.0;
        }
        return area;
    },
    
    /**

     * 计算投影到地球上的多边形的大致面积。 
     * 请注意，如果多边形是顺时针方向，则该区域为正值，否则为负值。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.SpatialReference} projection - 投影 - 几何坐标的空间参考系统。 如果未提供，则假定为Geographic / WGS84。
     * 
     * Reference:
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * @returns
     * {float} 以平方米为单位的多边形的面积。
     */
    getGeodesicArea: function(projection) {
        var ring = this;  // so we can work with a clone if needed
        if(projection) {
            //var gg = new OpenLayers.Projection("EPSG:4326");
            var gg = new GeoGlobe.SpatialReference("EPSG:4326");
            if(!gg.equals(projection)) {
                ring = this.clone().transform(projection, gg);
            }
        }
        var area = 0.0;
        var len = ring.components && ring.components.length;
        if(len > 2) {
            var p1, p2;
            for(var i=0; i<len-1; i++) {
                p1 = ring.components[i];
                p2 = ring.components[i+1];
                area += GeoGlobe.Util.rad(p2.x - p1.x) *
                        (2 + Math.sin(GeoGlobe.Util.rad(p1.y)) +
                        Math.sin(GeoGlobe.Util.rad(p2.y)));
            }
            area = area * 6378137.0 * 6378137.0 / 2.0;
        }
        return area;
    },
    
    /**

     * Test if a point is inside a linear ring.  For the case where a point
     *     is coincident with a linear ring edge, returns 1.  Otherwise,
     *     returns boolean.
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.Geometry.Point}point
     *
     * @returns
     * {Boolean | Number} The point is inside the linear ring.  Returns 1 if
     *     the point is coincident with an edge.  Returns boolean otherwise.
     * @private
     */
    containsPoint: function(point) {
        var approx = GeoGlobe.Number.limitSigDigs;
        var digs = 14;
        var px = approx(point.x, digs);
        var py = approx(point.y, digs);
        function getX(y, x1, y1, x2, y2) {
            return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;
        }
        var numSeg = this.components.length - 1;
        var start, end, x1, y1, x2, y2, cx, cy;
        var crosses = 0;
        for(var i=0; i<numSeg; ++i) {
            start = this.components[i];
            x1 = approx(start.x, digs);
            y1 = approx(start.y, digs);
            end = this.components[i + 1];
            x2 = approx(end.x, digs);
            y2 = approx(end.y, digs);
            
            /**
             * The following conditions enforce five edge-crossing rules:
             *    1. points coincident with edges are considered contained;
             *    2. an upward edge includes its starting endpoint, and
             *    excludes its final endpoint;
             *    3. a downward edge excludes its starting endpoint, and
             *    includes its final endpoint;
             *    4. horizontal edges are excluded; and
             *    5. the edge-ray intersection point must be strictly right
             *    of the point P.
             */
            if(y1 == y2) {
                // horizontal edge
                if(py == y1) {
                    // point on horizontal line
                    if(x1 <= x2 && (px >= x1 && px <= x2) || // right or vert
                       x1 >= x2 && (px <= x1 && px >= x2)) { // left or vert
                        // point on edge
                        crosses = -1;
                        break;
                    }
                }
                // ignore other horizontal edges
                continue;
            }
            cx = approx(getX(py, x1, y1, x2, y2), digs);
            if(cx == px) {
                // point on line
                if(y1 < y2 && (py >= y1 && py <= y2) || // upward
                   y1 > y2 && (py <= y1 && py >= y2)) { // downward
                    // point on edge
                    crosses = -1;
                    break;
                }
            }
            if(cx <= px) {
                // no crossing to the right
                continue;
            }
            if(x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {
                // no crossing
                continue;
            }
            if(y1 < y2 && (py >= y1 && py < y2) || // upward
               y1 > y2 && (py < y1 && py >= y2)) { // downward
                ++crosses;
            }
        }
        var contained = (crosses == -1) ?
            // on edge
            1 :
            // even (out) or odd (in)
            !!(crosses & 1);

        return contained;
    },

    /**

     * 确定输入几何体是否与此相交。
     * @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {GeoGlobe.Geometry}geometry -  任何类型的几何。
     *
     * @returns
     * {Boolean} 输入几何体与此相交。
     */
    intersects: function(geometry) {
        var intersect = false;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.containsPoint(geometry);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LineString") {
            intersect = geometry.intersects(this);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LinearRing") {
            intersect = GeoGlobe.Geometry.LineString.prototype.intersects.apply(
                this, [geometry]
            );
        } else {
            // check for component intersections
            for(var i=0, len=geometry.components.length; i<len; ++ i) {
                intersect = geometry.components[i].intersects(this);
                if(intersect) {
                    break;
                }
            }
        }
        return intersect;
    },

    /**

     * 返回此几何中所有点的列表。
     *  @memberof GeoGlobe.Geometry.LinearRing.prototype
     * @param {Boolean}nodes - 对于线条，只返回端点的顶点。 
     * 如果为false，则对于线条，仅返回不是端点的顶点。 
     * 如果未提供，则将返回所有顶点。
     *
     * @returns
     * {Array}几何中所有顶点的列表。
     */
    getVertices: function(nodes) {
        return (nodes === true) ? [] : this.components.slice(0, this.components.length-1);
    },

    CLASS_NAME: "GeoGlobe.Geometry.LinearRing"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Geometry.Polygon
 * @classdesc 多边形几何对象类。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection> 
 *  - <GeoGlobe.Geometry>
 *      多边形几何对象类,继承于GeoGlobe.Geometry.Collection和GeoGlobe.Geometry
 * @private
 *
 */
GeoGlobe.Geometry.Polygon = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**

     *  An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     *  @memberof  GeoGlobe.Geometry.Polygon .prototype
     *  @type {Array(String)}
     *  @private
     */
    componentTypes: ["GeoGlobe.Geometry.LinearRing"],

    /**

     * 多边形几何体的构造函数。
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     *
     * @param {Array(GeoGlobe.Geometry.LinearRing)}components
     */

    /** 

     * 通过从外孔的区域减去内孔的面积来计算。
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @returns
     * {float} 几何体的面积
     */
    getArea: function() {
        var area = 0.0;
        if ( this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getArea());
            for (var i=1, len=this.components.length; i<len; i++) {
                area -= Math.abs(this.components[i].getArea());
            }
        }
        return area;
    },

    /** 

     * 计算投影到地球上的多边形的大致面积。
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @param {OpenLayers.Projection}
     * projection -  几何坐标的空间参照系。 如果未提供，则假定为Geographic / WGS84。
     * 
     * 参考：
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
     *
     * @returns
     * {float} 多边形的近似测地面积，单位平方米。
     */
    getGeodesicArea: function(projection) {
        var area = 0.0;
        if(this.components && (this.components.length > 0)) {
            area += Math.abs(this.components[0].getGeodesicArea(projection));
            for(var i=1, len=this.components.length; i<len; i++) {
                area -= Math.abs(this.components[i].getGeodesicArea(projection));
            }
        }
        return area;
    },

    /**

     * Test if a point is inside a polygon.  Points on a polygon edge are
     *     considered inside.
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @param {GeoGlobe.Geometry.Point}point
     *
     * @returns
     * {Boolean | Number} The point is inside the polygon.  Returns 1 if the
     *     point is on an edge.  Returns boolean otherwise.
     * @private
     */
    containsPoint: function(point) {
        var numRings = this.components.length;
        var contained = false;
        if(numRings > 0) {
            // check exterior ring - 1 means on edge, boolean otherwise
            contained = this.components[0].containsPoint(point);
            if(contained !== 1) {
                if(contained && numRings > 1) {
                    // check interior rings
                    var hole;
                    for(var i=1; i<numRings; ++i) {
                        hole = this.components[i].containsPoint(point);
                        if(hole) {
                            if(hole === 1) {
                                // on edge
                                contained = 1;
                            } else {
                                // in hole
                                contained = false;
                            }                            
                            break;
                        }
                    }
                }
            }
        }
        return contained;
    },

    /**

     * Determine if the input geometry intersects this one.
     * 确定输入几何是否相交。 
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @param {GeoGlobe.Geometry}geometry -  任何类型的几何。
     *
     * @returns
     * {Boolean} 输入几何体与此相交。
     */
    intersects: function(geometry) {
        var intersect = false;
        var i, len;
        if(geometry.CLASS_NAME == "GeoGlobe.Geometry.Point") {
            intersect = this.containsPoint(geometry);
        } else if(geometry.CLASS_NAME == "GeoGlobe.Geometry.LineString" ||
                  geometry.CLASS_NAME == "GeoGlobe.Geometry.LinearRing") {
            // check if rings/linestrings intersect
            for(i=0, len=this.components.length; i<len; ++i) {
                intersect = geometry.intersects(this.components[i]);
                if(intersect) {
                    break;
                }
            }
            if(!intersect) {
                // check if this poly contains points of the ring/linestring
                for(i=0, len=geometry.components.length; i<len; ++i) {
                    intersect = this.containsPoint(geometry.components[i]);
                    if(intersect) {
                        break;
                    }
                }
            }
        } else {
            for(i=0, len=geometry.components.length; i<len; ++ i) {
                intersect = this.intersects(geometry.components[i]);
                if(intersect) {
                    break;
                }
            }
        }
        // check case where this poly is wholly contained by another
        if(!intersect && geometry.CLASS_NAME == "GeoGlobe.Geometry.Polygon") {
            // exterior ring points will be contained in the other geometry
            var ring = this.components[0];
            for(i=0, len=ring.components.length; i<len; ++i) {
                intersect = geometry.containsPoint(ring.components[i]);
                if(intersect) {
                    break;
                }
            }
        }
        return intersect;
    },

    /**

     * 计算两个几何图形之间的最近距离（在x-y平面上）。
     * @memberof  GeoGlobe.Geometry.Polygon .prototype
     * @param {GeoGlobe.Geometry}geometry - 目标几何。
     * @param {Object} options - 用于配置距离计算的可选属性。
     *
     * 有效选项：
     * details - {Boolean} 从距离计算中返回细节。默认为false。
     * edge - {Boolean} 计算从此几何体到目标几何体最近边的距离。 默认值是true。 
     * 如果为true，则从完全包含在目标中的几何体调用distanceTo将导致非零距离。 
     * 如果为false，则每当几何图形相交时，调用distanceTo将返回0.如果为false，则无法返回详细信息。
     *
     * @returns
     * {Number | Object} 这个几何与目标之间的距离。
     * 如果细节是真的，返回将是一个距离为x0，y0，x1和y1属性的对象。 
     * x0和y0属性表示此几何体上最近点的坐标。 x1和y1属性表示目标几何体上最近点的坐标。
     */
    distanceTo: function(geometry, options) {
        var edge = !(options && options.edge === false);
        var result;
        // this is the case where we might not be looking for distance to edge
        if(!edge && this.intersects(geometry)) {
            result = 0;
        } else {
            result = GeoGlobe.Geometry.Collection.prototype.distanceTo.apply(
                this, [geometry, options]
            );
        }
        return result;
    },

    CLASS_NAME: "GeoGlobe.Geometry.Polygon"
});

/**

 * 围绕半径创建正多边形。
 * @memberof  GeoGlobe.Geometry.Polygon .prototype
 * @param {GeoGlobe.Geometry.Point}origin -  多边形的中心。
 *  @param {Float}radius -  到顶点的距离，以地图为单位。
 * @param {Integer}sides -  边数。 20近似一个圆圈。
 * @param {Float} rotation -  原始旋转角度，以度为单位。
 */
GeoGlobe.Geometry.Polygon.createRegularPolygon = function(origin, radius, sides, rotation) {  
    var angle = Math.PI * ((1/sides) - (1/2));
    if(rotation) {
        angle += (rotation / 180) * Math.PI;
    }
    var rotatedAngle, x, y;
    var points = [];
    for(var i=0; i<sides; ++i) {
        rotatedAngle = angle + (i * 2 * Math.PI / sides);
        x = origin.x + (radius * Math.cos(rotatedAngle));
        y = origin.y + (radius * Math.sin(rotatedAngle));
        points.push(new GeoGlobe.Geometry.Point(x, y));
    }
    var ring = new GeoGlobe.Geometry.LinearRing(points);
    return new GeoGlobe.Geometry.Polygon([ring]);
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Geometry.MultiLineString
 * @classdesc 线集合几何对象类，由多个线几何对象（非闭合线）组成的。
 * 
 * Inherits from:
 *  - <GeoGlobe.Geometry.Collection>
 *  - <GeoGlobe.Geometry>
 *       线集合几何对象类,继承于GeoGlobe.Geometry.Collection和GeoGlobe.Geometry
 * @private
 */
GeoGlobe.Geometry.MultiLineString = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**
     *  An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     * @memberof GeoGlobe.Geometry.MultiLineString.prototype
     * @type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.LineString"],

    /**

     * MultiLineString几何体的构造函数。
     * @memberof GeoGlobe.Geometry.MultiLineString.prototype
     * @param {Array(GeoGlobe.Geometry.LineString)}components
     *
     */
    
    /**

     * Use this geometry (the source) to attempt to split a target geometry.
     * @memberof GeoGlobe.Geometry.MultiLineString.prototype
     * @param {GeoGlobe.Geometry}geometry -  The target geometry.
     * @param {Object} options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * Returns:
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     * @private
     */
    split: function(geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits, sourceLine, sourceLines, sourceSplit, targetSplit;
        var sourceParts = [];
        var targetParts = [geometry];
        for(var i=0, len=this.components.length; i<len; ++i) {
            sourceLine = this.components[i];
            sourceSplit = false;
            for(var j=0; j < targetParts.length; ++j) { 
                splits = sourceLine.split(targetParts[j], options);
                if(splits) {
                    if(mutual) {
                        sourceLines = splits[0];
                        for(var k=0, klen=sourceLines.length; k<klen; ++k) {
                            if(k===0 && sourceParts.length) {
                                sourceParts[sourceParts.length-1].addComponent(
                                    sourceLines[k]
                                );
                            } else {
                                sourceParts.push(
                                    new GeoGlobe.Geometry.MultiLineString([
                                        sourceLines[k]
                                    ])
                                );
                            }
                        }
                        sourceSplit = true;
                        splits = splits[1];
                    }
                    if(splits.length) {
                        // splice in new target parts
                        splits.unshift(j, 1);
                        Array.prototype.splice.apply(targetParts, splits);
                        break;
                    }
                }
            }
            if(!sourceSplit) {
                // source line was not hit
                if(sourceParts.length) {
                    // add line to existing multi
                    sourceParts[sourceParts.length-1].addComponent(
                        sourceLine.clone()
                    );
                } else {
                    // create a fresh multi
                    sourceParts = [
                        new GeoGlobe.Geometry.MultiLineString(
                            sourceLine.clone()
                        )
                    ];
                }
            }
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceSplit || targetSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },
    
    /**

     * Split this geometry (the target) with the given geometry (the source).
     *  @memberof GeoGlobe.Geometry.MultiLineString.prototype
     * @param {GeoGlobe.Geometry}geometry -  A geometry used to split this
     *     geometry (the source).
     * @param {Object} options -  Properties of this object will be used to determine
     *     how the split is conducted.
     *
     * Valid options:
     * mutual - {Boolean} Split the source geometry in addition to the target
     *     geometry.  Default is false.
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is
     *     true.  If false, a vertex on the source must be within the tolerance
     *     distance of the intersection to be considered a split.
     * tolerance - {Number} If a non-null value is provided, intersections
     *     within the tolerance distance of an existing vertex on the source
     *     will be assumed to occur at the vertex.
     * 
     * @returns
     * {Array} A list of geometries (of this same type as the target) that
     *     result from splitting the target with the source geometry.  The
     *     source and target geometry will remain unmodified.  If no split
     *     results, null will be returned.  If mutual is true and a split
     *     results, return will be an array of two arrays - the first will be
     *     all geometries that result from splitting the source geometry and
     *     the second will be all geometries that result from splitting the
     *     target geometry.
     * @private
     */
    splitWith: function(geometry, options) {
        var results = null;
        var mutual = options && options.mutual;
        var splits, targetLine, sourceLines, sourceSplit, targetSplit, sourceParts, targetParts;
        if(geometry instanceof GeoGlobe.Geometry.LineString) {
            targetParts = [];
            sourceParts = [geometry];
            for(var i=0, len=this.components.length; i<len; ++i) {
                targetSplit = false;
                targetLine = this.components[i];
                for(var j=0; j<sourceParts.length; ++j) {
                    splits = sourceParts[j].split(targetLine, options);
                    if(splits) {
                        if(mutual) {
                            sourceLines = splits[0];
                            if(sourceLines.length) {
                                // splice in new source parts
                                sourceLines.unshift(j, 1);
                                Array.prototype.splice.apply(sourceParts, sourceLines);
                                j += sourceLines.length - 2;
                            }
                            splits = splits[1];
                            if(splits.length === 0) {
                                splits = [targetLine.clone()];
                            }
                        }
                        for(var k=0, klen=splits.length; k<klen; ++k) {
                            if(k===0 && targetParts.length) {
                                targetParts[targetParts.length-1].addComponent(
                                    splits[k]
                                );
                            } else {
                                targetParts.push(
                                    new GeoGlobe.Geometry.MultiLineString([
                                        splits[k]
                                    ])
                                );
                            }
                        }
                        targetSplit = true;                    
                    }
                }
                if(!targetSplit) {
                    // target component was not hit
                    if(targetParts.length) {
                        // add it to any existing multi-line
                        targetParts[targetParts.length-1].addComponent(
                            targetLine.clone()
                        );
                    } else {
                        // or start with a fresh multi-line
                        targetParts = [
                            new GeoGlobe.Geometry.MultiLineString([
                                targetLine.clone()
                            ])
                        ];
                    }
                    
                }
            }
        } else {
            results = geometry.split(this);
        }
        if(sourceParts && sourceParts.length > 1) {
            sourceSplit = true;
        } else {
            sourceParts = [];
        }
        if(targetParts && targetParts.length > 1) {
            targetSplit = true;
        } else {
            targetParts = [];
        }
        if(sourceSplit || targetSplit) {
            if(mutual) {
                results = [sourceParts, targetParts];
            } else {
                results = targetParts;
            }
        }
        return results;
    },

    CLASS_NAME: "GeoGlobe.Geometry.MultiLineString"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Geometry.MultiPolygon
 * @classdesc 多边形集合几何对象类，由多个多边形几何对象组成。
 * 
 * 继承:
 *  - <GeoGlobe.Geometry.Collection>
 *       多边形集合几何对象类，继承于GeoGlobe.Geometry.Collection
 *
 */
GeoGlobe.Geometry.MultiPolygon = GeoGlobe.Class4OL(
  GeoGlobe.Geometry.Collection, {

    /**

     * An array of class names representing the types of
     * components that the collection can include.  A null value means the
     * component types are not restricted.
     * @memberof GeoGlobe.Geometry.MultiPolygon.prototype
     * @type {Array(String)}
     * @private
     */
    componentTypes: ["GeoGlobe.Geometry.Polygon"],

    /**

     *创建一个新的多边形集合几何对象。
     *@memberof GeoGlobe.Geometry.MultiPolygon.prototype
     *@param {Array(GeoGlobe.Geometry.Polygon)}components -  用于生成MultiPolygon的多边形数组
     *
     */

    CLASS_NAME: "GeoGlobe.Geometry.MultiPolygon"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

// TRASH THIS
GeoGlobe.State = {
    /** states */
    UNKNOWN: 'Unknown',
    INSERT: 'Insert',
    UPDATE: 'Update',
    DELETE: 'Delete'
};

/**
 * @memberof GeoGlobe..Feature.prototype
 * @requires View2D/tool/Util.js
 */

/**
 * @class GeoGlobe.Feature
 * 矢量要素使用GeoGlobe.Geometry类作为几何描述。
 * 他们有一个'attributes'属性，它是数据对象，'style'属性，默认值是在<GeoGlobe.Feature.style>对象中定义的。
 * 
 */
GeoGlobe.Feature = GeoGlobe.Class4OL({

	/**
     *
     * @memberof GeoGlobe.Feature.prototype
     * @type {String}
     * @private
     */
    id: null,
	
    /** 
     *  fid
     * @memberof GeoGlobe.Feature.prototype
     * @type {String}
     * @private
     */
    fid: null,
	
	/** 
     *  lonlat
     * @memberof GeoGlobe.Feature.prototype
     * @type {GeoGlobe.LngLat}
     * @private
     */
    lonlat: null,
    
    /** 
     * 几何
     * @memberof GeoGlobe.Feature.prototype
     * @type {GeoGlobe.Geometry}
     */
    geometry: null,

    /** 
     * 此对象包含描述该功能的任意可序列化属性。
     * @memberof GeoGlobe.Feature.prototype
     * @type {Object}
     */
    attributes: null,
	
	/** 
     *  data
     * @memberof GeoGlobe.Feature.prototype
     * @type {Object}
     * @private

     */
    data: null,
	
    /**
     * Property: bounds
     * {<GeoGlobe.LngLatBounds>} The box bounding that feature's geometry, that
     *     property can be set by an <GeoGlobe.Format> object when
     *     deserializing the feature, so in most cases it represents an
     *     information set by the server. 
     *  @memberof GeoGlobe.Feature.prototype
     *  @param bounds
     *  @private
     */
    bounds: null,

    /**
     * 状态
     * @memberof GeoGlobe.Feature.prototype
     *  @type {String}
     * @private
     */
    state: null,
    
    /**
     *如果此属性已设置，则在上传或删除功能时，{GeoGlobe.HTTP}会将其考虑在内。
     *  @memberof GeoGlobe.Feature.prototype
     *  @type {String}
     */
    url: null,
    
    /**
     * Intentrendering intent currently being used
     * @memberof GeoGlobe.Feature.prototype
     *  @type {String}
     */
    //renderIntent: "default",
    
    /**
     * @memberof GeoGlobe.Feature.prototype
     * @param {Object} modified
     *  An object with the originals of the geometry and attributes of
     * the feature, if they were changed. Currently this property is only read
     * by <GeoGlobe.Format.WFST.v1>, and written by
     * <OpenLayers.Control.ModifyFeature>, which sets the geometry property.
     * Applications can set the originals of modified attributes in the
     * attributes property. Note that applications have to check if this
     * object and the attributes property is already created before using it.
     * After a change made with ModifyFeature, this object could look like
     *
     * (code)
     * {
     *     geometry: >Object
     * }
     * (end)
     *
     * When an application has made changes to feature attributes, it could
     * have set the attributes to something like this:
     *
     * (code)
     * {
     *     attributes: {
     *         myAttribute: "original"
     *     }
     * }
     * (end)
     *
     * Note that <GeoGlobe.Format.WFST.v1> only checks for truthy values in
     * *modified.geometry* and the attribute names in *modified.attributes*,
     * but it is recommended to set the original values (and not just true) as
     * attribute value, so applications could use this information to undo
     * changes.
     * @private
     */
    modified: null,

    /** 
     *
     * 创建一个矢量特征. 
     * @memberof GeoGlobe.Feature.prototype

     * @param {GeoGlobe.Geometry}  geometry - 该特征所代表的几何图形。
     * @param {Object}attributes -  一个将被映射到<attributes>属性的可选对象。
     * @private  
     */
    initialize: function(geometry, attributes) {
        //OpenLayers.Feature.prototype.initialize.apply(this,[null, null, attributes]);
		this.data = (attributes != null) ? attributes : {};
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME + "_");
        this.lonlat = null;
        this.geometry = geometry ? geometry : null;
        this.state = null;
        this.attributes = {};
        if (attributes) {
            this.attributes = GeoGlobe.Util.extend(this.attributes,
                                                     attributes);
        }
        //this.style = style ? style : null; 
    },
    
    /** 
     * nullify references to prevent circular references and memory leaks
     * @memberof GeoGlobe.Feature.prototype
     * @private
     */
    destroy: function() {
        //if (this.layer) {
        //    this.layer.removeFeatures(this);
        //    this.layer = null;
        //}
            
        this.geometry = null;
        this.modified = null;
        //OpenLayers.Feature.prototype.destroy.apply(this, arguments);
		this.id = null;
        this.lonlat = null;
        this.data = null;
    },
    
    /**

     * Create a clone of this vector feature.  Does not set any non-standard
     *     properties.
     * @memberof GeoGlobe.Feature.prototype
     * @returns
     * {GeoGlobe.Feature} An exact clone of this vector feature.
     * @private
     */
    clone: function () {
        return new GeoGlobe.Feature(
            this.geometry ? this.geometry.clone() : null,
            this.attributes);
    },

    /**

     * Determine whether the feature is within the map viewport.  This method
     *     tests for an intersection between the geometry and the viewport
     *     bounds.  If a more effecient but less precise geometry bounds
     *     intersection is desired, call the method with the boundsOnly
     *     parameter true.
     *@memberof GeoGlobe.Feature.prototype

     * @param {Boolean} boundsOnly -  Only test whether a feature's bounds intersects
     *     the viewport bounds.  Default is false.  If false, the feature's
     *     geometry must intersect the viewport for onScreen to return true.
     * 
     * @returns
     * {Boolean} The feature is currently visible on screen (optionally
     *     based on its bounds if boundsOnly is true).
     * @private
     */
	/*
    onScreen:function(boundsOnly) {
        var onScreen = false;
        if(this.layer && this.layer.map) {
            var screenBounds = this.layer.map.getExtent();
            if(boundsOnly) {
                var featureBounds = this.geometry.getBounds();
                onScreen = screenBounds.intersectsBounds(featureBounds);
            } else {
                var screenPoly = screenBounds.toGeometry();
                onScreen = screenPoly.intersects(this.geometry);
            }
        }    
        return onScreen;
    },
    */

    /**

     * Determine whether the feature is displayed or not. It may not displayed
     *     because:
     *     - its style display property is set to 'none',
     *     - it doesn't belong to any layer,
     *     - the styleMap creates a symbolizer with display property set to 'none'
     *          for it,
     *     - the layer which it belongs to is not visible.
     * @memberof GeoGlobe.Feature.prototype
     * @returns
     * {Boolean} The feature is currently displayed.
     * @private
     */
	/*
    getVisibility: function() {
        return !(this.style && this.style.display == 'none' ||
                 !this.layer ||
                 this.layer && this.layer.styleMap &&
                 this.layer.styleMap.createSymbolizer(this, this.renderIntent).display == 'none' ||
                 this.layer && !this.layer.getVisibility());
    },
    */
    /**

     * HACK - we need to decide if all vector features should be able to
     *     create markers
     * @memberof GeoGlobe.Feature.prototype
     * @returns
     * {GeoGlobe.Marker} For now just returns null
     * @private
     */
    createMarker: function() {
        return null;
    },

    /**

     * HACK - we need to decide if all vector features should be able to
     *     delete markers
     * 
     * If user overrides the createMarker() function, s/he should be able
     *   to also specify an alternative function for destroying it
     *   @memberof GeoGlobe.Feature.prototype
     * @private
     */
    destroyMarker: function() {
        // pass
    },

    /**

     * HACK - we need to decide if all vector features should be able to
     *     create popups
     * 
     * @returns
     * {GeoGlobe.Popup} For now just returns null
     * @private
     */
    createPopup: function() {
        return null;
    },

    /**

     * Determins whether the feature intersects with the specified location.
     * @memberof GeoGlobe.Feature.prototype

     * @param {GeoGlobe.LngLat|Object}lonlat -  OpenLayers.LonLat or an
     *     object with a 'lon' and 'lat' properties.
     * toleranceLon - {float} Optional tolerance in Geometric Coords
     * toleranceLat - {float} Optional tolerance in Geographic Coords
     * 
     * @returns
     * {Boolean} Whether or not the feature is at the specified location
     * @private
     */
    atPoint: function(lonlat, toleranceLon, toleranceLat) {
        var atPoint = false;
        if(this.geometry) {
            atPoint = this.geometry.atPoint(lonlat, toleranceLon, 
                                                    toleranceLat);
        }
        return atPoint;
    },

    /**

     * HACK - we need to decide if all vector features should be able to
     * delete popups
     * @memberof GeoGlobe.Feature.prototype
     * @private
     */
    destroyPopup: function() {
        // pass
    },

    /**

     * Moves the feature and redraws it at its new location
     *@memberof GeoGlobe.Feature.prototype

     * @param {OpenLayers.LonLat | OpenLayers.Pixel}location -  the
     *         location to which to move the feature.
     * @private
     */
	/*
    move: function(location) {

        if(!this.layer || !this.geometry.move){
            //do nothing if no layer or immoveable geometry
            return undefined;
        }

        var pixel;
        if (location.CLASS_NAME == "OpenLayers.LonLat") {
            pixel = this.layer.getViewPortPxFromLonLat(location);
        } else {
            pixel = location;
        }
        
        var lastPixel = this.layer.getViewPortPxFromLonLat(this.geometry.getBounds().getCenterLonLat());
        var res = this.layer.map.getResolution();
        this.geometry.move(res * (pixel.x - lastPixel.x),
                           res * (lastPixel.y - pixel.y));
        this.layer.drawFeature(this);
        return lastPixel;
    },
    */
    
    /**

     * Sets the new state
     *@memberof GeoGlobe.Feature.prototype
     * @param {String}  state
     * @private
     */
    toState: function(state) {
        if (state == GeoGlobe.State.UPDATE) {
            switch (this.state) {
                case GeoGlobe.State.UNKNOWN:
                case GeoGlobe.State.DELETE:
                    this.state = state;
                    break;
                case GeoGlobe.State.UPDATE:
                case GeoGlobe.State.INSERT:
                    break;
            }
        } else if (state == GeoGlobe.State.INSERT) {
            switch (this.state) {
                case GeoGlobe.State.UNKNOWN:
                    break;
                default:
                    this.state = state;
                    break;
            }
        } else if (state == GeoGlobe.State.DELETE) {
            switch (this.state) {
                case GeoGlobe.State.INSERT:
                    // the feature should be destroyed
                    break;
                case GeoGlobe.State.DELETE:
                    break;
                case GeoGlobe.State.UNKNOWN:
                case GeoGlobe.State.UPDATE:
                    this.state = state;
                    break;
            }
        } else if (state == GeoGlobe.State.UNKNOWN) {
            this.state = state;
        }
    },
    
    CLASS_NAME: "GeoGlobe.Feature"
});


/**
 * @memberof GeoGlobe.Feature.prototype
 * @constant  GeoGlobe.Feature.style
 * OpenLayers features can have a number of style attributes. The 'default' 
 *     style will typically be used if no other style is specified. These
 *     styles correspond for the most part, to the styling properties defined
 *     by the SVG standard. 
 *     Information on fill properties: http://www.w3.org/TR/SVG/painting.html#FillProperties
 *     Information on stroke properties: http://www.w3.org/TR/SVG/painting.html#StrokeProperties
 *
 * Symbolizer: properties
 *  @param {Boolean} fill - Set to false if no fill is desired.
 *  @param {String}fillColor -  Hex fill color.  Default is "#ee9900".
 *  @param {Number}fillOpacity -  Fill opacity (0-1).  Default is 0.4
 *  @param {Boolean}stroke -  Set to false if no stroke is desired.
 *  @param {String}strokeColor -  Hex stroke color.  Default is "#ee9900".
 *  @param {Number}strokeOpacity -  Stroke opacity (0-1).  Default is 1.
 *  @param {Number} strokeWidth - Pixel stroke width.  Default is 1.
 * @param {String}strokeLinecap -  Stroke cap type.  Default is "round".  [butt | round | square]
 *  @param {String}strokeDashstyle - Stroke dash style.  Default is "solid". [dot | dash | dashdot | longdash | longdashdot | solid]
 * @param {Boolean} graphic - Set to false if no graphic is desired.
 *  @param {Number}pointRadius -  Pixel point radius.  Default is 6.
 *  @param {String}pointerEvents -   Default is "visiblePainted".
 *  @param {String}cursor -  Default is "".
 *  @param {String}externalGraphic -  Url to an external graphic that will be used for rendering points.
 *  @param {Number}graphicWidth -  Pixel width for sizing an external graphic.
 *  @param {Number}graphicHeight -  Pixel height for sizing an external graphic.
 *  @param {Number}graphicOpacity -  Opacity (0-1) for an external graphic.
 *  @param {Number}graphicXOffset -  Pixel offset along the positive x axis for displacing an external graphic.
 *  @param {Number}graphicYOffset -  Pixel offset along the positive y axis for displacing an external graphic.
 *  @param {Number} rotation - For point symbolizers, this is the rotation of a graphic in the clockwise direction about its center point (or any point off center as specified by graphicXOffset and graphicYOffset).
 * @param   {Number}graphicZIndex - The integer z-index value to use in rendering.
 * @param {String}graphicName -  Named graphic to use when rendering points.  Supported values include "circle" (default),
 *     "square", "star", "x", "cross", "triangle".
 * @param {String}graphicTitle -  Tooltip when hovering over a feature. *deprecated*, use title instead
 * @param {String}title -  Tooltip when hovering over a feature. Not supported by the canvas renderer.
 *  @param {String}backgroundGraphic -  Url to a graphic to be used as the background under an externalGraphic.
 *  @param {Number}backgroundGraphicZIndex -  The integer z-index value to use in rendering the background graphic.
 *  @param {Number}backgroundXOffset -  The x offset (in pixels) for the background graphic.
 *  @param {Number}backgroundYOffset -  The y offset (in pixels) for the background graphic.
 * @param {Number}backgroundHeight -  The height of the background graphic.  If not provided, the graphicHeight will be used.
 *  @param {Number} backgroundWidth - The width of the background width.  If not provided, the graphicWidth will be used.
 * @param {String}label -  The text for an optional label. For browsers that use the canvas renderer, this requires either
 *     fillText or mozDrawText to be available.
 * @param {String}labelAlign -  Label alignment. This specifies the insertion point relative to the text. It is a string
 *     composed of two characters. The first character is for the horizontal alignment, the second for the vertical
 *      alignment. Valid values for horizontal alignment: "l"=left, "c"=center, "r"=right. Valid values for vertical
 *      alignment: "t"=top, "m"=middle, "b"=bottom. Example values: "lt", "cm", "rb". Default is "cm".
 *  @param {Number} labelXOffset - {Pixel offset along the positive x axis for displacing the label. Not supported by the canvas renderer.
 *  @param {Number}labelYOffset -  Pixel offset along the positive y axis for displacing the label. Not supported by the canvas renderer.
 *  @param {Boolean}labelSelect -  If set to true, labels will be selectable using SelectFeature or similar controls.
 *     Default is false.
 *  @param {String}labelOutlineColor -  The color of the label outline. Default is 'white'. Only supported by the canvas & SVG renderers.
 * @param {Number}  labelOutlineWidth - The width of the label outline. Default is 3, set to 0 or null to disable. Only supported by the  SVG renderers.
 * @param {Number}labelOutlineOpacity -  The opacity (0-1) of the label outline. Default is fontOpacity. Only supported by the canvas & SVG renderers.
 * @param {String}fontColor -  The font color for the label, to be provided like CSS.
 *  @param {Number}fontOpacity -  Opacity (0-1) for the label
 * @param {String} fontFamily -  The font family for the label, to be provided like in CSS.
 *  @param {String} fontSize - The font size for the label, to be provided like in CSS.
 *  @param {String}fontStyle -  The font style for the label, to be provided like in CSS.
 * @param {String}fontWeight -  The font weight for the label, to be provided like in CSS.
 * @param {String}display -  Symbolizers will have no effect if display is set to "none".  All other values have no effect.
*/
/*
GeoGlobe.Feature.style = {
    'default': {
        fillColor: "#ee9900",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#ee9900",
        strokeOpacity: 1,
        strokeWidth: 1,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3
    },
    'select': {
        fillColor: "blue",
        fillOpacity: 0.4, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "blue",
        strokeOpacity: 1,
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "pointer",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'temporary': {
        fillColor: "#66cccc",
        fillOpacity: 0.2, 
        hoverFillColor: "white",
        hoverFillOpacity: 0.8,
        strokeColor: "#66cccc",
        strokeOpacity: 1,
        strokeLinecap: "round",
        strokeWidth: 2,
        strokeDashstyle: "solid",
        hoverStrokeColor: "red",
        hoverStrokeOpacity: 1,
        hoverStrokeWidth: 0.2,
        pointRadius: 6,
        hoverPointRadius: 1,
        hoverPointUnit: "%",
        pointerEvents: "visiblePainted",
        cursor: "inherit",
        fontColor: "#000000",
        labelAlign: "cm",
        labelOutlineColor: "white",
        labelOutlineWidth: 3

    },
    'delete': {
        display: "none"
    }
};
*/

/**

 * 获取要素数组范围
 *  @memberof GeoGlobe.Feature.prototype

 * @param {Array(GeoGlobe.Feature)} features -
 *
 * @returns
 * {GeoGlobe.LngLatBounds} 数据范围对象。
 * @private
 */
GeoGlobe.Feature.getBoundsByFeatures = function(features){
	var len = features.length;
	var geometries = new Array(len);
	for (var i=0; i<len; ++i) {
		geometries[i] = features[i].geometry;
	}
	var geom = new GeoGlobe.Geometry.Collection(geometries);
	geom.calculateBounds();
	return geom.bounds;
};

/**

 * 根据geojson对象，获得GeoGlobe.Feature对象数组
 *  * @memberof GeoGlobe.Feature.prototype

 * @returns
 * {Array(GeoGlobe.Feature)} 要素对象数组。
 * @private
 */
GeoGlobe.Feature.fromGeoJson = function(geojson) {
    var fea;
    if (GeoGlobe.Format && GeoGlobe.Format.GeoJSON) {
        format = new GeoGlobe.Format.GeoJSON();
    	var fea = format.read(geojson);
    }
    return fea;
};/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */




/**
 * @class GeoGlobe.Filter
 *@classdesc 支持OGC标准的过滤器类。 这个类代表一个OGC过滤器。
 */
GeoGlobe.Filter = GeoGlobe.Class4OL({
    
    /** 

     * 这个类表示一个通用的过滤器。
     * @memberof GeoGlobe.Filter.prototype
     * @param {Object} options - 可选对象的属性将在实例上设置。
     * 
     * @returns {GeoGlobe.Filter}
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
    },

    /** 

     * 删除对所添加内容的引用。
     * @memberof GeoGlobe.Filter.prototype
     */
    destroy: function() {
    },

    /**

     * 在特定的上下文中评估此过滤器。 
     * 实例或子类应该覆盖此方法。
     * 
     * @memberof GeoGlobe.Filter.prototype
     * @param {Object} context - 用于评估过滤器的上下文。 如果提供了矢量特征，则feature.attributes将用作上下文。
     * 
     * @returns {Boolean} 该过滤器适用。
     */
    evaluate: function(context) {
        return true;
    },
    
    /**

     * 克隆这个过滤器。 应该由子类来实现。
     * @memberof GeoGlobe.Filter.prototype
     * @returns {GeoGlobe.Filter} 克隆这个过滤器.
     */
    clone: function() {
        return null;
    },
    
    /**

     * @memberof GeoGlobe.Filter.prototype
     * @returns {String} 在您的构建中包含<GeoGlobe.Format.CQL>以获取返回的过滤器的CQL表示形式。 否则，将返回“[Object object]”。
     */
    toString: function() {
        var string;
        if (GeoGlobe.Format && GeoGlobe.Format.CQL) {
            string = GeoGlobe.Format.CQL.prototype.write(this);
        } else {
            string = Object.prototype.toString.call(this);
        }
        return string;
    },
    
    CLASS_NAME: "GeoGlobe.Filter"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 *  @memberof GeoGlobe.Filter.FeatureId.prototype
 * @requires View2D/Filter/Filter.js
 */

/**
 * @class GeoGlobe.Filter.FeatureId
 * @classdesc OGC：FeatureId过滤器，用于SLD样式规则。 该类代表ogc：FeatureId Filter，用于基于规则的SLD样式.
*/
GeoGlobe.Filter.FeatureId = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /** 

     * 特征ID来评估这个规则。
     * 要在params对象内传递。
     * @memberof GeoGlobe.Filter.FeatureId.prototype
     * @type {Array(String)}
     */
    fids: null,
    
    /**
     *
     *@memberof GeoGlobe.Filter.FeatureId.prototype
     * @type {String}
     * @private

     */
    type: "FID",
    
    /** 

     * 创建一个ogc：FeatureId规则。
     *@memberof GeoGlobe.Filter.FeatureId.prototype

     * @param {Object} options -  具有可在规则上设置属性的可选对象
     * 
     * @returns
     * {GeoGlobe.Filter.FeatureId}
     */
    initialize: function(options) {
        this.fids = [];
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
    },

    /**

     * 针对特定功能评估此规则
     *@memberof GeoGlobe.Filter.FeatureId.prototype
     * @param {GeoGlobe.Feature} feature - 功能将规则应用于。
     * 对于矢量特征，检查针对fid运行，针对id的简单特征。
     * 
     * @returns
     * {Boolean} 如果规则适用，则为true;否则为false
     */
    evaluate: function(feature) {
        for (var i=0, len=this.fids.length; i<len; i++) {
            var fid = feature.fid || feature.id;
            if (fid == this.fids[i]) {
                return true;
            }
        }
        return false;
    },
    
    /**

     * 克隆这个过滤器。
     *@memberof GeoGlobe.Filter.FeatureId.prototype
        * @returns
     * {GeoGlobe.Filter.FeatureId} 克隆这个过滤器。
     */
    clone: function() {
        var filter = new GeoGlobe.Filter.FeatureId();
        GeoGlobe.Util.extend(filter, this);
        filter.fids = this.fids.slice();
        return filter;
    },
    
    CLASS_NAME: "GeoGlobe.Filter.FeatureId"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @memberof GeoGlobe.Filter.Logical.prototype
 * @requires :View2D/Filter/Filter.js
 */

/**
 * @class GeoGlobe.Filter.Logical

 * @classdesc OGC逻辑运算符规则过滤器类。
 * @example
 //逻辑过滤器
 var filter = new GeoGlobe.Filter.Logical({
            type: GeoGlobe.Filter.Logical.AND,
            filters: [
                new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LIKE, //比较运算类型
                    property: "PCODE",//查询字段
                    value: "中餐馆" //字段值
                }),
                new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.EQUAL_TO,
                    property: "OID",
                    value: "16"
                }),
                new GeoGlobe.Filter.Spatial({
                    type: GeoGlobe.Filter.Spatial.INTERSECTS, //空间过滤器的类型
                    property: "Geometry", //要素中几何属性的名称
                    value: GeoGlobe.Bounds.fromString(bbox), //查询范围
                    projection: "EPSG:4326" //空间参考
                })
            ]
        });
 */
GeoGlobe.Filter.Logical = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    filters: null, 
     
    /**
     *
     * 逻辑运算符的类型。 可用的类型是：
     * - GeoGlobe.Filter.Logical.AND = "&&";
     * - GeoGlobe.Filter.Logical.OR  = "||";
     * - GeoGlobe.Filter.Logical.NOT = "!";
     * @memberof GeoGlobe.Filter.Logical.prototype
     * @type {String}
     */
    type: null,

    /** 

     * 创建一个逻辑过滤器（&&，||，!）。
     *  @memberof GeoGlobe.Filter.Logical.prototype
     * @param {Object}options -  一个可选对象，可在过滤器上设置属性。 
     * @returns
     * {GeoGlobe.Filter.Logical}
     */
    initialize: function(options) {
        this.filters = [];
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
    },
    
    /** 

     * 删除对子过滤器的引用。
     * @memberof GeoGlobe.Filter.Logical.prototype
     */
    destroy: function() {
        this.filters = null;
        GeoGlobe.Filter.prototype.destroy.apply(this);
    },

    /**

     * 在特定的上下文中评估此过滤器。
     * @memberof GeoGlobe.Filter.Logical.prototype
     * @param {Object}context -  用于评估过滤器的上下文。  还可以提供矢量特征以评估比较过滤器或空间过滤器中的几何特征的特征属性。
     * @returns
     * {Boolean} 该过滤器适用。
     */
    evaluate: function(context) {
        var i, len;
        switch(this.type) {
            case GeoGlobe.Filter.Logical.AND:
                for (i=0, len=this.filters.length; i<len; i++) {
                    if (this.filters[i].evaluate(context) == false) {
                        return false;
                    }
                }
                return true;
                
            case GeoGlobe.Filter.Logical.OR:
                for (i=0, len=this.filters.length; i<len; i++) {
                    if (this.filters[i].evaluate(context) == true) {
                        return true;
                    }
                }
                return false;
            
            case GeoGlobe.Filter.Logical.NOT:
                return (!this.filters[0].evaluate(context));
        }
        return undefined;
    },
    
    /**

     * 复制这个过滤器。
     * @memberof GeoGlobe.Filter.Logical.prototype
     * @returns
     * {GeoGlobe.Filter.Logical} 复制这个过滤器。
     */
    clone: function() {
        var filters = [];        
        for(var i=0, len=this.filters.length; i<len; ++i) {
            filters.push(this.filters[i].clone());
        }
        return new GeoGlobe.Filter.Logical({
            type: this.type,
            filters: filters
        });
    },
    
    CLASS_NAME: "GeoGlobe.Filter.Logical"
});


GeoGlobe.Filter.Logical.AND = "&&";
GeoGlobe.Filter.Logical.OR  = "||";
GeoGlobe.Filter.Logical.NOT = "!";
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 *  @memberof GeoGlobe.Filter.Comparison.prototype
 * @requires View2D/Filter/Filter.js
 */

/**
 * @class GeoGlobe.Filter.Comparison
 * @classdesc 比较操作符过滤器类。 这个类代表一个比较过滤器。
 * @example
 new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LIKE, //比较运算类型
                    property: "PCODE",//查询字段
                    value: "中餐馆" //字段值
                })
 *
 */
GeoGlobe.Filter.Comparison = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     * 比较类型. 
     *  @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {String}
     * 
     * @example 
     * GeoGlobe.Filter.Comparison.EQUAL_TO                 = "==";
     * GeoGlobe.Filter.Comparison.NOT_EQUAL_TO             = "!=";
     * GeoGlobe.Filter.Comparison.LESS_THAN                = "<";
     * GeoGlobe.Filter.Comparison.GREATER_THAN             = ">";
     * GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO    = "<=";
     * GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
     * GeoGlobe.Filter.Comparison.BETWEEN                  = "..";
     * GeoGlobe.Filter.Comparison.LIKE                     = "~";
     * GeoGlobe.Filter.Comparison.IS_NULL                  = "NULL";
     */
    type: null,
    
    /**
     *  要比较的上下文属性的名称
     *  @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {String}
     */
    property: null,
    
    /**
     * 二进制比较的比较值。 在字符串的情况下，这可以是文本和propertyNames的组合，形式为“literal $ {propertyName}”
     * @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {Number | string}
     */
    value: null,
    
    /**

     *  Force case sensitive searches for EQUAL_TO and NOT_EQUAL_TO
     *     comparisons.  The Filter Encoding 1.1 specification added a matchCase
     *     attribute to ogc:PropertyIsEqualTo and ogc:PropertyIsNotEqualTo
     *     elements.  This property will be serialized with those elements only
     *     if using the v1.1.0 filter format. However, when evaluating filters
     *     here, the matchCase property will always be respected (for EQUAL_TO
     *     and NOT_EQUAL_TO).  Default is true.
     *     @memberof GeoGlobe.Filter.Comparison.prototype
     *    @type {Boolean}
     *    @private
     */
    matchCase: true,
    
    /**
    * 比较之间的下限。 在字符串的情况下，这可以是文本和propertyNames的组合，形式为“literal $ {propertyName}”
     *   @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {Number | string}
     */
    lowerBoundary: null,
    
    /**
     * 比较之间的上限。 在字符串的情况下，这可以是文本和propertyNames的组合，形式为“literal $ {propertyName}”
     *   @memberof GeoGlobe.Filter.Comparison.prototype
     * @type {Number | string}
     */
    upperBoundary: null,

    /** 

     * 创建比较规则。
     * @memberof GeoGlobe.Filter.Comparison.prototype
     * @param {Object} options -  具有可在规则上设置属性的可选对象
     * 
     * @returns
     * {GeoGlobe.Filter.Comparison}
     */
    initialize: function(options) {
        GeoGlobe.Filter.prototype.initialize.apply(this, [options]);
        // since matchCase on PropertyIsLike is not schema compliant, we only
        // want to use this if explicitly asked for
        if (this.type === GeoGlobe.Filter.Comparison.LIKE 
            && options.matchCase === undefined) {
                this.matchCase = null;
        }
    },

    /**

     *  在特定的上下文中评估此过滤器。
     *  @memberof GeoGlobe.Filter.Comparison.prototype
     *  @param {Object}  context - 用于评估过滤器的上下文。 如果提供了矢量特征，则feature.attributes将用作上下文。
     * 
     * @returns
     * {Boolean} 该过滤器适用。
     */
    evaluate: function(context) {
        if (context instanceof GeoGlobe.Feature) {
            context = context.attributes;
        }
        var result = false;
        var got = context[this.property];
		if (got === undefined) {
            return false;
        }
        var exp;
        switch(this.type) {
            case GeoGlobe.Filter.Comparison.EQUAL_TO:
                exp = this.value;
                if(!this.matchCase &&
                   typeof got == "string" && typeof exp == "string") {
                    result = (got.toUpperCase() == exp.toUpperCase());
                } else {
                    result = (got == exp);
                }
                break;
            case GeoGlobe.Filter.Comparison.NOT_EQUAL_TO:
                exp = this.value;
                if(!this.matchCase &&
                   typeof got == "string" && typeof exp == "string") {
                    result = (got.toUpperCase() != exp.toUpperCase());
                } else {
                    result = (got != exp);
                }
                break;
            case GeoGlobe.Filter.Comparison.LESS_THAN:
                result = got < this.value;
                break;
            case GeoGlobe.Filter.Comparison.GREATER_THAN:
                result = got > this.value;
                break;
            case GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO:
                result = got <= this.value;
                break;
            case GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO:
                result = got >= this.value;
                break;
            case GeoGlobe.Filter.Comparison.BETWEEN:
                result = (got >= this.lowerBoundary) &&
                    (got <= this.upperBoundary);
                break;
            case GeoGlobe.Filter.Comparison.LIKE:
                var regexp = new RegExp(this.value, "gi");
                result = regexp.test(got);
                break;
            case GeoGlobe.Filter.Comparison.IS_NULL:
                result = (got === null);
                break;
        }
        return result;
    },
    
    /**

    * 根据指定的通配符将此规则的值转换为正则表达式字符串。 如果该值不是正则表达式，则必须在此类的实例化后调用此方法。
     *@memberof GeoGlobe.Filter.Comparison.prototype
     *@param {Char} wildCard   -  通配符在上面的值中，默认是“*”
     *@param {Char}singleChar -  上述值中的单字符通配符默认为“。”
     *@param {Char}escapeChar -  转义字符在上面的值中，默认是“！”
     * 
     * @returns
     * {String} 正则表达式字符串
     */
    value2regex: function(wildCard, singleChar, escapeChar) {
        if (wildCard == ".") {
            throw new Error("'.' is an unsupported wildCard character for " +
                            "GeoGlobe.Filter.Comparison");
        }
        

        // set UMN MapServer defaults for unspecified parameters
        wildCard = wildCard ? wildCard : "*";
        singleChar = singleChar ? singleChar : ".";
        escapeChar = escapeChar ? escapeChar : "!";
        
        this.value = this.value.replace(
                new RegExp("\\"+escapeChar+"(.|$)", "g"), "\\$1");
        this.value = this.value.replace(
                new RegExp("\\"+singleChar, "g"), ".");
        this.value = this.value.replace(
                new RegExp("\\"+wildCard, "g"), ".*");
        this.value = this.value.replace(
                new RegExp("\\\\.\\*", "g"), "\\"+wildCard);
        this.value = this.value.replace(
                new RegExp("\\\\\\.", "g"), "\\"+singleChar);
        
        return this.value;
    },
    
    /**

     * Convert the value of this rule from a regular expression string into an
     *     ogc literal string using a wildCard of *, a singleChar of ., and an
     *     escape of !.  Leaves the <value> property unmodified.
     * @memberof GeoGlobe.Filter.Comparison.prototype
     * @returns
     * {String} A string value.
     * @private
     */
    regex2value: function() {
        
        var value = this.value;
        
        // replace ! with !!
        value = value.replace(/!/g, "!!");

        // replace \. with !. (watching out for \\.)
        value = value.replace(/(\\)?\\\./g, function($0, $1) {
            return $1 ? $0 : "!.";
        });
        
        // replace \* with #* (watching out for \\*)
        value = value.replace(/(\\)?\\\*/g, function($0, $1) {
            return $1 ? $0 : "!*";
        });
        
        // replace \\ with \
        value = value.replace(/\\\\/g, "\\");

        // convert .* to * (the sequence #.* is not allowed)
        value = value.replace(/\.\*/g, "*");
        
        return value;
    },
    
    /**

     * 克隆这个过滤器。
     * @memberof GeoGlobe.Filter.Comparison.prototype
     * @returns
     * {GeoGlobe.Filter.Comparison} 克隆这个过滤器。
     */
    clone: function() {
        return GeoGlobe.Util.extend(new GeoGlobe.Filter.Comparison(), this);
    },
    
    CLASS_NAME: "GeoGlobe.Filter.Comparison"
});


GeoGlobe.Filter.Comparison.EQUAL_TO                 = "==";
GeoGlobe.Filter.Comparison.NOT_EQUAL_TO             = "!=";
GeoGlobe.Filter.Comparison.LESS_THAN                = "<";
GeoGlobe.Filter.Comparison.GREATER_THAN             = ">";
GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO    = "<=";
GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
GeoGlobe.Filter.Comparison.BETWEEN                  = "..";
GeoGlobe.Filter.Comparison.LIKE                     = "~";
GeoGlobe.Filter.Comparison.IS_NULL                  = "NULL";
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Filter.Spatial
 * @classdesc 空间关系过滤器。
 *
 */
GeoGlobe.Filter.Spatial = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     * 空间过滤器的类型

     * 该类型应该是以下之一：
     * - GeoGlobe.Filter.Spatial.BBOX
     * - GeoGlobe.Filter.Spatial.INTERSECTS
     * - GeoGlobe.Filter.Spatial.DWITHIN
     * - GeoGlobe.Filter.Spatial.WITHIN
     * - GeoGlobe.Filter.Spatial.CONTAINS
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @type {String}
     * @default null

     */
    type: null,
    
    /**
     * 要比较的上下文属性的名称
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @type {String}
     */
    property: null,
    
    /**

     * 过滤器使用的边界或几何图形。
     * 对INTERSECTS或DWITHIN过滤器使用BBOX过滤器和几何图形的边界。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     *
     */
    value: null,

    /**
     * 在DWithin空间过滤器中使用的距离。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @type {Number}

     */
    distance: null,

    /**
     * 单位用于距离的单位，例如'm'。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @type {String}
     */
    distanceUnits: null,
    
    /** 

     * 创建一个空间过滤器。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @param {Object}options -  一个可选对象，可在过滤器上设置属性。
     * @example
     new GeoGlobe.Filter.Spatial({
                    type: GeoGlobe.Filter.Spatial.INTERSECTS, //空间过滤器的类型
                    property: "Geometry", //要素中几何属性的名称
                    value: GeoGlobe.Bounds.fromString(bbox), //查询范围
                    projection: "EPSG:4326" //空间参考
                })
     * @returns
     * {GeoGlobe.Filter.Spatial}
     */

   /**
    * 针对特定功能评估此过滤器。
    * @memberof GeoGlobe.Filter.Spatial.prototype
    * @param {GeoGlobe.Feature}feature -  应用在过滤器上的功能.
    * @returns
    * {Boolean} 该功是否符合过滤条件.
    */
    evaluate: function(feature) {
        var intersect = false;
        switch(this.type) {
            case GeoGlobe.Filter.Spatial.BBOX:
            case GeoGlobe.Filter.Spatial.INTERSECTS:
                if(feature.geometry) {
                    var geom = this.value;
                    if(this.value.CLASS_NAME == "GeoGlobe.LngLatBounds") {
                        geom = this.value.toGeometry();
                    }
                    if(feature.geometry.intersects(geom)) {
                        intersect = true;
                    }
                }
                break;
            default:
                throw new Error('evaluate is not implemented for this filter type.');
        }
        return intersect;
    },

    /**

     * 复制过滤器。
     * @memberof GeoGlobe.Filter.Spatial.prototype
     * @returns
     * {GeoGlobe.Filter.Spatial} 复制过滤器。
     */
    clone: function() {
        var options = GeoGlobe.Util.applyDefaults({
            value: this.value && this.value.clone && this.value.clone()
        }, this);
        return new GeoGlobe.Filter.Spatial(options);
    },
    CLASS_NAME: "GeoGlobe.Filter.Spatial"
});

GeoGlobe.Filter.Spatial.BBOX = "BBOX";
GeoGlobe.Filter.Spatial.INTERSECTS = "INTERSECTS";
GeoGlobe.Filter.Spatial.DWITHIN = "DWITHIN";
GeoGlobe.Filter.Spatial.WITHIN = "WITHIN";
GeoGlobe.Filter.Spatial.CONTAINS = "CONTAINS";
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 *  @memberof GeoGlobe.Filter.Function.prototype
 * @requires View2D/Filter/Filter.js
 */

/**
 * @class GeoGlobe.Filter.Function
 * @classdesc 这个类表示一个过滤器函数。
 * 我们使用这个类来创建可以包含过滤器函数作为值的复杂过滤器。
 * 支持将函数作为其他函数参数来使用。
 */
GeoGlobe.Filter.Function = GeoGlobe.Class4OL(GeoGlobe.Filter, {

    /**
     *  函数名称
     * @memberof GeoGlobe.Filter.Function.prototype
     * @type {String}
     */
    name: null,
    
    /**
     * @memberof GeoGlobe.Filter.Function.prototype
     * @param {Array()}  params
     * 函数参数
     * 现在仅支持其他函数，字符串或数字
     */
    params: null,  
    
    /** 

     * 创造一个过滤器函数。
     * @memberof GeoGlobe.Filter.Function.prototype
     * @param {Object}options -  具有可在函数上设置的属性的可选对象。
     * 
     * @returns
     * {GeoGlobe.Filter.Function}
     */

    CLASS_NAME: "GeoGlobe.Filter.Function"
});

/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Protocol
 * @classdesc Abstract vector layer protocol class.  Not to be instantiated directly.  Use one of the protocol subclasses instead.
 * @private
 */
GeoGlobe.Protocol = GeoGlobe.Class4OL({
    
    /**
     * The format used by this protocol.
     * @memberof GeoGlobe.Protocol.prototype
     *  @type {GeoGlobe.Format}
     */
    format: null,
    
    /**
     *  Any options sent to the constructor.
     *  @memberof GeoGlobe.Protocol.prototype
     *   @type {Object}
     */
    options: null,

    /**
     * The creator of the protocol can set autoDestroy to false
     *      to fully control when the protocol is destroyed. Defaults to true.
     * @memberof GeoGlobe.Protocol.prototype
     * @type {Boolean}
     */
    autoDestroy: true,
   
    /**
     *  Optional default filter to read requests
     *  @memberof GeoGlobe.Protocol.prototype
     *  @type {GeoGlobe.Filter}
     */
    defaultFilter: null,
    
    /**
     * @memberof GeoGlobe.Protocol.prototype
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     */
    initialize: function(options) {
        options = options || {};
        GeoGlobe.Util.extend(this, options);
        this.options = options;
    },

    /**
     *  Merge filter passed to the read method with the default one
     * @memberof GeoGlobe.Protocol.prototype
     * @param {GeoGlobe.Filter} filter
     */
    mergeWithDefaultFilter: function(filter) {
        var merged;
        if (filter && this.defaultFilter) {
            merged = new GeoGlobe.Filter.Logical({
                type: GeoGlobe.Filter.Logical.AND,
                filters: [this.defaultFilter, filter]
            });
        } else {
            merged = filter || this.defaultFilter || undefined;
        }
        return merged;
    },

    /**
     *
     * Clean up the protocol.
     *  @memberof GeoGlobe.Protocol.prototype
     */
    destroy: function() {
        this.options = null;
        this.format = null;
    },
    
    /**
     * Construct a request for reading new features.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {Object} options  - Optional object for configuring the request.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An GeoGlobe.Protocol.Response object,
     * the same object will be passed to the callback function passed if one exists in the options object.
     */
    read: function(options) {
        options = options || {};
        options.filter = this.mergeWithDefaultFilter(options.filter);
    },
    
    
    /**
     * Construct a request for writing newly created features.
     * @memberof GeoGlobe.Protocol.prototype
     * @param  {Array({GeoGlobe.Feature})} or {GeoGlobe.Feature} features
     * @param {Object} options   -  Optional object for configuring the request.
     *
     * @returns {GeoGlobe.Protocol.Response}   - An GeoGlobe.Protocol.Response
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    create: function() {
    },
    
    /**
     * Construct a request updating modified features.
     * @memberof GeoGlobe.Protocol.prototype
     * @param  {Array({GeoGlobe.Feature})} or {GeoGlobe.Feature.Vector}  features
     * @param {Object} options  - Optional object for configuring the request.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An GeoGlobe.Protocol.Response
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    update: function() {
    },
    
    /**
     * Construct a request deleting a removed feature.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {GeoGlobe.Feature} feature
     * @param {Object} options  - Optional object for configuring the request.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An GeoGlobe.Protocol.Response
     * object, the same object will be passed to the callback function passed
     * if one exists in the options object.
     */
    "delete": function() {
    },

    /**
     * Go over the features and for each take action
     *       based on the feature state. Possible actions are create, update and delete.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {Array({GeoGlobe.Feature})} features
     * @param {Object} options  - Object whose possible keys are "create", "update",
     *      "delete", "callback" and "scope", the values referenced by the
     *      first three are objects as passed to the "create", "update", and
     *      "delete" methods, the value referenced by the "callback" key is
     *      a function which is called when the commit operation is complete
     *      using the scope referenced by the "scope" key.
     *
     * @returns {Array({GeoGlobe.Protocol.Response})}  - An array of GeoGlobe.Protocol.Response objects.
     */
    commit: function() {
    },

    /**
     * Abort an ongoing request.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {GeoGlobe.Protocol.Response} response
     */
    abort: function(response) {
    },
   
    /**
     *  Returns a function that applies the given public method with resp an options arguments.
     * @memberof GeoGlobe.Protocol.prototype
     * @param {Function} method  - The method to be applied by the callback.
     * @param {GeoGlobe.Protocol.Response} response  - The protocol response object.
     * @param {Object} options  - Options sent to the protocol method
     */
    createCallback: function(method, response, options) {
        return GeoGlobe.Function.bind(function() {
            method.apply(this, [response, options]);
        }, this);
    },
   
    CLASS_NAME: "GeoGlobe.Protocol" 
});

/**
 * @class GeoGlobe.Protocol.Response
 * @classdesc Protocols return Response objects to their users.
 * @private
 */
GeoGlobe.Protocol.Response = GeoGlobe.Class4OL({
    /**
     *  GeoGlobe.Protocol.Response.SUCCESS or GeoGlobe.Protocol.Response.FAILURE
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {Number}
     */
    code: null,

    /**
     * The type of request this response corresponds to.Either "create", "read", "update" or "delete".
     *  @memberof GeoGlobe.Protocol.Response.prototype
     * @type {String}
     */
    requestType: null,

    /**
     * true if this is the last response expected in a commit,false otherwise, defaults to true.
     *@memberof GeoGlobe.Protocol.Response.prototype
     *  @type {Boolaen}
     */
    last: true,

    /**
     * The features returned in the response by the server. Depending on the
     * protocol's read payload, either features or data will be populated.
     *  @memberof GeoGlobe.Protocol.Response.prototype
     * @type {{Array(GeoGlobe.Feature)} | {GeoGlobe.Feature}}
     */
    features: null,

    /**
     * The data returned in the response by the server. Depending on the
     * protocol's read payload, either features or data will be populated.
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {Object}
     */
    data: null,

    /**
     *  The features provided by the user and placed in the request by the protocol.
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {{Array(GeoGlobe.Feature)} | {GeoGlobe.Feature}}
     */
    reqFeatures: null,

    /**
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {Object}
     */
    priv: null,

    /**
     * The error object in case a service exception was encountered.
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @type {Object}
     */
    error: null,

    /**
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
    },

    /**
     * @memberof GeoGlobe.Protocol.Response.prototype
     * @returns {Boolean} - true on success, false otherwise
     */
    success: function() {
        return this.code > 0;
    },

    CLASS_NAME: "GeoGlobe.Protocol.Response"
});

GeoGlobe.Protocol.Response.SUCCESS = 1;
GeoGlobe.Protocol.Response.FAILURE = 0;
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * if application uses the query string, for example, for BBOX parameters,
 * GeoGlobe/Format/QueryStringFilter.js should be included in the build config file
 */

/**
 * @class GeoGlobe.Protocol.HTTP
 * @classdesc  A basic HTTP protocol for vector layers.  Create a new instance with the
 *     GeoGlobe.Protocol.HTTP constructor.Inherits from GeoGlobe.Protocol
 * @private
 */
GeoGlobe.Protocol.HTTP = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     *  Service URL, read-only, set through the options passed to constructor.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {String}
     */
    url: null,

    /**
     * HTTP request headers, read-only, set through the options passed to the constructor
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @type {Object}
     *
     * @example
     * {'Content-Type': 'plain/text'}
     */
    headers: null,

    /**
     *  Parameters of GET requests, read-only, set through the options passed to the constructor,
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Object}
     *
     * @example
     * {'bbox': '5,5,5,5'}
     */
    params: null,
    
    /**
     * Function to be called when the {read}, {create},
     *     {update}, {delete} or {commit} operation completes, read-only,
     *     set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @type {Object}
     */
    callback: null,

    /**
     *  Callback execution scope,read-only,set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @type {Object}
     *
     */
    scope: null,

    /**
     * true if read operations are done with POST requests instead of GET, defaults to false.
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Boolaen}
     */
    readWithPOST: false,

    /**
     * true if update operations are done with POST requests defaults to false.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @type {Boolaen}
     */
    updateWithPOST: false,
    
    /**
     * true if delete operations are done with POST requests defaults to false. if true, POST data is set to output of format.write().
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Boolaen}
     */
    deleteWithPOST: false,

    /**
     * If true percent signs are added around values
     *     read from LIKE filters, for example if the protocol
     *     read method is passed a LIKE filter whose property
     *     is "foo" and whose value is "bar" the string
     *     "foo__ilike=%bar%" will be sent in the query string;
     *     defaults to false.
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Boolaen}
     */
    wildcarded: false,

    /**
     * Include the SRS identifier in BBOX query string parameter.
     *     Default is false.  If true and the layer has a projection object set,
     *     any BBOX filter will be serialized with a fifth item identifying the
     *     projection.  E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *  @type {Boolaen}
     */
    srsInBBOX: false,

    /**
     *  A class for giving layers generic HTTP protocol.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     * @param {String} url
     * @param {Object} headers
     * @param {Object} params  - URL parameters for GET requests
     * @param {GeoGlobe.Format} format
     * @param {Function} callback
     * @param {Object} scope
     */
    initialize: function(options) {
        options = options || {};
        this.params = {};
        this.headers = {};
        GeoGlobe.Protocol.prototype.initialize.apply(this, arguments);

        if (!this.filterToParams && GeoGlobe.Format.QueryStringFilter) {
            var format = new GeoGlobe.Format.QueryStringFilter({
                wildcarded: this.wildcarded,
                srsInBBOX: this.srsInBBOX
            });
            this.filterToParams = function(filter, params) {
                return format.write(filter, params);
            };
        }
    },
    
    /**
     * Clean up the protocol.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *
     */
    destroy: function() {
        this.params = null;
        this.headers = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * Optional method to translate an {GeoGlobe.Filter} object into an object
     *     that can be serialized as request query string provided.  If a custom
     *     method is not provided, the filter will be serialized using the 
     *     {GeoGlobe.Format.QueryStringFilter} class.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     *
     * @param {GeoGlobe.Filter} filter   - filter to convert.
     * @param  {Object} params  - The parameters object.
     *
     * @returns {Object}  - The resulting parameters object.
     */
    
    /**
     * Construct a request for reading new features.
     *  @memberof GeoGlobe.Protocol.HTTP.prototype
     *
     * @param  {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     * @param {String} url  - Url for the request.
     * @param {Object} params  - Parameters to get serialized as a query string.
     * @param {Object} headers  - Headers to be set on the request.
     * @param {GeoGlobe.Filter} filter  -  Filter to get serialized as a query string.
     * @param {Boolean} readWithPOST  - If the request should be done with POST.
     *
     * @returns {GeoGlobe.Protocol.Response}  - A response object, whose "priv" property
     *     references the HTTP request, this object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the features received from the server.
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = options || {};
        options.params = GeoGlobe.Util.applyDefaults(
            options.params, this.options.params);
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        if (options.filter && this.filterToParams) {
            options.params = this.filterToParams(
                options.filter, options.params
            );
        }
        var readWithPOST = (options.readWithPOST !== undefined) ?
                           options.readWithPOST : this.readWithPOST;
        var resp = new GeoGlobe.Protocol.Response({requestType: "read"});
        if(readWithPOST) {
            var headers = options.headers || {};
            headers["Content-Type"] = "application/x-www-form-urlencoded";
            resp.priv = GeoGlobe.Request.POST({
                url: options.url,
                callback: this.createCallback(this.handleRead, resp, options),
                data: GeoGlobe.Util.getParameterString(options.params),
                headers: headers
            });
        } else {
            resp.priv = GeoGlobe.Request.GET({
                url: options.url,
                callback: this.createCallback(this.handleRead, resp, options),
                params: options.params,
                headers: options.headers
            });
        }
        return resp;
    },

    /**
     * Individual callbacks are created for read, create and update, should a subclass need to override each one separately.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  - The response object to pass to the user callback.
     * @param {Object}   - The user options passed to the read call.
     */
    handleRead: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Construct a request for writing newly created features.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {Array({GeoGlobe.Feature.Vector})} or {GeoGlobe.Feature.Vector} features
     * @param {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * @returns {GeoGlobe.Protocol.Response}
     * - An {GeoGlobe.Protocol.Response}
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the features received from the server.
     */
    create: function(features, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: features,
            requestType: "create"
        });

        resp.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleCreate, resp, options),
            headers: options.headers,
            data: this.format.write(features)
        });

        return resp;
    },

    /**
     * Called the the request issued by <create> is complete.  May be overridden by subclasses.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  - The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the create call.
     */
    handleCreate: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Construct a request updating modified feature.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Feature.Vector} feature
     * @param {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An GeoGlobe.Protocol.Response
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes, its "features" property is then populated with the
     *     the feature received from the server.
     */
    update: function(feature, options) {
        options = options || {};
        var url = options.url ||
                  feature.url ||
                  this.options.url + "/" + feature.fid;
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: feature,
            requestType: "update"
        });

        var method = this.updateWithPOST ? "POST" : "PUT";
        resp.priv = GeoGlobe.Request[method]({
            url: url,
            callback: this.createCallback(this.handleUpdate, resp, options),
            headers: options.headers,
            data: this.format.write(feature)
        });

        return resp;
    },

    /**
     * Called the the request issued by update is complete.  May be overridden by subclasses.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  - The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the update call.
     */
    handleUpdate: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Construct a request deleting a removed feature.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Feature.Vector} feature
     * @param {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * @returns {GeoGlobe.Protocol.Response}  - An {GeoGlobe.Protocol.Response}
     *     object, whose "priv" property references the HTTP request, this 
     *     object is also passed to the callback function when the request
     *     completes.
     */
    "delete": function(feature, options) {
        options = options || {};
        var url = options.url ||
                  feature.url ||
                  this.options.url + "/" + feature.fid;
        options = GeoGlobe.Util.applyDefaults(options, this.options);

        var resp = new GeoGlobe.Protocol.Response({
            reqFeatures: feature,
            requestType: "delete"
        });

        var method = this.deleteWithPOST ? "POST" : "DELETE";
        var requestOptions = {
            url: url,
            callback: this.createCallback(this.handleDelete, resp, options),
            headers: options.headers
        };
        if (this.deleteWithPOST) {
            requestOptions.data = this.format.write(feature);
        }
        resp.priv = GeoGlobe.Request[method](requestOptions);

        return resp;
    },

    /**
     * Called the the request issued by delete is complete.  May be overridden by subclasses.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  - The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the delete call.
     */
    handleDelete: function(resp, options) {
        this.handleResponse(resp, options);
    },

    /**
     * Called by CRUD specific handlers.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp  -  The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the create, read, update, or delete call.
     */
    handleResponse: function(resp, options) {
        var request = resp.priv;
        if(options.callback) {
            if(request.status >= 200 && request.status < 300) {
                // success
                if(resp.requestType != "delete") {
                    resp.features = this.parseFeatures(request);
                }
                resp.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                // failure
                resp.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, resp);
        }
    },

    /**
     * Read HTTP response body and return features.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {XMLHttpRequest} request  - The request object
     *
     * @returns {Array({GeoGlobe.Feature.Vector})} or {GeoGlobe.Feature.Vector}
     *  - Array of features or a single feature.
     */
    parseFeatures: function(request) {
        var doc = request.responseXML;
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if (!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    /**
     *  Iterate over each feature and take action based on the feature state.
     *     Possible actions are create, update and delete.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {Array({GeoGlobe.Feature.Vector})} features
     * @param {Object} options   - Optional object for setting up intermediate commit callbacks.
     * @param {Object} create   -  Optional object to be passed to the <create> method.
     * @param {Object} update  - Optional object to be passed to the <update> method.
     * @param {Object} delete  - Optional object to be passed to the <delete> method.
     * @param {Function} callback  - Optional function to be called when the commit is complete.
     * @param  {Object} scope  -  Optional object to be set as the scope of the callback.
     *
     * @returns {Array(GeoGlobe.Protocol.Response)}  - An array of response objects,
     *     one per request made to the server, each object's "priv" property
     *     references the corresponding HTTP request.
     */
    commit: function(features, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        var resp = [], nResponses = 0;
        
        // Divide up features before issuing any requests.  This properly
        // counts requests in the event that any responses come in before
        // all requests have been issued.
        var types = {};
        types[GeoGlobe.State.INSERT] = [];
        types[GeoGlobe.State.UPDATE] = [];
        types[GeoGlobe.State.DELETE] = [];
        var feature, list, requestFeatures = [];
        for(var i=0, len=features.length; i<len; ++i) {
            feature = features[i];
            list = types[feature.state];
            if(list) {
                list.push(feature);
                requestFeatures.push(feature); 
            }
        }
        // tally up number of requests
        var nRequests = (types[GeoGlobe.State.INSERT].length > 0 ? 1 : 0) +
            types[GeoGlobe.State.UPDATE].length +
            types[GeoGlobe.State.DELETE].length;
        
        // This response will be sent to the final callback after all the others
        // have been fired.
        var success = true;
        var finalResponse = new GeoGlobe.Protocol.Response({
            reqFeatures: requestFeatures        
        });
        
        function insertCallback(response) {
            var len = response.features ? response.features.length : 0;
            var fids = new Array(len);
            for(var i=0; i<len; ++i) {
                fids[i] = response.features[i].fid;
            }   
            finalResponse.insertIds = fids;
            callback.apply(this, [response]);
        }
 
        function callback(response) {
            this.callUserCallback(response, options);
            success = success && response.success();
            nResponses++;
            if (nResponses >= nRequests) {
                if (options.callback) {
                    finalResponse.code = success ?
                        GeoGlobe.Protocol.Response.SUCCESS :
                        GeoGlobe.Protocol.Response.FAILURE;
                    options.callback.apply(options.scope, [finalResponse]);
                }    
            }
        }

        // start issuing requests
        var queue = types[GeoGlobe.State.INSERT];
        if(queue.length > 0) {
            resp.push(this.create(
                queue, GeoGlobe.Util.applyDefaults(
                    {callback: insertCallback, scope: this}, options.create
                )
            ));
        }
        queue = types[GeoGlobe.State.UPDATE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this.update(
                queue[i], GeoGlobe.Util.applyDefaults(
                    {callback: callback, scope: this}, options.update
                ))
            );
        }
        queue = types[GeoGlobe.State.DELETE];
        for(var i=queue.length-1; i>=0; --i) {
            resp.push(this["delete"](
                queue[i], GeoGlobe.Util.applyDefaults(
                    {callback: callback, scope: this}, options["delete"]
                ))
            );
        }
        return resp;
    },

    /**
     * Abort an ongoing request, the response object passed to
     *      this method must come from this HTTP protocol (as a result
     *      of a create, read, update, delete or commit operation).
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} response
     */
    abort: function(response) {
        if (response) {
            response.priv.abort();
        }
    },

    /**
     *  This method is used from within the commit method each time an
     *     an HTTP response is received from the server, it is responsible
     *     for calling the user-supplied callbacks.
     * @memberof GeoGlobe.Protocol.HTTP.prototype
     * @param {GeoGlobe.Protocol.Response} resp
     * @param {Object} options  - The map of options passed to the commit call.
     */
    callUserCallback: function(resp, options) {
        var opt = options[resp.requestType];
        if(opt && opt.callback) {
            opt.callback.call(opt.scope, resp);
        }
    },

    CLASS_NAME: "GeoGlobe.Protocol.HTTP"
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Protocol.WFS
 * @classdesc Used to create a versioned WFS protocol.  Default version is 1.0.0.
 *
 * @returns {GeoGlobe.Protocol}  - A WFS protocol of the given version.
 *
 * @example
 *     var protocol = new GeoGlobe.Protocol.WFS({
 *         version: "1.1.0",
 *         url:  "http://demo.opengeo.org/geoserver/wfs",
 *         featureType: "tasmania_roads",
 *         featureNS: "http://www.openplans.org/topp",
 *         geometryName: "the_geom"
 *     });
 * (end)
 *
 * See the protocols for specific WFS versions for more detail.
 * @private
 */

GeoGlobe.Protocol.WFS = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Protocol.WFS.DEFAULTS
    );
    var cls = GeoGlobe.Protocol.WFS["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported WFS version: " + options.version;
    }
    return new cls(options);
};

/**
 * GeoGlobe.Protocol.WFS.DEFAULTS
 *  @memberof GeoGlobe.Protocol.WFS.prototype
 */
GeoGlobe.Protocol.WFS.DEFAULTS = {
    "version": "1.0.0"
};
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Protocol.WFS.v1
 * @classdesc Abstract class for for v1.0.0 and v1.1.0 protocol.Inherits from: GeoGlobe.Protocol
 * @private
 */
GeoGlobe.Protocol.WFS.v1 = GeoGlobe.Class4OL(GeoGlobe.Protocol, {
    
    /**
     * WFS version number.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    version: null,
    
    /**
     * Name of spatial reference system.  Default is "EPSG:4326".
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    srsName: "EPSG:4326",
    
    /**
     *  Local feature typeName.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    featureType: null,
    
    /**
     *  Feature namespace.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    featureNS: null,
    
    /**
     * Name of the geometry attribute for features.  Default is "the_geom" for WFS version 1.0, and null for higher versions.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    geometryName: "the_geom",

    /**
     * Optional maximum number of features to retrieve.
     *  @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {Integer}
     */
    
    /**
     * Optional schema location that will be included in the
     *     schemaLocation attribute value.  Note that the feature type schema
     *     is required for a strict XML validator (on transactions with an
     *     insert for example), but is *not* required by the WFS specification
     *     (since the server is supposed to know about feature type schemas).
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    schema: null,

    /**
     * Namespace alias for feature type.  Default is "feature".
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {String}
     */
    featurePrefix: "feature",
    
    /**
     * Optional options for the format.  If a format is not provided,this property can be used to extend the default format options.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {Object}
     */
    formatOptions: null,

    /** 
     * For WFS requests it is possible to get a
     *     different output format than GML. In that case, we cannot parse  
     *     the response with the default format (WFST) and we need a different format for reading.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {GeoGlobe.Format}
     */ 
    readFormat: null,
    
    /**
     * Optional object to pass to format's read.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {Object}
     */
    readOptions: null,
    
    /**
     * A class for giving layers WFS protocol.
     *  @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     *
     * @param {String} url  - URL to send requests to (required).
     * @param {String} featureType  - Local (without prefix) feature typeName (required).
     * @param {String} featureNS  - Feature namespace (required, but can be autodetected
     *     during the first query if GML is used as readFormat and
     *     featurePrefix is provided and matches the prefix used by the server
     *     for this featureType).
     * @param {String} featurePrefix  - Feature namespace alias (optional - only used
     *     for writing if featureNS is provided).  Default is 'feature'.
     * @param {String} geometryName  - Name of geometry attribute.  The default is
     *     'the_geom' for WFS version 1.0, and null for higher versions. If
     *     null, it will be set to the name of the first geometry found in the
     *     first read operation.
     * @param {Boolean} multi  - If set to true, geometries will be casted to Multi
     *     geometries before they are written in a transaction. No casting will
     *     be done when reading features.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = GeoGlobe.Format.WFST(GeoGlobe.Util.extend({
                version: this.version,
                featureType: this.featureType,
                featureNS: this.featureNS,
                featurePrefix: this.featurePrefix,
                geometryName: this.geometryName,
                srsName: this.srsName,
                schema: this.schema
            }, this.formatOptions));
        }
        if (!options.geometryName && parseFloat(this.format.version) > 1.0) {
            this.setGeometryName(null);
        }
    },
    
    /**
     *  Clean up the protocol.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * Construct a request for reading new features.  Since WFS splits the
     *     basic CRUD operations into GetFeature requests (for read) and
     *     Transactions (for all others), this method does not make use of the
     *     format's read method (that is only about reading transaction responses).
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     * @param {Object} options  - Options for the read operation, in addition to the
     *     options set on the instance (options set here will take precedence).
     *
     * @example
     * To use a configured protocol to get e.g. a WFS hit count, applications
     * could do the following:
     *
     * (code)
     * protocol.read({
     *     readOptions: {output: "object"},
     *     resultType: "hits",
     *     maxFeatures: null,
     *     callback: function(resp) {
     *         // process resp.numberOfFeatures here
     *     }
     * });
     * (end)
     *
     * To use a configured protocol to use WFS paging (if supported by the
     * server), applications could do the following:
     *
     * (code)
     * protocol.read({
     *     startIndex: 0,
     *     count: 50
     * });
     * (end)
     *
     * To limit the attributes returned by the GetFeature request, applications
     * can use the propertyNames option to specify the properties to include in
     * the response:
     *
     * (code)
     * protocol.read({
     *     propertyNames: ["DURATION", "INTENSITY"]
     * });
     * (end)
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options || {});
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});
        
        var data = GeoGlobe.Format.XML.prototype.write.apply(
            this.format, [this.format.writeNode("wfs:GetFeature", options)]
        );

        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            params: options.params,
            headers: options.headers,
            data: data
        });

        return response;
    },

    /**
     * Change the feature type on the fly.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     * @param {String} featureType  - Local (without prefix) feature typeName.
     */
    setFeatureType: function(featureType) {
        this.featureType = featureType;
        this.format.featureType = featureType;
    },
 
    /**
     * Sets the geometryName option after instantiation.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @param {String} geometryName  - Name of geometry attribute.
     */
    setGeometryName: function(geometryName) {
        this.geometryName = geometryName;
        this.format.geometryName = geometryName;
    },
    
    /**
     * Deal with response from the read request
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype.
     *
     * @param {GeoGlobe.Protocol.Response} response  - The response object to pass to the user callback.
     * @param {Object} options  - The user options passed to the read call.
     */
    handleRead: function(response, options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);

        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                var result = this.parseResponse(request, options.readOptions);
                if (result && result.success !== false) { 
                    if (options.readOptions && options.readOptions.output == "object") {
                        GeoGlobe.Util.extend(response, result);
                    } else {
                        response.features = result;
                    }
                    response.code = GeoGlobe.Protocol.Response.SUCCESS;
                } else {
                    // failure (service exception)
                    response.code = GeoGlobe.Protocol.Response.FAILURE;
                    response.error = result;
                }
            } else {
                // failure
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Read HTTP response body and return features
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     *
     * @param {XMLHttpRequest} request  - The request object
     * @param  {Object} options  - Optional object to pass to format's read
     *
     * @returns {Object} or {Array({GeoGlobe.Feature})} or {GeoGlobe.Feature}
     *  - An object with a features property, an array of features or a single feature.
     */
    parseResponse: function(request, options) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
		
        //var result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
        //    this.format.read(doc, options);
		var result=null;
        try{
        	result = (this.readFormat !== null) ? this.readFormat.read(doc) : 
            this.format.read(doc, options);
        }catch(e){
        	var error = "程序运行异常："+e.name + "，"+e.message;
        	alert(error);
        	//throw e;
        }
        if (!this.featureNS) {
            var format = this.readFormat || this.format;
            this.featureNS = format.featureNS;
            // no need to auto-configure again on subsequent reads
            format.autoConfig = false;
            if (!this.geometryName) {
                this.setGeometryName(format.geometryName);
            }
        }
        return result;
    },

    /**
     * Given a list of feature, assemble a batch request for update, create,
     *     and delete transactions.  A commit call on the prototype amounts
     *     to writing a WFS transaction - so the write method on the format
     *     is used.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @param {Array(GeoGlobe.Feature)} features
     * @param  {Object} options
     *
     * Array of objects with information for writing
     *      out Native elements, these objects have vendorId, safeToIgnore and
     *      value properties. The Native  element is intended to allow access to
     *      vendor specific capabilities of any particular web feature server or datastore.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @type {Array({Object})}
     *
     * @returns {GeoGlobe.Protocol.Response}   - A response object with a features
     *     property containing any insertIds and a property referencing the XMLHttpRequest object.
     */
    commit: function(features, options) {

        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);
        
        var response = new GeoGlobe.Protocol.Response({
            requestType: "commit",
            reqFeatures: features
        });
        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            headers: options.headers,
            data: this.format.write(features, options),
            callback: this.createCallback(this.handleCommit, response, options)
        });
        
        return response;
    },
    
    /**
     * Called when the commit request returns.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @param {GeoGlobe.Protocol.Response} response   - The response object to pass to the user callback.
     * @param {Object} options  - The user options passed to the commit call.
     */
    handleCommit: function(response, options) {
        if(options.callback) {
            var request = response.priv;

            // ensure that we have an xml doc
            var data = request.responseXML;
            if(!data || !data.documentElement) {
                data = request.responseText;
            }
            
            var obj = this.format.read(data) || {};
            
            response.insertIds = obj.insertIds || [];
            if (obj.success) {
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                response.code = GeoGlobe.Protocol.Response.FAILURE;
                response.error = obj;
            }
            options.callback.call(options.scope, response);
        }
    },
    
    /**
     * Send a request that deletes all features by their filter.
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * 
     * @param {GeoGlobe.Filter} filter  - filter
     */
    filterDelete: function(filter, options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options);    
        
        var response = new GeoGlobe.Protocol.Response({
            requestType: "commit"
        });    
        
        var root = this.format.createElementNSPlus("wfs:Transaction", {
            attributes: {
                service: "WFS",
                version: this.version
            }
        });
        
        var deleteNode = this.format.createElementNSPlus("wfs:Delete", {
            attributes: {
                typeName: (options.featureNS ? this.featurePrefix + ":" : "") +
                    options.featureType
            }
        });       
        
        if(options.featureNS) {
            deleteNode.setAttribute("xmlns:" + this.featurePrefix, options.featureNS);
        }
        var filterNode = this.format.writeNode("ogc:Filter", filter);
        
        deleteNode.appendChild(filterNode);
        
        root.appendChild(deleteNode);
        
        var data = GeoGlobe.Format.XML.prototype.write.apply(
            this.format, [root]
        );
        
        return GeoGlobe.Request.POST({
            url: this.url,
            callback : options.callback || function(){},
            data: data
        });   
        
    },

    /**
     * Abort an ongoing request, the response object passed to
     * this method must come from this protocol (as a result of a read, or commit operation).
     * @memberof GeoGlobe.Protocol.WFS.v1.prototype
     * @param {GeoGlobe.Protocol.Response} response
     */
    abort: function(response) {
        if (response) {
            response.priv.abort();
        }
    },
  
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Protocol.WFS.v1_0_0
 * @classdesc  A WFS v1.0.0 protocol for vector layers.  Create a new instance with the
 *     GeoGlobe.Protocol.WFS.v1_0_0 constructor.Inherits from:GeoGlobe.Protocol.WFS.v1
 * @private
 */
GeoGlobe.Protocol.WFS.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Protocol.WFS.v1, {
    
    /**
     * WFS version number.
     * @memberof GeoGlobe.Protocol.WFS.v1_0_0.prototype
     * @type {String}
     */
    version: "1.0.0",
    
    /**
     * A class for giving layers WFS v1.0.0 protocol.
     * @memberof GeoGlobe.Protocol.WFS.v1_0_0.prototype
     *
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     *
     * @param {String} featureType  - Local (without prefix) feature typeName (required).
     * @param featureNS  - Feature namespace (optional).
     * @param {String}  featurePrefix  - Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * @param {String} geometryName  - Name of geometry attribute.  Default is 'the_geom'.
     */
   
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1_0_0" 
});
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class GeoGlobe.Protocol.WFS.v1_1_0
 * @classdesc A WFS v1.1.0 protocol for vector layers.  Create a new instance with the
 *     GeoGlobe.Protocol.WFS.v1_1_0 constructor.Inherits from:GeoGlobe.Protocol.WFS.v1
 * @private
 *  Differences from the v1.0.0 protocol:
 *  - uses Filter Encoding 1.1.0 instead of 1.0.0
 *  - uses GML 3 instead of 2 if no format is provided
 */
GeoGlobe.Protocol.WFS.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Protocol.WFS.v1, {
    
    /**
     * WFS version number.
     * @memberof GeoGlobe.Protocol.WFS.v1_1_0.prototype
     * @type {String}
     */
    version: "1.1.0",
    
    /**
     * A class for giving layers WFS v1.1.0 protocol.
     * @memberof GeoGlobe.Protocol.WFS.v1_1_0.prototype
     *
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     *
     * @param {String} featureType  - Local (without prefix) feature typeName (required).
     * @param {String} featureNS  - Feature namespace (optional).
     * @param {String} featurePrefix  - Feature namespace alias (optional - only used
     *     if featureNS is provided).  Default is 'feature'.
     * @param {String} geometryName  - Name of geometry attribute.  Default is 'the_geom'.
     * @param {String} outputFormat  - Optional output format to use for WFS GetFeature
     *     requests. This can be any format advertized by the WFS's
     *     GetCapabilities response. If set, an appropriate readFormat also
     *     has to be provided, unless outputFormat is GML3, GML2 or JSON.
     * @param {GeoGlobe.Format}  readFormat  - An appropriate format parser if
     *     outputFormat is none of GML3, GML2 or JSON.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.WFS.v1.prototype.initialize.apply(this, arguments);
        if (this.outputFormat && !this.readFormat) {
            if (this.outputFormat.toLowerCase() == "gml2") {
                this.readFormat = new GeoGlobe.Format.GML.v2({
                    featureType: this.featureType,
                    featureNS: this.featureNS,
                    geometryName: this.geometryName
                });
            } else if (this.outputFormat.toLowerCase() == "json") {
                this.readFormat = new GeoGlobe.Format.GeoJSON();
            }
        }
    },
   
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1_1_0"
});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Protocol.CSW
 * @classdesc Used to create a versioned CSW protocol. Default version is 2.0.2.
 * @private
 */
GeoGlobe.Protocol.CSW = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Protocol.CSW.DEFAULTS
    );
    var cls = GeoGlobe.Protocol.CSW["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSW version: " + options.version;
    }
    return new cls(options);
};

/**
 * @memberof GeoGlobe.Popup.prototype
 */
GeoGlobe.Protocol.CSW.DEFAULTS = {
    "version": "2.0.2"
};
/**
 * @class GeoGlobe.Protocol.CSW.v2_0_2
 * @classdesc CS-W (Catalogue services for the Web) version 2.0.2 protocol.Inherits from GeoGlobe.Protocol
 * @private
 */
GeoGlobe.Protocol.CSW.v2_0_2 = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     * Optional options for the format.  If a format is not provided,this property can be used to extend the default format options.
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     * @type {Object}
     */
    formatOptions: null,

    /**
     * A class for CSW version 2.0.2 protocol management.
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     * @param {Object} options  -  Optional object whose properties will be set on the instance.
     */
    initialize: function(options) {
        GeoGlobe.Protocol.prototype.initialize.apply(this, [options]);
        if(!options.format) {
            this.format = new GeoGlobe.Format.CSWGetRecords.v2_0_2(GeoGlobe.Util.extend({
            }, this.formatOptions));
        }
    },

    /**
     * destroy  - Clean up the protocol.
     *  @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     */
    destroy: function() {
        if(this.options && !this.options.format) {
            this.format.destroy();
        }
        this.format = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    /**
     * Construct a request for reading new records from the Catalogue.
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     */
    read: function(options) {
        options = GeoGlobe.Util.extend({}, options);
        GeoGlobe.Util.applyDefaults(options, this.options || {});
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});

        var data = this.format.write(options.params || options);

        response.priv = GeoGlobe.Request.POST({
            url: options.url,
            callback: this.createCallback(this.handleRead, response, options),
            params: options.params,
            headers: options.headers,
            data: data
        });

        return response;
    },

    /**
     *  Deal with response from the read request.
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     *
     * @param {GeoGlobe.Protocol.Response} response  - The response object to pass to the user callback.
     *     This response is given a code property, and optionally a data property.
     *     The latter represents the CSW records as returned by the call to
     *     the CSW format read method.
     * @param {Object} options  - The user options passed to the read call.
     */
    handleRead: function(response, options) {
        if(options.callback) {
            var request = response.priv;
            if(request.status >= 200 && request.status < 300) {
                // success
                response.data = this.parseData(request);
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                // failure
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Read HTTP response body and return records
     * @memberof GeoGlobe.Protocol.CSW.v2_0_2.prototype
     * @param  {XMLHttpRequest} request  -  The request object
     *
     * @returns {Object}  - The CSW records as returned by the call to the format read method.
     */
    parseData: function(request) {
        var doc = request.responseXML;
        if(!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc || doc.length <= 0) {
            return null;
        }
        return this.format.read(doc);
    },

    CLASS_NAME: "GeoGlobe.Protocol.CSW.v2_0_2"

});
/* Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */


/**
 * if application uses the query string, for example, for BBOX parameters,
 * GeoGlobe/Format/QueryStringFilter.js should be included in the build config file
 */

/**
 * @class  GeoGlobe.Protocol.Script
 * @classdesc A basic Script protocol for vector layers.  Create a new instance with the
 *     GeoGlobe.Protocol.Script constructor.  A script protocol is used to
 *     get around the same origin policy.  It works with services that return
 *     JSONP - that is, JSON wrapped in a client-specified callback.  The
 *     protocol handles fetching and parsing of feature data and sends parsed
 *     features to the <callback> configured with the protocol.  The protocol
 *     expects features serialized as GeoJSON by default, but can be configured
 *     to work with other formats by setting the <format> property.Inherits from GeoGlobe.Protocol
 * @private
 */
GeoGlobe.Protocol.Script = GeoGlobe.Class4OL(GeoGlobe.Protocol, {

    /**
     * Service URL.
     *
     * The service is expected to return serialized
     *     features wrapped in a named callback (where the callback name is
     *     generated by this protocol).
     *     Read-only, set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @type {String}
     */
    url: null,

    /**
     * Query string parameters to be appended to the URL.Read-only, set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @type {Object}
     *
     * @example
     * {maxFeatures: 50}
     */
    params: null,
    
    /**
     * Function to be called when the <read> operation completes.
     *  @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {Object}
     */
    callback: null,

    /**
     * Template for creating a unique callback function name
     *      for the registry. Should include ${id}.  The ${id} variable will be
     *      replaced with a string identifier prefixed with a "c" (e.g. c1, c2).
     *      Default is "GeoGlobe.Protocol.Script.registry.${id}".
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @type {String}
     */
    callbackTemplate: "GeoGlobe.Protocol.Script.registry.${id}",

    /**
     * The name of the query string parameter that the service
     *     recognizes as the callback identifier.  Default is "callback".
     *     This key is used to generate the URL for the script.  For example
     *     setting <callbackKey> to "myCallback" would result in a URL like 
     *     http://example.com/?myCallback=...
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {String}
     */
    callbackKey: "callback",

    /**
     * Where a service requires that the callback query string
     *     parameter value is prefixed by some string, this value may be set.
     *     For example, setting callbackPrefix  to "foo:" would result in a
     *     URL like http://example.com/?callback=foo:...  Default is "".
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {String}
     */
    callbackPrefix: "",

    /**
     * Optional ``this`` object for the callback. Read-only, set through the options passed to the constructor.
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {Object}
     */
    scope: null,

    /**
     * Format for parsing features.  Default is an
     *     GeoGlobe.Format.GeoJSON format.  If an alternative is provided,
     *     the format's read method must take an object and return an array
     *     of features.
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {GeoGlobe.Format}
     */
    format: null,

    /**
     * References all pending requests.  Property names are script
     *     identifiers and property values are script elements.
     * @memberof GeoGlobe.Protocol.Script.prototype
     *  @type {Object}
     */
    pendingRequests: null,

    /**
     * Include the SRS identifier in BBOX query string parameter.
     *     Setting this property has no effect if a custom filterToParams method
     *     is provided.   Default is false.  If true and the layer has a 
     *     projection object set, any BBOX filter will be serialized with a 
     *     fifth item identifying the projection.  
     *     E.g. bbox=-1000,-1000,1000,1000,EPSG:900913
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @type {Boolean}
     */
    srsInBBOX: false,

    /**
     * A class for giving layers generic Script protocol.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Object} options  - Optional object whose properties will be set on the instance.
     * @param  {String}  url
     * @param {Object} params
     * @param {Function} callback
     * @param  {Object} scope
     */
    initialize: function(options) {
        options = options || {};
        this.params = {};
        this.pendingRequests = {};
        GeoGlobe.Protocol.prototype.initialize.apply(this, arguments);
        if (!this.format) {
            this.format = new GeoGlobe.Format.GeoJSON();
        }

        if (!this.filterToParams && GeoGlobe.Format.QueryStringFilter) {
            var format = new GeoGlobe.Format.QueryStringFilter({
                srsInBBOX: this.srsInBBOX
            });
            this.filterToParams = function(filter, params) {
                return format.write(filter, params);
            };
        }
    },
    
    /**
     * Construct a request for reading new features.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Object} options  - Optional object for configuring the request.
     *     This object is modified and should not be reused.
     *
     * @param {String} url  - Url for the request.
     * @param {Object} params  - Parameters to get serialized as a query string.
     * @param {GeoGlobe.Filter} filter  -  Filter to get serialized as a query string.
     *
     * @returns {GeoGlobe.Protocol.Response}
     *  - A response object, whose "priv" property
     *     references the injected script.  This object is also passed to the
     *     callback function when the request completes, its "features" property
     *     is then populated with the features received from the server.
     */
    read: function(options) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        options.params = GeoGlobe.Util.applyDefaults(
            options.params, this.options.params
        );
        if (options.filter && this.filterToParams) {
            options.params = this.filterToParams(
                options.filter, options.params
            );
        }
        var response = new GeoGlobe.Protocol.Response({requestType: "read"});
        var request = this.createRequest(
            options.url, 
            options.params, 
            GeoGlobe.Function.bind(function(data) {
                response.data = data;
                this.handleRead(response, options);
            }, this)
        );
        response.priv = request;
        return response;
    },

    /** 
     * Optional method to translate an <GeoGlobe.Filter> object into an object
     *     that can be serialized as request query string provided.  If a custom 
     *     method is not provided, any filter will not be serialized. 
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {GeoGlobe.Filter} filter  - filter to convert.
     * @param  params  - The parameters object.
     * 
     * @returns {Object}  - The resulting parameters object.
     */

    /** 
     * Issues a request for features by creating injecting a script in the document head.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {String} url  - Service URL.
     * @param {Object} params  - Query string parameters.
     * @param {Function} callback  - Callback to be called with resulting data.
     *
     * @returns {HTMLScriptElement}  - The script pending execution.
     */
    createRequest: function(url, params, callback) {
        var id = GeoGlobe.Protocol.Script.register(callback);
        var name = GeoGlobe.String.format(this.callbackTemplate, {id: id});
        params = GeoGlobe.Util.extend({}, params);
        params[this.callbackKey] = this.callbackPrefix + name;
        url = GeoGlobe.Util.urlAppend(
            url, GeoGlobe.Util.getParameterString(params)
        );
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = url;
        script.id = "GeoGlobe_Protocol_Script_" + id;
        this.pendingRequests[script.id] = script;
        var head = document.getElementsByTagName("head")[0];
        head.appendChild(script);
        return script;
    },
    
    /** 
     * Remove a script node associated with a response from the document.  Also
     *     unregisters the callback and removes the script from the pendingRequests object.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {HTMLScriptElement}  script
     */
    destroyRequest: function(script) {
        GeoGlobe.Protocol.Script.unregister(script.id.split("_").pop());
        delete this.pendingRequests[script.id];
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
    },

    /**
     * Individual callbacks are created for read, create and update, should
     *     a subclass need to override each one separately.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {GeoGlobe.Protocol.Response} response  - The response object to pass to the user callback.
     * @param {Object} options  - The user options passed to the read call.
     */
    handleRead: function(response, options) {
        this.handleResponse(response, options);
    },

    /**
     * Called by CRUD specific handlers.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {GeoGlobe.Protocol.Response} response  - The response object to pass to any user callback.
     * @param {Object} options  - The user options passed to the create, read, update,or delete call.
     */
    handleResponse: function(response, options) {
        if (options.callback) {
            if (response.data) {
                response.features = this.parseFeatures(response.data);
                response.code = GeoGlobe.Protocol.Response.SUCCESS;
            } else {
                response.code = GeoGlobe.Protocol.Response.FAILURE;
            }
            this.destroyRequest(response.priv);
            options.callback.call(options.scope, response);
        }
    },

    /**
     * Read Script response body and return features.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Object} data  - The data sent to the callback function by the server.
     *
     * @returns {Array({GeoGlobe.Feature})} or {GeoGlobe.Feature}  - Array of features or a single feature.
     */
    parseFeatures: function(data) {
        return this.format.read(data);
    },

    /**
     * Abort an ongoing request.  If no response is provided, all pending requests will be aborted.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {GeoGlobe.Protocol.Response} response  - The response object returned from a <read> request.
     */
    abort: function(response) {
        if (response) {
            this.destroyRequest(response.priv);
        } else {
            for (var key in this.pendingRequests) {
                this.destroyRequest(this.pendingRequests[key]);
            }
        }
    },
    
    /**
     * Clean up the protocol.
     *  @memberof GeoGlobe.Protocol.Script.prototype
     */
    destroy: function() {
        this.abort();
        delete this.params;
        delete this.format;
        GeoGlobe.Protocol.prototype.destroy.apply(this);
    },

    CLASS_NAME: "GeoGlobe.Protocol.Script" 
});

(function() {
    var o = GeoGlobe.Protocol.Script;
    var counter = 0;
    o.registry = {};
    
    /**
     * Register a callback for a newly created script.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Function} callback  - The callback to be executed when the newly added
     *     script loads.  This callback will be called with a single argument
     *     that is the JSON returned by the service.
     *
     * @returns {Number}  - An identifier for retrieving the registered callback.
     */
    o.register = function(callback) {
        var id = "c"+(++counter);
        o.registry[id] = function() {
            callback.apply(this, arguments);
        };
        return id;
    };
    
    /**
     * Unregister a callback previously registered with the register function.
     * @memberof GeoGlobe.Protocol.Script.prototype
     * @param {Number} id   - The identifer returned by the register function.
     */
    o.unregister = function(id) {
        delete o.registry[id];
    };
})();
/**
 * @class GeoGlobe.Format
 * @classdesc 用于格式读取/写入各种格式的基类。 GeoGlobe.Format的子类预计会有读取和写入方法。
 * 格式化基类。
 *  @returns GeoGlobe.Format的一个实例
 */


GeoGlobe.Format = GeoGlobe.Class4OL({
    /**
     *A reference to options passed to the constructor.
     * @memberof GeoGlobe.Format.prototype
     * @type {object}
     * @private
     */

    options: null,
    
    /**
     * externalProjection- 当通过externalProjection和internalProjection传递时，
     * 格式将重新投影它读取或写入的几何。 
     * externalProjection是被传入读取或写出的内容所使用的投影。 
     * 为了重投影，指定投影的投影转换函数必须可用。 
     * 这种支持可以通过proj4js或通过自定义转换函数来提供。 
     * 看到{GeoGlobe.SpatialReference.addTransform}获取更多关于自定义转换的信息。
     * @memberof GeoGlobe.Format.prototype
     * @type {GeoGlobe.SpatialReference}
     */
    externalProjection: null,

    internalProjection: null,
    /**
     * data- 当keepData为true时，这是发送来读取的解析字符串
     * @memberof  GeoGlobe.Format.prototype
     * @type {object}
     */

    data: null,
    /**
     * keepData-保持对最近读取的数据的引用（数据）。默认为false。
     * @memberof  GeoGlobe.Format.prototype
     * @type {object}
     */

    keepData: false,

    /**
     * Instances of this class are not useful.  See one of the subclasses.
     * @classdesc GeoGlobe.Format
     * @memberof GeoGlobe.Format.prototype
     * @param {Object}options - 一个可选的对象，其属性设置在格式有效选项：KeEpData -{BooLoe}中，如果是true，在读取时，数据属性将被设置为解析对象（例如JSON或XML对象）。
     *
     */
    initialize: function(options) {
        GeoGlobe.Util.extend(this, options);
        this.options = options;
    },
    
    /**
     * 清理。
     * @memberof GeoGlobe.Format.prototype
     */
    destroy: function() {
    },

    /**
    * Read data from a string, and return an object whose type depends on the
     subclass.
     * @memberof GeoGlobe.Format.prototype
     * @param {string}data - Data to read/parse.
     * @returns  Depends on the subclass
     * @private
     */
    read: function(data) {
        throw new Error('Read not implemented.');
    },
    
    /**
     *  Accept an object, and return a string.
     * @memberof GeoGlobe.Format.prototype
     * @param {Object}object - Object to be serialized
     * @returns {String} A string representation of the object.
     * @private
     */
    write: function(object) {
        throw new Error('Write not implemented.');
    },

    CLASS_NAME: "GeoGlobe.Format"
});     
/**
 * @class  GeoGlobe.Format.XML
 * @classdesc  可扩展标记语言的格式化类。
 */

GeoGlobe.Format.XML = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     *  Mapping of namespace aliases to namespace URIs.  Properties
     *     of this object should not be set individually.  Read-only.  All
     *     XML subclasses should have their own namespaces object.  Use
     *     setNamespace to add or set a namespace alias after construction.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {Object}
     * @private
     */
    namespaces: null,
    
    /**
     * namespaceAlias- Mapping of namespace URI to namespace alias.  This object
     *     is read-only.  Use setNamespace to add or set a namespace alias.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {Object}
     * @private
     */
    namespaceAlias: null,
    
    /**
     * defaultPrefix-The default namespace alias for creating element nodes.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {String}
     * @private
     */
    defaultPrefix: null,
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {null}
     * @private
     *
     */
    readers: {},
    
    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {null}
     * @private
     */
    writers: {},

    /**
     * xmldom-If this browser uses ActiveX, this will be set to a XMLDOM
     *     object.  It is not intended to be a browser sniffing property.
     *     Instead, the xmldom property is used instead of code document end
     *     where namespaced node creation methods are not supported. In all
     *     other browsers, this remains null.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @type {XMLDom}
     * @private
     */
    xmldom: null,

    /**
     * 构建一个XML解析器。 解析器用于读取和写入XML。
     * 从字符串读取XML返回一个DOM元素。 
     * 从DOM元素编写XML返回一个字符串。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Object}options -可选对象，其属性将设置在对象上。
     */
    initialize: function(options) {
        if(window.ActiveXObject) {
            this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
        }
        GeoGlobe.Format.prototype.initialize.apply(this, [options]);
        // clone the namespace object and set all namespace aliases
        this.namespaces = GeoGlobe.Util.extend({}, this.namespaces);
        this.namespaceAlias = {};
        for(var alias in this.namespaces) {
            this.namespaceAlias[this.namespaces[alias]] = alias;
        }
    },
    
    /**
     * 清除。
     * @memberof  GeoGlobe.Format.XML.prototype
     */
    destroy: function() {
        this.xmldom = null;
        GeoGlobe.Format.prototype.destroy.apply(this, arguments);
    },
    
    /**
     * Set a namespace alias and URI for the format.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String}alias - The namespace alias (prefix).
     * @param {String} uri - The namespace URI.
     * @private
     */
    setNamespace: function(alias, uri) {
        this.namespaces[alias] = uri;
        this.namespaceAlias[uri] = alias;
    },

    /**
     * 解析XML字符串并返回DOM节点。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String} text - XML字符串
     * @returns {DOMElement} 返回值是DOM节点
     */
    read: function(text) {
        var index = text.indexOf('<');
        if(index > 0) {
            text = text.substring(index);
        }
        var node = GeoGlobe.Util.Try(
            GeoGlobe.Function.bind((
                function() {
                    var xmldom;
                    /**
                     * Since we want to be able to call this method on the prototype
                     * itself, this.xmldom may not exist even if in IE.
                     */
                    if(window.ActiveXObject && !this.xmldom) {
                        xmldom = new ActiveXObject("Microsoft.XMLDOM");
                    } else {
                        xmldom = this.xmldom;
                        
                    }
                    xmldom.loadXML(text);
                    return xmldom;
                }
            ), this),
            function() {
                return new DOMParser().parseFromString(text, 'text/xml');
            },
            function() {
                var req = new XMLHttpRequest();
                req.open("GET", "data:" + "text/xml" +
                         ";charset=utf-8," + encodeURIComponent(text), false);
                if(req.overrideMimeType) {
                    req.overrideMimeType("text/xml");
                }
                req.send(null);
                return req.responseXML;
            }
        );

        if(this.keepData) {
            this.data = node;
        }

        return node;
    },

    /**
     * 将DOM节点编译成XML字符串
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -DOM节点。
     * @returns {String} 返回XML字符串。
     */
    write: function(node) {
        var data;
        //if(this.xmldom) {//20160407修改，解决不支持IE11的问题
        if(node.xml) {
            data = node.xml;
        } else {
            var serializer = new XMLSerializer();
            if (node.nodeType == 1) {
                // Add nodes to a document before serializing. Everything else
                // is serialized as is. This may need more work. See #1218 .
                var doc = document.implementation.createDocument("", "", null);
                if (doc.importNode) {
                    node = doc.importNode(node, true);
                }
                doc.appendChild(node);
                data = serializer.serializeToString(doc);
            } else {
                data = serializer.serializeToString(node);
            }
        }
        return data;
    },

    /**
     * 用命名空间创建一个新元素。 
     * 该节点可以使用标准的node.appendChild方法附加到另一个节点。 
     * 对于跨浏览器支持，必须使用此方法而不是document.createElementNS。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String}uri - 元素命名空间URI。
     * @param {String} name - 元素的前缀（前缀：localname）。
     * @returns {Element} 具有命名空间的DOM元素。
     */
    createElementNS: function(uri, name) {
        var element;
        if(this.xmldom) {
            if(typeof uri == "string") {
                element = this.xmldom.createNode(1, name, uri);
            } else {
                element = this.xmldom.createNode(1, name, "");
            }
        } else {
            element = document.createElementNS(uri, name);
        }
        return element;
    },

    /**
     *创建一个可以附加到由createElementNS创建的另一个节点的文档片段节点。
      这将在IE外调用document.createDocumentFragment。 
     在IE中，使用ActiveX对象的createDocumentFragment方法。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @returns {Element} 文档片段。
     */
    createDocumentFragment: function() {
        var element;
        if (this.xmldom) {
            element = this.xmldom.createDocumentFragment();
        } else {
            element = document.createDocumentFragment();
        }
        return element;
    },

    /**
     * 创建一个文本节点。 
     * 该节点可以使用标准的node.appendChild方法附加到另一个节点。 
     * 对于跨浏览器支持，必须使用此方法而不是document.createTextNode。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String} text -  文本节点。
     * @returns {DOMElement} DOM文本节点。
     */
    createTextNode: function(text) {
        var node;
        if (typeof text !== "string") {
            text = String(text);
        }
        if(this.xmldom) {
            node = this.xmldom.createTextNode(text);
        } else {
            node = document.createTextNode(text);
        }
        return node;
    },

    /**
     * 给定名称空间URI和本地名称，获取节点上的元素列表。
     * 要返回给定命名空间中的所有节点，请使用'*'作为name参数。 
     * 要返回给定（本地）名称的所有节点，而不考虑命名空间，请使用'*'作为uri参数。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param  {Element} node -搜索属性节点的节点。
     * @param {String} uri - 命名空间URI。
     * @param {String}name -  属性本地名称（不带前缀）。
     * @returns {NodeList} 节点列表或元素数组。
     */
    getElementsByTagNameNS: function(node, uri, name) {
        var elements = [];
        if(node.getElementsByTagNameNS) {
            elements = node.getElementsByTagNameNS(uri, name);
        } else {
            // brute force method
            var allNodes = node.getElementsByTagName("*");
            var potentialNode, fullName;
            for(var i=0, len=allNodes.length; i<len; ++i) {
                potentialNode = allNodes[i];
                fullName = (potentialNode.prefix) ?
                           (potentialNode.prefix + ":" + name) : name;
                if((name == "*") || (fullName == potentialNode.nodeName)) {
                    if((uri == "*") || (uri == potentialNode.namespaceURI)) {
                        elements.push(potentialNode);
                    }
                }
            }
        }
        return elements;
    },

    /**
     * 获取给定命名空间URI和本地名称的属性节点。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param  {Element} node -搜索属性节点的节点。
     * @param {String} uri - 命名空间URI。
     * @param {String}name -  属性的本地名称（不带前缀）。
     * @returns {DOMElement} 属性节点，如果没有找到，则返回null。
     */
    getAttributeNodeNS: function(node, uri, name) {
        var attributeNode = null;
        if(node.getAttributeNodeNS) {
            attributeNode = node.getAttributeNodeNS(uri, name);
        } else {
            var attributes = node.attributes;
            var potentialNode, fullName;
            for(var i=0, len=attributes.length; i<len; ++i) {
                potentialNode = attributes[i];
                if(potentialNode.namespaceURI == uri) {
                    fullName = (potentialNode.prefix) ?
                               (potentialNode.prefix + ":" + name) : name;
                    if(fullName == potentialNode.nodeName) {
                        attributeNode = potentialNode;
                        break;
                    }
                }
            }
        }
        return attributeNode;
    },

    /**
     * 获取给定命名空间URI和本地名称的属性值。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Element} node -搜索属性的节点。
     * @param {String}uri - 命名空间URI。
     * @param {String} name - 属性的本地名称（不带前缀）。
     * @returns {String} 属性值，如果没有找到返回空字符串。
     */
    getAttributeNS: function(node, uri, name) {
        var attributeValue = "";
        if(node.getAttributeNS) {
            attributeValue = node.getAttributeNS(uri, name) || "";
        } else {
            var attributeNode = this.getAttributeNodeNS(node, uri, name);
            if(attributeNode) {
                attributeValue = attributeNode.nodeValue;
            }
        }
        return attributeValue;
    },
    
    /**
     * 获取节点的文本值（如果存在），或返回可选的默认字符串。
     * 如果不存在第一个子项并且未提供默认值，则返回空字符串。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -  用于查找第一个子元素的值。
     * @param {String} def - 可选字符串在没有第一个子元素值的情况下返回。
     * @returns {String} 给定节点的第一个子元素的值。
     */
    getChildValue: function(node, def) {
        var value = def || "";
        if(node) {
            for(var child=node.firstChild; child; child=child.nextSibling) {
                switch(child.nodeType) {
                    case 3: // text node
                    case 4: // cdata section
                        value += child.nodeValue;
                }
            }
        }
        return value;
    },

    /**
     * 测试给定节点是否只有简单内容（即没有子元素节点）。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement}  node -元素节点。
     * @returns {Boolean} 该节点没有子元素节点（类型1的节点）。
     */
    isSimpleContent: function(node) {
        var simple = true;
        for(var child=node.firstChild; child; child=child.nextSibling) {
            if(child.nodeType === 1) {
                simple = false;
                break;
            }
        }
        return simple;
    },
    
    /**
     * 确定给定节点的内容类型。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node - 给定节点。
     * @returns {Integer} 如果节点没有内容，简单，复杂或混合内容，
     * 则为GeoGlobe.Format.XML.CONTENT_TYPE。{EMPTY，SIMPLE，COMPLEX，MIXED}之一。
     */
    contentType: function(node) {
        var simple = false,
            complex = false;
            
        var type = GeoGlobe.Format.XML.CONTENT_TYPE.EMPTY;

        for(var child=node.firstChild; child; child=child.nextSibling) {
            switch(child.nodeType) {
                case 1: // element
                    complex = true;
                    break;
                case 8: // comment
                    break;
                default:
                    simple = true;
            }
            if(complex && simple) {
                break;
            }
        }
        
        if(complex && simple) {
            type = GeoGlobe.Format.XML.CONTENT_TYPE.MIXED;
        } else if(complex) {
            return GeoGlobe.Format.XML.CONTENT_TYPE.COMPLEX;
        } else if(simple) {
            return GeoGlobe.Format.XML.CONTENT_TYPE.SIMPLE;
        }
        return type;
    },

    /**
     * 确定节点是否具有与给定名称和名称空间匹配的特定属性。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Element}node - 需要设置属性的元素节点。
     * @param  {String}uri - 属性的命名空间URI。
     * @param {String}name -该属性的本地名称（前缀：localname）。
     * @returns {Boolean} 该节点具有与名称和命名空间匹配的属性。
     */
    hasAttributeNS: function(node, uri, name) {
        var found = false;
        if(node.hasAttributeNS) {
            found = node.hasAttributeNS(uri, name);
        } else {
            found = !!this.getAttributeNodeNS(node, uri, name);
        }
        return found;
    },
    
    /**
     * 添加新属性或使用给定命名空间和名称更改属性的值。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Element}node - 需要设置属性的元素节点。
     * @param  {String}uri - 属性的命名空间URI。
     * @param {String}name -该属性的合法名称（前缀：localname）。
     * @param {String}value - 属性值。
     */
    setAttributeNS: function(node, uri, name, value) {
        if(node.setAttributeNS) {
            node.setAttributeNS(uri, name, value);
        } else {
            if(this.xmldom) {
                if(uri) {
                    var attribute = node.ownerDocument.createNode(
                        2, name, uri
                    );
                    attribute.nodeValue = value;
                    node.setAttributeNode(attribute);
                } else {
                    node.setAttribute(name, value);
                }
            } else {
                throw "setAttributeNS not implemented";
            }
        }
    },

    /**
     * Shorthand for creating namespaced elements with optional attributes and
     *     child text nodes.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String}name - The qualified node name.
     * @param  {Object}options - Optional object for node configuration.
     * @param {String} uri - Optional namespace uri for the element - supply a prefix
     *     instead if the namespace uri is a property of the format's namespace
     *     object.
     * @param {object} attributes -  Optional attributes to be set using the
     *     setAttributes method.
     * @param {String} value -  Optional text to be appended as a text node.
     * @returns {Element} An element node.
     * @private
     */
    createElementNSPlus: function(name, options) {
        options = options || {};
        // order of prefix preference
        // 1. in the uri option
        // 2. in the prefix option
        // 3. in the qualified name
        // 4. from the defaultPrefix
        var uri = options.uri || this.namespaces[options.prefix];
        if(!uri) {
            var loc = name.indexOf(":");
            uri = this.namespaces[name.substring(0, loc)];
        }
        if(!uri) {
            uri = this.namespaces[this.defaultPrefix];
        }
        var node = this.createElementNS(uri, name);
        if(options.attributes) {
            this.setAttributes(node, options.attributes);
        }
        var value = options.value;
        if(value != null) {
            node.appendChild(this.createTextNode(value));
        }
        return node;
    },
    
    /**
     *  Set multiple attributes given key value pairs from an object.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {Element}  node - An element node.
     * @param {Object}obj - An object whose properties represent attribute
     *     names and values represent attribute values.  If an attribute name
     *     is a qualified name ("prefix:local"), the prefix will be looked up
     *     in the parsers {namespaces} object.  If the prefix is found,
     *     setAttributeNS will be used instead of setAttribute.
     * @private
     */
    setAttributes: function(node, obj) {
        var value, uri;
        for(var name in obj) {
            if(obj[name] != null && obj[name].toString) {
                value = obj[name].toString();
                // check for qualified attribute name ("prefix:local")
                uri = this.namespaces[name.substring(0, name.indexOf(":"))] || null;
                this.setAttributeNS(node, uri, name, value);
            }
        }
    },

    /**
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement}  node - The node to be read (required).
     * @param {Object} obj - The object to be modified (optional).
     * @returns {Object} The input object, modified (or a new one if none was provided).
     * @private
     */
    readNode: function(node, obj) {
        if(!obj) {
            obj = {};
        }
        var group = this.readers[node.namespaceURI ? this.namespaceAlias[node.namespaceURI]: this.defaultPrefix];
        if(group) {
            var local = node.localName || node.nodeName.split(":").pop();
            var reader = group[local] || group["*"];
            if(reader) {
                reader.apply(this, [node, obj]);
            }
        }
        return obj;
    },

    /**
     * Shorthand for applying the named readers to all children of a node.
     *     For each child of type 1 (element), readSelf is called.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -  The node to be read (required).
     * @param {Object} obj - The object to be modified (optional).
     * @returns {Object} The input object, modified.
     * @private
     */
    readChildNodes: function(node, obj) {
        if(!obj) {
            obj = {};
        }
        var children = node.childNodes;
        var child;
        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                this.readNode(child, obj);
            }
        }
        return obj;
    },

    /**
     * Shorthand for applying one of the named writers and appending the
     *     results to a node.  If a qualified name is not provided for the
     *     second argument (and a local name is used instead), the namespace
     *     of the parent node will be assumed.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {String} name -  The name of a node to generate.  If a qualified name
     *     (e.g. "pre:Name") is used, the namespace prefix is assumed to be
     *     in the writers group.  If a local name is used (e.g. "Name") then
     *     the namespace of the parent is assumed.  If a local name is used
     *     and no parent is supplied, then the default namespace is assumed.
     * @param {Object} obj - Structure containing data for the writer.
     * parent - {DOMElement} Result will be appended to this node.  If no parent
     *     is supplied, the node will not be appended to anything.
     * @returns {DOMElement} The child node.
     * @private
     */
    writeNode: function(name, obj, parent) {
        var prefix, local;
        var split = name.indexOf(":");
        if(split > 0) {
            prefix = name.substring(0, split);
            local = name.substring(split + 1);
        } else {
            if(parent) {
                prefix = this.namespaceAlias[parent.namespaceURI];
            } else {
                prefix = this.defaultPrefix;
            }
            local = name;
        }
        var child = this.writers[prefix][local].apply(this, [obj]);
        if(parent) {
            parent.appendChild(child);
        }
        return child;
    },

    /**
     * 获取第一个子元素。 如果它匹配给定的名称和命名空间URI只需要可选地返回第一个元素，。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -节点。
     * @param {String}  name -要搜索的相邻节点的本地名称。
     * @param {String}  uri - 要搜索的相邻节点的命名空间URL。
     * @returns {DOMElement} 第一个元素。 如果找不到，
     * 或者找到除元素之外的重要元素，或者找到的元素与可选名称和uri不匹配，则返回null。
     */
    getChildEl: function(node, name, uri) {
        return node && this.getThisOrNextEl(node.firstChild, name, uri);
    },
    
    /**
     * 获取下一个兄弟元素。 只有当匹配给定的本地名称和命名空间URI时，才可以获取第一个兄弟元素。
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement} node -节点。
     * @param {String}  name -要搜索的兄弟的可选本地名称。
     * @param {String}  uri - 要搜索的兄弟的可选命名空间URI。
     * @returns {DOMElement} 下一个兄弟元素。
     * 除了找到元素之外的重要元素，或找到的元素与可选的名称和uri不匹配外，
     * 如果找不到任何元素，则返回null。
     */
    getNextEl: function(node, name, uri) {
        return node && this.getThisOrNextEl(node.nextSibling, name, uri);
    },
    
    /**
     * Return this node or the next element node.  Optionally get the first
     *     sibling with the given local name or namespace URI.
     * @memberof  GeoGlobe.Format.XML.prototype
     * @param {DOMElement}node -  The node.
     * @param {String} name - Optional local name of the sibling to search for.
     * @param {String}uri - Optional namespace URI of the sibling to search for.
     * @returns {DOMElement} The next sibling element.  Returns null if no element is
     *     found, something significant besides an element is found, or the
     *     found element does not match the query.
     * @private
     */
    getThisOrNextEl: function(node, name, uri) {
        outer: for(var sibling=node; sibling; sibling=sibling.nextSibling) {
            switch(sibling.nodeType) {
                case 1: // Element
                    if((!name || name === (sibling.localName || sibling.nodeName.split(":").pop())) &&
                       (!uri || uri === sibling.namespaceURI)) {
                        // matches
                        break outer;
                    }
                    sibling = null;
                    break outer;
                case 3: // Text
                    if(/^\s*$/.test(sibling.nodeValue)) {
                        break;
                    }
                case 4: // CDATA
                case 6: // ENTITY_NODE
                case 12: // NOTATION_NODE
                case 10: // DOCUMENT_TYPE_NODE
                case 11: // DOCUMENT_FRAGMENT_NODE
                    sibling = null;
                    break outer;
            } // ignore comments and processing instructions
        }
        return sibling || null;
    },
    
    /**
     * 获取前缀并返回给定节点上与其关联的命名空间URI（如果未找到则返回null）。 
     * 为前缀提供null将返回默认名称空间。
     * @memberof  GeoGlobe.Format.XML.prototype
     * 对于支持它的浏览器，这会调用本地lookupNamesapceURI函数。 在其他浏览器中，
     * 这是http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3lookupNamespaceURI的实现路径。
     *
     * 对于不支持attribute.ownerElement属性的浏览器，不能在属性节点上调用此方法。
     *     

     * @param {DOMElement} node - 从哪个节点开始查找。
     * @param {String} prefix -通过要查找的前缀或null来查找默认命名空间。
     * @returns {String} 给定前缀的命名空间URI。 如果无法找到前缀或节点类型错误，则返回null。
     */
    lookupNamespaceURI: function(node, prefix) {
        var uri = null;
        if(node) {
            if(node.lookupNamespaceURI) {
                uri = node.lookupNamespaceURI(prefix);
            } else {
                outer: switch(node.nodeType) {
                    case 1: // ELEMENT_NODE
                        if(node.namespaceURI !== null && node.prefix === prefix) {
                            uri = node.namespaceURI;
                            break outer;
                        }
                        var len = node.attributes.length;
                        if(len) {
                            var attr;
                            for(var i=0; i<len; ++i) {
                                attr = node.attributes[i];
                                if(attr.prefix === "xmlns" && attr.name === "xmlns:" + prefix) {
                                    uri = attr.value || null;
                                    break outer;
                                } else if(attr.name === "xmlns" && prefix === null) {
                                    uri = attr.value || null;
                                    break outer;
                                }
                            }
                        }
                        uri = this.lookupNamespaceURI(node.parentNode, prefix);
                        break outer;
                    case 2: // ATTRIBUTE_NODE
                        uri = this.lookupNamespaceURI(node.ownerElement, prefix);
                        break outer;
                    case 9: // DOCUMENT_NODE
                        uri = this.lookupNamespaceURI(node.documentElement, prefix);
                        break outer;
                    case 6: // ENTITY_NODE
                    case 12: // NOTATION_NODE
                    case 10: // DOCUMENT_TYPE_NODE
                    case 11: // DOCUMENT_FRAGMENT_NODE
                        break outer;
                    default: 
                        // TEXT_NODE (3), CDATA_SECTION_NODE (4), ENTITY_REFERENCE_NODE (5),
                        // PROCESSING_INSTRUCTION_NODE (7), COMMENT_NODE (8)
                        uri =  this.lookupNamespaceURI(node.parentNode, prefix);
                        break outer;
                }
            }
        }
        return uri;
    },
    
    /**
     * Get an XML document for nodes that are not supported in HTML (e.g.
     * createCDATASection). On IE, this will either return an existing or
     * create a new xmldom on the instance. On other browsers, this will
     * either return an existing or create a new shared document (see
     * GeoGlobe.Format.XML.document).
     * @memberof  GeoGlobe.Format.XML.prototype
     * @returns {XMLDocument}
     * @private
     */
    getXMLDoc: function() {
        if (!GeoGlobe.Format.XML.document && !this.xmldom) {
            if (document.implementation && document.implementation.createDocument) {
                GeoGlobe.Format.XML.document =
                    document.implementation.createDocument("", "", null);
            } else if (!this.xmldom && window.ActiveXObject) {
                this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
            }
        }
        return GeoGlobe.Format.XML.document || this.xmldom;
    },

    CLASS_NAME: "GeoGlobe.Format.XML" 

});     

GeoGlobe.Format.XML.CONTENT_TYPE = {EMPTY: 0, SIMPLE: 1, COMPLEX: 2, MIXED: 3};

/**
 * @memberof  GeoGlobe.Format.XML.prototype
 * 获取前缀并返回给定节点上与其关联的命名空间URI（如果未找到则返回null）。 
 * 为前缀提供null将返回默认命名空间。
 *
 * 对于支持它的浏览器，这会调用本地lookupNamesapceURI函数。  在其他浏览器通过这个地址调用
 *     http://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespaceURI.
 *
 * 对于不支持attribute.ownerElement属性的浏览器，不能在属性节点上调用此方法。
 * @param {DOMElement}node -  从哪个节点开始查找。
 * @param {String}  prefix -通过要查找的前缀或null来查找默认命名空间。
 * @returns {String} 给定前缀的名，命名空间URI。 如果无法找到前缀或节点类型错误，则返回null。
 */
GeoGlobe.Format.XML.lookupNamespaceURI = GeoGlobe.Function.bind(
    GeoGlobe.Format.XML.prototype.lookupNamespaceURI,
    GeoGlobe.Format.XML.prototype
);

/**
 * GeoGlobe.Format.XML.document- XML document to reuse for creating non-HTML compliant nodes,
 * like document.createCDATASection.
 * @memberof GeoGlobe.Format.XML.prototype
 * @type {XMLDocument}
 * @private
 */
GeoGlobe.Format.XML.document = null;
/**
 * @class GeoGlobe.Format.XML.VersionedOGC
 * @classdesc  版本格式的基类，即支持多个版本的格式。
 * @private
 */

GeoGlobe.Format.XML.VersionedOGC = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * defaultVersion - 如果没有找到，则假定版本号。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     */
    defaultVersion: null,
    
    /**
     *version-指定版本字符串（如果已知）。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     */
    version: null,

    /**
     * profile - 如果提供，使用自定义配置文件。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     */
    profile: null,

    /**
     *allowFallback-如果找不到返回版本的概要分析器，
     *则使用非概要分析器作为回退。 
     *使用它的应用程序代码应该考虑到返回对象结构可能缺少配置文件的细节。
     *默认为false。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {Boolean}
     */
    allowFallback: false,

    /**
     * name-The name of this parser, this is the part of the CLASS_NAME
     * except for "GeoGlobe.Format."
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     * @private
     */
    name: null,

    /**
     * 如果为true，写入将返回一个字符串，否则返回一个DOMElement。 默认为false。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {Boolean}
     */
    stringifyOutput: false,

    /**
     * parser- Instance of the versioned parser.  Cached for multiple read and
     *    write calls of the same version.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {Object}
     * @private
     */
    parser: null,

    /**
     * 构造函数。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {Object} options - 可选对象，其属性将设置在对象上。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        var className = this.CLASS_NAME;
        this.name = className.substring(className.lastIndexOf(".")+1);
    },

    /**
     * Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {DOMElement} root -
     * @param {Object}options - Optional configuration object.
     * @returns {String} The version to use.
     * @private
     */
    getVersion: function(root, options) {
        var version;
        // read
        if (root) {
            version = this.version;
            if(!version) {
                version = root.getAttribute("version");
                if(!version) {
                    version = this.defaultVersion;
                }
            }
        } else { // write
            version = (options && options.version) || 
                this.version || this.defaultVersion;
        }
        return version;
    },

    /**
     * Get an instance of the cached parser if available, otherwise create one.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {String}version
     * @returns {GeoGlobe.Format}
     * @private
     */
    getParser: function(version) {
        version = version || this.defaultVersion;
        var profile = this.profile ? "_" + this.profile : "";
        if(!this.parser || this.parser.VERSION != version) {
            var format = GeoGlobe.Format[this.name][
                "v" + version.replace(/\./g, "_") + profile
            ];
            if(!format) {
                if (profile !== "" && this.allowFallback) {
                    // fallback to the non-profiled version of the parser
                    profile = "";
                    format = GeoGlobe.Format[this.name][
                        "v" + version.replace(/\./g, "_")
                    ];
                }
                if (!format) {
                    throw "Can't find a " + this.name + " parser for version " +
                          version + profile;
                }
            }
            this.parser = new format(this.options);
        }
        return this.parser;
    },

    /**
     * 写一个文件。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {Object} obj -代表文档的对象。
     * @param {Object}options - 可选的配置对象。
     * @returns {String} 该文件是一个字符串。
     */
    write: function(obj, options) {
        var version = this.getVersion(null, options);
        this.parser = this.getParser(version);
        var root = this.parser.write(obj, options);
        if (this.stringifyOutput === false) {
            return root;
        } else {
            return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
        }
    },

    /**
     * 阅读文档并返回代表文档的对象。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {String | DOMElement} data - 要读取的数据。
     * @param {Object}options - 读者的选择。
     * @returns {Object} 代表文档的对象。
     */
    read: function(data, options) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var version = this.getVersion(root);
        this.parser = this.getParser(version);          // Select the parser
        var obj = this.parser.read(data, options);      // Parse the data

        var errorProperty = this.parser.errorProperty || null;
        if (errorProperty !== null && obj[errorProperty] === undefined) {
            // an error must have happened, so parse it and report back
            var format = new GeoGlobe.Format.OGCExceptionReport();
            obj.error = format.read(data);
        }
        obj.version = version;
        return obj;
    },

    CLASS_NAME: "GeoGlobe.Format.XML.VersionedOGC"
});

/**
 * @class GeoGlobe.Format.GML
 * @classdesc  读/写GML。 用GeoGlobe.Format.GML构造函数创建一个新实例。 支持GML简单功能配置文件。
 * 解析GML文件类
 */

GeoGlobe.Format.GML = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * featureNS-用于特征属性的名称空间。 默认是“http://mapserver.gis.umn.edu/mapserver”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    
    /**
     * featurePrefix- 名称空间别名（或前缀）用于特征节点。 默认是“feature”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    featurePrefix: "feature",
    
    /**
     * featureName-要素的元素名称。 默认是“featureMember”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    featureName: "featureMember", 
    
    /**
     * layerName- 数据图层的名称。 默认是“features”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    layerName: "features",
    
    /**
     * geometryName- 几何元素的名称。 默认为“geometry”。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    geometryName: "geometry",
    
    /**
     * collectionName- featureCollection元素的名称。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    collectionName: "FeatureCollection",
    
    /**
     * gmlns- GML命名空间。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {String}
     */
    gmlns: "http://www.opengis.net/gml",

    /**
     * extractAttributes- 从GML中提取属性。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {Boolean}
     */
    extractAttributes: true,
    
    /**
     * xy- GML坐标的顺序true：（x，y）或false：（y，x）不建议更改，应该实例化新格式。
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {Boolean}
     */ 
    xy: true,
    
    /**
     * 为GML创建一个新的解析器。
     * @memberof GeoGlobe.Format.GML.prototype
     * @classdesc  GeoGlobe.Format.GML
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        // compile regular expressions once instead of every time they are used
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g)
        };
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * 读取数据解析并且返回要素数组。
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {String}data - or {DOMElement} 数据读取/解析。
     *
     * @returns {Array(GeoGlobe.Feature.Vector)} 一系列要素。
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var featureNodes = this.getElementsByTagNameNS(data.documentElement,
                                                       this.gmlns,
                                                       this.featureName);
        var features = [];
        for(var i=0; i<featureNodes.length; i++) {
            var feature = this.parseFeature(featureNodes[i]);
            if(feature) {
                features.push(feature);
            }
        }
        return features;
    },
    
    /**
     * This function is the core of the GML parsing code in GeoGlobe.
     *    It creates the geometries that are then attached to the returned
     *    feature, and calls parseAttributes() to get attribute data out.
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {DOMElement}node -  A GML feature node.
     * @private
     */
    parseFeature: function(node) {
        // only accept one geometry per feature - look for highest "order"
        var order = ["MultiPolygon", "Polygon",
                     "MultiLineString", "LineString",
                     "MultiPoint", "Point", "Envelope"];
        // FIXME: In case we parse a feature with no geometry, but boundedBy an Envelope,
        // this code creates a geometry derived from the Envelope. This is not correct.
        var type, nodeList, geometry, parser;
        for(var i=0; i<order.length; ++i) {
            type = order[i];
            nodeList = this.getElementsByTagNameNS(node, this.gmlns, type);
            if(nodeList.length > 0) {
                // only deal with first geometry of this type
                parser = this.parseGeometry[type.toLowerCase()];
                if(parser) {
                    geometry = parser.apply(this, [nodeList[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        geometry.transform(this.externalProjection, 
                                           this.internalProjection); 
                    }                       
                } else {
                    throw new TypeError("Unsupported geometry type: " + type);
                }
                // stop looking for different geometry types
                break;
            }
        }

        var bounds;
        var boxNodes = this.getElementsByTagNameNS(node, this.gmlns, "Box");
        for(i=0; i<boxNodes.length; ++i) {
            var boxNode = boxNodes[i];
            var box = this.parseGeometry["box"].apply(this, [boxNode]);
            var parentNode = boxNode.parentNode;
            var parentName = parentNode.localName ||
                             parentNode.nodeName.split(":").pop();
            if(parentName === "boundedBy") {
                bounds = box;
            } else {
                geometry = box.toGeometry();
            }
        }
        
        // construct feature (optionally with attributes)
        var attributes;
        if(this.extractAttributes) {
            attributes = this.parseAttributes(node);
        }
        var feature = new GeoGlobe.Feature(geometry, attributes);
        feature.bounds = bounds;
        
        feature.gml = {
            featureType: node.firstChild.nodeName.split(":")[1],
            featureNS: node.firstChild.namespaceURI,
            featureNSPrefix: node.firstChild.prefix
        };
                
        // assign fid - this can come from a "fid" or "id" attribute
        var childNode = node.firstChild;
        var fid;
        while(childNode) {
            if(childNode.nodeType == 1) {
                fid = childNode.getAttribute("fid") ||
                      childNode.getAttribute("id");
                if(fid) {
                    break;
                }
            }
            childNode = childNode.nextSibling;
        }
        feature.fid = fid;
        return feature;
    },
    
    /**

     * Properties of this object are the functions that parse geometries based
         on their type.
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {null}
     * @private
     */
    parseGeometry: {
        
        /**
         * Given a GML node representing a point geometry, create an GeoGlobe
         *     point geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement}node - A GML node.
         * @returns {GeoGlobe.Geometry.Point} A point geometry.
         * @private
         */
        point: function(node) {
            /**
             * Three coordinate variations to consider:
             * 1) gml:pos>x y z/gml:pos
             * 2) gml:coordinatesx, y, z/gml:coordinates
             * 3) gml:coordgml:X>x/gml:X gml:Y>y</gml:Y</gml:coord
             */
            var nodeList, coordString;
            var coords = [];

            // look for <gml:pos>
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns, "pos");
            if(nodeList.length > 0) {
                coordString = nodeList[0].firstChild.nodeValue;
                coordString = coordString.replace(this.regExes.trimSpace, "");
                coords = coordString.split(this.regExes.splitSpace);
            }

            // look for <gml:coordinates>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coordinates");
                if(nodeList.length > 0) {
                    coordString = nodeList[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.removeSpace,
                                                      "");
                    coords = coordString.split(",");
                }
            }

            // look for <gml:coord>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coord");
                if(nodeList.length > 0) {
                    var xList = this.getElementsByTagNameNS(nodeList[0],
                                                            this.gmlns, "X");
                    var yList = this.getElementsByTagNameNS(nodeList[0],
                                                            this.gmlns, "Y");
                    if(xList.length > 0 && yList.length > 0) {
                        coords = [xList[0].firstChild.nodeValue,
                                  yList[0].firstChild.nodeValue];
                    }
                }
            }
                
            // preserve third dimension
            if(coords.length == 2) {
                coords[2] = null;
            }
            
            if (this.xy) {
                return new GeoGlobe.Geometry.Point(coords[0], coords[1],
                                                 coords[2]);
            }
            else{
                return new GeoGlobe.Geometry.Point(coords[1], coords[0],
                                                 coords[2]);
            }
        },
        
        /**
         * Given a GML node representing a multipoint geometry, create an
              GeoGlobe multipoint geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement} node - A GML node.
         * @returns {GeoGlobe.Geometry.MultiPoint} A multipoint geometry.
         * @private
         */
        multipoint: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "Point");
            var components = [];
            if(nodeList.length > 0) {
                var point;
                for(var i=0; i<nodeList.length; ++i) {
                    point = this.parseGeometry.point.apply(this, [nodeList[i]]);
                    if(point) {
                        components.push(point);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiPoint(components);
        },
        
        /**
         *  Given a GML node representing a linestring geometry, create an
            GeoGlobe linestring geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement}node - A GML node.
         * @returns {GeoGlobe.Geometry.LineString} A linestring geometry.
         * @private
         */
        linestring: function(node, ring) {
            /**
             * Two coordinate variations to consider:
             * 1) gml:posList dimension="d">x0 y0 z0 x1 y1 z1/gml:posList
             * 2) gml:coordinates x0, y0, z0 x1, y1, z1/gml:coordinates
             */
            var nodeList, coordString;
            var coords = [];
            var points = [];

            // look for <gml:posList>
            nodeList = this.getElementsByTagNameNS(node, this.gmlns, "posList");
            if(nodeList.length > 0) {
                coordString = this.getChildValue(nodeList[0]);
                coordString = coordString.replace(this.regExes.trimSpace, "");
                coords = coordString.split(this.regExes.splitSpace);
                var dim = parseInt(nodeList[0].getAttribute("dimension"));
                var j, x, y, z;
                for(var i=0; i<coords.length/dim; ++i) {
                    j = i * dim;
                    x = coords[j];
                    y = coords[j+1];
                    z = (dim == 2) ? null : coords[j+2];
                    if (this.xy) {
                        points.push(new GeoGlobe.Geometry.Point(x, y, z));
                    } else {
                        points.push(new GeoGlobe.Geometry.Point(y, x, z));
                    }
                }
            }

            // look for <gml:coordinates>
            if(coords.length == 0) {
                nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "coordinates");
                if(nodeList.length > 0) {
                    coordString = this.getChildValue(nodeList[0]);
                    coordString = coordString.replace(this.regExes.trimSpace,
                                                      "");
                    coordString = coordString.replace(this.regExes.trimComma,
                                                      ",");
                    var pointList = coordString.split(this.regExes.splitSpace);
                    for(var i=0; i<pointList.length; ++i) {
                        coords = pointList[i].split(",");
                        if(coords.length == 2) {
                            coords[2] = null;
                        }
                        if (this.xy) {
                            points.push(new GeoGlobe.Geometry.Point(coords[0],
                                                                  coords[1],
                                                                  coords[2]));
                        } else {
                            points.push(new GeoGlobe.Geometry.Point(coords[1],
                                                                  coords[0],
                                                                  coords[2]));
                        }
                    }
                }
            }

            var line = null;
            if(points.length != 0) {
                if(ring) {
                    line = new GeoGlobe.Geometry.LinearRing(points);
                } else {
                    line = new GeoGlobe.Geometry.LineString(points);
                }
            }
            return line;
        },
        
        /**
         *  Given a GML node representing a multilinestring geometry, create an
            GeoGlobe multilinestring geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement}node - A GML node.
         * @returns {GeoGlobe.Geometry.MultiLineString} A multilinestring geometry.
         * @private
         */
        multilinestring: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "LineString");
            var components = [];
            if(nodeList.length > 0) {
                var line;
                for(var i=0; i<nodeList.length; ++i) {
                    line = this.parseGeometry.linestring.apply(this,
                                                               [nodeList[i]]);
                    if(line) {
                        components.push(line);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiLineString(components);
        },
        
        /**
         * Given a GML node representing a polygon geometry, create an
            GeoGlobe polygon geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement} node -A GML node.
         * @returns {GeoGlobe.Geometry.Polygon} A polygon geometry.
         * @private
         */
        polygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "LinearRing");
            var components = [];
            if(nodeList.length > 0) {
                // this assumes exterior ring first, inner rings after
                var ring;
                for(var i=0; i<nodeList.length; ++i) {
                    ring = this.parseGeometry.linestring.apply(this,
                                                        [nodeList[i], true]);
                    if(ring) {
                        components.push(ring);
                    }
                }
            }
            return new GeoGlobe.Geometry.Polygon(components);
        },
        
        /**
         * Given a GML node representing a multipolygon geometry, create an
           GeoGlobe multipolygon geometry.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement} node - A GML node.
         * @returns {GeoGlobe.Geometry.MultiPolygon} A multipolygon geometry.
         * @private
         */
        multipolygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                       "Polygon");
            var components = [];
            if(nodeList.length > 0) {
                var polygon;
                for(var i=0; i<nodeList.length; ++i) {
                    polygon = this.parseGeometry.polygon.apply(this,
                                                               [nodeList[i]]);
                    if(polygon) {
                        components.push(polygon);
                    }
                }
            }
            return new GeoGlobe.Geometry.MultiPolygon(components);
        },
        
        envelope: function(node) {
            var components = [];
            var coordString;
            var envelope;
            
            var lpoint = this.getElementsByTagNameNS(node, this.gmlns, "lowerCorner");
            if (lpoint.length > 0) {
                var coords = [];
                
                if(lpoint.length > 0) {
                    coordString = lpoint[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.trimSpace, "");
                    coords = coordString.split(this.regExes.splitSpace);
                }
                
                if(coords.length == 2) {
                    coords[2] = null;
                }
                if (this.xy) {
                    var lowerPoint = new GeoGlobe.Geometry.Point(coords[0], coords[1],coords[2]);
                } else {
                    var lowerPoint = new GeoGlobe.Geometry.Point(coords[1], coords[0],coords[2]);
                }
            }
            
            var upoint = this.getElementsByTagNameNS(node, this.gmlns, "upperCorner");
            if (upoint.length > 0) {
                var coords = [];
                
                if(upoint.length > 0) {
                    coordString = upoint[0].firstChild.nodeValue;
                    coordString = coordString.replace(this.regExes.trimSpace, "");
                    coords = coordString.split(this.regExes.splitSpace);
                }
                
                if(coords.length == 2) {
                    coords[2] = null;
                }
                if (this.xy) {
                    var upperPoint = new GeoGlobe.Geometry.Point(coords[0], coords[1],coords[2]);
                } else {
                    var upperPoint = new GeoGlobe.Geometry.Point(coords[1], coords[0],coords[2]);
                }
            }
            
            if (lowerPoint && upperPoint) {
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, lowerPoint.y));
                components.push(new GeoGlobe.Geometry.Point(upperPoint.x, lowerPoint.y));
                components.push(new GeoGlobe.Geometry.Point(upperPoint.x, upperPoint.y));
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, upperPoint.y));
                components.push(new GeoGlobe.Geometry.Point(lowerPoint.x, lowerPoint.y));
                
                var ring = new GeoGlobe.Geometry.LinearRing(components);
                envelope = new GeoGlobe.Geometry.Polygon([ring]);
            }
            return envelope; 
        },

        /**
         *  Given a GML node representing a box geometry, create an
           GeoGlobe.Bounds.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {DOMElement} node -A GML node.
         * @returns {GeoGlobe.Bounds} A bounds representing the box.
         * @private
         */
        box: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.gmlns,
                                                   "coordinates");
            var coordString;
            var coords, beginPoint = null, endPoint = null;
            if (nodeList.length > 0) {
                coordString = nodeList[0].firstChild.nodeValue;
                coords = coordString.split(" ");
                if (coords.length == 2) {
                    beginPoint = coords[0].split(",");
                    endPoint = coords[1].split(",");
                }
            }
            if (beginPoint !== null && endPoint !== null) {
                var sw = new GeoGlobe.LngLat(parseFloat(beginPoint[0]), parseFloat(beginPoint[1]));
				var ne = new GeoGlobe.LngLat(parseFloat(endPoint[0]), parseFloat(endPoint[1]));
				return new GeoGlobe.LngLatBounds(sw, ne);
            }
        }
        
    },
    
    /**
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {DOMElement}node -
     * @returns {Object} An attributes object.
     * @private
     */
    parseAttributes: function(node) {
        var attributes = {};
        // assume attributes are children of the first type 1 child
        var childNode = node.firstChild;
        var children, i, child, grandchildren, grandchild, name, value;
        while(childNode) {
            if(childNode.nodeType == 1) {
                // attributes are type 1 children with one type 3 child
                children = childNode.childNodes;
                for(i=0; i<children.length; ++i) {
                    child = children[i];
                    if(child.nodeType == 1) {
                        grandchildren = child.childNodes;
                        if(grandchildren.length == 1) {
                            grandchild = grandchildren[0];
                            if(grandchild.nodeType == 3 ||
                               grandchild.nodeType == 4) {
                                name = (child.prefix) ?
                                        child.nodeName.split(":")[1] :
                                        child.nodeName;
                                value = grandchild.nodeValue.replace(
                                                this.regExes.trimSpace, "");
                                attributes[name] = value;
                            }
                        } else {
                            // If child has no childNodes (grandchildren),
                            // set an attribute with null value.
                            // e.g. <prefix:fieldname/> becomes
                            // {fieldname: null}
                            attributes[child.nodeName.split(":").pop()] = null;
                        }
                    }
                }
                break;
            }
            childNode = childNode.nextSibling;
        }
        return attributes;
    },
    
    /**
     * 根据要素数组生成GML格式数据。
     * Generate a GML document string given a list of features.
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {Array(GeoGlobe.Feature.Vector)}features - 要序列化为字符串的要素列表。
     * @returns {String} 代表GML文档的字符串。
     */
    write: function(features) {
        if(!(GeoGlobe.Util.isArray(features))) {
            features = [features];
        }
        var gml = this.createElementNS("http://www.opengis.net/wfs",
                                       "wfs:" + this.collectionName);
        for(var i=0; i<features.length; i++) {
            gml.appendChild(this.createFeatureXML(features[i]));
        }
        return GeoGlobe.Format.XML.prototype.write.apply(this, [gml]);
    },

    /**
     *  Accept an GeoGlobe.Feature.Vector, and build a GML node for it.
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {GeoGlobe.Feature.Vector}feature - The feature to be built as GML.
     * @returns {DOMElement} A node reprensting the feature in GML.
     * @private
     */
    createFeatureXML: function(feature) {
        var geometry = feature.geometry;
        var geometryNode = this.buildGeometryNode(geometry);
        var geomContainer = this.createElementNS(this.featureNS,
                                                 this.featurePrefix + ":" +
                                                 this.geometryName);
        geomContainer.appendChild(geometryNode);
        var featureNode = this.createElementNS(this.gmlns,
                                               "gml:" + this.featureName);
        var featureContainer = this.createElementNS(this.featureNS,
                                                    this.featurePrefix + ":" +
                                                    this.layerName);
        var fid = feature.fid || feature.id;
        featureContainer.setAttribute("fid", fid);
        featureContainer.appendChild(geomContainer);
        for(var attr in feature.attributes) {
            var attrText = this.createTextNode(feature.attributes[attr]); 
            var nodename = attr.substring(attr.lastIndexOf(":") + 1);
            var attrContainer = this.createElementNS(this.featureNS,
                                                     this.featurePrefix + ":" +
                                                     nodename);
            attrContainer.appendChild(attrText);
            featureContainer.appendChild(attrContainer);
        }    
        featureNode.appendChild(featureContainer);
        return featureNode;
    },
    
    /**
     * 根据geometry生成GML格式数据。
     * @memberof GeoGlobe.Format.GML.prototype
     */
    buildGeometryNode: function(geometry) {
        if (this.externalProjection && this.internalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, 
                               this.externalProjection);
        }    
        var className = geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        var builder = this.buildGeometry[type.toLowerCase()];
        return builder.apply(this, [geometry]);
    },

    /**
     *  Object containing methods to do the actual geometry node building based on geometry type.
     * @memberof GeoGlobe.Format.GML.prototype
     * @type {null}
     * @private
     *
     */
    buildGeometry: {
        // TBD retrieve the srs from layer
        // srsName is non-standard, so not including it until it's right.
        // gml.setAttribute("srsName",
        //                  "http://www.opengis.net/gml/srs/epsg.xml#4326");

        /**
         * Given an GeoGlobe point geometry, create a GML point.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.Point}geometry -  A point geometry.
         * @returns {DOMElement} A GML point node.
         * @private
         */
        point: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:Point");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         *  Given an GeoGlobe multipoint geometry, create a GML multipoint.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.MultiPoint}geometry - A multipoint geometry.
         * @returns {DOMElement} A GML multipoint node.
         * @private
         */
        multipoint: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiPoint");
            var points = geometry.components;
            var pointMember, pointGeom;
            for(var i=0; i<points.length; i++) { 
                pointMember = this.createElementNS(this.gmlns,
                                                   "gml:pointMember");
                pointGeom = this.buildGeometry.point.apply(this,
                                                               [points[i]]);
                pointMember.appendChild(pointGeom);
                gml.appendChild(pointMember);
            }
            return gml;            
        },
        
        /**
         *  Given an GeoGlobe linestring geometry, create a GML linestring.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.LineString}  geometry -A linestring geometry.
         * @returns {DOMElement} A GML linestring node.
         * @private
         */
        linestring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:LineString");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Given an GeoGlobe multilinestring geometry, create a GML
         *     multilinestring.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.MultiLineString}geometry -  A multilinestring
         *     geometry.
         * @returns {DOMElement} A GML multilinestring node.
         * @private
         */
        multilinestring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiLineString");
            var lines = geometry.components;
            var lineMember, lineGeom;
            for(var i=0; i<lines.length; ++i) {
                lineMember = this.createElementNS(this.gmlns,
                                                  "gml:lineStringMember");
                lineGeom = this.buildGeometry.linestring.apply(this,
                                                                   [lines[i]]);
                lineMember.appendChild(lineGeom);
                gml.appendChild(lineMember);
            }
            return gml;
        },
        
        /**
         * Given an GeoGlobe linearring geometry, create a GML linearring.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.LinearRing}geometry -  A linearring geometry.
         * @returns {DOMElement} A GML linearring node.
         * @private
         */
        linearring: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:LinearRing");
            gml.appendChild(this.buildCoordinatesNode(geometry));
            return gml;
        },
        
        /**
         * Given an GeoGlobe polygon geometry, create a GML polygon.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.Polygon} geometry - A polygon geometry.
         *
         * @returns {DOMElement} A GML polygon node.
         * @private
         */
        polygon: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:Polygon");
            var rings = geometry.components;
            var ringMember, ringGeom, type;
            for(var i=0; i<rings.length; ++i) {
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
                ringMember = this.createElementNS(this.gmlns,
                                                  "gml:" + type);
                ringGeom = this.buildGeometry.linearring.apply(this,
                                                                   [rings[i]]);
                ringMember.appendChild(ringGeom);
                gml.appendChild(ringMember);
            }
            return gml;
        },
        
        /**
         * Given an GeoGlobe multipolygon geometry, create a GML multipolygon.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.MultiPolygon}geometry -  A multipolygon
         *     geometry.
         * @returns {DOMElement} A GML multipolygon node.
         * @private
         */
        multipolygon: function(geometry) {
            var gml = this.createElementNS(this.gmlns, "gml:MultiPolygon");
            var polys = geometry.components;
            var polyMember, polyGeom;
            for(var i=0; i<polys.length; ++i) {
                polyMember = this.createElementNS(this.gmlns,
                                                  "gml:polygonMember");
                polyGeom = this.buildGeometry.polygon.apply(this,
                                                                [polys[i]]);
                polyMember.appendChild(polyGeom);
                gml.appendChild(polyMember);
            }
            return gml;

        },
        
        /**
         * Given an GeoGlobe bounds, create a GML box.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.Bounds}bounds - A bounds object.
         *
         * @returns {DOMElement} A GML box node.
         * @private
         */
        //bounds: function(bounds) {
            //var gml = this.createElementNS(this.gmlns, "gml:Box");
            //gml.appendChild(this.buildCoordinatesNode(bounds));
            //return gml;
        //},
 
        /**
         * Given an GeoGlobe bounds, create a GML box.
         * @memberof GeoGlobe.Format.GML.prototype
         * @param {GeoGlobe.Geometry.Bounds}bounds - A bounds object.
         * @returns {DOMElement} A GML box node.
         * @private
         */
        lnglatbounds: function(bounds) {
            var gml = this.createElementNS(this.gmlns, "gml:Box");
            gml.appendChild(this.buildCoordinatesNode(bounds));
            return gml;
        }
    },

    /**
     * builds the coordinates XmlNode
     * (code)
     * gml:coordinates decimal="." cs="," ts=" ">.../gml:coordinates
     * (end)
     * @memberof GeoGlobe.Format.GML.prototype
     * @param {GeoGlobe.Geometry} geometry -
     * @returns {XmlNode} created xmlNode
     * @private
     */
    buildCoordinatesNode: function(geometry) {
        var coordinatesNode = this.createElementNS(this.gmlns,
                                                   "gml:coordinates");
        coordinatesNode.setAttribute("decimal", ".");
        coordinatesNode.setAttribute("cs", ",");
        coordinatesNode.setAttribute("ts", " ");

        var parts = [];

        if(geometry instanceof mapboxgl.LngLatBounds){//GeoGlobe
            parts.push(geometry.getWest() + "," + geometry.getSouth());
            parts.push(geometry.getEast() + "," + geometry.getNorth());
        } else {
            var points = (geometry.components) ? geometry.components : [geometry];
            for(var i=0; i<points.length; i++) {
                parts.push(points[i].x + "," + points[i].y);                
            }            
        }

        var txtNode = this.createTextNode(parts.join(" "));
        coordinatesNode.appendChild(txtNode);
        
        return coordinatesNode;
    },

    CLASS_NAME: "GeoGlobe.Format.GML"
});
/** Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */


/**
 * 虽然在完整版本中是必需的，但如果排除GML格式，我们在这里设置命名空间。
 */
if(!GeoGlobe.Format.GML) {
    GeoGlobe.Format.GML = {};
}

/**
 * @class  GeoGlobe.Format.GML.Base
 * @classdesc GMLv2与GMLv3的基类 Superclass for GML parsers.Inherits from:GeoGlobe.Format.XML
 *
 */
GeoGlobe.Format.GML.Base = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     *  Mapping of namespace aliases to namespace URIs.
     *@memberof GeoGlobe.Format.GML.Base.prototype
     *@type {Object}
     *@private
     */
    namespaces: {
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs" // this is a convenience for reading wfs:FeatureCollection
    },
    
    /**
     *
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
    defaultPrefix: "gml",

    /**
     *  Schema location for a particular minor version.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @type {String}
     * @private
     */
    schemaLocation: null,
    
    /**
     *本地（无前缀）功能类型名称（s）。
     * @memberof GeoGlobe.Base.prototype
     *  @type {Array(String)| String}
     */
    featureType: null,
    
    /**
     * 功能命名空间。 必须在构造选项中进行设置。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {String}
     */
    featureNS: null,

    /**
     *几何元素的名称。 默认为“几何”。 如果为null，则在解析第一个几何图形时将设置为read。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {String}
     */
    geometryName: "geometry",

    /**
     *从GML中提取属性。 默认值是true。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {Boolean}
     */
    extractAttributes: true,
    
    /**
     * 空间参考系统的URI。 
     * 这对于单个部分几何体是可选的，对于集合体和多重体是必需的。 
     * 如果设置，则会为所有几何图形编写srsName属性.
     * Default为空。
     *  @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {String}
     */
    srsName: null,

    /**
     *GML坐标的顺序true：（x，y）或false：（y，x）不建议更改，应该实例化新的Format。
     *@memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {Boolean}
     */ 
    xy: true,

    /**
     * Maps GeoGlobe geometry class names to GML element names.
     *     Use setGeometry Types before accessing this property.
     *    @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {Object}
     */
    geometryTypes: null,

    /**

     * {Boolean} True if there is only 1 featureType, and not an array
     *     of featuretypes.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @type {Boolean}
     * @private
     */
    singleFeatureType: null,
    
    /**

     *  Indicates if the format was configured without a featureNS,
     * but auto-configured  featureNS and featureType> during read.
     * Subclasses making use of featureType auto-configuration should make
     * the first call to the readNode method (usually in the read method)
     * with true as 3rd argument, so the auto-configured featureType can be
     * reset and the format can be reused for subsequent reads with data from
     * different featureTypes. Set to false after read if you want to keep the
     * auto-configured values.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     *  @type {Boolean}
     */


    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private

     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g),
        featureMember: (/^(.*:)?featureMembers?$/)
    },

    /**

     *这个类的实例不是直接创建的。 改为使用GeoGlobe.Format.GML.v2或GeoGlobe.Format.GML.v3构造函数。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @type {Boolean}
     * @param {Object}选项 - 一个可选对象，其属性将在此实例上设置。
     *
     * 有效的选项属性：

     * @param {Array(String) | String} featuretype - 本地（无前缀）功能typeName（s）（写入所需）。
     * @param {String} featureNS -  功能名称空间（写入所需）。
     * @param {String} geometryName - 几何元素名称（写入所需）。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.setGeometryTypes();
        if(options && options.featureNS) {
            this.setNamespace("feature", options.featureNS);
        }
        this.singleFeatureType = !options || (typeof options.featureType === "string");
    },
    
    /**

     *@memberof GeoGlobe.Format.GML.Base.prototype
     * @param {DOMElement} data - A gml:featureMember element, a gml:featureMembers
     *     element, or an element containing either of the above at any level.
     *
     * @returns {Array(GeoGlobe.Feature)} An array of features.
     * @private
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var features = [];
        this.readNode(data, {features: features}, true);
        if(features.length == 0) {
            // look for gml:featureMember elements
            var elements = this.getElementsByTagNameNS(
                data, this.namespaces.gml, "featureMember"
            );
            if(elements.length) {
                for(var i=0, len=elements.length; i<len; ++i) {
                    this.readNode(elements[i], {features: features}, true);
                }
            } else {
                // look for gml:featureMembers elements (this is v3, but does no harm here)
                var elements = this.getElementsByTagNameNS(
                    data, this.namespaces.gml, "featureMembers"
                );
                if(elements.length) {
                    // there can be only one
                    this.readNode(elements[0], {features: features}, true);
                }
            }
        }
        return features;
    },
    
    /**

     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *@memberof GeoGlobe.Format.GML.Base.prototype

     *@param  {DOMElement} node -The node to be read (required).
     *@param {Object}  obj - The object to be modified (optional).
     *@param  {Boolean}first - Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *
     * @returns {Object} The input object, modified (or a new one if none was provided).
     * @private
     */
    readNode: function(node, obj, first) {
        // on subsequent calls of format.read(), we want to reset auto-
        // configured properties and auto-configure again.
        if (first === true && this.autoConfig === true) {
            this.featureType = null;
            delete this.namespaceAlias[this.featureNS];
            delete this.namespaces["feature"];
            this.featureNS = null;
        }
        // featureType auto-configuration
        if (!this.featureNS && (!(node.prefix in this.namespaces) &&
                node.parentNode.namespaceURI == this.namespaces["gml"] &&
                this.regExes.featureMember.test(node.parentNode.nodeName))) {
            this.featureType = node.nodeName.split(":").pop();
            this.setNamespace("feature", node.namespaceURI);
            this.featureNS = node.namespaceURI;
            this.autoConfig = true;
        }
        return GeoGlobe.Format.XML.prototype.readNode.apply(this, [node, obj]);
    },
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
    readers: {
        "gml": {
            "_inherit": function(node, obj, container) {
                // To be implemented by version specific parsers
            },
            "featureMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "featureMembers": function(node, obj) {
                this.readChildNodes(node, obj);                
            },
            "name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "boundedBy": function(node, obj) {
                var container = {};
                this.readChildNodes(node, container);
                if(container.components && container.components.length > 0) {
                    obj.bounds = container.components[0];
                }
            },
            "Point": function(node, container) {
                var obj = {points: []};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(obj.points[0]);
            },
            "coordinates": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                var coords;
                var numPoints = pointList.length;
                var points = new Array(numPoints);
                for(var i=0; i<numPoints; ++i) {
                    coords = pointList[i].split(",");
                    if (this.xy) {
                        points[i] = new GeoGlobe.Geometry.Point(
                            coords[0], coords[1], coords[2]
                        );
                    } else {
                        points[i] = new GeoGlobe.Geometry.Point(
                            coords[1], coords[0], coords[2]
                        );
                    }
                }
                obj.points = points;
            },
            "coord": function(node, obj) {
                var coord = {};
                this.readChildNodes(node, coord);
                if(!obj.points) {
                    obj.points = [];
                }
                obj.points.push(new GeoGlobe.Geometry.Point(
                    coord.x, coord.y, coord.z
                ));
            },
            "X": function(node, coord) {
                coord.x = this.getChildValue(node);
            },
            "Y": function(node, coord) {
                coord.y = this.getChildValue(node);
            },
            "Z": function(node, coord) {
                coord.z = this.getChildValue(node);
            },
            "MultiPoint": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiPoint(obj.components)
                ];
            },
            "pointMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LineString": function(node, container) {
                var obj = {};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.LineString(obj.points)
                );
            },
            "MultiLineString": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiLineString(obj.components)
                ];
            },
            "lineStringMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Polygon": function(node, container) {
                var obj = {outer: null, inner: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                obj.inner.unshift(obj.outer);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.Polygon(obj.inner)
                );
            },
            "LinearRing": function(node, obj) {
                var container = {};
                this.readers.gml._inherit.apply(this, [node, container]);
                this.readChildNodes(node, container);
                obj.components = [new GeoGlobe.Geometry.LinearRing(
                    container.points
                )];
            },
            "MultiPolygon": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.MultiPolygon(obj.components)
                ];
            },
            "polygonMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "GeometryCollection": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                container.components = [
                    new GeoGlobe.Geometry.Collection(obj.components)
                ];
            },
            "geometryMember": function(node, obj) {
                this.readChildNodes(node, obj);
            }
        },
        "feature": {
            "*": function(node, obj) {
                // The node can either be named like the featureType, or it
                // can be a child of the feature:featureType.  Children can be
                // geometry or attributes.
                var name;
                var local = node.localName || node.nodeName.split(":").pop();
                // Since an attribute can have the same name as the feature type
                // we only want to read the node as a feature if the parent
                // node can have feature nodes as children.  In this case, the
                // obj.features property is set.
                if (obj.features) {
                    if (!this.singleFeatureType &&
                        (GeoGlobe.Util.indexOf(this.featureType, local) !== -1)) {
                        name = "_typeName";
                    } else if(local === this.featureType) {
                        name = "_typeName";
                    }else if(GeoGlobe.Util.isArray(this.featureType_)) {
						//this.featureType_属性是补丁中新增的属性，目的是让解析器能解析多个图层的数据。
						for(var i = 0; i < this.featureType_.length;i++) {
							if(this.featureType_[i] === local) {
								name = "_typeName";
								break;
							}
						}
					}
                } else {
                    // Assume attribute elements have one child node and that the child
                    // is a text node.  Otherwise assume it is a geometry node.
                    if(node.childNodes.length == 0 ||
                       (node.childNodes.length == 1 && node.firstChild.nodeType == 3)) {
                        if(this.extractAttributes) {
                            name = "_attribute";
                        }
                    } else {
                        name = "_geometry";
                    }
                }
                if(name) {
                    this.readers.feature[name].apply(this, [node, obj]);
                }
            },
            "_typeName": function(node, obj) {
                var container = {components: [], attributes: {}};
                this.readChildNodes(node, container);
                // look for common gml namespaced elements
                if(container.name) {
                    container.attributes.name = container.name;
                }
                var feature = new GeoGlobe.Feature(
                    container.components[0], container.attributes
                );
                if (!this.singleFeatureType) {
                    feature.type = node.nodeName.split(":").pop();
                    feature.namespace = node.namespaceURI;
                }
                var fid = node.getAttribute("fid") ||
                    this.getAttributeNS(node, this.namespaces["gml"], "id");
                if(fid) {
                    feature.fid = fid;
                }
                if(this.internalProjection && this.externalProjection &&
                   feature.geometry) {
                    feature.geometry.transform(
                        this.externalProjection, this.internalProjection
                    );
                }
                if(container.bounds) {
                    feature.bounds = container.bounds;
                }
                obj.features.push(feature);
            },
            "_geometry": function(node, obj) {
                if (!this.geometryName) {
                    this.geometryName = node.nodeName.split(":").pop();
                }
                this.readChildNodes(node, obj);
            },
            "_attribute": function(node, obj) {
                var local = node.localName || node.nodeName.split(":").pop();
                var value = this.getChildValue(node);
                obj.attributes[local] = value;
            }
        },
        "wfs": {
            "FeatureCollection": function(node, obj) {
                this.readChildNodes(node, obj);
            }
        }
    },
    
    /**

     *@memberof GeoGlobe.Base.prototype
     * @param {Array(GeoGlobe.Feature) | GeoGlobe.Feature} features -
     *     An array of features or a single feature.
     *
     * @returns
     * {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     * @private
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            name = "featureMembers";
        } else {
            name = "featureMember";
        }
        var root = this.writeNode("gml:" + name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },
    
    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
    writers: {
        "gml": {
            "featureMember": function(feature) {
                var node = this.createElementNSPlus("gml:featureMember");
                this.writeNode("feature:_typeName", feature, node);
                return node;
            },
            "MultiPoint": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiPoint");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode("pointMember", components[i], node);
                }
                return node;
            },
            "pointMember": function(geometry) {
                var node = this.createElementNSPlus("gml:pointMember");
                this.writeNode("Point", geometry, node);
                return node;
            },
            "MultiLineString": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiLineString");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode("lineStringMember", components[i], node);
                }
                return node;
            },
            "lineStringMember": function(geometry) {
                var node = this.createElementNSPlus("gml:lineStringMember");
                this.writeNode("LineString", geometry, node);
                return node;
            },
            "MultiPolygon": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiPolygon");
                var components = geometry.components || [geometry];
                for(var i=0, ii=components.length; i<ii; ++i) {
                    this.writeNode(
                        "polygonMember", components[i], node
                    );
                }
                return node;
            },
            "polygonMember": function(geometry) {
                var node = this.createElementNSPlus("gml:polygonMember");
                this.writeNode("Polygon", geometry, node);
                return node;
            },
            "GeometryCollection": function(geometry) {
                var node = this.createElementNSPlus("gml:GeometryCollection");
                for(var i=0, len=geometry.components.length; i<len; ++i) {
                    this.writeNode("geometryMember", geometry.components[i], node);
                }
                return node;
            },
            "geometryMember": function(geometry) {
                var node = this.createElementNSPlus("gml:geometryMember");
                var child = this.writeNode("feature:_geometry", geometry);
                node.appendChild(child.firstChild);
                return node;
            }
        },
        "feature": {
            "_typeName": function(feature) {
                var node = this.createElementNSPlus("feature:" + this.featureType, {
                    attributes: {fid: feature.fid}
                });
                if(feature.geometry) {
                    this.writeNode("feature:_geometry", feature.geometry, node);
                }
                for(var name in feature.attributes) {
                    var value = feature.attributes[name];
                    if(value != null) {
                        this.writeNode(
                            "feature:_attribute",
                            {name: name, value: value}, node
                        );
                    }
                }
                return node;
            },
            "_geometry": function(geometry) {
                if(this.externalProjection && this.internalProjection) {
                    geometry = geometry.clone().transform(
                        this.internalProjection, this.externalProjection
                    );
                }    
                var node = this.createElementNSPlus(
                    "feature:" + this.geometryName
                );
                var type = this.geometryTypes[geometry.CLASS_NAME];
                var child = this.writeNode("gml:" + type, geometry, node);
                if(this.srsName) {
                    child.setAttribute("srsName", this.srsName);
                }
                return node;
            },
            "_attribute": function(obj) {
                return this.createElementNSPlus("feature:" + obj.name, {
                    value: obj.value
                });
            }
        },
        "wfs": {
            "FeatureCollection": function(features) {
                /**
                 * This is only here because GML2 only describes abstract
                 * feature collections.  Typically, you would not be using
                 * the GML format to write wfs elements.  This just provides
                 * some way to write out lists of features.  GML3 defines the
                 * featureMembers element, so that is used by default instead.
                 */
                var node = this.createElementNSPlus("wfs:FeatureCollection");
                for(var i=0, len=features.length; i<len; ++i) {
                    this.writeNode("gml:featureMember", features[i], node);
                }
                return node;
            }
        }
    },
    
    /**

     * Sets the geometryTypes mapping.
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
    setGeometryTypes: function() {
        this.geometryTypes = {
            "GeoGlobe.Geometry.Point": "Point",
            "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
            "GeoGlobe.Geometry.LineString": "LineString",
            "GeoGlobe.Geometry.MultiLineString": "MultiLineString",
            "GeoGlobe.Geometry.Polygon": "Polygon",
            "GeoGlobe.Geometry.MultiPolygon": "MultiPolygon",
            "GeoGlobe.Geometry.Collection": "GeometryCollection"
        };
    },
	
    /**

     * 增加featureType_属性，让gml解析器能解析多个图层的数据。
     * @memberof GeoGlobe.Format.GML.Base.prototype
     * @private
     */
	setFeatureType_: function(featureType) {
		this.featureType_ = featureType;
	},

    CLASS_NAME: "GeoGlobe.Format.GML.Base"

});
/** Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */


/**
 * @class  GeoGlobe.Format.GML.v2

 * @classdesc 解析GML文件类（V2版本当服务版本不是1.1.0时使用）。Parses GML version 2.
 *
 * Inherits from:
 *  - GeoGlobe.Format.GML.Base
 */
GeoGlobe.Format.GML.v2 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.Base, {
    
    

    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd",

    /**
     * Constructor: GeoGlobe.Format.GML.v2
     * 为GML v2创建一个解析器。
     *@memberof GeoGlobe.Format.GML.v2.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     *
     * 有效的选项属性：
     * featureType - {String} 本地（无前缀）功能typeName（必需）。
     * featureNS - {String} 功能名称空间（必需）。
     * geometryName - {String} 几何元素名称。
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.Base.prototype.initialize.apply(this, [options]);
    },

    /**
     * readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.GML.v2.prototype
     * @private
     */
    readers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "outerBoundaryIs": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.outer = obj.components[0];
            },
            "innerBoundaryIs": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.inner.push(obj.components[0]);
            },
            "Box": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                var min = obj.points[0];
                var max = obj.points[1];
                var sw = new GeoGlobe.LngLat(min.x, min.y);
     			var ne = new GeoGlobe.LngLat(max.x, max.y);
                container.components.push(
                    new GeoGlobe.LngLatBounds(sw, ne)
                );
            }
        }, GeoGlobe.Format.GML.Base.prototype.readers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.readers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.readers["wfs"]
    },

    /**
     *  @memberof GeoGlobe.Format.GML.v2.prototype

     * @param features - {Array(GeoGlobe.Feature) | GeoGlobe.Feature
     *     An array of features or a single feature.
     *
     * @returns {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     * @private
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            // GML2 only has abstract feature collections
            // wfs provides a feature collection from a well-known schema
            name = "wfs:FeatureCollection";
        } else {
            name = "gml:featureMember";
        }
        var root = this.writeNode(name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },

    /**
     *  writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.GML.v2.prototype
     * @private
     */
    writers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "Point": function(geometry) {
                var node = this.createElementNSPlus("gml:Point");
                this.writeNode("coordinates", [geometry], node);
                return node;
            },
            "coordinates": function(points) {
                var numPoints = points.length;
                var parts = new Array(numPoints);
                var point;
                for(var i=0; i<numPoints; ++i) {
                    point = points[i];
                    if(this.xy) {
                        parts[i] = point.x + "," + point.y;
                    } else {
                        parts[i] = point.y + "," + point.x;
                    }
                    if(point.z != undefined) { // allow null or undefined
                        parts[i] += "," + point.z;
                    }
                }
                return this.createElementNSPlus("gml:coordinates", {
                    attributes: {
                        decimal: ".", cs: ",", ts: " "
                    },
                    value: (numPoints == 1) ? parts[0] : parts.join(" ")
                });
            },
            "LineString": function(geometry) {
                var node = this.createElementNSPlus("gml:LineString");
                this.writeNode("coordinates", geometry.components, node);
                return node;
            },
            "Polygon": function(geometry) {
                var node = this.createElementNSPlus("gml:Polygon");
                this.writeNode("outerBoundaryIs", geometry.components[0], node);
                for(var i=1; i<geometry.components.length; ++i) {
                    this.writeNode(
                        "innerBoundaryIs", geometry.components[i], node
                    );
                }
                return node;
            },
            "outerBoundaryIs": function(ring) {
                var node = this.createElementNSPlus("gml:outerBoundaryIs");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "innerBoundaryIs": function(ring) {
                var node = this.createElementNSPlus("gml:innerBoundaryIs");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "LinearRing": function(ring) {
                var node = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("coordinates", ring.components, node);
                return node;
            },
            "Box": function(bounds) {
                var node = this.createElementNSPlus("gml:Box");
                this.writeNode("coordinates", [
                    {x: bounds._sw.lng, y: bounds._sw.lat},
                    {x: bounds._ne.lng, y: bounds._ne.lat}
                ], node);
                // srsName attribute is optional for gml:Box
                if(this.srsName) {
                    node.setAttribute("srsName", this.srsName);
                }
                return node;
            }
        }, GeoGlobe.Format.GML.Base.prototype.writers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.writers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.writers["wfs"]
    },
    
    CLASS_NAME: "GeoGlobe.Format.GML.v2"

});
/** Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */



/**
 * @class  GeoGlobe.Format.GML.v2

 * @classdesc 解析GML文件类（V3版本当服务版本是1.1.0时使用）。
 * Inherits from:
 *  - GeoGlobe.Format.GML.Base
 */
GeoGlobe.Format.GML.v3 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.Base, {
    
    /**
     *Schema location for a particular minor version.  The writers
     *     conform with the Simple Features Profile for GML.
     * @memberof GeoGlobe.v3.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",

    /**
     *  Write gml:Curve instead of gml:LineString elements.  This also
     *     affects the elements in multi-part geometries.  Default is false.
     *     To write gml:Curve elements instead of gml:LineString, set curve
     *     to true in the options to the contstructor (cannot be changed after
     *     instantiation).
     * @memberof GeoGlobe.v3.prototype
     * @type {Boolean}
     * @private
*/
    curve: false,
    
    /**
     * Write gml:MultiCurve instead of gml:MultiLineString.  Since
     *     the latter is deprecated in GML 3, the default is true.  To write
     *     gml:MultiLineString instead of gml:MultiCurve, set multiCurve to
     *     false in the options to the constructor (cannot be changed after
     *     instantiation).
     * @memberof GeoGlobe.v3.prototype
     * @type {Boolean}
     * @private
     */

    multiCurve: true,
    
    /**
     * Write gml:Surface instead of gml:Polygon elements.  This also
     *     affects the elements in multi-part geometries.  Default is false.
     *     To write gml:Surface elements instead of gml:Polygon, set surface
     *     to true in the options to the contstructor (cannot be changed after
     *     instantiation).
     * @memberof GeoGlobe.v3.prototype
     * @type {Boolean}
     * @private
     */
    surface: false,

    /**
     * Write gml:multiSurface instead of gml:MultiPolygon.  Since
     *     the latter is deprecated in GML 3, the default is true.  To write
     *     gml:MultiPolygon instead of gml:multiSurface, set multiSurface to
     *     false in the options to the constructor (cannot be changed after
     *     instantiation).
     * @memberof GeoGlobe.v3.prototype
     * @type {Boolean}
     * @private
     */
    multiSurface: true,

    /**
     * Constructor: GeoGlobe.Format.GML.v3
     * 为GML v3创建一个解析器。
     * @memberof GeoGlobe.v3.prototype
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     *
     * 有效的选项属性：
     * featureType - {String} 本地（无前缀）功能typeName（必需）。
     * featureNS - {String} 功能名称空间（必需）。
     * geometryName - {String} 几何元素名称。
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.Base.prototype.initialize.apply(this, [options]);
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.v3.prototype
     * @private
     */
    readers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "_inherit": function(node, obj, container) {
                // SRSReferenceGroup attributes
                var dim = parseInt(node.getAttribute("srsDimension"), 10) ||
                    (container && container.srsDimension);
                if (dim) {
                    obj.srsDimension = dim;
                }
            },
            "featureMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Curve": function(node, container) {
                var obj = {points: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                container.components.push(
                    new GeoGlobe.Geometry.LineString(obj.points)
                );
            },
            "segments": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LineStringSegment": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                if(obj.points) {
                    Array.prototype.push.apply(container.points, obj.points);
                }
            },
            "pos": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                var coords = str.split(this.regExes.splitSpace);
                var point;
                if(this.xy) {
                    point = new GeoGlobe.Geometry.Point(
                        coords[0], coords[1], coords[2]
                    );
                } else {
                    point = new GeoGlobe.Geometry.Point(
                        coords[1], coords[0], coords[2]
                    );
                }
                obj.points = [point];
            },
            "posList": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, ""
                );
                var coords = str.split(this.regExes.splitSpace);
                // The "dimension" attribute is from the GML 3.0.1 spec.
                var dim = obj.srsDimension ||
                    parseInt(node.getAttribute("srsDimension") || node.getAttribute("dimension"), 10) || 2;
                var j, x, y, z;
                var numPoints = coords.length / dim;
                var points = new Array(numPoints);
                for(var i=0, len=coords.length; i<len; i += dim) {
                    x = coords[i];
                    y = coords[i+1];
                    z = (dim == 2) ? undefined : coords[i+2];
                    if (this.xy) {
                        points[i/dim] = new GeoGlobe.Geometry.Point(x, y, z);
                    } else {
                        points[i/dim] = new GeoGlobe.Geometry.Point(y, x, z);
                    }
                }
                obj.points = points;
            },
            "Surface": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "patches": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "PolygonPatch": function(node, obj) {
                this.readers.gml.Polygon.apply(this, [node, obj]);
            },
            "exterior": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.outer = obj.components[0];
            },
            "interior": function(node, container) {
                var obj = {};
                this.readChildNodes(node, obj);
                container.inner.push(obj.components[0]);
            },
            "MultiCurve": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(obj.components.length > 0) {
                    container.components = [
                        new GeoGlobe.Geometry.MultiLineString(obj.components)
                    ];
                }
            },
            "curveMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "MultiSurface": function(node, container) {
                var obj = {components: []};
                this.readers.gml._inherit.apply(this, [node, obj, container]);
                this.readChildNodes(node, obj);
                if(obj.components.length > 0) {
                    container.components = [
                        new GeoGlobe.Geometry.MultiPolygon(obj.components)
                    ];
                }
            },
            "surfaceMember": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "surfaceMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "pointMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "lineStringMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "polygonMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "geometryMembers": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Envelope": function(node, container) {
                var obj = {points: new Array(2)};
                this.readChildNodes(node, obj);
                if(!container.components) {
                    container.components = [];
                }
                var min = obj.points[0];
                var max = obj.points[1];
                var sw = new GeoGlobe.LngLat(min.x, min.y);
     			var ne = new GeoGlobe.LngLat(max.x, max.y);
                container.components.push(
                    new GeoGlobe.LngLatBounds(sw, ne)
                );
            },
            "lowerCorner": function(node, container) {
                var obj = {};
                this.readers.gml.pos.apply(this, [node, obj]);
                container.points[0] = obj.points[0];
            },
            "upperCorner": function(node, container) {
                var obj = {};
                this.readers.gml.pos.apply(this, [node, obj]);
                container.points[1] = obj.points[0];
            }
        }, GeoGlobe.Format.GML.Base.prototype.readers["gml"]),            
        "feature": GeoGlobe.Format.GML.Base.prototype.readers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.readers["wfs"]
    },
    
    /**

     * @memberof GeoGlobe.v3.prototype
     * @param {Array(GeoGlobe.Feature) | GeoGlobe.Feature}features -
     *     An array of features or a single feature.
     *
     * @returns {String} Given an array of features, a doc with a gml:featureMembers
     *     element will be returned.  Given a single feature, a doc with a
     *     gml:featureMember element will be returned.
     * @private
     */
    write: function(features) {
        var name;
        if(GeoGlobe.Util.isArray(features)) {
            name = "featureMembers";
        } else {
            name = "featureMember";
        }
        var root = this.writeNode("gml:" + name, features);
        this.setAttributeNS(
            root, this.namespaces["xsi"],
            "xsi:schemaLocation", this.schemaLocation
        );

        return GeoGlobe.Format.XML.prototype.write.apply(this, [root]);
    },

    /**
     *  writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.v3.prototype
     * @private
     */
    writers: {
        "gml": GeoGlobe.Util.applyDefaults({
            "featureMembers": function(features) {
                var node = this.createElementNSPlus("gml:featureMembers");
                for(var i=0, len=features.length; i<len; ++i) {
                    this.writeNode("feature:_typeName", features[i], node);
                }
                return node;
            },
            "Point": function(geometry) {
                var node = this.createElementNSPlus("gml:Point");
                this.writeNode("pos", geometry, node);
                return node;
            },
            "pos": function(point) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (point.x + " " + point.y) : (point.y + " " + point.x);
                return this.createElementNSPlus("gml:pos", {
                    value: pos
                });
            },
            "LineString": function(geometry) {
                var node = this.createElementNSPlus("gml:LineString");
                this.writeNode("posList", geometry.components, node);
                return node;
            },
            "Curve": function(geometry) {
                var node = this.createElementNSPlus("gml:Curve");
                this.writeNode("segments", geometry, node);
                return node;
            },
            "segments": function(geometry) {
                var node = this.createElementNSPlus("gml:segments");
                this.writeNode("LineStringSegment", geometry, node);
                return node;
            },
            "LineStringSegment": function(geometry) {
                var node = this.createElementNSPlus("gml:LineStringSegment");
                this.writeNode("posList", geometry.components, node);
                return node;
            },
            "posList": function(points) {
                // only 2d for simple features profile
                var len = points.length;
                var parts = new Array(len);
                var point;
                for(var i=0; i<len; ++i) {
                    point = points[i];
                    if(this.xy) {
                        parts[i] = point.x + " " + point.y;
                    } else {
                        parts[i] = point.y + " " + point.x;
                    }
                }
                return this.createElementNSPlus("gml:posList", {
                    value: parts.join(" ")
                }); 
            },
            "Surface": function(geometry) {
                var node = this.createElementNSPlus("gml:Surface");
                this.writeNode("patches", geometry, node);
                return node;
            },
            "patches": function(geometry) {
                var node = this.createElementNSPlus("gml:patches");
                this.writeNode("PolygonPatch", geometry, node);
                return node;
            },
            "PolygonPatch": function(geometry) {
                var node = this.createElementNSPlus("gml:PolygonPatch", {
                    attributes: {interpolation: "planar"}
                });
                this.writeNode("exterior", geometry.components[0], node);
                for(var i=1, len=geometry.components.length; i<len; ++i) {
                    this.writeNode(
                        "interior", geometry.components[i], node
                    );
                }
                return node;
            },
            "Polygon": function(geometry) {
                var node = this.createElementNSPlus("gml:Polygon");
                this.writeNode("exterior", geometry.components[0], node);
                for(var i=1, len=geometry.components.length; i<len; ++i) {
                    this.writeNode(
                        "interior", geometry.components[i], node
                    );
                }
                return node;
            },
            "exterior": function(ring) {
                var node = this.createElementNSPlus("gml:exterior");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "interior": function(ring) {
                var node = this.createElementNSPlus("gml:interior");
                this.writeNode("LinearRing", ring, node);
                return node;
            },
            "LinearRing": function(ring) {
                var node = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("posList", ring.components, node);
                return node;
            },
            "MultiCurve": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiCurve");
                var components = geometry.components || [geometry];
                for(var i=0, len=components.length; i<len; ++i) {
                    this.writeNode("curveMember", components[i], node);
                }
                return node;
            },
            "curveMember": function(geometry) {
                var node = this.createElementNSPlus("gml:curveMember");
                if(this.curve) {
                    this.writeNode("Curve", geometry, node);
                } else {
                    this.writeNode("LineString", geometry, node);
                }
                return node;
            },
            "MultiSurface": function(geometry) {
                var node = this.createElementNSPlus("gml:MultiSurface");
                var components = geometry.components || [geometry];
                for(var i=0, len=components.length; i<len; ++i) {
                    this.writeNode("surfaceMember", components[i], node);
                }
                return node;
            },
            "surfaceMember": function(polygon) {
                var node = this.createElementNSPlus("gml:surfaceMember");
                if(this.surface) {
                    this.writeNode("Surface", polygon, node);
                } else {
                    this.writeNode("Polygon", polygon, node);
                }
                return node;
            },
            "Envelope": function(bounds) {
                var node = this.createElementNSPlus("gml:Envelope");
                this.writeNode("lowerCorner", bounds, node);
                this.writeNode("upperCorner", bounds, node);
                // srsName attribute is required for gml:Envelope
                if(this.srsName) {
                    node.setAttribute("srsName", this.srsName);
                }
                return node;
            },
            "lowerCorner": function(bounds) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (bounds._sw.lng + " " + bounds._sw.lat) :
                    (bounds._sw.lat + " " + bounds._sw.lng);
                return this.createElementNSPlus("gml:lowerCorner", {
                    value: pos
                });
            },
            "upperCorner": function(bounds) {
                // only 2d for simple features profile
                var pos = (this.xy) ?
                    (bounds._ne.lng + " " + bounds._ne.lat) :
                    (bounds._ne.lat + " " + bounds._ne.lng);
                return this.createElementNSPlus("gml:upperCorner", {
                    value: pos
                });
            }
        }, GeoGlobe.Format.GML.Base.prototype.writers["gml"]),
        "feature": GeoGlobe.Format.GML.Base.prototype.writers["feature"],
        "wfs": GeoGlobe.Format.GML.Base.prototype.writers["wfs"]
    },

    /**

     * Sets the geometryTypes mapping.
     * @memberof GeoGlobe.v3.prototype
     * @private
     */
    setGeometryTypes: function() {
        this.geometryTypes = {
            "GeoGlobe.Geometry.Point": "Point",
            "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
            "GeoGlobe.Geometry.LineString": (this.curve === true) ? "Curve": "LineString",
            "GeoGlobe.Geometry.MultiLineString": (this.multiCurve === false) ? "MultiLineString" : "MultiCurve",
            "GeoGlobe.Geometry.Polygon": (this.surface === true) ? "Surface" : "Polygon",
            "GeoGlobe.Geometry.MultiPolygon": (this.multiSurface === false) ? "MultiPolygon" : "MultiSurface",
            "GeoGlobe.Geometry.Collection": "GeometryCollection"
        };
    },
    
    CLASS_NAME: "GeoGlobe.Format.GML.v3"

});
/**
 * @class  GeoGlobe.Format.KML
 * @classdesc 读/写KML。 用GeoGlobe.Format.KML构造函数创建一个新实例。
 * @private
 */

GeoGlobe.Format.KML = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * namespaces-Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        kml: "http://www.opengis.net/kml/2.2",
        gx: "http://www.google.com/kml/ext/2.2"
    },

    /**
     * kmlns- 使用KML命名空间。 默认为2.0命名空间。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     */
    kmlns: "http://earth.google.com/kml/2.0",
    
    /**
     * placemarksDesc-地标的名称。 默认值是 "No description available"。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     */
    placemarksDesc: "No description available",
    
    /**
     * foldersName- 文件夹的名称。 默认值是“GeoGlobe导出”。如果设置为null，则不会创建名称元素。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     */
    foldersName: "GeoGlobe export",
    
    /**
     * foldersDesc- 文件夹的说明。 默认值是“在[date]上导出”。如果设置为null，则不会创建任何说明元素。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     */
    foldersDesc: "Exported on " + new Date(),
    
    /**
     * extractAttributes- 从KML中提取属性。 默认值是true。
     *抽取styleUrls要求将其设置为true请注意，目前只处理Data和SimpleData元素。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Boolean}
     */
    extractAttributes: true,
    
    /**
     * kvpAttributes- 仅在extractAttributes为true时使用。
     * 如果设置为true，则属性将是简单的键值对，与其他格式兼容。
     * 任何displayName元素都将被忽略。如果设置为false，则属性将为对象，
     * 保留任何displayName元素，但不会 与其他格式兼容。 
     * displayName中的任何CDATA都将作为字符串值读入。
     * 默认为false。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Boolean}
     */
    kvpAttributes: false,
    
    /**
     * extractStyles- Extract styles from KML.  Default is false.
     *           Extracting styleUrls also requires extractAttributes to be
     *           set to true
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Boolean}
     * @private
     */
    extractStyles: false,
    
    /**
     * extractTracks- 提取gx：跟踪地标元素的元素。
     * 默认为false。 如果为true，则会为所有gx：Track元素中的所有点生成要素。 
     * 特征将具有基于轨道中元素的when（Date）属性。 
     * 如果曲目包含角度元素，则要素将具有标题，倾斜和滚动属性。 
     * 如果轨迹点坐标具有三个值，则要素将具有第三个坐标值的高度属性。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Boolean}
     */
    extractTracks: false,
    
    /**
     * trackAttributes-如果<extractTracks>为true，
     * 那么gx：Track元素中的点将被解析为具有when，heading，tilt和roll属性的特征。 
     * 任何其他属性名称都可以在<trackAttributes>中提供。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Array}
     */
    trackAttributes: null,
    
    /**
     * internalns- KML Namespace to use -- defaults to the namespace of the
     *     Placemark node being parsed, but falls back to kmlns.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     * @private
     */
    internalns: null,

    /**
     * features-Array of features
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Array}
     * @private
     */
    features: null,

    /**
     * styles- Storage of style objects
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Object}
     * @private
     */
    styles: null,
    
    /**
     * styleBaseUrl
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {String}
     * @private
     */
    styleBaseUrl: "",

    /**
     * fetched- Storage of KML URLs that have been fetched before
     *     in order to prevent reloading them.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {Object}
     * @private
     */
    fetched: null,

    /**
     * 递归加载外部KML URL的最大深度默认为0：不执行外部提取
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {int}
     */
    maxDepth: 0,

    /**
     * 为KML创建一个新的解析器。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @classdesc GeoGlobe.Format.KML
     * @param {Object} options -一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        // compile regular expressions once instead of every time they are used
        this.regExes = {
            trimSpace: (/^\s*|\s*$/g),
            removeSpace: (/\s*/g),
            splitSpace: (/\s+/),
            trimComma: (/\s*,\s*/g),
            kmlColor: (/(\w{2})(\w{2})(\w{2})(\w{2})/),
            kmlIconPalette: (/root:\/\/icons\/palette-(\d+)(\.\w+)/),
            straightBracket: (/\$\[(.*?)\]/g)
        };
        // KML coordinates are always in longlat WGS84
        this.externalProjection = new GeoGlobe.SpatialReference("EPSG:4326");

        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     *  从字符串读取数据，并返回要素列表。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array}nodes   - of {DOMElement} 数据读取/解析。
     * @returns {Array(GeoGlobe.Feature)} 要素列表。
     */
    read: function(data) {
        this.features = [];
        this.styles   = {};
        this.fetched  = {};

        // Set default options 
        var options = {
            depth: 0,
            styleBaseUrl: this.styleBaseUrl
        };

        return this.parseData(data, options);
    },

    /**
     * Read data from a string, and return a list of features.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array}nodes   - of {DOMElement} data to read/parse.
     * @param {Object}options -  Hash of options
     * @returns {Array(GeoGlobe.Feature)} List of features.
     * @private
     */
    parseData: function(data, options) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }

        // Loop throught the following node types in this order and
        // process the nodes found 
        var types = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"];
        for(var i=0, len=types.length; i<len; ++i) {
            var type = types[i];

            var nodes = this.getElementsByTagNameNS(data, "*", type);

            // skip to next type if no nodes are found
            if(nodes.length == 0) { 
                continue;
            }

            switch (type.toLowerCase()) {

                // Fetch external links 
                case "link":
                case "networklink":
                    this.parseLinks(nodes, options);
                    break;

                // parse style information
                case "style":
                    if (this.extractStyles) {
                        this.parseStyles(nodes, options);
                    }
                    break;
                case "stylemap":
                    if (this.extractStyles) {
                        this.parseStyleMaps(nodes, options);
                    }
                    break;

                // parse features
                case "placemark":
                    this.parseFeatures(nodes, options);
                    break;
            }
        }
        
        return this.features;
    },

    /**
     * Finds URLs of linked KML documents and fetches them
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array}nodes   - of {DOMElement} data to read/parse.
     * @param {Object}options -  Hash of options
     * @private
     */
    parseLinks: function(nodes, options) {
        
        // Fetch external links <NetworkLink> and <Link>
        // Don't do anything if we have reached our maximum depth for recursion
        if (options.depth >= this.maxDepth) {
            return false;
        }

        // increase depth
        var newOptions = GeoGlobe.Util.extend({}, options);
        newOptions.depth++;

        for(var i=0, len=nodes.length; i<len; i++) {
            var href = this.parseProperty(nodes[i], "*", "href");
            if(href && !this.fetched[href]) {
                this.fetched[href] = true; // prevent reloading the same urls
                var data = this.fetchLink(href);
                if (data) {
                    this.parseData(data, newOptions);
                }
            } 
        }

    },

    /**
     * Fetches a URL and returns the result
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @private
     */
    fetchLink: function(href) {
        var request = GeoGlobe.Request.GET({url: href, async: false});
        if (request) {
            return request.responseText;
        }
    },

    /**
     * Parses Style nodes
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array} of {DOMElement}nodes    -  data to read/parse.
     * @param {Object}options  - Hash of options
     * @private
     * 
     */
    parseStyles: function(nodes, options) {
        for(var i=0, len=nodes.length; i<len; i++) {
            var style = this.parseStyle(nodes[i]);
            if(style) {
                var styleName = (options.styleBaseUrl || "") + "#" + style.id;
                
                this.styles[styleName] = style;
            }
        }
    },

    /**
     * Parses a kml color (in 'aabbggrr' format) and returns the corresponding
     * color and opacity or null if the color is invalid.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {String}kmlColor - a kml formated color
     * @returns {Object}
     * @private
     */
    parseKmlColor: function(kmlColor) {
        var color = null;
        if (kmlColor) {
            var matches = kmlColor.match(this.regExes.kmlColor);
            if (matches) {
                color = {
                    color: '#' + matches[4] + matches[3] + matches[2],
                    opacity: parseInt(matches[1], 16) / 255
                };
            }
        }
        return color;
    },

    /**
     * Parses the children of a Style node and builds the style hash
     * accordingly
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {DOMElement} node -Style node
     * @private
     * 
     */
    parseStyle: function(node) {
        var style = {};
        
        var types = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", 
                     "LabelStyle"];
        var type, styleTypeNode, nodeList, geometry, parser;
        for(var i=0, len=types.length; i<len; ++i) {
            type = types[i];
            styleTypeNode = this.getElementsByTagNameNS(node, "*", type)[0];
            if(!styleTypeNode) { 
                continue;
            }

            // only deal with first geometry of this type
            switch (type.toLowerCase()) {
                case "linestyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["strokeColor"] = color.color;
                        style["strokeOpacity"] = color.opacity;
                    }
                    
                    var width = this.parseProperty(styleTypeNode, "*", "width");
                    if (width) {
                        style["strokeWidth"] = width;
                    }
                    break;

                case "polystyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["fillOpacity"] = color.opacity;
                        style["fillColor"] = color.color;
                    }
                    // Check if fill is disabled
                    var fill = this.parseProperty(styleTypeNode, "*", "fill");
                    if (fill == "0") {
                        style["fillColor"] = "none";
                    }
                    // Check if outline is disabled
                    var outline = this.parseProperty(styleTypeNode, "*", "outline");
                    if (outline == "0") {
                        style["strokeWidth"] = "0";
                    }
                   
                    break;

                case "iconstyle":
                    // set scale
                    var scale = parseFloat(this.parseProperty(styleTypeNode, 
                                                          "*", "scale") || 1);
  
                    // set default width and height of icon
                    var width = 32 * scale;
                    var height = 32 * scale;

                    var iconNode = this.getElementsByTagNameNS(styleTypeNode, 
                                               "*", 
                                               "Icon")[0];
                    if (iconNode) {
                        var href = this.parseProperty(iconNode, "*", "href");
                        if (href) {                                                   

                            var w = this.parseProperty(iconNode, "*", "w");
                            var h = this.parseProperty(iconNode, "*", "h");

                            // Settings for Google specific icons that are 64x64
                            // We set the width and height to 64 and halve the
                            // scale to prevent icons from being too big
                            var google = "http://maps.google.com/mapfiles/kml";
                            if (GeoGlobe.String.startsWith(
                                                 href, google) && !w && !h) {
                                w = 64;
                                h = 64;
                                scale = scale / 2;
                            }
                                
                            // if only dimension is defined, make sure the
                            // other one has the same value
                            w = w || h;
                            h = h || w;

                            if (w) {
                                width = parseInt(w) * scale;
                            }

                            if (h) {
                                height = parseInt(h) * scale;
                            }

                            // support for internal icons 
                            //    (/root://icons/palette-x.png)
                            // x and y tell the position on the palette:
                            // - in pixels
                            // - starting from the left bottom
                            // We translate that to a position in the list 
                            // and request the appropriate icon from the 
                            // google maps website
                            var matches = href.match(this.regExes.kmlIconPalette);
                            if (matches)  {
                                var palette = matches[1];
                                var file_extension = matches[2];

                                var x = this.parseProperty(iconNode, "*", "x");
                                var y = this.parseProperty(iconNode, "*", "y");

                                var posX = x ? x/32 : 0;
                                var posY = y ? (7 - y/32) : 7;

                                var pos = posY * 8 + posX;
                                href = "http://maps.google.com/mapfiles/kml/pal" 
                                     + palette + "/icon" + pos + file_extension;
                            }

                            style["graphicOpacity"] = 1; // fully opaque
                            style["externalGraphic"] = href;
                        }

                    }


                    // hotSpots define the offset for an Icon
                    var hotSpotNode = this.getElementsByTagNameNS(styleTypeNode, 
                                               "*", 
                                               "hotSpot")[0];
                    if (hotSpotNode) {
                        var x = parseFloat(hotSpotNode.getAttribute("x"));
                        var y = parseFloat(hotSpotNode.getAttribute("y"));

                        var xUnits = hotSpotNode.getAttribute("xunits");
                        if (xUnits == "pixels") {
                            style["graphicXOffset"] = -x * scale;
                        }
                        else if (xUnits == "insetPixels") {
                            style["graphicXOffset"] = -width + (x * scale);
                        }
                        else if (xUnits == "fraction") {
                            style["graphicXOffset"] = -width * x;
                        }

                        var yUnits = hotSpotNode.getAttribute("yunits");
                        if (yUnits == "pixels") {
                            style["graphicYOffset"] = -height + (y * scale) + 1;
                        }
                        else if (yUnits == "insetPixels") {
                            style["graphicYOffset"] = -(y * scale) + 1;
                        }
                        else if (yUnits == "fraction") {
                            style["graphicYOffset"] =  -height * (1 - y) + 1;
                        }
                    }

                    style["graphicWidth"] = width;
                    style["graphicHeight"] = height;
                    break;

                case "balloonstyle":
                    var balloonStyle = GeoGlobe.Util.getXmlNodeValue(
                                            styleTypeNode);
                    if (balloonStyle) {
                        style["balloonStyle"] = balloonStyle.replace(
                                       this.regExes.straightBracket, "${$1}");
                    }
                    break;
                case "labelstyle":
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");
                    var color = this.parseKmlColor(kmlColor);
                    if (color) {
                        style["fontColor"] = color.color;
                        style["fontOpacity"] = color.opacity;
                    }
                    break;

                default:
            }
        }

        // Some polygons have no line color, so we use the fillColor for that
        if (!style["strokeColor"] && style["fillColor"]) {
            style["strokeColor"] = style["fillColor"];
        }

        var id = node.getAttribute("id");
        if (id && style) {
            style.id = id;
        }

        return style;
    },

    /**
     * Parses StyleMap nodes, but only uses the 'normal' key
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array} of {DOMElement}nodes    - data to read/parse.
     * @private
     */
    parseStyleMaps: function(nodes, options) {
        // Only the default or "normal" part of the StyleMap is processed now
        // To do the select or "highlight" bit, we'd need to change lots more

        for(var i=0, len=nodes.length; i<len; i++) {
            var node = nodes[i];
            var pairs = this.getElementsByTagNameNS(node, "*", 
                            "Pair");

            var id = node.getAttribute("id");
            for (var j=0, jlen=pairs.length; j<jlen; j++) {
                var pair = pairs[j];
                // Use the shortcut in the SLD format to quickly retrieve the 
                // value of a node. Maybe it's good to have a method in 
                // Format.XML to do this
                var key = this.parseProperty(pair, "*", "key");
                var styleUrl = this.parseProperty(pair, "*", "styleUrl");

                if (styleUrl && key == "normal") {
                    this.styles[(options.styleBaseUrl || "") + "#" + id] =
                        this.styles[(options.styleBaseUrl || "") + styleUrl];
                }

                // TODO: implement the "select" part
                //if (styleUrl && key == "highlight") {
                //}

            }
        }

    },


    /**
     * Loop through all Placemark nodes and parse them.
     * Will create a list of features
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array} of {DOMElement}nodes    - data to read/parse.
     * @param {Object} Hash of options
     * @private
     * 
     */
    parseFeatures: function(nodes, options) {
        var features = [];
        for(var i=0, len=nodes.length; i<len; i++) {
            var featureNode = nodes[i];
            var feature = this.parseFeature.apply(this,[featureNode]) ;
            if(feature) {

                // Create reference to styleUrl 
                if (this.extractStyles && feature.attributes &&
                    feature.attributes.styleUrl) {
                    feature.style = this.getStyle(feature.attributes.styleUrl, options);
                }

                if (this.extractStyles) {
                    // Make sure that <Style> nodes within a placemark are 
                    // processed as well
                    var inlineStyleNode = this.getElementsByTagNameNS(featureNode,
                                                        "*",
                                                        "Style")[0];
                    if (inlineStyleNode) {
                        var inlineStyle= this.parseStyle(inlineStyleNode);
                        if (inlineStyle) {
                            feature.style = GeoGlobe.Util.extend(
                                feature.style, inlineStyle
                            );
                        }
                    }
                }

                // check if gx:Track elements should be parsed
                if (this.extractTracks) {
                    var tracks = this.getElementsByTagNameNS(
                        featureNode, this.namespaces.gx, "Track"
                    );
                    if (tracks && tracks.length > 0) {
                        var track = tracks[0];
                        var container = {
                            features: [],
                            feature: feature
                        };
                        this.readNode(track, container);
                        if (container.features.length > 0) {
                            features.push.apply(features, container.features);
                        }
                    }
                } else {
                    // add feature to list of features
                    features.push(feature);                    
                }
            } else {
                throw "Bad Placemark: " + i;
            }
        }

        // add new features to existing feature list
        this.features = this.features.concat(features);
    },
    
    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @private
     */
    readers: {
        "kml": {
            "when": function(node, container) {
                container.whens.push(GeoGlobe.Date.parse(
                    this.getChildValue(node)
                ));
            },
            "_trackPointAttribute": function(node, container) {
                var name = node.nodeName.split(":").pop();
                container.attributes[name].push(this.getChildValue(node));
            }
        },
        "gx": {
            "Track": function(node, container) {
                var obj = {
                    whens: [],
                    points: [],
                    angles: []
                };
                if (this.trackAttributes) {
                    var name;
                    obj.attributes = {};
                    for (var i=0, ii=this.trackAttributes.length; i<ii; ++i) {
                        name = this.trackAttributes[i];
                        obj.attributes[name] = [];
                        if (!(name in this.readers.kml)) {
                            this.readers.kml[name] = this.readers.kml._trackPointAttribute;
                        }
                    }
                }
                this.readChildNodes(node, obj);
                if (obj.whens.length !== obj.points.length) {
                    throw new Error("gx:Track with unequal number of when (" +
                                    obj.whens.length + ") and gx:coord (" +
                                    obj.points.length + ") elements.");
                }
                var hasAngles = obj.angles.length > 0;
                if (hasAngles && obj.whens.length !== obj.angles.length) {
                    throw new Error("gx:Track with unequal number of when (" +
                                    obj.whens.length + ") and gx:angles (" +
                                    obj.angles.length + ") elements.");
                }
                var feature, point, angles;
                for (var i=0, ii=obj.whens.length; i<ii; ++i) {
                    feature = container.feature.clone();
                    feature.fid = container.feature.fid || container.feature.id;
                    point = obj.points[i];
                    feature.geometry = point;
                    if ("z" in point) {
                        feature.attributes.altitude = point.z;
                    }
                    if (this.internalProjection && this.externalProjection) {
                        feature.geometry.transform(
                            this.externalProjection, this.internalProjection
                        ); 
                    }
                    if (this.trackAttributes) {
                        for (var j=0, jj=this.trackAttributes.length; j<jj; ++j) {
                            var name = this.trackAttributes[j];
                            feature.attributes[name] = obj.attributes[name][i];
                        }
                    }
                    feature.attributes.when = obj.whens[i];
                    feature.attributes.trackId = container.feature.id;
                    if (hasAngles) {
                        angles = obj.angles[i];
                        feature.attributes.heading = parseFloat(angles[0]);
                        feature.attributes.tilt = parseFloat(angles[1]);
                        feature.attributes.roll = parseFloat(angles[2]);
                    }
                    container.features.push(feature);
                }
            },
            "coord": function(node, container) {
                var str = this.getChildValue(node);
                var coords = str.replace(this.regExes.trimSpace, "").split(/\s+/);
                var point = new GeoGlobe.Geometry.Point(coords[0], coords[1]);
                if (coords.length > 2) {
                    point.z = parseFloat(coords[2]);
                }
                container.points.push(point);
            },
            "angles": function(node, container) {
                var str = this.getChildValue(node);
                var parts = str.replace(this.regExes.trimSpace, "").split(/\s+/);
                container.angles.push(parts);
            }
        }
    },
    
    /**、
     * This function is the core of the KML parsing code in GeoGlobe.
     *     It creates the geometries that are then attached to the returned
     *     feature, and calls parseAttributes() to get attribute data out.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {DOMElement}node
     * @returns {GeoGlobe.Feature} A vector feature.
     * @private
     */
    parseFeature: function(node) {
        // only accept one geometry per feature - look for highest "order"
        var order = ["MultiGeometry", "Polygon", "LineString", "Point"];
        var type, nodeList, geometry, parser;
        for(var i=0, len=order.length; i<len; ++i) {
            type = order[i];
            this.internalns = node.namespaceURI ? 
                    node.namespaceURI : this.kmlns;
            nodeList = this.getElementsByTagNameNS(node, 
                                                   this.internalns, type);
            if(nodeList.length > 0) {
                // only deal with first geometry of this type
                var parser = this.parseGeometry[type.toLowerCase()];
                if(parser) {
                    geometry = parser.apply(this, [nodeList[0]]);
                    if (this.internalProjection && this.externalProjection) {
                        geometry.transform(this.externalProjection, 
                                           this.internalProjection); 
                    }                       
                } else {
                    throw new TypeError("Unsupported geometry type: " + type);
                }
                // stop looking for different geometry types
                break;
            }
        }

        // construct feature (optionally with attributes)
        var attributes;
        if(this.extractAttributes) {
            attributes = this.parseAttributes(node);
        }
        var feature = new GeoGlobe.Feature(geometry, attributes);

        var fid = node.getAttribute("id") || node.getAttribute("name");
        if(fid != null) {
            feature.fid = fid;
        }

        return feature;
    },        
    
    /**
     * Retrieves a style from a style hash using styleUrl as the key
     * If the styleUrl doesn't exist yet, we try to fetch it
     * Internet
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @returns {Object}  - (reference to) Style hash
     * @private
     */
    getStyle: function(styleUrl, options) {

        var styleBaseUrl = GeoGlobe.Util.removeTail(styleUrl);

        var newOptions = GeoGlobe.Util.extend({}, options);
        newOptions.depth++;
        newOptions.styleBaseUrl = styleBaseUrl;

        // Fetch remote Style URLs (if not fetched before) 
        if (!this.styles[styleUrl] 
                && !GeoGlobe.String.startsWith(styleUrl, "#") 
                && newOptions.depth <= this.maxDepth
                && !this.fetched[styleBaseUrl] ) {

            var data = this.fetchLink(styleBaseUrl);
            if (data) {
                this.parseData(data, newOptions);
            }

        }

        // return requested style
        var style = GeoGlobe.Util.extend({}, this.styles[styleUrl]);
        return style;
    },
    
    /**
     *  Properties of this object are the functions that parse geometries based
     *     on their type.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @private
     */
    parseGeometry: {
        
        /**
         * Given a KML node representing a point geometry, create an GeoGlobe
         *     point geometry.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {DOMElement} node - A KML Polygon node.
         * @returns {GeoGlobe.Geometry.Point} A point geometry.
         * @private
         */
        point: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "coordinates");
            var coords = [];
            if(nodeList.length > 0) {
                var coordString = nodeList[0].firstChild.nodeValue;
                coordString = coordString.replace(this.regExes.removeSpace, "");
                coords = coordString.split(",");
            }

            var point = null;
            if(coords.length > 1) {
                // preserve third dimension
                if(coords.length == 2) {
                    coords[2] = null;
                }
                point = new GeoGlobe.Geometry.Point(coords[0], coords[1],
                                                      coords[2]);
            } else {
                throw "Bad coordinate string: " + coordString;
            }
            return point;
        },
        
        /**
         * Given a KML node representing a linestring geometry, create an
         *     GeoGlobe linestring geometry.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {DOMElement}node - A KML Polygon node.
         * @returns {GeoGlobe.Geometry.LineString} A linestring geometry.
         * @private
         */
        linestring: function(node, ring) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "coordinates");
            var line = null;
            if(nodeList.length > 0) {
                var coordString = this.getChildValue(nodeList[0]);

                coordString = coordString.replace(this.regExes.trimSpace,
                                                  "");
                coordString = coordString.replace(this.regExes.trimComma,
                                                  ",");
                var pointList = coordString.split(this.regExes.splitSpace);
                var numPoints = pointList.length;
                var points = new Array(numPoints);
                var coords, numCoords;
                for(var i=0; i<numPoints; ++i) {
                    coords = pointList[i].split(",");
                    numCoords = coords.length;
                    if(numCoords > 1) {
                        if(coords.length == 2) {
                            coords[2] = null;
                        }
                        points[i] = new GeoGlobe.Geometry.Point(coords[0],
                                                                  coords[1],
                                                                  coords[2]);
                    } else {
                        throw "Bad LineString point coordinates: " +
                              pointList[i];
                    }
                }
                if(numPoints) {
                    if(ring) {
                        line = new GeoGlobe.Geometry.LinearRing(points);
                    } else {
                        line = new GeoGlobe.Geometry.LineString(points);
                    }
                } else {
                    throw "Bad LineString coordinates: " + coordString;
                }
            }

            return line;
        },
        
        /**
         *  Given a KML node representing a polygon geometry, create an
         *     GeoGlobe polygon geometry.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {DOMElement}node - A KML Polygon node.
         *
         * @returns {GeoGlobe.Geometry.Polygon} A polygon geometry.
         * @private
         */
        polygon: function(node) {
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,
                                                       "LinearRing");
            var numRings = nodeList.length;
            var components = new Array(numRings);
            if(numRings > 0) {
                // this assumes exterior ring first, inner rings after
                var ring;
                for(var i=0, len=nodeList.length; i<len; ++i) {
                    ring = this.parseGeometry.linestring.apply(this,
                                                        [nodeList[i], true]);
                    if(ring) {
                        components[i] = ring;
                    } else {
                        throw "Bad LinearRing geometry: " + i;
                    }
                }
            }
            return new GeoGlobe.Geometry.Polygon(components);
        },
        
        /**
         *  Given a KML node representing a multigeometry, create an
         *     GeoGlobe geometry collection.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * Parameters:
         * @param {DOMElement}node - A KML MultiGeometry node.
         *
         * @returns {GeoGlobe.Geometry.Collection} A geometry collection.
         * @private
         */
        multigeometry: function(node) {
            var child, parser;
            var parts = [];
            var children = node.childNodes;
            for(var i=0, len=children.length; i<len; ++i ) {
                child = children[i];
                if(child.nodeType == 1) {
                    var type = (child.prefix) ?
                            child.nodeName.split(":")[1] :
                            child.nodeName;
                    var parser = this.parseGeometry[type.toLowerCase()];
                    if(parser) {
                        parts.push(parser.apply(this, [child]));
                    }
                }
            }
            return new GeoGlobe.Geometry.Collection(parts);
        }
        
    },

    /**
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @returns {Object} An attributes object.
     * @private
     */
    parseAttributes: function(node) {
        var attributes = {};
       
        // Extended Data is parsed first.
        var edNodes = node.getElementsByTagName("ExtendedData");
        if (edNodes.length) {
            attributes = this.parseExtendedData(edNodes[0]);
        }
        
        // assume attribute nodes are type 1 children with a type 3 or 4 child
        var child, grandchildren, grandchild;
        var children = node.childNodes;

        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                grandchildren = child.childNodes;
                if(grandchildren.length >= 1 && grandchildren.length <= 3) {
                    var grandchild;
                    switch (grandchildren.length) {
                        case 1:
                            grandchild = grandchildren[0];
                            break;
                        case 2:
                            var c1 = grandchildren[0];
                            var c2 = grandchildren[1];
                            grandchild = (c1.nodeType == 3 || c1.nodeType == 4) ?
                                c1 : c2;
                            break;
                        case 3:
                        default:
                            grandchild = grandchildren[1];
                            break;
                    }
                    if(grandchild.nodeType == 3 || grandchild.nodeType == 4) {
                        var name = (child.prefix) ?
                                child.nodeName.split(":")[1] :
                                child.nodeName;
                        var value = GeoGlobe.Util.getXmlNodeValue(grandchild);
                        if (value) {
                            value = value.replace(this.regExes.trimSpace, "");
                            attributes[name] = value;
                        }
                    }
                } 
            }
        }
        return attributes;
    },

    /**
     * Parse ExtendedData from KML. Limited support for schemas/datatypes.
     *     See http://code.google.com/apis/kml/documentation/kmlreference.html#extendeddata
     *     for more information on extendeddata.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @private
     */
    parseExtendedData: function(node) {
        var attributes = {};
        var i, len, data, key;
        var dataNodes = node.getElementsByTagName("Data");
        for (i = 0, len = dataNodes.length; i < len; i++) {
            data = dataNodes[i];
            key = data.getAttribute("name");
            var ed = {};
            var valueNode = data.getElementsByTagName("value");
            if (valueNode.length) {
                ed['value'] = this.getChildValue(valueNode[0]);
            }
            if (this.kvpAttributes) {
                attributes[key] = ed['value'];
            } else {
                var nameNode = data.getElementsByTagName("displayName");
                if (nameNode.length) {
                    ed['displayName'] = this.getChildValue(nameNode[0]);
                }
                attributes[key] = ed;
            } 
        }
        var simpleDataNodes = node.getElementsByTagName("SimpleData");
        for (i = 0, len = simpleDataNodes.length; i < len; i++) {
            var ed = {};
            data = simpleDataNodes[i];
            key = data.getAttribute("name");
            ed['value'] = this.getChildValue(data);
            if (this.kvpAttributes) {
                attributes[key] = ed['value'];
            } else {
                ed['displayName'] = key;
                attributes[key] = ed;
            }
        }
        
        return attributes;    
    },
    
    /**
     * Convenience method to find a node and return its value
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {DOMElement} xmlNode
     * @param {String} namespace  - namespace of the node to find
     * @param {String} tagName  -name of the property to parse
     * @returns {String} The value for the requested property (defaults to null)
     * @private
     */    
    parseProperty: function(xmlNode, namespace, tagName) {
        var value;
        var nodeList = this.getElementsByTagNameNS(xmlNode, namespace, tagName);
        try {
            value = GeoGlobe.Util.getXmlNodeValue(nodeList[0]);
        } catch(e) {
            value = null;
        }
     
        return value;
    },                                                              

    /**
     *  接受Feature Collection，并返回一个字符串。
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Array(GeoGlobe.Feature)} features - 要素数组。
     * @returns {String} 一个KML字符串。
     */
    write: function(features) {
        if(!(GeoGlobe.Util.isArray(features))) {
            features = [features];
        }
        var kml = this.createElementNS(this.kmlns, "kml");
        var folder = this.createFolderXML();
        for(var i=0, len=features.length; i<len; ++i) {
            folder.appendChild(this.createPlacemarkXML(features[i]));
        }
        kml.appendChild(folder);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [kml]);
    },

    /**
     * Creates and returns a KML folder node
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @returns {DOMElement}
     * @private
     */
    createFolderXML: function() {
        // Folder
        var folder = this.createElementNS(this.kmlns, "Folder");

        // Folder name
        if (this.foldersName) {
            var folderName = this.createElementNS(this.kmlns, "name");
            var folderNameText = this.createTextNode(this.foldersName); 
            folderName.appendChild(folderNameText);
            folder.appendChild(folderName);
        }

        // Folder description
        if (this.foldersDesc) {
            var folderDesc = this.createElementNS(this.kmlns, "description");        
            var folderDescText = this.createTextNode(this.foldersDesc); 
            folderDesc.appendChild(folderDescText);
            folder.appendChild(folderDesc);
        }

        return folder;
    },

    /**
     * Creates and returns a KML placemark node representing the given feature.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {GeoGlobe.Feature}feature -
     * @returns {DOMElement}
     * @private
     */
    createPlacemarkXML: function(feature) {        
        // Placemark name
        var placemarkName = this.createElementNS(this.kmlns, "name");
        var label = (feature.style && feature.style.label) ? feature.style.label : feature.id;
        var name = feature.attributes.name || label;
        placemarkName.appendChild(this.createTextNode(name));

        // Placemark description
        var placemarkDesc = this.createElementNS(this.kmlns, "description");
        var desc = feature.attributes.description || this.placemarksDesc;
        placemarkDesc.appendChild(this.createTextNode(desc));
        
        // Placemark
        var placemarkNode = this.createElementNS(this.kmlns, "Placemark");
        if(feature.fid != null) {
            placemarkNode.setAttribute("id", feature.fid);
        }
        placemarkNode.appendChild(placemarkName);
        placemarkNode.appendChild(placemarkDesc);

        // Geometry node (Point, LineString, etc. nodes)
        var geometryNode = this.buildGeometryNode(feature.geometry);
        placemarkNode.appendChild(geometryNode);        
        
        // output attributes as extendedData
        if (feature.attributes) {
            var edNode = this.buildExtendedData(feature.attributes);
            if (edNode) {
                placemarkNode.appendChild(edNode);
            }
        }
        
        return placemarkNode;
    },    

    /**
     * Builds and returns a KML geometry node with the given geometry.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {GeoGlobe.Geometry}geometry -
     * @returns {DOMElement}
     * @private
     */
    buildGeometryNode: function(geometry) {
        var className = geometry.CLASS_NAME;
        var type = className.substring(className.lastIndexOf(".") + 1);
        var builder = this.buildGeometry[type.toLowerCase()];
        var node = null;
        if(builder) {
            node = builder.apply(this, [geometry]);
        }
        return node;
    },

    /**
     * Object containing methods to do the actual geometry node building
     *     based on geometry type.
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @type {null}
     * @private
     */
    buildGeometry: {
        // TBD: Anybody care about namespace aliases here (these nodes have
        //    no prefixes)?

        /**
         * Given an GeoGlobe point geometry, create a KML point.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.LineString}geometry -  A linestring geometry.
         * @returns {DOMElement} A KML linestring node.
         * @private
         */
        point: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "Point");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Given an GeoGlobe multipoint geometry, create a KML
         *     GeometryCollection.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.LineString}geometry -  A linestring geometry.
         * @returns {DOMElement} A KML linestring node.
         * @private
         */
        multipoint: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Given an GeoGlobe linestring geometry, create a KML linestring.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.LineString}geometry -  A linestring geometry.
         * @returns {DOMElement} A KML linestring node.
         * @private
         */
        linestring: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "LineString");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Given an GeoGlobe multilinestring geometry, create a KML
         *     GeometryCollection.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.Point}geometry - A multilinestring geometry.
         * @returns {DOMElement} A KML GeometryCollection node.
         * @private
         */
        multilinestring: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         * Given an GeoGlobe linearring geometry, create a KML linearring.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.LinearRing}geometry - A linearring geometry.
         * @returns {DOMElement} A KML linearring node.
         * @private
         */
        linearring: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "LinearRing");
            kml.appendChild(this.buildCoordinatesNode(geometry));
            return kml;
        },
        
        /**
         * Given an GeoGlobe polygon geometry, create a KML polygon.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.Polygon} geometry -A polygon geometry.
         * @returns {DOMElement} A KML polygon node.
         * @private
         */
        polygon: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "Polygon");
            var rings = geometry.components;
            var ringMember, ringGeom, type;
            for(var i=0, len=rings.length; i<len; ++i) {
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";
                ringMember = this.createElementNS(this.kmlns, type);
                ringGeom = this.buildGeometry.linearring.apply(this,
                                                               [rings[i]]);
                ringMember.appendChild(ringGeom);
                kml.appendChild(ringMember);
            }
            return kml;
        },
        
        /**
         * Given an GeoGlobe multipolygon geometry, create a KML
         *     GeometryCollection.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.Point}geometry - A multipolygon geometry.
         * @returns {DOMElement} A KML GeometryCollection node.
         * @private
         */
        multipolygon: function(geometry) {
            return this.buildGeometry.collection.apply(this, [geometry]);
        },

        /**
         *  Given an GeoGlobe geometry collection, create a KML MultiGeometry.
         * @memberof GeoGlobe.Format.KMLs.prototype
         * @param {GeoGlobe.Geometry.Collection}geometry - A geometry collection.
         * @returns {DOMElement} A KML MultiGeometry node.
         * @private
         */
        collection: function(geometry) {
            var kml = this.createElementNS(this.kmlns, "MultiGeometry");
            var child;
            for(var i=0, len=geometry.components.length; i<len; ++i) {
                child = this.buildGeometryNode.apply(this,
                                                     [geometry.components[i]]);
                if(child) {
                    kml.appendChild(child);
                }
            }
            return kml;
        }
    },

    /**
     * Builds and returns the KML coordinates node with the given geometry
     * coordinates.../coordinates
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {GeoGlobe.Geometry}geometry -
     * @returns {DOMElement}
     * @private
     */     
    buildCoordinatesNode: function(geometry) {
        var coordinatesNode = this.createElementNS(this.kmlns, "coordinates");
        
        var path;
        var points = geometry.components;
        if(points) {
            // LineString or LinearRing
            var point;
            var numPoints = points.length;
            var parts = new Array(numPoints);
            for(var i=0; i<numPoints; ++i) {
                point = points[i];
                parts[i] = this.buildCoordinates(point);
            }
            path = parts.join(" ");
        } else {
            // Point
            path = this.buildCoordinates(geometry);
        }
        
        var txtNode = this.createTextNode(path);
        coordinatesNode.appendChild(txtNode);
        
        return coordinatesNode;
    },    
    
    /**
     *  buildCoordinates
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {GeoGlobe.Geometry.Point}point -
     * @returns {String} a coordinate pair
     * @private
     */
    buildCoordinates: function(point) {
        if (this.internalProjection && this.externalProjection) {
            point = point.clone();
            point.transform(this.internalProjection, 
                               this.externalProjection);
        }
        return point.x + "," + point.y;                     
    },

    /**
     * buildExtendedData
     * @memberof GeoGlobe.Format.KMLs.prototype
     * @param {Object}attributes -
     * @returns {DOMElement} A KML ExtendedData node or {null} if no attributes.‘
     * @private
     */
    buildExtendedData: function(attributes) {
        var extendedData = this.createElementNS(this.kmlns, "ExtendedData");
        for (var attributeName in attributes) {
            // empty, name, description, styleUrl attributes ignored
            if (attributes[attributeName] && attributeName != "name" && attributeName != "description" && attributeName != "styleUrl") {
                var data = this.createElementNS(this.kmlns, "Data");
                data.setAttribute("name", attributeName);
                var value = this.createElementNS(this.kmlns, "value");
                if (typeof attributes[attributeName] == "object") {
                    // cater for object attributes with 'value' properties
                    // other object properties will output an empty node
                    if (attributes[attributeName].value) {
                        value.appendChild(this.createTextNode(attributes[attributeName].value));
                    }
                    if (attributes[attributeName].displayName) {
                        var displayName = this.createElementNS(this.kmlns, "displayName");
                        // displayName always written as CDATA
                        displayName.appendChild(this.getXMLDoc().createCDATASection(attributes[attributeName].displayName));
                        data.appendChild(displayName);
                    }
                } else {
                    value.appendChild(this.createTextNode(attributes[attributeName]));
                }
                data.appendChild(value);
                extendedData.appendChild(data);
            }
        }
        if (this.isSimpleContent(extendedData)) {
            return null;
        } else {
            return extendedData;
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.KML" 
});
/**
 * @class GeoGlobe.Format.OWSCommon
 * @classdesc  阅读OWSCommon。 使用GeoGlobe.Format.OWSCommon构造函数创建一个新实例。
 * @private
 */
GeoGlobe.Format.OWSCommon = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     *defaultVersion-如果没有找到版本号， 默认值是“1.0.0”。
     * @memberof GeoGlobe.Format.OWSCommon.prototype
     * @type {String}
     */
    defaultVersion: "1.0.0",
    
    /**
     *  为OWSCommon创建一个新的解析器。
     * @classdesc OpenLayers.Format.OWSCommon
     * @param {Object}options -  An optional object whose properties will be set on
     *     this instance.
     */

    /**
     *  Returns the version to use. Subclasses can override this function
     * if a different version detection is needed.
     * @memberof GeoGlobe.Format.OWSCommon.prototype
     * @param {String | DOMElement} data -Data to read.
     * @param {Object}options -  Options for the reader.
     * @returns {String} The version to use.
     * @private
     */
    getVersion: function(root, options) {
        var version = this.version;
        if(!version) {
            // remember version does not correspond to the OWS version
            // it corresponds to the WMS/WFS/WCS etc. request version
            var uri = root.getAttribute("xmlns:ows");
            // the above will fail if the namespace prefix is different than
            // ows and if the namespace is declared on a different element
            if (uri && uri.substring(uri.lastIndexOf("/")+1) === "1.1") {
                version ="1.1.0";
            } 
            if(!version) {
                version = this.defaultVersion;
            }
        }
        return version;
    },

    /**
     * 阅读OWSCommon文档并返回一个对象。
     * @memberof GeoGlobe.Format.OWSCommon.prototype
     * @param {String | DOMElement} data -可读取的数据。
     * @param {Object}options -  可选项。
     * @returns {Object} 代表文档结构的对象。
     */

    CLASS_NAME: "GeoGlobe.Format.OWSCommon" 
});
/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Format.OWSCommon.v1
 * @classdesc Common readers and writers for OWSCommon v1.X formats,Inherits from GeoGlobe.Format.XML
 * @private
 */
GeoGlobe.Format.OWSCommon.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
   
    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.OWSCommon.v1.prototype
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * @memberof GeoGlobe.Format.OWSCommon.v1.prototype
     *
     * @param  {DOMElement}data - An OWSCommon document element.
     * @param {Object}  options -Options for the reader.
     *
     * @returns {Object}  - An object representing the OWSCommon document.
     * @private
     */
    read: function(data, options) {
        options = GeoGlobe.Util.applyDefaults(options, this.options);
        var ows = {};
        this.readChildNodes(data, ows);
        return ows;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.OWSCommon.v1.prototype
     * @private
     */
    readers: {
        "ows": {
            "Exception": function(node, exceptionReport) {
                var exception = {
                    code: node.getAttribute('exceptionCode'),
                    locator: node.getAttribute('locator'),
                    texts: []
                };
                exceptionReport.exceptions.push(exception);
                this.readChildNodes(node, exception);
            },
            "ExceptionText": function(node, exception) {
                var text = this.getChildValue(node);
                exception.texts.push(text);
            },
            "ServiceIdentification": function(node, obj) {
                obj.serviceIdentification = {};
                this.readChildNodes(node, obj.serviceIdentification);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, serviceIdentification) {
                serviceIdentification["abstract"] = this.getChildValue(node);
            },
            "Keywords": function(node, serviceIdentification) {
                serviceIdentification.keywords = {};
                this.readChildNodes(node, serviceIdentification.keywords);
            },
            "Keyword": function(node, keywords) {
                keywords[this.getChildValue(node)] = true;
            },
            "ServiceType": function(node, serviceIdentification) {
                serviceIdentification.serviceType = {
                    codeSpace: node.getAttribute('codeSpace'), 
                    value: this.getChildValue(node)};
            },
            "ServiceTypeVersion": function(node, serviceIdentification) {
                serviceIdentification.serviceTypeVersion = this.getChildValue(node);
            },
            "Fees": function(node, serviceIdentification) {
                serviceIdentification.fees = this.getChildValue(node);
            },
            "AccessConstraints": function(node, serviceIdentification) {
                serviceIdentification.accessConstraints = 
                    this.getChildValue(node);
            },
            "ServiceProvider": function(node, obj) {
                obj.serviceProvider = {};
                this.readChildNodes(node, obj.serviceProvider);
            },
            "ProviderName": function(node, serviceProvider) {
                serviceProvider.providerName = this.getChildValue(node);
            },
            "ProviderSite": function(node, serviceProvider) {
                serviceProvider.providerSite = this.getAttributeNS(node, 
                    this.namespaces.xlink, "href");
            },
            "ServiceContact": function(node, serviceProvider) {
                serviceProvider.serviceContact = {};
                this.readChildNodes(node, serviceProvider.serviceContact);
            },
            "IndividualName": function(node, serviceContact) {
                serviceContact.individualName = this.getChildValue(node);
            },
            "PositionName": function(node, serviceContact) {
                serviceContact.positionName = this.getChildValue(node);
            },
            "ContactInfo": function(node, serviceContact) {
                serviceContact.contactInfo = {};
                this.readChildNodes(node, serviceContact.contactInfo);
            },
            "Phone": function(node, contactInfo) {
                contactInfo.phone = {};
                this.readChildNodes(node, contactInfo.phone);
            },
            "Voice": function(node, phone) {
                phone.voice = this.getChildValue(node);
            },
            "Address": function(node, contactInfo) {
                contactInfo.address = {};
                this.readChildNodes(node, contactInfo.address);
            },
            "DeliveryPoint": function(node, address) {
                address.deliveryPoint = this.getChildValue(node);
            },
            "City": function(node, address) {
                address.city = this.getChildValue(node);
            },
            "AdministrativeArea": function(node, address) {
                address.administrativeArea = this.getChildValue(node);
            },
            "PostalCode": function(node, address) {
                address.postalCode = this.getChildValue(node);
            },
            "Country": function(node, address) {
                address.country = this.getChildValue(node);
            },
            "ElectronicMailAddress": function(node, address) {
                address.electronicMailAddress = this.getChildValue(node);
            },
            "Role": function(node, serviceContact) {
                serviceContact.role = this.getChildValue(node);
            },
            "OperationsMetadata": function(node, obj) {
                obj.operationsMetadata = {};
                this.readChildNodes(node, obj.operationsMetadata);
            },
            "Operation": function(node, operationsMetadata) {
                var name = node.getAttribute("name");
                operationsMetadata[name] = {};
                this.readChildNodes(node, operationsMetadata[name]);
            },
            "DCP": function(node, operation) {
                operation.dcp = {};
                this.readChildNodes(node, operation.dcp);
            },
            "HTTP": function(node, dcp) {
                dcp.http = {};
                this.readChildNodes(node, dcp.http);
            },
            "Get": function(node, http) {
                if (!http.get) {
                    http.get = [];
                }
                var obj = {
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")
                };
                this.readChildNodes(node, obj);
                http.get.push(obj);
            },
            "Post": function(node, http) {
                if (!http.post) {
                    http.post = [];
                }
                var obj = {
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")
                };
                this.readChildNodes(node, obj);
                http.post.push(obj);
            },
            "Parameter": function(node, operation) {
                if (!operation.parameters) {
                    operation.parameters = {};
                }
                var name = node.getAttribute("name");
                operation.parameters[name] = {};
                this.readChildNodes(node, operation.parameters[name]);
            },
            "Constraint": function(node, obj) {
                if (!obj.constraints) {
                    obj.constraints = {};
                }
                var name = node.getAttribute("name");
                obj.constraints[name] = {};
                this.readChildNodes(node, obj.constraints[name]);
            },
            "Value": function(node, allowedValues) {
                allowedValues[this.getChildValue(node)] = true;
            },
            "OutputFormat": function(node, obj) {
                obj.formats.push({value: this.getChildValue(node)});
                this.readChildNodes(node, obj);
            },
            "WGS84BoundingBox": function(node, obj) {
                var boundingBox = {};
                boundingBox.crs = node.getAttribute("crs");
                if (obj.BoundingBox) {
                    obj.BoundingBox.push(boundingBox);
                } else {
                    obj.projection = boundingBox.crs;
                    boundingBox = obj;
               }
               this.readChildNodes(node, boundingBox);
            },
            "BoundingBox": function(node, obj) {
                // FIXME: We consider that BoundingBox is the same as WGS84BoundingBox
                // LowerCorner = "min_x min_y"
                // UpperCorner = "max_x max_y"
                // It should normally depend on the projection
                this.readers['ows']['WGS84BoundingBox'].apply(this, [node, obj]);
            },
            "LowerCorner": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, "");
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
                var str = this.getChildValue(node).replace(
                    this.regExes.trimSpace, "");
                str = str.replace(this.regExes.trimComma, ",");
                var pointList = str.split(this.regExes.splitSpace);
                obj.right = pointList[0];
                obj.top = pointList[1];
                //obj.bounds = new GeoGlobe.Bounds(obj.left, obj.bottom,obj.right, obj.top);
                obj.bounds = new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(obj.left, obj.bottom),new GeoGlobe.LngLat(obj.right, obj.top));
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
            "Language": function(node, obj) {
                obj.language = this.getChildValue(node);
            }
        }
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.OWSCommon.v1.prototype
     * @private
     */
    writers: {
        "ows": {
            "BoundingBox": function(options, nodeName) {
                var node = this.createElementNSPlus(nodeName || "ows:BoundingBox", {
                    attributes: {
                        crs: options.projection
                    }
                });
                this.writeNode("ows:LowerCorner", options, node);
                this.writeNode("ows:UpperCorner", options, node);
                return node;
            },
            "LowerCorner": function(options) {
                var node = this.createElementNSPlus("ows:LowerCorner", {
                    //value: options.bounds.left + " " + options.bounds.bottom });
                    value: options.bounds._sw.lng + " " + options.bounds._sw.lat });
                return node;
            },
            "UpperCorner": function(options) {
                var node = this.createElementNSPlus("ows:UpperCorner", {
                    //value: options.bounds.right + " " + options.bounds.top });
                    value: options.bounds._ne.lng + " " + options.bounds._ne.lat });
                return node;
            },
            "Identifier": function(identifier) {
                var node = this.createElementNSPlus("ows:Identifier", {
                    value: identifier });
                return node;
            },
            "Title": function(title) {
                var node = this.createElementNSPlus("ows:Title", {
                    value: title });
                return node;
            },
            "Abstract": function(abstractValue) {
                var node = this.createElementNSPlus("ows:Abstract", {
                    value: abstractValue });
                return node;
            },
            "OutputFormat": function(format) {
                var node = this.createElementNSPlus("ows:OutputFormat", {
                    value: format });
                return node;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1"

});
/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Format.OWSCommon.v1_0_0
 * @classdesc 解析器的OWS通用版本1.0.0。,Inherits from:GeoGlobe.Format.OWSCommon.v1
 * @private
 */

GeoGlobe.Format.OWSCommon.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1, {
    
    /**
     * Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.OWSCommon.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.OWSCommon.v1_0_0.prototype
     * @private
     */
    readers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "ExceptionReport": function(node, obj) {
                obj.success = false;
                obj.exceptionReport = {
                    version: node.getAttribute('version'),
                    language: node.getAttribute('language'),
                    exceptions: []
                };
                this.readChildNodes(node, obj.exceptionReport);
            } 
        }, GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows)
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.OWSCommon.v1_0_0.prototype
     * @private
     */
    writers: {
        "ows": GeoGlobe.Format.OWSCommon.v1.prototype.writers.ows
    },
    
    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1_0_0"

});
/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @class GeoGlobe.Format.OWSCommon.v1_1_0
 * @classdesc OWS Common Edition 1.1.0的解析器。
 * @private
 *
 */
GeoGlobe.Format.OWSCommon.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1, {

    /**
     * Mapping of namespace aliases to namespace URIs.Inherits from:GeoGlobe.Format.OWSCommon.v1
     * @memberof GeoGlobe.Format.OWSCommon.v1_1_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.OWSCommon.v1_1_0.prototype
     * @private
     */
    readers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "ExceptionReport": function(node, obj) {
                obj.exceptionReport = {
                    version: node.getAttribute('version'),
                    language: node.getAttribute('xml:lang'),
                    exceptions: []
                };
                this.readChildNodes(node, obj.exceptionReport);
            },
            "AllowedValues": function(node, parameter) {
                parameter.allowedValues = {};
                this.readChildNodes(node, parameter.allowedValues);
            },
            "AnyValue": function(node, parameter) {
                parameter.anyValue = true;
            },
            "DataType": function(node, parameter) {
                parameter.dataType = this.getChildValue(node);
            },
            "Range": function(node, allowedValues) {
                allowedValues.range = {};
                this.readChildNodes(node, allowedValues.range);
            },
            "MinimumValue": function(node, range) {
                range.minValue = this.getChildValue(node);
            },
            "MaximumValue": function(node, range) {
                range.maxValue = this.getChildValue(node);
            },
            "Identifier": function(node, obj) {
                obj.identifier = this.getChildValue(node);
            },
            "SupportedCRS": function(node, obj) {
                obj.supportedCRS = this.getChildValue(node);
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.readers["ows"])
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.OWSCommon.v1_1_0.prototype
     * @private
     */
    writers: {
        "ows": GeoGlobe.Util.applyDefaults({
            "Range": function(range) {
                var node = this.createElementNSPlus("ows:Range", {
                    attributes: {
                        'ows:rangeClosure': range.closure
                    }
                });
                this.writeNode("ows:MinimumValue", range.minValue, node);
                this.writeNode("ows:MaximumValue", range.maxValue, node);
                return node;
            },
            "MinimumValue": function(minValue) {
                var node = this.createElementNSPlus("ows:MinimumValue", {
                    value: minValue
                });
                return node;
            },
            "MaximumValue": function(maxValue) {
                var node = this.createElementNSPlus("ows:MaximumValue", {
                    value: maxValue
                });
                return node;
            },
            "Value": function(value) {
                var node = this.createElementNSPlus("ows:Value", {
                    value: value
                });
                return node;
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.writers["ows"])
    },

    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1_1_0"

});
/**
 * @class  GeoGlobe.Format.WFSCapabilities
 * @classdesc  网络要素服务获取服务信息操作格式化解析类。将XML格式的网络要素服务能力描述信息解析成JavaScript对象。
 * @returns {Array} 图层列表。
 */
GeoGlobe.Format.WFSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * 默认版本号-如果没有找到版本号， 默认值是“1.1.0”。
     * @memberof  GeoGlobe.Format.WFSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.1.0",

    /**
     *  为web要素服务功能创建一个新的解析器。
     * @memberof  GeoGlobe.Format.WFSCapabilities.prototype
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 读取功能数据，并返回一个图层列表。
     * @memberof  GeoGlobe.Format.WFSCapabilities.prototype
     * @param {String | DOMElement}   data - 数据读取/解析。
     */    
    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities" 
});
/**
 * @class  GeoGlobe.Format.WFSCapabilities.v1
 * @classdesc 抽象类，不能直接实例化，应实例化其子类。
 * 
 */

GeoGlobe.Format.WFSCapabilities.v1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        wfs: "http://www.opengis.net/wfs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        ows: "http://www.opengis.net/ows"
    },


    /**
     * 为了确定解析是否失败而要检查的返回对象的哪个属性。
     * 如果返回的对象上的errorProperty未定义。
     * 则文档将通过OGCExceptionReport解析器运行。
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @type {String}
     */
    errorProperty: "featureTypeList",

    /**
     * defaultPrefix
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @type {null}
     * @private
     */
    defaultPrefix: "wfs",
    
    /**
     * 创建其中一个子类的实例。
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @classdesc GeoGlobe.Format.WFSCapabilities.v1_1
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 从字符串读取功能数据，并返回一个图层列表。
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @param {String| DOMElement} data - 数据读取/解析。
     * @returns {Array} 命名图层列表。
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WFSCapabilities.v1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wfs": {
            "WFS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "FeatureTypeList": function(node, request) {
                request.featureTypeList = {
                    featureTypes: []
                };
                this.readChildNodes(node, request.featureTypeList);
            },
            "FeatureType": function(node, featureTypeList) {
                var featureType = {};
                this.readChildNodes(node, featureType);
                featureTypeList.featureTypes.push(featureType);
            },
            "Name": function(node, obj) {
                var name = this.getChildValue(node);
                if(name) {
                    var parts = name.split(":");
                    obj.name = parts.pop();
                    if(parts.length > 0) {
                        obj.featureNS = this.lookupNamespaceURI(node, parts[0]);
                    }
                }
            },
            "Title": function(node, obj) {
                var title = this.getChildValue(node);
                if(title) {
                    obj.title = title;
                }
            },
            "Abstract": function(node, obj) {
                var abst = this.getChildValue(node);
                if(abst) {
                    obj["abstract"] = abst;
                }
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1" 

});
/**
 * @class  GeoGlobe.Format.WFSCapabilities/v1_0_0
 * @classdesc  Read WFS Capabilities version 1.0.0.
 * WFS服务 1.0.0版本的GetCapabilities操作格式化类。
 * @private
 */


GeoGlobe.Format.WFSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WFSCapabilities.v1, {
    
    /**
     * 为WFS功能版本1.0.0创建一个新的解析器。
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "Service": function(node, capabilities) {
                capabilities.service = {};
                this.readChildNodes(node, capabilities.service);
            },
            "Fees": function(node, service) {
                var fees = this.getChildValue(node);
                if (fees && fees.toLowerCase() != "none") {
                    service.fees = fees;
                }
            },
            "AccessConstraints": function(node, service) {
                var constraints = this.getChildValue(node);
                if (constraints && constraints.toLowerCase() != "none") {
                    service.accessConstraints = constraints;
                }
            },
            "OnlineResource": function(node, service) {
                var onlineResource = this.getChildValue(node);
                if (onlineResource && onlineResource.toLowerCase() != "none") {
                    service.onlineResource = onlineResource;
                }
            },
            "Keywords": function(node, service) {
                var keywords = this.getChildValue(node);
                if (keywords && keywords.toLowerCase() != "none") {
                    service.keywords = keywords.split(', ');
                }
            },
            "Capability": function(node, capabilities) {
                capabilities.capability = {};
                this.readChildNodes(node, capabilities.capability);
            },
            "Request": function(node, obj) {
                obj.request = {};
                this.readChildNodes(node, obj.request);
            },
            "GetFeature": function(node, request) {
                request.getfeature = {
                    href: {}, // DCPType
                    formats: [] // ResultFormat
                };
                this.readChildNodes(node, request.getfeature);
            },
            "ResultFormat": function(node, obj) {
                var children = node.childNodes;
                var childNode;
                for(var i=0; i<children.length; i++) {
                    childNode = children[i];
                    if(childNode.nodeType == 1) {
                        obj.formats.push(childNode.nodeName);
                    }
                }
            },
            "DCPType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "HTTP": function(node, obj) {
                this.readChildNodes(node, obj.href);
            },
            "Get": function(node, obj) {
                obj.get = node.getAttribute("onlineResource");
            },
            "Post": function(node, obj) {
                obj.post = node.getAttribute("onlineResource");
            },
            "SRS": function(node, obj) {
                var srs = this.getChildValue(node);
                if (srs) {
                    obj.srs = srs;
                }
            },
			"LatLongBoundingBox": function(node, obj) {
				var minx = node.getAttribute("minx");
				var miny = node.getAttribute("miny");
				var maxx = node.getAttribute("maxx");
				var maxy = node.getAttribute("maxy");
				obj.bbox = minx + "," + miny + "," + maxx + "," + maxy;
	        },
			"TemporalFeatureLayer": function(node, featureTypeList){//新增多时态WFS查询参数
			    featureTypeList.temporalFeatureLayers = [];
			    var temporalFeatureLayer = {};
			    this.readChildNodes(node, temporalFeatureLayer);
			    featureTypeList.temporalFeatureLayers.push(temporalFeatureLayer);
			},
			"Extent": function(node, obj){//TODO，需要验证，该节点是否废弃
			    //obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			},
			"Dimension": function(node, obj) {//添加wfs:Dimension方法解析时间版本
				//obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			}
        }, GeoGlobe.Format.WFSCapabilities.v1.prototype.readers["wfs"])
    },
    
    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1_0_0" 

});
/**
 * @class  GeoGlobe.Format.WFSCapabilities/v1_0_0
 * @classdesc  Read WFS Capabilities version 1.0.0.
 * WFS服务 1.0.0版本的GetCapabilities操作格式化类。
 * @private
 */


GeoGlobe.Format.WFSCapabilities.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WFSCapabilities.v1, {

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @type {null}
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * Create a new parser for WFS capabilities version 1.1.0.
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @param {Object} options - An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WFSCapabilities/v1_0_0.prototype
     * @type {null}
     * @private
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "DefaultSRS": function(node, obj) {
                var defaultSRS = this.getChildValue(node);
                if (defaultSRS) {
                    obj.srs = defaultSRS;
                }
            },
			"WGS84BoundingBox": function(node, obj) {
				var lowerCorner = node.getElementsByTagName("ows:LowerCorner");
				var lowerCornerValue = this.getChildValue(lowerCorner[0]);
				var lowerCornerArray = lowerCornerValue.split(" ");
				
				var upperCorner = node.getElementsByTagName("ows:UpperCorner");
				var upperCornerValue = this.getChildValue(upperCorner[0]);
				var upperCornerArray = upperCornerValue.split(" ");
				obj.bbox = lowerCornerArray[0] + "," + lowerCornerArray[1] + "," + upperCornerArray[0] + "," + upperCornerArray[1];
			},
			"TemporalFeatureLayer": function(node, featureTypeList){//新增多时态WFS查询参数
			    featureTypeList.temporalFeatureLayers = [];
			    var temporalFeatureLayer = {};
			    this.readChildNodes(node, temporalFeatureLayer);
			    featureTypeList.temporalFeatureLayers.push(temporalFeatureLayer);
			},
			"Extent": function(node, obj){//TODO，需要验证，该节点是否废弃
			    //obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			},
			"Dimension": function(node, obj) {//添加wfs:Dimension方法解析时间版本
				//obj.time.name= node.getAttribute("name");
				obj.defaultTime = node.getAttribute("default");
				var timeArr = this.getChildValue(node).split("/");
				obj.time = timeArr;//timeArr.splice(0, timeArr.length -1);
			}
        }, GeoGlobe.Format.WFSCapabilities.v1.prototype.readers["wfs"]),
        "ows": GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows
    },

    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1_1_0" 

});
/**
 * @class  GeoGlobe.Format.WFSDescribeFeatureType
 * @classdesc 阅读WFS DescribeFeatureType响应信息。
 * @returns {Object} 表示WFS DescribeFeatureType响应信息的对象。
 * @private
 */

GeoGlobe.Format.WFSDescribeFeatureType = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     *  Compiled regular expressions for manipulating strings.
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @type {null}
     * @private
     *
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g)
    },
    
    /**
     * namespaces-Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        xsd: "http://www.w3.org/2001/XMLSchema"
    },
    
    /**
     *  Create a new parser for WFS DescribeFeatureType responses.
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @param {Object} options - An optional object whose properties will be set on
     *     this instance.
     * @private
     */
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @type {null}
     * @private
     */
    readers: {
        "xsd": {
            "schema": function(node, obj) {
                var complexTypes = [];
                var customTypes = {};
                var schema = {
                    complexTypes: complexTypes,
                    customTypes: customTypes
                };
                var i, len;
                
                this.readChildNodes(node, schema);

                var attributes = node.attributes;
                var attr, name;
                for(i=0, len=attributes.length; i<len; ++i) {
                    attr = attributes[i];
                    name = attr.name;
                    if(name.indexOf("xmlns") === 0) {
                        this.setNamespace(name.split(":")[1] || "", attr.value);
                    } else {
                        obj[name] = attr.value;
                    }
                }
                obj.featureTypes = complexTypes;                
                obj.targetPrefix = this.namespaceAlias[obj.targetNamespace];
                
                // map complexTypes to names of customTypes
                var complexType, customType;
                for(i=0, len=complexTypes.length; i<len; ++i) {
                    complexType = complexTypes[i];
                    customType = customTypes[complexType.typeName];
                    if(customTypes[complexType.typeName]) {
                        complexType.typeName = customType.name;
                    }
                }
            },
            "complexType": function(node, obj) {
                var complexType = {
                    // this is a temporary typeName, it will be overwritten by
                    // the schema reader with the metadata found in the
                    // customTypes hash
                    "typeName": node.getAttribute("name")
                };
                this.readChildNodes(node, complexType);
                obj.complexTypes.push(complexType);
            },
            "complexContent": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "extension": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "sequence": function(node, obj) {
                var sequence = {
                    elements: []
                };
                this.readChildNodes(node, sequence);
                obj.properties = sequence.elements;
            },
            "element": function(node, obj) {
                var type;
                if(obj.elements) {
                    var element = {};
                    var attributes = node.attributes;
                    var attr;
                    for(var i=0, len=attributes.length; i<len; ++i) {
                        attr = attributes[i];
                        element[attr.name] = attr.value;
                    }
                    
					type = element.type || element.ref;
                    if(!type) {
                        type = {};
                        this.readChildNodes(node, type);
                        element.restriction = type;
                        element.type = type.base;
                    }
                    var fullType = type.base || type;
                    element.localType = fullType.split(":").pop();
                    obj.elements.push(element);
                    this.readChildNodes(node, element);
                }
                
                if(obj.complexTypes) {
                    type = node.getAttribute("type");
                    var localType = type.split(":").pop();
                    obj.customTypes[localType] = {
                        "name": node.getAttribute("name"),
                        "type": type
                    };
                }
            },
            "annotation": function(node, obj) {
                obj.annotation = {};
                this.readChildNodes(node, obj.annotation);
            },
            "appinfo": function(node, obj) {
                if (!obj.appinfo) {
                    obj.appinfo = [];
                }
                obj.appinfo.push(this.getChildValue(node));
            },
            "documentation": function(node, obj) {
                if (!obj.documentation) {
                    obj.documentation = [];
                }
                var value = this.getChildValue(node);
                obj.documentation.push({
                    lang: node.getAttribute("xml:lang"),
                    textContent: value.replace(this.regExes.trimSpace, "")
                });
            },
            "simpleType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "restriction": function(node, obj) {
                obj.base = node.getAttribute("base");
                this.readRestriction(node, obj);
            }
        }
    },
    
    /**
     * Reads restriction defined in the child nodes of a restriction element
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @param {DOMElement}  node - the node to parse
     * obj - {Object} the object that receives the read result
     * @private
     */
    readRestriction: function(node, obj) {
        var children = node.childNodes;
        var child, nodeName, value;
        for(var i=0, len=children.length; i<len; ++i) {
            child = children[i];
            if(child.nodeType == 1) {
                nodeName = child.nodeName.split(":").pop();
                value = child.getAttribute("value");
                if(!obj[nodeName]) {
                    obj[nodeName] = value;
                } else {
                    if(typeof obj[nodeName] == "string") {
                        obj[nodeName] = [obj[nodeName]];
                    }
                    obj[nodeName].push(value);
                }
            }
        }
    },
    
    /**
     * @memberof  GeoGlobe.Format.WFSDescribeFeatureType.prototype
     * @param {DOMElement|String}data - A WFS DescribeFeatureType document.
     * @private
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var schema = {};
        if (data.nodeName.split(":").pop() === 'ExceptionReport') {
            // an exception must have occurred, so parse it
            var parser = new GeoGlobe.Format.OGCExceptionReport();
            schema.error = parser.read(data);
        } else {
            this.readNode(data, schema);
        }
        return schema;
    },
    
    CLASS_NAME: "GeoGlobe.Format.WFSDescribeFeatureType"

});
/**
 * @class  GeoGlobe.Format.WKT
 * @classdesc 用于阅读和编写公认文本的类。 用GeoGlobe.Format.WKT构造函数创建一个新实例。
 * @returns {GeoGlobe.Format.WKT} 新的WKT解析器。
 */

GeoGlobe.Format.WKT = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     * 为WKT创建一个新的解析器
     * @memberof GeoGlobe.Format.WKT.prototype
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置
     */
    initialize: function(options) {
        this.regExes = {
            'typeStr': /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            'spaces': /\s+/,
            'parenComma': /\)\s*,\s*\(/,
            'doubleParenComma': /\)\s*\)\s*,\s*\(\s*\(/,  // can't use {2} here
            'trimParens': /^\s*\(?(.*?)\)?\s*$/
        };
        GeoGlobe.Format.prototype.initialize.apply(this, [options]);
    },

    /**
     * 解析WKT字符串并返回矢量要素或矢量要素数组。 支持点，多点，
     * @memberof GeoGlobe.Format.WKT.prototype
     * @param {String}wkt - 一个WKT字符串
     * @returns {GeoGlobe.Feature|Array} 用于GEOMETRYCOLLECTION WKT的特征或特征阵列。
     */
    read: function(wkt) {
        var features, type, str;
        wkt = wkt.replace(/[\n\r]/g, " ");
        var matches = this.regExes.typeStr.exec(wkt);
        if(matches) {
            type = matches[1].toLowerCase();
            str = matches[2];
            if(this.parse[type]) {
                features = this.parse[type].apply(this, [str]);
            }
            if (this.internalProjection && this.externalProjection) {
                if (features && 
                    features.CLASS_NAME == "GeoGlobe.Feature") {
                    features.geometry.transform(this.externalProjection,
                                                this.internalProjection);
                } else if (features &&
                           type != "geometrycollection" &&
                           typeof features == "object") {
                    for (var i=0, len=features.length; i<len; i++) {
                        var component = features[i];
                        component.geometry.transform(this.externalProjection,
                                                     this.internalProjection);
                    }
                }
            }
        }    
        return features;
    },

    /**
     * 将特征或特征数组编译成WKT字符串。
     * @memberof GeoGlobe.Format.WKT.prototype
     * @param {GeoGlobe.Feature|Array}features - 一个功能或一系列功能
     * @returns {String} 返回输入几何图形的WKT字符串表示
     */
    write: function(features) {
        var collection, geometry, isCollection;
        if (features.constructor == Array) {
            collection = features;
            isCollection = true;
        } else {
            collection = [features];
            isCollection = false;
        }
        var pieces = [];
        if (isCollection) {
            pieces.push('GEOMETRYCOLLECTION(');
        }
        for (var i=0, len=collection.length; i<len; ++i) {
            if (isCollection && i>0) {
                pieces.push(',');
            }
            geometry = collection[i].geometry;
            pieces.push(this.extractGeometry(geometry));
        }
        if (isCollection) {
            pieces.push(')');
        }
        return pieces.join('');
    },

    /**
     * Entry point to construct the WKT for a single Geometry object.
     * @memberof  GeoGlobe.Format.WKT.prototype
     * @param {GeoGlobe.Geometry.Geometry} geometry -
     * @returns {String} A WKT string of representing the geometry
     * @private
     */
    extractGeometry: function(geometry) {
        var type = geometry.CLASS_NAME.split('.')[2].toLowerCase();
        if (!this.extract[type]) {
            return null;
        }
        if (this.internalProjection && this.externalProjection) {
            geometry = geometry.clone();
            geometry.transform(this.internalProjection, this.externalProjection);
        }                       
        var wktType = type == 'collection' ? 'GEOMETRYCOLLECTION' : type.toUpperCase();
        var data = wktType + '(' + this.extract[type].apply(this, [geometry]) + ')';
        return data;
    },
    

    extract: {
        /**
         * Return a space delimited string of point coordinates.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.Point} point
         * @returns {String} A string of coordinates representing the point
         * @private
         */
        'point': function(point) {
            return point.x + ' ' + point.y;
        },

        /**
         * Return a comma delimited string of point coordinates from a multipoint.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.MultiPoint} multipoint
         * @returns {String} A string of point coordinate strings representing
         *                  the multipoint
         * @private
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.point.apply(this, [multipoint.components[i]]) +
                           ')');
            }
            return array.join(',');
        },
        
        /**
         *  Return a comma delimited string of point coordinates from a line.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.LineString} linestring
         * @returns {String} A string of point coordinate strings representing
         *                  the linestring
         * @private
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array.join(',');
        },

        /**
         * Return a comma delimited string of linestring strings from a multilinestring.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.MultiLineString} multilinestring
         * @returns {String} A string of of linestring strings representing
         *                  the multilinestring
         * @private
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.linestring.apply(this, [multilinestring.components[i]]) +
                           ')');
            }
            return array.join(',');
        },
        
        /**
         * Return a comma delimited string of linear ring arrays from a polygon.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.Polygon} polygon
         * @returns {String} An array of linear ring arrays representing the polygon
         * @private
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.linestring.apply(this, [polygon.components[i]]) +
                           ')');
            }
            return array.join(',');
        },

        /**
         * Return an array of polygon arrays from a multipolygon.
         * @memberof   GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.MultiPolygon} multipolygon
         * @returns {String} An array of polygon arrays representing
         *                  the multipolygon
         * @private
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push('(' +
                           this.extract.polygon.apply(this, [multipolygon.components[i]]) +
                           ')');
            }
            return array.join(',');
        },

        /**
         * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an GeoGlobe.Geometry.Collection
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {GeoGlobe.Geometry.Collection} collection
         * @returns {String} internal WKT representation of the collection
         * @private
         */
        'collection': function(collection) {
            var array = [];
            for(var i=0, len=collection.components.length; i<len; ++i) {
                array.push(this.extractGeometry.apply(this, [collection.components[i]]));
            }
            return array.join(',');
        }

    },


    parse: {
        /**
         * Return point feature given a point WKT fragment.
         * @param {String} str A WKT fragment representing the point
         * @returns {GeoGlobe.Feature} A point feature
         * @private
         */
        'point': function(str) {
            var coords = GeoGlobe.String.trim(str).split(this.regExes.spaces);
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.Point(coords[0], coords[1])
            );
        },

        /**
         * Return a multipoint feature given a multipoint WKT fragment.
         * @memberof   GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the multipoint
         * @returns {GeoGlobe.Feature} A multipoint feature
         * @private
         */
        'multipoint': function(str) {
            var point;
            var points = GeoGlobe.String.trim(str).split(',');
            var components = [];
            for(var i=0, len=points.length; i<len; ++i) {
                point = points[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.point.apply(this, [point]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiPoint(components)
            );
        },
        
        /**
         * Return a linestring feature given a linestring WKT fragment.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the linestring
         * @returns {GeoGlobe.Feature} A linestring feature
         * @private
         */
        'linestring': function(str) {
            var points = GeoGlobe.String.trim(str).split(',');
            var components = [];
            for(var i=0, len=points.length; i<len; ++i) {
                components.push(this.parse.point.apply(this, [points[i]]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.LineString(components)
            );
        },

        /**
         * Return a multilinestring feature given a multilinestring WKT fragment.
         * @memberof  GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the multilinestring
         * @returns {GeoGlobe.Feature} A multilinestring feature
         * @private
         */
        'multilinestring': function(str) {
            var line;
            var lines = GeoGlobe.String.trim(str).split(this.regExes.parenComma);
            var components = [];
            for(var i=0, len=lines.length; i<len; ++i) {
                line = lines[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.linestring.apply(this, [line]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiLineString(components)
            );
        },
        
        /**
         * Return a polygon feature given a polygon WKT fragment.
         * @memberof   GeoGlobe.Format.WKT.prototyp
         * @param {String} str A WKT fragment representing the polygon
         * @returns {GeoGlobe.Feature} A polygon feature
         * @private
         */
        'polygon': function(str) {
            var ring, linestring, linearring;
            var rings = GeoGlobe.String.trim(str).split(this.regExes.parenComma);
            var components = [];
            for(var i=0, len=rings.length; i<len; ++i) {
                ring = rings[i].replace(this.regExes.trimParens, '$1');
                linestring = this.parse.linestring.apply(this, [ring]).geometry;
                linearring = new GeoGlobe.Geometry.LinearRing(linestring.components);
                components.push(linearring);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.Polygon(components)
            );
        },

        /**
         * Return a multipolygon feature given a multipolygon WKT fragment.
         * @memberof   GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the multipolygon
         * @returns {GeoGlobe.Feature.Vector} A multipolygon feature
         * @private
         */
        'multipolygon': function(str) {
            var polygon;
            var polygons = GeoGlobe.String.trim(str).split(this.regExes.doubleParenComma);
            var components = [];
            for(var i=0, len=polygons.length; i<len; ++i) {
                polygon = polygons[i].replace(this.regExes.trimParens, '$1');
                components.push(this.parse.polygon.apply(this, [polygon]).geometry);
            }
            return new GeoGlobe.Feature(
                new GeoGlobe.Geometry.MultiPolygon(components)
            );
        },

        /**
         * Return an array of features given a geometrycollection WKT fragment.
         * @memberof   GeoGlobe.Format.WKT.prototype
         * @param {String} str A WKT fragment representing the geometrycollection
         * @returns {Array} An array of GeoGlobe.Feature.
         * @private
         */
        'geometrycollection': function(str) {
            // separate components of the collection with |
            str = str.replace(/,\s*([A-Za-z])/g, '|$1');
            var wktArray = GeoGlobe.String.trim(str).split('|');
            var components = [];
            for(var i=0, len=wktArray.length; i<len; ++i) {
                components.push(GeoGlobe.Format.WKT.prototype.read.apply(this,[wktArray[i]]));
            }
            return components;
        }

    },

    CLASS_NAME: "GeoGlobe.Format.WKT" 
});     
/**
 * @class  GeoGlobe.Format.CQL.prototype
 * @classdesc 阅读CQL字符串以获取GeoGlobe.Filter对象。 编写GeoGlobe.Filter对象来获取CQL字符串。 使用创建一个新的分析器
  GeoGlobe.Format.CQL构造函数。
 */

GeoGlobe.Format.CQL = (function() {
    
    var tokens = [
        "PROPERTY", "COMPARISON", "VALUE", "LOGICAL"
    ],

    patterns = {
        PROPERTY: /^[_a-zA-Z]\w*/,
        COMPARISON: /^(=|<>|<=|<|>=|>|LIKE)/i,
        IS_NULL: /^IS NULL/i,
        COMMA: /^,/,
        LOGICAL: /^(AND|OR)/i,
        VALUE: /^('([^']|'')*'|\d+(\.\d*)?|\.\d+)/,
        LPAREN: /^\(/,
        RPAREN: /^\)/,
        SPATIAL: /^(BBOX|INTERSECTS|DWITHIN|WITHIN|CONTAINS)/i,
        NOT: /^NOT/i,
        BETWEEN: /^BETWEEN/i,
        GEOMETRY: function(text) {
            var type = /^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)/.exec(text);
            if (type) {
                var len = text.length;
                var idx = text.indexOf("(", type[0].length);
                if (idx > -1) {
                    var depth = 1;
                    while (idx < len && depth > 0) {
                        idx++;
                        switch(text.charAt(idx)) {
                            case '(':
                                depth++;
                                break;
                            case ')':
                                depth--;
                                break;
                            default:
                                // in default case, do nothing
                        }
                    }
                }
                return [text.substr(0, idx+1)];
            }
        },
        END: /^$/
    },

    follows = {
        LPAREN: ['GEOMETRY', 'SPATIAL', 'PROPERTY', 'VALUE', 'LPAREN'],
        RPAREN: ['NOT', 'LOGICAL', 'END', 'RPAREN'],
        PROPERTY: ['COMPARISON', 'BETWEEN', 'COMMA', 'IS_NULL'],
        BETWEEN: ['VALUE'],
        IS_NULL: ['END'],
        COMPARISON: ['VALUE'],
        COMMA: ['GEOMETRY', 'VALUE', 'PROPERTY'],
        VALUE: ['LOGICAL', 'COMMA', 'RPAREN', 'END'],
        SPATIAL: ['LPAREN'],
        LOGICAL: ['NOT', 'VALUE', 'SPATIAL', 'PROPERTY', 'LPAREN'],
        NOT: ['PROPERTY', 'LPAREN'],
        GEOMETRY: ['COMMA', 'RPAREN']
    },

    operators = {
        '=': GeoGlobe.Filter.Comparison.EQUAL_TO,
        '<>': GeoGlobe.Filter.Comparison.NOT_EQUAL_TO,
        '<': GeoGlobe.Filter.Comparison.LESS_THAN,
        '<=': GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
        '>': GeoGlobe.Filter.Comparison.GREATER_THAN,
        '>=': GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
        'LIKE': GeoGlobe.Filter.Comparison.LIKE,
        'BETWEEN': GeoGlobe.Filter.Comparison.BETWEEN,
        'IS NULL': GeoGlobe.Filter.Comparison.IS_NULL
    },

    operatorReverse = {},

    logicals = {
        'AND': GeoGlobe.Filter.Logical.AND,
        'OR': GeoGlobe.Filter.Logical.OR
    },

    logicalReverse = {},

    precedence = {
        'RPAREN': 3,
        'LOGICAL': 2,
        'COMPARISON': 1
    };

    var i;
    for (i in operators) {
        if (operators.hasOwnProperty(i)) {
            operatorReverse[operators[i]] = i;
        }
    }

    for (i in logicals) {
        if (logicals.hasOwnProperty(i)) {
            logicalReverse[logicals[i]] = i;
        }
    }

    function tryToken(text, pattern) {
        if (pattern instanceof RegExp) {
            return pattern.exec(text);
        } else {
            return pattern(text);
        }
    }

    function nextToken(text, tokens) {
        var i, token, len = tokens.length;
        for (i=0; i<len; i++) {
            token = tokens[i];
            var pat = patterns[token];
            var matches = tryToken(text, pat);
            if (matches) {
                var match = matches[0];
                var remainder = text.substr(match.length).replace(/^\s*/, "");
                return {
                    type: token,
                    text: match,
                    remainder: remainder
                };
            }
        }

        var msg = "ERROR: In parsing: [" + text + "], expected one of: ";
        for (i=0; i<len; i++) {
            token = tokens[i];
            msg += "\n    " + token + ": " + patterns[token];
        }

        throw new Error(msg);
    }

    function tokenize(text) {
        var results = [];
        var token, expect = ["NOT", "GEOMETRY", "SPATIAL", "PROPERTY", "LPAREN"];

        do {
            token = nextToken(text, expect);
            text = token.remainder;
            expect = follows[token.type];
            if (token.type != "END" && !expect) {
                throw new Error("No follows list for " + token.type);
            }
            results.push(token);
        } while (token.type != "END");

        return results;
    }

    function buildAst(tokens) {
        var operatorStack = [],
            postfix = [];

        while (tokens.length) {
            var tok = tokens.shift();
            switch (tok.type) {
                case "PROPERTY":
                case "GEOMETRY":
                case "VALUE":
                    postfix.push(tok);
                    break;
                case "COMPARISON":
                case "BETWEEN":
                case "IS_NULL":
                case "LOGICAL":
                    var p = precedence[tok.type];

                    while (operatorStack.length > 0 &&
                        (precedence[operatorStack[operatorStack.length - 1].type] <= p)
                    ) {
                        postfix.push(operatorStack.pop());
                    }

                    operatorStack.push(tok);
                    break;
                case "SPATIAL":
                case "NOT":
                case "LPAREN":
                    operatorStack.push(tok);
                    break;
                case "RPAREN":
                    while (operatorStack.length > 0 &&
                        (operatorStack[operatorStack.length - 1].type != "LPAREN")
                    ) {
                        postfix.push(operatorStack.pop());
                    }
                    operatorStack.pop(); // toss out the LPAREN

                    if (operatorStack.length > 0 &&
                        operatorStack[operatorStack.length-1].type == "SPATIAL") {
                        postfix.push(operatorStack.pop());
                    }
                case "COMMA":
                case "END":
                    break;
                default:
                    throw new Error("Unknown token type " + tok.type);
            }
        }

        while (operatorStack.length > 0) {
            postfix.push(operatorStack.pop());
        }

        function buildTree() {
            var tok = postfix.pop();
            switch (tok.type) {
                case "LOGICAL":
                    var rhs = buildTree(),
                        lhs = buildTree();
                    return new GeoGlobe.Filter.Logical({
                        filters: [lhs, rhs],
                        type: logicals[tok.text.toUpperCase()]
                    });
                case "NOT":
                    var operand = buildTree();
                    return new GeoGlobe.Filter.Logical({
                        filters: [operand],
                        type: GeoGlobe.Filter.Logical.NOT
                    });
                case "BETWEEN":
                    var min, max, property;
                    postfix.pop(); // unneeded AND token here
                    max = buildTree();
                    min = buildTree();
                    property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        lowerBoundary: min,
                        upperBoundary: max,
                        type: GeoGlobe.Filter.Comparison.BETWEEN
                    });
                case "COMPARISON":
                    var value = buildTree(),
                        property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        value: value,
                        type: operators[tok.text.toUpperCase()]
                    });
                case "IS_NULL":
                    var property = buildTree();
                    return new GeoGlobe.Filter.Comparison({
                        property: property,
                        type: operators[tok.text.toUpperCase()]
                    });
                case "VALUE":
                    var match = tok.text.match(/^'(.*)'$/);
                    if (match) {
                        return match[1].replace(/''/g, "'");
                    } else {
                        return Number(tok.text);
                    }
                case "SPATIAL":
                    switch(tok.text.toUpperCase()) {
                        case "BBOX":
                            var maxy = buildTree(),
                                maxx = buildTree(),
                                miny = buildTree(),
                                minx = buildTree(),
                                prop = buildTree();

                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.BBOX,
                                property: prop,
                                value: GeoGlobe.LngLatBounds.fromArray(
                                    [minx, miny, maxx, maxy]
                                )
                            });
                        case "INTERSECTS":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.INTERSECTS,
                                property: property,
                                value: value
                            });
                        case "WITHIN":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.WITHIN,
                                property: property,
                                value: value
                            });
                        case "CONTAINS":
                            var value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.CONTAINS,
                                property: property,
                                value: value
                            });
                        case "DWITHIN":
                            var distance = buildTree(),
                                value = buildTree(),
                                property = buildTree();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.DWITHIN,
                                value: value,
                                property: property,
                                distance: Number(distance)
                            });
                    }
                case "GEOMETRY":
                    return GeoGlobe.Geometry.fromWKT(tok.text);
                default:
                    return tok.text;
            }
        }

        var result = buildTree();
        if (postfix.length > 0) {
            var msg = "Remaining tokens after building AST: \n";
            for (var i = postfix.length - 1; i >= 0; i--) {
                msg += postfix[i].type + ": " + postfix[i].text + "\n";
            }
            throw new Error(msg);
        }

        return result;
    }

    return GeoGlobe.Class4OL(GeoGlobe.Format, {
        /**
         * 从CQL字符串生成过滤器。
         * @memberof  GeoGlobe.Format.CQL.prototype
         * @param {String}  text - CQL文本。
         * @returns {GeoGlobe.Filter} 基于CQL文本的过滤器。
         */
        read: function(text) { 
            var result = buildAst(tokenize(text));
            if (this.keepData) {
                this.data = result;
            }
            return result;
        },

        /**
         * 将过滤器转换为CQL字符串。
         * @memberof GeoGlobe.Format.CQL.prototype
         * @param {GeoGlobe.Filter}filter -  过滤器。
         * @returns {String} 基于过滤器的CQL字符串。
         */
        write: function(filter) {
            if (filter instanceof GeoGlobe.Geometry) {
                return filter.toString();
            }
            switch (filter.CLASS_NAME) {
                case "GeoGlobe.Filter.Spatial":
                    switch(filter.type) {
                        case GeoGlobe.Filter.Spatial.BBOX:
                            return "BBOX(" +
                                filter.property + "," +
                                filter.value.toBBOX() +
                                ")";
                        case GeoGlobe.Filter.Spatial.DWITHIN:
                            return "DWITHIN(" +
                                filter.property + ", " +
                                this.write(filter.value) + ", " +
                                filter.distance + ")";
                        case GeoGlobe.Filter.Spatial.WITHIN:
                            return "WITHIN(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        case GeoGlobe.Filter.Spatial.INTERSECTS:
                            return "INTERSECTS(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        case GeoGlobe.Filter.Spatial.CONTAINS:
                            return "CONTAINS(" +
                                filter.property + ", " +
                                this.write(filter.value) + ")";
                        default:
                            throw new Error("Unknown spatial filter type: " + filter.type);
                    }
                case "GeoGlobe.Filter.Logical":
                    if (filter.type == GeoGlobe.Filter.Logical.NOT) {
                        // TODO: deal with precedence of logical operators to 
                        // avoid extra parentheses (not urgent)
                        return "NOT (" + this.write(filter.filters[0]) + ")";
                    } else {
                        var res = "(";
                        var first = true;
                        for (var i = 0; i < filter.filters.length; i++) {
                            if (first) {
                                first = false;
                            } else {
                                res += ") " + logicalReverse[filter.type] + " (";
                            }
                            res += this.write(filter.filters[i]);
                        }
                        return res + ")";
                    }
                case "GeoGlobe.Filter.Comparison":
                    if (filter.type == GeoGlobe.Filter.Comparison.BETWEEN) {
                        return filter.property + " BETWEEN " + 
                            this.write(filter.lowerBoundary) + " AND " + 
                            this.write(filter.upperBoundary);
                    } else {
                        return (filter.value !== null) ? filter.property +
                            " " + operatorReverse[filter.type] + " " + 
                            this.write(filter.value) : filter.property +
                            " " + operatorReverse[filter.type];
                    }
                case undefined:
                    if (typeof filter === "string") {
                        return "'" + filter.replace(/'/g, "''") + "'";
                    } else if (typeof filter === "number") {
                        return String(filter);
                    }
                default:
                    throw new Error("Can't encode: " + filter.CLASS_NAME + " " + filter);
            }
        },

        CLASS_NAME: "GeoGlobe.Format.CQL"

    });
})();

/**
 * @class GeoGlobe.Format.Filter
 * @classdesc  用GeoGlobe.Format.Filter构造函数创建一个新实例。
 * 过滤器的格式化类。
 */


GeoGlobe.Format.Filter = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {

    /**
     * 默认版本 - 如果没有找到，则假定版本号。 默认值是“1.0.0”。
     * @memberof GeoGlobe.Format.Filter.prototype
     * @type {String}
     */

    defaultVersion: "1.0.0",
    
    /**
     * 写一个ogc：Filter给定一个过滤器对象。
     * @memberof GeoGlobe.Format.Filter.prototype
     * @param {GeoGlobe.Filter} filter -一个过滤器。
     * @param  {Object}options - 可选的配置对象。
     * @returns {Elment} ogc：过滤元素节点。
     */
    
    /**
     * 阅读并过滤文档并返回代表过滤器的对象。
     * @memberof GeoGlobe.Format.Filter.prototype
     * @param {String | DOMElement}data -  要读取的数据
     * @returns {GeoGlobe.Filter} 过滤器对象。
     */

    CLASS_NAME: "GeoGlobe.Format.Filter" 
});
/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */


/**
 * @class  GeoGlobe.Format.Filter.v1

 * @classdesc 过滤器的格式化超类。
 *
 * 继承:
 *  - GeoGlobe.Format.XML
 */
GeoGlobe.Format.Filter.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**

     * Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * defaultPrefix
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @private
     */
    defaultPrefix: "ogc",

    /**
     *  Schema location for a particular minor version.
     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * @type {String}
     * @private
     */
    schemaLocation: null,
    
    /**

     * 这个类的实例不是直接创建的。改为使用GeoGlobe.Format.Filter构造函数。
     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * @param {Object} options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**

     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * @param {DOMElement} data -  A Filter document element.
     *
     * @returns {GeoGlobe.Filter} A filter object.
     * @private
     */
    read: function(data) {
        var obj = {};
        this.readers.ogc["Filter"].apply(this, [data, obj]);
        return obj.filter;
    },
    
    /**
     * readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @private
     */
    readers: {
        "ogc": {
            "_expression": function(node) {
                // only the simplest of ogc:expression handled
                // "some text and an <PropertyName>attribute</PropertyName>"}
                var obj, value = "";
                for(var child=node.firstChild; child; child=child.nextSibling) {
                    switch(child.nodeType) {
                        case 1:
                            obj = this.readNode(child);
                            if (obj.property) {
                                value += "${" + obj.property + "}";
                            } else if (obj.value !== undefined) {
                                value += obj.value;
                            }
                            break;
                        case 3: // text node
                        case 4: // cdata section
                            value += child.nodeValue;
                    }
                }
                return value;
            },
            "Filter": function(node, parent) {
                // Filters correspond to subclasses of GeoGlobe.Filter.
                // Since they contain information we don't persist, we
                // create a temporary object and then pass on the filter
                // (ogc:Filter) to the parent obj.
                var obj = {
                    fids: [],
                    filters: []
                };
                this.readChildNodes(node, obj);
                if(obj.fids.length > 0) {
                    parent.filter = new GeoGlobe.Filter.FeatureId({
                        fids: obj.fids
                    });
                } else if(obj.filters.length > 0) {
                    parent.filter = obj.filters[0];
                }
            },
            "FeatureId": function(node, obj) {
                var fid = node.getAttribute("fid");
                if(fid) {
                    obj.fids.push(fid);
                }
            },
            "And": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.AND
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Or": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.OR
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Not": function(node, obj) {
                var filter = new GeoGlobe.Filter.Logical({
                    type: GeoGlobe.Filter.Logical.NOT
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLessThan": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LESS_THAN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsGreaterThan": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.GREATER_THAN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLessThanOrEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsGreaterThanOrEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsBetween": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.BETWEEN
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "Literal": function(node, obj) {
                obj.value = GeoGlobe.String.numericIf(
                    this.getChildValue(node), true);
            },
            "PropertyName": function(node, filter) {
                filter.property = this.getChildValue(node);
            },
            "LowerBoundary": function(node, filter) {
                filter.lowerBoundary = GeoGlobe.String.numericIf(
                    this.readers.ogc._expression.call(this, node), true);
            },
            "UpperBoundary": function(node, filter) {
                filter.upperBoundary = GeoGlobe.String.numericIf(
                    this.readers.ogc._expression.call(this, node), true);
            },
            "Intersects": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.INTERSECTS);
            },
            "Within": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.WITHIN);
            },
            "Contains": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.CONTAINS);
            },
            "DWithin": function(node, obj) {
                this.readSpatial(node, obj, GeoGlobe.Filter.Spatial.DWITHIN);
            },
            "Distance": function(node, obj) {
                obj.distance = parseInt(this.getChildValue(node));
                obj.distanceUnits = node.getAttribute("units");
            },
            "Function": function(node, obj) {
                //TODO write decoder for it
                return;
            },
            "PropertyIsNull": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.IS_NULL
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            }
        }
    },
    
    /**

     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * Read a {GeoGlobe.Filter.Spatial} filter.
     * 

     *  @param {DOMElement} node -A DOM element that contains an ogc:expression.
     *  @param {Object}obj - The target object.
     *  @param {String}type -  One of the GeoGlobe.Filter.Spatial.* constants.
     *
     * @returns
     * {GeoGlobe.Filter.Spatial} The created filter.
     * @private
     */
    readSpatial: function(node, obj, type) {
        var filter = new GeoGlobe.Filter.Spatial({
            type: type
        });
        this.readChildNodes(node, filter);
        filter.value = filter.components[0];
        delete filter.components;
        obj.filters.push(filter);
    },

    /**

     * 生成用于Literal元素值的字符串表示形式。 默认编码器将日期值写为ISO 8601字符串。
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @param {Object}value -  字面值编码
     *
     * @returns {String} 所提供值的字符串表示形式。
     */
    encodeLiteral: function(value) {
        if (value instanceof Date) {
            value = GeoGlobe.Date.toISOString(value);
        }
        return value;
    },

    /**

     * Limited support for writing OGC expressions. Currently it supports
     * (GeoGlobe.Filter.Function || String || Number)
     *@memberof  GeoGlobe.Format.Filter.v1.prototype

     * @param (GeoGlobe.Filter.Function| String | Number)value -
     * @param {DOMElement}node -  A parent DOM element
     *
     * @returns
     * {DOMElement} Updated node element.
     * @private
     */
    writeOgcExpression: function(value, node) {
        if (value instanceof GeoGlobe.Filter.Function){
            this.writeNode("Function", value, node);
        } else {
            this.writeNode("Literal", value, node);
        }
        return node;
    },    
    
    /**

     *@memberof  GeoGlobe.Format.Filter.v1.prototype
     * @param {GeoGlobe.Filter}  filter - A filter object.
     *
     * @returns {DOMElement} An ogc:Filter element.
     * @private
     */
    write: function(filter) {
        return this.writers.ogc["Filter"].apply(this, [filter]);
    },
    
    /**

     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.v1.prototype
     * @private
     */
    writers: {
        "ogc": {
            "Filter": function(filter) {
                var node = this.createElementNSPlus("ogc:Filter");
                this.writeNode(this.getFilterType(filter), filter, node);
                return node;
            },
            "_featureIds": function(filter) {
                var node = this.createDocumentFragment();
                for (var i=0, ii=filter.fids.length; i<ii; ++i) {
                    this.writeNode("ogc:FeatureId", filter.fids[i], node);
                }
                return node;
            },
            "FeatureId": function(fid) {
                return this.createElementNSPlus("ogc:FeatureId", {
                    attributes: {fid: fid}
                });
            },
            "And": function(filter) {
                var node = this.createElementNSPlus("ogc:And");
                var childFilter;
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {
                    childFilter = filter.filters[i];
                    this.writeNode(
                        this.getFilterType(childFilter), childFilter, node
                    );
                }
                return node;
            },
            "Or": function(filter) {
                var node = this.createElementNSPlus("ogc:Or");
                var childFilter;
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {
                    childFilter = filter.filters[i];
                    this.writeNode(
                        this.getFilterType(childFilter), childFilter, node
                    );
                }
                return node;
            },
            "Not": function(filter) {
                var node = this.createElementNSPlus("ogc:Not");
                var childFilter = filter.filters[0];
                this.writeNode(
                    this.getFilterType(childFilter), childFilter, node
                );
                return node;
            },
            "PropertyIsLessThan": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLessThan");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsGreaterThan": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThan");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLessThanOrEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLessThanOrEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsGreaterThanOrEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThanOrEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsBetween": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsBetween");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                this.writeNode("LowerBoundary", filter, node);
                this.writeNode("UpperBoundary", filter, node);
                return node;
            },
            "PropertyName": function(filter) {
                // no ogc:expression handling for now
                return this.createElementNSPlus("ogc:PropertyName", {
                    value: filter.property
                });
            },
            "Literal": function(value) {
                var encode = this.encodeLiteral ||
                    GeoGlobe.Format.Filter.v1.prototype.encodeLiteral;
                return this.createElementNSPlus("ogc:Literal", {
                    value: encode(value)
                });
            },
            "LowerBoundary": function(filter) {
                // handle Literals or Functions for now
                var node = this.createElementNSPlus("ogc:LowerBoundary");
                this.writeOgcExpression(filter.lowerBoundary, node);
                return node;
            },
            "UpperBoundary": function(filter) {
                // handle Literals or Functions for now
                var node = this.createElementNSPlus("ogc:UpperBoundary");
                this.writeNode("Literal", filter.upperBoundary, node);
                return node;
            },
            "INTERSECTS": function(filter) {
                return this.writeSpatial(filter, "Intersects");
            },
            "WITHIN": function(filter) {
                return this.writeSpatial(filter, "Within");
            },
            "CONTAINS": function(filter) {
                return this.writeSpatial(filter, "Contains");
            },
            "DWITHIN": function(filter) {
                var node = this.writeSpatial(filter, "DWithin");
                this.writeNode("Distance", filter, node);
                return node;
            },
            "Distance": function(filter) {
                return this.createElementNSPlus("ogc:Distance", {
                    attributes: {
                        units: filter.distanceUnits
                    },
                    value: filter.distance
                });
            },
            "Function": function(filter) {
                var node = this.createElementNSPlus("ogc:Function", {
                    attributes: {
                        name: filter.name
                    }
                });
                var params = filter.params;
                for(var i=0, len=params.length; i<len; i++){
                    this.writeOgcExpression(params[i], node);
                }
                return node;
            },
            "PropertyIsNull": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNull");
                this.writeNode("PropertyName", filter, node);
                return node;
            },
			"SortBy": function(sortProperties) {
                var node = this.createElementNSPlus("ogc:SortBy");
                for (var i=0,l=sortProperties.length;i<l;i++) {
                    this.writeNode(
                        "ogc:SortProperty",
                        sortProperties[i],
                        node
                    );
                }
                return node;
            },
            "SortProperty": function(sortProperty) {
                var node = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode(
                    "ogc:PropertyName",
                    sortProperty,
                    node
                );
                this.writeNode(
                    "ogc:SortOrder",
                    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
                    node
                );
                return node;
            },
            "SortOrder": function(value) {
                var node = this.createElementNSPlus("ogc:SortOrder", {
                    value: value
                });
                return node;
            }
        }
    },

    /**
     *getFilterType
     * @memberof GeoGlobe.v1.prototype
     * @private
     */
    getFilterType: function(filter) {
        var filterType = this.filterMap[filter.type];
        if(!filterType) {
            throw "Filter writing not supported for rule type: " + filter.type;
        }
        return filterType;
    },
    
    /**
     *  Contains a member for each filter type.  Values are node names
     *     for corresponding OGC Filter child elements.
     * @memberof  GeoGlobe.Format.Filter.v1.prototype
     * @type {Object}
     * @private
     */
    filterMap: {
        "&&": "And",
        "||": "Or",
        "!": "Not",
        "==": "PropertyIsEqualTo",
        "!=": "PropertyIsNotEqualTo",
        "<": "PropertyIsLessThan",
        ">": "PropertyIsGreaterThan",
        "<=": "PropertyIsLessThanOrEqualTo",
        ">=": "PropertyIsGreaterThanOrEqualTo",
        "..": "PropertyIsBetween",
        "~": "PropertyIsLike",
        "NULL": "PropertyIsNull",
        "BBOX": "BBOX",
        "DWITHIN": "DWITHIN",
        "WITHIN": "WITHIN",
        "CONTAINS": "CONTAINS",
        "INTERSECTS": "INTERSECTS",
        "FID": "_featureIds"
    },

    CLASS_NAME: "GeoGlobe.Format.Filter.v1"

});
/** Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */

/**
 * @memberof GeoGlobe.Format.Filter.v1_0_0.prototype
 * @requires  View2D/Format/GML/v2.js
 * @requires View2D/Format/Filter/v1.js
 */

/**
 * @class GeoGlobe.Format.Filter.v1_0_0
 * @classdesc Write ogc:Filter version 1.0.0.
 * 
 */
GeoGlobe.Format.Filter.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.GML.v2, GeoGlobe.Format.Filter.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.0.0
     * @private
     */
    VERSION: "1.0.0",
    
    /**
     * schemaLocation
     * {String} http://www.opengis.net/ogc/filter/1.0.0/filter.xsd
     * @memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/ogc/filter/1.0.0/filter.xsd",

    /**

     * 这个类的实例不是直接创建的。 改为使用GeoGlobe.Format.Filter构造函数。
     *@memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     *@param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.v2.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     * @private
     */
    readers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsNotEqualTo": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.NOT_EQUAL_TO
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLike": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LIKE
                });
                this.readChildNodes(node, filter);
                var wildCard = node.getAttribute("wildCard");
                var singleChar = node.getAttribute("singleChar");
                var esc = node.getAttribute("escape");
                filter.value2regex(wildCard, singleChar, esc);
                obj.filters.push(filter);
            }
        }, GeoGlobe.Format.Filter.v1.prototype.readers["ogc"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.readers["feature"]        
    },

    /**
     * writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     * @private
     */
    writers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsNotEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNotEqualTo");
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLike": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        wildCard: "*", singleChar: ".", escape: "!"
                    }
                });
                // no ogc:expression handling for now
                this.writeNode("PropertyName", filter, node);
                // convert regex string to ogc string
                this.writeNode("Literal", filter.regex2value(), node);
                return node;
            },
            "BBOX": function(filter) {
                var node = this.createElementNSPlus("ogc:BBOX");
                // PropertyName is mandatory in 1.0.0, but e.g. GeoServer also
                // accepts filters without it. When this is used with
                // GeoGlobe.Protocol.WFS, GeoGlobe.Format.WFST will set a
                // missing filter.property to the geometryName that is
                // configured with the protocol, which defaults to "the_geom".
                // So the only way to omit this mandatory property is to not
                // set the property on the filter and to set the geometryName
                // on the WFS protocol to null. The latter also happens when
                // the protocol is configured without a geometryName and a
                // featureNS.
                filter.property && this.writeNode("PropertyName", filter, node);
                var box = this.writeNode("gml:Box", filter.value, node);
                if(filter.projection) {
                    box.setAttribute("srsName", filter.projection);
                }
                return node;
            }
        }, GeoGlobe.Format.Filter.v1.prototype.writers["ogc"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.writers["feature"]
    },

    /**

     *
     * Read a {GeoGlobe.Filter.Spatial} filter and converts it into XML.
     *@memberof GeoGlobe.Format.Filter.v1_0_0.prototype
     * @param {GeoGlobe.Filter.Spatial}filter - The filter.
     *@param  {String} name -Name of the generated XML element.
     *
     * @returns {DOMElement} The created XML element.
     * @private
     */
    writeSpatial: function(filter, name) {
        var node = this.createElementNSPlus("ogc:"+name);
        this.writeNode("PropertyName", filter, node);
        if(filter.value instanceof GeoGlobe.Filter.Function) {
            this.writeNode("Function", filter.value, node);
        } else {
        var child;
        if(filter.value instanceof GeoGlobe.Geometry) {
            child = this.writeNode("feature:_geometry", filter.value).firstChild;
        } else {
            child = this.writeNode("gml:Box", filter.value);
        }
        if(filter.projection) {
            child.setAttribute("srsName", filter.projection);
        }
        node.appendChild(child);
        }
        return node;
    },
    CLASS_NAME: "GeoGlobe.Format.Filter.v1_0_0"

});
/**
 * @class GeoGlobe.Format.Filter.v1_1_0
 *@classdesc  Write ogc:Filter version 1.1.0.
 *
 * Differences from the v1.0.0 parser:
 *  - uses GML v3 instead of GML v2
 *  - reads matchCase attribute on ogc:PropertyIsEqual and
 *        ogc:PropertyIsNotEqual elements.
 *  - writes matchCase attribute from comparison filters of type EQUAL_TO,
 *        NOT_EQUAL_TO and LIKE.
 * 
 * Inherits from: 
 *  - GeoGlobe.Format.GML.v3
 *  - GeoGlobe.Format.Filter.v1
 * @private
 */
GeoGlobe.Format.Filter.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.GML.v3, GeoGlobe.Format.Filter.v1, {
    
    /**
     * Constant: VERSION
     * {String} 1.1.0
     * @private
     */
    VERSION: "1.1.0",
    
    /**
     * schemaLocation
     * {String} http://www.opengis.net/ogc/filter/1.1.0/filter.xsd
     * @memberof  GeoGlobe .v1_1_0.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/ogc/filter/1.1.0/filter.xsd",

    /**

     * 这个类的实例不是直接创建的。改为使用GeoGlobe.Format.Filter构造函数。
     * @memberof GeoGlobe .v1_1_0.prototype
     * @param {Object} options -一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.GML.v3.prototype.initialize.apply(
            this, [options]
        );
    },

    /**
     * readers
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe .v1_1_0.prototype
     * @private
     */
    readers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(node, obj) {
                var matchCase = node.getAttribute("matchCase");
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.EQUAL_TO,
                    matchCase: !(matchCase === "false" || matchCase === "0")
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsNotEqualTo": function(node, obj) {
                var matchCase = node.getAttribute("matchCase");
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.NOT_EQUAL_TO,
                    matchCase: !(matchCase === "false" || matchCase === "0")
                });
                this.readChildNodes(node, filter);
                obj.filters.push(filter);
            },
            "PropertyIsLike": function(node, obj) {
                var filter = new GeoGlobe.Filter.Comparison({
                    type: GeoGlobe.Filter.Comparison.LIKE
                });
                this.readChildNodes(node, filter);
                var wildCard = node.getAttribute("wildCard");
                var singleChar = node.getAttribute("singleChar");
                var esc = node.getAttribute("escapeChar");
                filter.value2regex(wildCard, singleChar, esc);
                obj.filters.push(filter);
            }
        }, GeoGlobe.Format.Filter.v1.prototype.readers["ogc"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.readers["feature"]        
    },

    /**
     * writers
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe .v1_1_0.prototype
     * @private
     */
    writers: {
        "ogc": GeoGlobe.Util.applyDefaults({
            "PropertyIsEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsEqualTo", {
                    attributes: {matchCase: filter.matchCase}
                });
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsNotEqualTo": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsNotEqualTo", {
                    attributes: {matchCase: filter.matchCase}
                });
                // no ogc:expression handling for PropertyName for now
                this.writeNode("PropertyName", filter, node);
                // handle Literals or Functions for now
                this.writeOgcExpression(filter.value, node);
                return node;
            },
            "PropertyIsLike": function(filter) {
                var node = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        matchCase: filter.matchCase,
                        wildCard: "*", singleChar: ".", escapeChar: "!"
                    }
                });
                // no ogc:expression handling for now
                this.writeNode("PropertyName", filter, node);
                // convert regex string to ogc string
                this.writeNode("Literal", filter.regex2value(), node);
                return node;
            },
            "BBOX": function(filter) {
                var node = this.createElementNSPlus("ogc:BBOX");
                // PropertyName is optional in 1.1.0
                filter.property && this.writeNode("PropertyName", filter, node);
                var box = this.writeNode("gml:Envelope", filter.value);
                if(filter.projection) {
                    box.setAttribute("srsName", filter.projection);
                }
                node.appendChild(box); 
                return node;
            },
            "SortBy": function(sortProperties) {
                var node = this.createElementNSPlus("ogc:SortBy");
                for (var i=0,l=sortProperties.length;i<l;i++) {
                    this.writeNode(
                        "ogc:SortProperty",
                        sortProperties[i],
                        node
                    );
                }
                return node;
            }, 
            "SortProperty": function(sortProperty) {
                var node = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode(
                    "ogc:PropertyName",
                    sortProperty,
                    node
                );
                this.writeNode(
                    "ogc:SortOrder",
                    (sortProperty.order == 'DESC') ? 'DESC' : 'ASC',
                    node
                );
                return node;
            },
            "SortOrder": function(value) {
                var node = this.createElementNSPlus("ogc:SortOrder", {
                    value: value
                });
                return node;
            }
        }, GeoGlobe.Format.Filter.v1.prototype.writers["ogc"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.writers["feature"]
    },

    /**

     * @memberof GeoGlobe .v1_1_0.prototype
     * Read a {GeoGlobe.Filter.Spatial} filter and converts it into XML.
     *

     *@param {GeoGlobe.Filter.Spatial} filter -  The filter.
     *@param {String} name -  Name of the generated XML element.
     *
     * @returns {DOMElement} The created XML element.
     * @private
     */
    writeSpatial: function(filter, name) {
        var node = this.createElementNSPlus("ogc:"+name);
        this.writeNode("PropertyName", filter, node);
        if(filter.value instanceof GeoGlobe.Filter.Function) {
            this.writeNode("Function", filter.value, node);
        } else {
        var child;
        if(filter.value instanceof GeoGlobe.Geometry) {
            child = this.writeNode("feature:_geometry", filter.value).firstChild;
        } else {
            child = this.writeNode("gml:Envelope", filter.value);
        }
        if(filter.projection) {
            child.setAttribute("srsName", filter.projection);
        }
        node.appendChild(child);
        }
        return node;
    },

    CLASS_NAME: "GeoGlobe.Format.Filter.v1_1_0"

});
/**
 * @class GeoGlobe.Format.WFST
 * @classdesc 
 * 带有事务操作的网络要素服务格式化类。
 * @returns {GeoGlobe.Format} 给定版本的带有事务操作的网络要素服务。
 */

GeoGlobe.Format.WFST = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Format.WFST.DEFAULTS
    );
    var cls = GeoGlobe.Format.WFST["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported WFST version: " + options.version;
    }
    return new cls(options);
};

/**
 * 带有事务操作的网络要素服务格式的默认属性。
 * @memberof GeoGlobe.Format.WFST.DEFAULTS
 * @type {Object}
 */
GeoGlobe.Format.WFST.DEFAULTS = {
    "version": "1.0.0"
};
/**
 * @class GeoGlobe.Format.WFST.v1
 * @classdesc  
 * 带有事务处理类型的网络要素服务的格式化超类。
 */

GeoGlobe.Format.WFST.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs",
        gml: "http://www.opengis.net/gml",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows"
    },
    
    /**
     * defaultPrefix
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {null}
     * @private
     */
    defaultPrefix: "wfs",

    /**
     * 版本- 网络要素服务的版本号
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {String}
     */
    version: null,

    /**
     * schemaLocation- Schema location for a particular minor version.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {String}
     * @private
     */
    schemaLocations: null,
    
    /**
     * srsName- 空间参考系统的URI。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {String}
     */
    srsName: null,

    /**
     * 从GML中提取属性。 默认值是true。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {Boolean}
     */
    extractAttributes: true,
    
    /**
     * GML的xy-Order坐标为true：（x，y）或false：（y，x）
     * 不建议更改，应该实例化新格式。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {Boolean}
     */ 
    xy: true,

    /**
     * stateName- Maps feature states to node names.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {Object}
     * @private
     */
    stateName: null,
    
    /**
     * 这个类的实例不是直接创建的。  
     * 改为使用GeoGlobe.Format.WFST.v1_0_0或GeoGlobe.Format.WFST.v1_1_0构造函数。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        // set state name mapping
        this.stateName = {};
        this.stateName[GeoGlobe.State.INSERT] = "wfs:Insert";
        this.stateName[GeoGlobe.State.UPDATE] = "wfs:Update";
        this.stateName[GeoGlobe.State.DELETE] = "wfs:Delete";
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @private
     */
    getSrsName: function(feature, options) {
        var srsName = options && options.srsName;
        if(!srsName) {
            if(feature && feature.layer) {
                srsName = feature.layer.projection.getCode();
            } else {
                srsName = this.srsName;
            }
        }
        return srsName;
    },

    /**
     * 解析事务的响应。 
     * 由于WFS分为事务请求（创建，更新和删除）和GetFeature请求（读取），
     * 因此此方法处理这两种类型的响应的解析。
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @param {String | Document} data -带有事务操作类型的网络要素服务文档。
     * @param {Object} options -选项。
     *
     * 有效的选项属性：{字符串}输出 - “功能”或“对象”。 默认值是“功能”，
     * 这意味着该方法将返回一组功能。 如果设置为“object”，
     * 则将返回解析器读取的具有“features”属性和其他属性的对象。
     *
     * @returns {Array | Object} 输出取决于输出选项。
     */
    read: function(data, options) {
        options = options || {};
        GeoGlobe.Util.applyDefaults(options, {
            output: "features"
        });
        
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        if(data) {
            this.readNode(data, obj, true);
        }
        if(obj.features && options.output === "features") {
            obj = obj.features;
        }
        return obj;
    },
    
    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wfs": {
            "FeatureCollection": function(node, obj) {
                obj.features = [];
                this.readChildNodes(node, obj);
            }
        }
    },
    
    /**
     * Given an array of features, write a WFS transaction.  This assumes
     *     the features have a state property that determines the operation
     *     type - insert, update, or delete.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @param {Array(GeoGlobe.Feature)} features -A list of features. See
     *     below for a more detailed description of the influence of the
     *     feature's *modified* property.
     * options - {Object}
     *
     * feature.modified rules:
     * If a feature has a modified property set, the following checks will be
     * made before a feature's geometry or attribute is included in an Update
     * transaction:
     * - *modified* is not set at all: The geometry and all attributes will be
     *     included.
     * - *modified.geometry* is set (null or a geometry): The geometry will be
     *     included. If *modified.attributes* is not set, all attributes will
     *     be included.
     * - *modified.attributes* is set: Only the attributes set (i.e. to null or
     *     a value) in *modified.attributes* will be included. 
     *     If *modified.geometry* is not set, the geometry will not be included.
     *
     * Valid options include:
     * - *multi* {Boolean} If set to true, geometries will be casted to
     *   Multi geometries before writing.
     *
     * @returns {String} A serialized WFS transaction.
     * @private
     */
    write: function(features, options) {
        var node = this.writeNode("wfs:Transaction", {
            features:features,
            options: options
        });
        var value = this.schemaLocationAttr();
        if(value) {
            this.setAttributeNS(
                node, this.namespaces["xsi"], "xsi:schemaLocation",  value
            );
        }
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    },
    
    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @type {null}
     * @private
     */
    writers: {
        "wfs": {
            "GetFeature": function(options) {
				/*
                var node = this.createElementNSPlus("wfs:GetFeature", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: options && options.handle,
                        outputFormat: options && options.outputFormat,
                        maxFeatures: options && options.maxFeatures,
                        "xsi:schemaLocation": this.schemaLocationAttr(options)
                    }
                });
                */
				var node = this.createElementNSPlus("wfs:GetFeature", {
			        attributes: {
			            service: "WFS",
			            version: this.version,
						//handle: options && options.handle,
			            outputFormat: options && options.outputFormat,
			            maxFeatures: options && options.maxFeatures,
			            resultType: options && options.resultType,//增加resultType属性
			            startPosition: options && options.startPosition,//增加startPosition属性
			            "xsi:schemaLocation": this.schemaLocationAttr(options)
			        }
			    });
                if (typeof this.featureType == "string") {
                    this.writeNode("Query", options, node);
                } else {
                    for (var i=0,len = this.featureType.length; i<len; i++) { 
                        options.featureType = this.featureType[i]; 
                        this.writeNode("Query", options, node); 
                    } 
                }
			    return node;
            },
            "Transaction": function(obj) {
                obj = obj || {};
                var options = obj.options || {};
                var node = this.createElementNSPlus("wfs:Transaction", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: options.handle
                    }
                });
                var i, len;
                var features = obj.features;
                if(features) {
                    // temporarily re-assigning geometry types
                    if (options.multi === true) {
                        GeoGlobe.Util.extend(this.geometryTypes, {
                            "GeoGlobe.Geometry.Point": "MultiPoint",
                            "GeoGlobe.Geometry.LineString": (this.multiCurve === true) ? "MultiCurve": "MultiLineString",
                            "GeoGlobe.Geometry.Polygon": (this.multiSurface === true) ? "MultiSurface" : "MultiPolygon"
                        });
                    }
                    var name, feature;
                    for(i=0, len=features.length; i<len; ++i) {
                        feature = features[i];
                        name = this.stateName[feature.state];
                        if(name) {
                            this.writeNode(name, {
                                feature: feature, 
                                options: options
                            }, node);
                        }
                    }
                    // switch back to original geometry types assignment
                    if (options.multi === true) {
                        this.setGeometryTypes();
                    }
                }
                if (options.nativeElements) {
                    for (i=0, len=options.nativeElements.length; i<len; ++i) {
                        this.writeNode("wfs:Native", 
                            options.nativeElements[i], node);
                    }
                }
                return node;
            },
            "Native": function(nativeElement) {
                var node = this.createElementNSPlus("wfs:Native", {
                    attributes: {
                        vendorId: nativeElement.vendorId,
                        safeToIgnore: nativeElement.safeToIgnore
                    },
                    value: nativeElement.value
                });
                return node;
            },
            "Insert": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Insert", {
                    attributes: {
                        handle: options && options.handle
                    }
                });
                this.srsName = this.getSrsName(feature);
                this.writeNode("feature:_typeName", feature, node);
                return node;
            },
            "Update": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Update", {
                    attributes: {
                        handle: options && options.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +
                            this.featureType
                    }
                });
                if(this.featureNS) {
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                }
                
                // add in geometry
                var modified = feature.modified;
                if (this.geometryName !== null && (!modified || modified.geometry !== undefined)) {
                    this.srsName = this.getSrsName(feature);
                    this.writeNode(
                        "Property", {name: this.geometryName, value: feature.geometry}, node
                    );
                }
        
                // add in attributes
                for(var key in feature.attributes) {
                    if(feature.attributes[key] !== undefined &&
                                (!modified || !modified.attributes ||
                                (modified.attributes && modified.attributes[key] !== undefined))) {
                        this.writeNode(
                            "Property", {name: key, value: feature.attributes[key]}, node
                        );
                    }
                }
                
                // add feature id filter
                this.writeNode("ogc:Filter", new GeoGlobe.Filter.FeatureId({
                    fids: [feature.fid]
                }), node);
        
                return node;
            },
            "Property": function(obj) {
                var node = this.createElementNSPlus("wfs:Property");
                this.writeNode("Name", obj.name, node);
                if(obj.value !== null) {
                    this.writeNode("Value", obj.value, node);
                }
                return node;
            },
            "Name": function(name) {
                return this.createElementNSPlus("wfs:Name", {value: name});
            },
            "Value": function(obj) {
                var node;
                if(obj instanceof GeoGlobe.Geometry) {
                    node = this.createElementNSPlus("wfs:Value");
                    var geom = this.writeNode("feature:_geometry", obj).firstChild;
                    node.appendChild(geom);
                } else {
                    node = this.createElementNSPlus("wfs:Value", {value: obj});                
                }
                return node;
            },
            "Delete": function(obj) {
                var feature = obj.feature;
                var options = obj.options;
                var node = this.createElementNSPlus("wfs:Delete", {
                    attributes: {
                        handle: options && options.handle,
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +
                            this.featureType
                    }
                });
                if(this.featureNS) {
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                }
                this.writeNode("ogc:Filter", new GeoGlobe.Filter.FeatureId({
                    fids: [feature.fid]
                }), node);
                return node;
            }
        }
    },

    /**
     * Generate the xsi:schemaLocation attribute value.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @returns {String} The xsi:schemaLocation attribute or undefined if none.
     * @private
     */
    schemaLocationAttr: function(options) {
        options = GeoGlobe.Util.extend({
            featurePrefix: this.featurePrefix,
            schema: this.schema
        }, options);
        var schemaLocations = GeoGlobe.Util.extend({}, this.schemaLocations);
        if(options.schema) {
            schemaLocations[options.featurePrefix] = options.schema;
        }
        var parts = [];
        var uri;
        for(var key in schemaLocations) {
            uri = this.namespaces[key];
            if(uri) {
                parts.push(uri + " " + schemaLocations[key]);
            }
        }
        var value = parts.join(" ") || undefined;
        return value;
    },
    
    /**
     * Set the property of each spatial filter.
     * @memberof  GeoGlobe.Format.WFST.v1.prototype
     * @param {GeoGlobe.Filter}filter
     * @private
     */
    setFilterProperty: function(filter) {
        if(filter.filters) {
            for(var i=0, len=filter.filters.length; i<len; ++i) {
                GeoGlobe.Format.WFST.v1.prototype.setFilterProperty.call(this, filter.filters[i]);
            }
        } else {
            if(filter instanceof GeoGlobe.Filter.Spatial && !filter.property) {
                // got a spatial filter without property, so set it
                filter.property = this.geometryName;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WFST.v1" 

});
/**
 * @class  GeoGlobe.Format.WFST.v1_0_0
 * @classdesc  创建WFS v1.0.0事务的格式。 使用GeoGlobe.Format.WFST.v1_0_0构造函数创建一个新实例。
 * WFST的格式化类。1.0.0版本。
 * @returns {Object} 输入对象已修改（如果没有提供，则为新的输入对象）。
 * @private
 */


GeoGlobe.Format.WFST.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.Filter.v1_0_0, GeoGlobe.Format.WFST.v1, {
    
    /**
     * version-WFS version number.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {String}
     * @private
     */
    version: "1.0.0",

    /**
     * srsNameInQuery- 如果参数系统在查询请求中通过“srsName”属性传递给“wfs：Query”元素，
     * 则该属性默认为false，因为它不符合WFS 1.0.0。
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {Boolean}
     */
    srsNameInQuery: false,
    
    /**
     *  Properties are namespace aliases, values are schema locations.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    schemaLocations: {
        "wfs": "http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd"
    },


    initialize: function(options) {
        GeoGlobe.Format.Filter.v1_0_0.prototype.initialize.apply(this, [options]);
        GeoGlobe.Format.WFST.v1.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @param {DOMElement} node - The node to be read (required).
     * @param {Object}obj - The object to be modified (optional).
     * @param {Boolean} first -  Should be set to true for the first node read.
     *    This  is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     * @private

     */
    readNode: function(node, obj, first) {
        // Not the superclass, only the mixin classes inherit from
        // Format.GML.v2. We need this because we don't want to get readNode
        // from the superclass's superclass, which is GeoGlobe.Format.XML.
        return GeoGlobe.Format.GML.v2.prototype.readNode.apply(this, arguments);
    },
    
    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {null}
     * @private
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "WFS_TransactionResponse": function(node, obj) {
                obj.insertIds = [];
                obj.success = false;
                this.readChildNodes(node, obj);
            },
            "InsertResult": function(node, container) {
                var obj = {fids: []};
                this.readChildNodes(node, obj);
                container.insertIds = container.insertIds.concat(obj.fids);
            },
            "TransactionResult": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Status": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "SUCCESS": function(node, obj) {
                obj.success = true;
            }
        }, GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.readers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_0_0.prototype.readers["ogc"]
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    writers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "Query": function(options) {
                options = GeoGlobe.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName,
                    srsNameInQuery: this.srsNameInQuery
                }, options);
                var prefix = options.featurePrefix;
                var node = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (options.featureNS ? prefix + ":" : "") +
                            options.featureType,
						time: options && options.time, //可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间
						userecent: options && options.userecent //可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
                    }
                });
                if(options.srsNameInQuery && options.srsName) {
                    node.setAttribute("srsName", options.srsName);
                }
                if(options.featureNS) {
                    node.setAttribute("xmlns:" + prefix, options.featureNS);
                }
                if(options.propertyNames) {
                    for(var i=0,len = options.propertyNames.length; i<len; i++) {
                        this.writeNode(
                            "ogc:PropertyName", 
                            {property: options.propertyNames[i]},
                            node
                        );
                    }
                }
                if(options.filter) {
                    this.setFilterProperty(options.filter);
                    this.writeNode("ogc:Filter", options.filter, node);
                }
				if (options.sortBy) {
                    this.writeNode("ogc:SortBy", options.sortBy, node);
                }
				if (options.groupBy) {
	                this.writeNode("ogc:GroupBy", options.groupBy, node);
	            }
                return node;
            }
        }, GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]),
        "gml": GeoGlobe.Format.GML.v2.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v2.prototype.writers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_0_0.prototype.writers["ogc"]
    },
   
    CLASS_NAME: "GeoGlobe.Format.WFST.v1_0_0" 
});
/**
 * @class  GeoGlobe.Format.WFST.v1_0_0
 * @classdesc  A format for creating WFS v1.0.0 transactions.  Create a new instance with the
 *     GeoGlobe.Format.WFST.v1_0_0 constructor.
 * WFST的格式化类。1.0.0版本。
 * @private
 */

GeoGlobe.Format.WFST.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.Filter.v1_1_0, GeoGlobe.Format.WFST.v1, {
    
    /**
     * version- WFS version number.
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {String}
     * @private
     */
    version: "1.1.0",
    
    /**
     * schemaLocations- Properties are namespace aliases, values are schema locations.
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    schemaLocations: {
        "wfs": "http://schemas.opengis.net/wfs/1.1.0/wfs.xsd"
    },
    
    /**
     * 要从FeatureCollection中读取其他信息（如hit count（numberOfFeatures）），
     * 请使用{output：“object”}作为第二个参数调用GeoGlobe.Format.WFST.v1.read方法。 
     * 请注意，可以使用resultType =“hits”请求参数向WFS 1.1.0服务器请求命中计数。
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * 一个解析和生成WFS v1.1.0事务的类。
     * @param {Object} options -Optional 对象的属性将在实例上设置。
     *
     * 有效的选项属性：
     * @param {String} featureType -  本地（无前缀）功能typeName（必需）。
     * @param {String} featureNS -  功能名称空间（可选）。
     * @param {String} featurePrefix - 功能名称空间别名（可选 - 仅用于如果提供featureNS）。 默认是'feature'。
     * @param {String} geometryName -  几何属性的名称。 默认是'the_geom'。
     */
    initialize: function(options) {
        GeoGlobe.Format.Filter.v1_1_0.prototype.initialize.apply(this, [options]);
        GeoGlobe.Format.WFST.v1.prototype.initialize.apply(this, [options]);
    },
    
    /**
     * Shorthand for applying one of the named readers given the node
     *     namespace and local name.  Readers take two args (node, obj) and
     *     generally extend or modify the second.
     *@memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     *@param {DOMElement} node - The node to be read (required).
     *@param  {Object}obj - The object to be modified (optional).
     *@param {Boolean}first -  Should be set to true for the first node read. This
     *     is usually the readNode call in the read method. Without this being
     *     set, auto-configured properties will stick on subsequent reads.
     *@returns {Object} The input object, modified (or a new one if none was provided).
     *@private
     */
    readNode: function(node, obj, first) {
        // Not the superclass, only the mixin classes inherit from
        // Format.GML.v3. We need this because we don't want to get readNode
        // from the superclass's superclass, which is GeoGlobe.Format.XML.
        return GeoGlobe.Format.GML.v3.prototype.readNode.apply(this, arguments);
    },
    
    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {null}
     * @private
     */
    readers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "FeatureCollection": function(node, obj) {
                obj.numberOfFeatures = parseInt(node.getAttribute(
                    "numberOfFeatures"));
                GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]["FeatureCollection"].apply(
                    this, arguments);
            },
            "TransactionResponse": function(node, obj) {
                obj.insertIds = [];
                obj.success = false;
                this.readChildNodes(node, obj);
            },
            "TransactionSummary": function(node, obj) {
                // this is a limited test of success
                obj.success = true;
            },
            "InsertResults": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Feature": function(node, container) {
                var obj = {fids: []};
                this.readChildNodes(node, obj);
                container.insertIds.push(obj.fids[0]);
            }
        }, GeoGlobe.Format.WFST.v1.prototype.readers["wfs"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.readers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.readers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.readers["ogc"],
        "ows": GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"]
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof GeoGlobe.Format.WFST.v1_0_0.prototype
     * @type {null}
     * @private
     */
    writers: {
        "wfs": GeoGlobe.Util.applyDefaults({
            "GetFeature": function(options) {
                var node = GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]["GetFeature"].apply(this, arguments);
                options && this.setAttributes(node, {
                    resultType: options.resultType,
                    startIndex: options.startIndex,
                    count: options.count
                });
                return node;
            },
            "Query": function(options) {
                options = GeoGlobe.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName
                }, options);
                var prefix = options.featurePrefix;
                var node = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (options.featureNS ? prefix + ":" : "") +
                            options.featureType,
                        srsName: options.srsName,
						time: options && options.time, //可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间
						userecent: options && options.userecent //可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
                    }
                });
                if(options.featureNS) {
                    node.setAttribute("xmlns:" + prefix, options.featureNS);
                }
                if(options.propertyNames) {
                    for(var i=0,len = options.propertyNames.length; i<len; i++) {
                        this.writeNode(
                            "wfs:PropertyName", 
                            {property: options.propertyNames[i]},
                            node
                        );
                    }
                }
                if(options.filter) {
                    GeoGlobe.Format.WFST.v1_1_0.prototype.setFilterProperty.call(this, options.filter);
                    this.writeNode("ogc:Filter", options.filter, node);
                }
				if (options.sortBy) {
	                this.writeNode("ogc:SortBy", options.sortBy, node);
	            }
				if (options.groupBy) {
	                this.writeNode("ogc:GroupBy", options.groupBy, node);
	            }
                return node;
            },
            "PropertyName": function(obj) {
                return this.createElementNSPlus("wfs:PropertyName", {
                    value: obj.property
                });
            }            
        }, GeoGlobe.Format.WFST.v1.prototype.writers["wfs"]),
        "gml": GeoGlobe.Format.GML.v3.prototype.writers["gml"],
        "feature": GeoGlobe.Format.GML.v3.prototype.writers["feature"],
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers["ogc"]
    },

    CLASS_NAME: "GeoGlobe.Format.WFST.v1_1_0" 
});
/**
 * @class GeoGlobe.Format.JSON
 * @classdesc   JSON格式化类。解析器安全地读取/写入JSON。 使用GeoGlobe.Format.JSON构造函数创建一个新实例。
 * @returns   {Object} 一个对象，数组，字符串或数字。
 */

GeoGlobe.Format.JSON = GeoGlobe.Class4OL(GeoGlobe.Format, {
    
    /**
     * indent-对于“pretty”打印，缩进字符串将在每个缩进级别使用一次。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {String}
     */
    indent: "    ",
    
    /**
     *  space- 对于“pretty”打印，空格字符串将在“：”分隔名称/值对之后使用。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {String}
     */
    space: " ",
    
    /**
     * newline- 对于“pretty”打印，换行符字符串将用于每个名称/值对或数组项目的末尾。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {String}
     */
    newline: "\n",
    
    /**
     * level- For "pretty" printing, this is incremented/decremented during
     *     serialization.
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {int}
     * @private
     */
    level: 0,

    /**
     * pretty-Serialize with extra whitespace for structure.  This is set
     *     by the write method.
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {Boolean}
     * @private
     */
    pretty: false,

    /**
     * nativeJSON- Does the browser support native json?
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @type {Boolean}
     * @private
     */
    nativeJSON: (function() {
        return !!(window.JSON && typeof JSON.parse == "function" && typeof JSON.stringify == "function");
    })(),

    /**
     * 为JSON创建一个新的解析器。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 解析json字符串。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @param {String} json -一个JSON字符串
     * @param  {Function}filter - 将在最终结果的每个级别调用每个键和值的函数。 
     * 每个值将被过滤器功能的结果替换。
     * 这可用于将通用对象改为类的实例，
     * 或将日期字符串转换为Date对象。
     */
    read: function(json, filter) {
        var object;
        if (this.nativeJSON) {
            object = JSON.parse(json, filter);
        } else try {
            /**
             * Parsing happens in three stages. In the first stage, we run the
             *     text against a regular expression which looks for non-JSON
             *     characters. We are especially concerned with '()' and 'new'
             *     because they can cause invocation, and '=' because it can
             *     cause mutation. But just to be safe, we will reject all
             *     unexpected characters.
             */
            if (/^[\],:{}\s]*$/.test(json.replace(/\\["\\\/bfnrtu]/g, '@').
                                replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').
                                replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

                /**
                 * In the second stage we use the eval function to compile the
                 *     text into a JavaScript structure. The '{' operator is
                 *     subject to a syntactic ambiguity in JavaScript - it can
                 *     begin a block or an object literal. We wrap the text in
                 *     parens to eliminate the ambiguity.
                 */
                object = eval('(' + json + ')');

                /**
                 * In the optional third stage, we recursively walk the new
                 *     structure, passing each name/value pair to a filter
                 *     function for possible transformation.
                 */
                if(typeof filter === 'function') {
                    function walk(k, v) {
                        if(v && typeof v === 'object') {
                            for(var i in v) {
                                if(v.hasOwnProperty(i)) {
                                    v[i] = walk(i, v[i]);
                                }
                            }
                        }
                        return filter(k, v);
                    }
                    object = walk('', object);
                }
            }
        } catch(e) {
            // Fall through if the regexp test fails.
        }

        if(this.keepData) {
            this.data = object;
        }

        return object;
    },

    /**
     *  将对象序列化为JSON字符串。
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @param {String} value - 要序列化的对象，数组，字符串，数字，布尔值或日期。
     * @param {Boolean} pretty -  使用换行符和缩进结构化输出。默认为false。
     * @returns {String} 输入值的JSON字符串表示形式。
     */
    write: function(value, pretty) {
        this.pretty = !!pretty;
        var json = null;
        var type = typeof value;
        if(this.serialize[type]) {
            try {
                json = (!this.pretty && this.nativeJSON) ?
                    JSON.stringify(value) :
                    this.serialize[type].apply(this, [value]);
            } catch(err) {
                GeoGlobe.Console.error("Trouble serializing: " + err);
            }
        }
        return json;
    },
    
    /**
     * Output an indentation string depending on the indentation level.
     * @memberof  GeoGlobe.Format.JSON.prototype
     * @returns {String} An appropriate indentation string.
     * @private
     */
    writeIndent: function() {
        var pieces = [];
        if(this.pretty) {
            for(var i=0; i<this.level; ++i) {
                pieces.push(this.indent);
            }
        }
        return pieces.join('');
    },
    
    /**
     * Output a string representing a newline if in pretty printing mode.
     * @memberof GeoGlobe.Format.JSON.prototype
     * @returns {String} A string representing a new line.
     * @private
     */
    writeNewline: function() {
        return (this.pretty) ? this.newline : '';
    },
    
    /**
     * Output a string representing a space if in pretty printing mode.
     * @memberof GeoGlobe.Format.JSON.prototype
     * @returns {String} A space.
     * @private
     */
    writeSpace: function() {
        return (this.pretty) ? this.space : '';
    },

    /**
     * \Object with properties corresponding to the serializable data types.
     *     Property values are functions that do the actual serializing.
     * @memberof GeoGlobe.Format.JSON.prototype
     * @type {null}
     * @private
     *
     */
    serialize: {
        /**
         * Transform an object into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Object}object - The object to be serialized.
         * @returns {String} A JSON string representing the object.
         * @private
         */
        'object': function(object) {
            // three special objects that we want to treat differently
            if(object == null) {
                return "null";
            }
            if(object.constructor == Date) {
                return this.serialize.date.apply(this, [object]);
            }
            if(object.constructor == Array) {
                return this.serialize.array.apply(this, [object]);
            }
            var pieces = ['{'];
            this.level += 1;
            var key, keyJSON, valueJSON;
            
            var addComma = false;
            for(key in object) {
                if(object.hasOwnProperty(key)) {
                    // recursive calls need to allow for sub-classing
                    keyJSON = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [key, this.pretty]);
                    valueJSON = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [object[key], this.pretty]);
                    if(keyJSON != null && valueJSON != null) {
                        if(addComma) {
                            pieces.push(',');
                        }
                        pieces.push(this.writeNewline(), this.writeIndent(),
                                    keyJSON, ':', this.writeSpace(), valueJSON);
                        addComma = true;
                    }
                }
            }
            
            this.level -= 1;
            pieces.push(this.writeNewline(), this.writeIndent(), '}');
            return pieces.join('');
        },
        
        /**
         * Transform an array into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Array}array -  The array to be serialized
         * @returns {String} A JSON string representing the array.
         * @private
         */
        'array': function(array) {
            var json;
            var pieces = ['['];
            this.level += 1;
    
            for(var i=0, len=array.length; i<len; ++i) {
                // recursive calls need to allow for sub-classing
                json = GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                    [array[i], this.pretty]);
                if(json != null) {
                    if(i > 0) {
                        pieces.push(',');
                    }
                    pieces.push(this.writeNewline(), this.writeIndent(), json);
                }
            }

            this.level -= 1;    
            pieces.push(this.writeNewline(), this.writeIndent(), ']');
            return pieces.join('');
        },
        
        /**
         *  Transform a string into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {String}string - The string to be serialized
         * @returns {String} A JSON string representing the string.
         * @private
         */
        'string': function(string) {
            // If the string contains no control characters, no quote characters, and no
            // backslash characters, then we can simply slap some quotes around it.
            // Otherwise we must also replace the offending characters with safe
            // sequences.    
            var m = {
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"' : '\\"',
                '\\': '\\\\'
            };
            if(/["\\\x00-\x1f]/.test(string)) {
                return '"' + string.replace(/([\x00-\x1f\\"])/g, function(a, b) {
                    var c = m[b];
                    if(c) {
                        return c;
                    }
                    c = b.charCodeAt();
                    return '\\u00' +
                        Math.floor(c / 16).toString(16) +
                        (c % 16).toString(16);
                }) + '"';
            }
            return '"' + string + '"';
        },

        /**
         *  Transform a number into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Number} number -The number to be serialized.
         * @returns {String} A JSON string representing the number.
         * @private
         */
        'number': function(number) {
            return isFinite(number) ? String(number) : "null";
        },
        
        /**
         * Transform a boolean into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Boolean}bool -  The boolean to be serialized.
         * @returns {String} A JSON string representing the boolean.
         * @private
         */
        'boolean': function(bool) {
            return String(bool);
        },
        
        /**
         * Transform a date into a JSON string.
         * @memberof  GeoGlobe.Format.JSON.prototype
         * @param {Date} date -The date to be serialized.
         * @returns {String} A JSON string representing the date.
         * @private
         */
        'date': function(date) {    
            function format(number) {
                // Format integers to have at least two digits.
                return (number < 10) ? '0' + number : number;
            }
            return '"' + date.getFullYear() + '-' +
                    format(date.getMonth() + 1) + '-' +
                    format(date.getDate()) + 'T' +
                    format(date.getHours()) + ':' +
                    format(date.getMinutes()) + ':' +
                    format(date.getSeconds()) + '"';
        }
    },

    CLASS_NAME: "GeoGlobe.Format.JSON" 

});     
/**
 * @class GeoGlobe.Format.GeoJSON
 * @classdesc  读写GeoJSON。创建一个新的解析器JSON格式化类。
 * 
 */


GeoGlobe.Format.GeoJSON = GeoGlobe.Class4OL(GeoGlobe.Format.JSON, {

    /**
     * ignoreExtraDims- 读取几何时忽略高于2的尺寸。
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @type {Boolean}
     */ 
    ignoreExtraDims: false,
    
    /**
     * 为GeoJSON创建一个新的解析器。
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  反序列化GeoJSON字符串。
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {String}json -  一个GeoJSON字符串
     * @param {String}type -  用于确定输出结构的可选字符串。 支持的值是“Geometry”，
     * “feature”和“FeatureCollection”。 
     * 如果缺失或为空，则假定缺省为“FeatureCollection”。
     * @param {Function} filter - 将在最终结果的每个级别调用每个键和值的函数。 
     * 每个值将被过滤器功能的结果替换。 
     * 这可用于将通用对象改为类的实例，
     * 或将日期字符串转换为Date对象。
     * @returns {Object} 返回值取决于类型参数的值。 
     * 如果type是“FeatureCollection”（默认），则返回将是一个GeoGlobe.Feature数组。 
     * 如果type是“Geometry”，则输入json必须表示单个几何体，并且返回将是GeoGlobe.Geometry。 
     * 如果type是“Feature”，则输入json必须表示一个特征，返回值将是GeoGlobe.Feature。
     */
    read: function(json, type, filter) {
        type = (type) ? type : "FeatureCollection";
        var results = null;
        var obj = null;
        if (typeof json == "string") {
            obj = GeoGlobe.Format.JSON.prototype.read.apply(this,
                                                              [json, filter]);
        } else { 
            obj = json;
        }    
        if(!obj) {
            GeoGlobe.Console.error("Bad JSON: " + json);
        } else if(typeof(obj.type) != "string") {
            GeoGlobe.Console.error("Bad GeoJSON - no type: " + json);
        } else if(this.isValidType(obj, type)) {
            switch(type) {
                case "Geometry":
                    try {
                        results = this.parseGeometry(obj);
                    } catch(err) {
                        GeoGlobe.Console.error(err);
                    }
                    break;
                case "Feature":
                    try {
                        results = this.parseFeature(obj);
                        results.type = "Feature";
                    } catch(err) {
                        GeoGlobe.Console.error(err);
                    }
                    break;
                case "FeatureCollection":
                    // for type FeatureCollection, we allow input to be any type
                    results = [];
                    switch(obj.type) {
                        case "Feature":
                            try {
                                results.push(this.parseFeature(obj));
                            } catch(err) {
                                results = null;
                                GeoGlobe.Console.error(err);
                            }
                            break;
                        case "FeatureCollection":
                            for(var i=0, len=obj.features.length; i<len; ++i) {
                                try {
                                    results.push(this.parseFeature(obj.features[i]));
                                } catch(err) {
                                    results = null;
                                    GeoGlobe.Console.error(err);
                                }
                            }
                            break;
                        default:
                            try {
                                var geom = this.parseGeometry(obj);
                                results.push(new GeoGlobe.Feature(geom));
                            } catch(err) {
                                results = null;
                                GeoGlobe.Console.error(err);
                            }
                    }
                break;
            }
        }
        return results;
    },
    
    /**
     * Check if a GeoJSON object is a valid representative of the given type.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @returns {Boolean} The object is valid GeoJSON object of the given type.
     * @private
     */
    isValidType: function(obj, type) {
        var valid = false;
        switch(type) {
            case "Geometry":
                if(GeoGlobe.Util.indexOf(
                    ["Point", "MultiPoint", "LineString", "MultiLineString",
                     "Polygon", "MultiPolygon", "Box", "GeometryCollection"],
                    obj.type) == -1) {
                    // unsupported geometry type
                    GeoGlobe.Console.error("Unsupported geometry type: " +
                                              obj.type);
                } else {
                    valid = true;
                }
                break;
            case "FeatureCollection":
                // allow for any type to be converted to a feature collection
                valid = true;
                break;
            default:
                // for Feature types must match
                if(obj.type == type) {
                    valid = true;
                } else {
                    GeoGlobe.Console.error("Cannot convert types from " +
                                              obj.type + " to " + type);
                }
        }
        return valid;
    },
    
    /**
     * Convert a feature object from GeoJSON into an
     *     GeoGlobe.Feature.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {Object}obj - An object created from a GeoJSON object
     * @returns {GeoGlobe.Feature} A feature.
     * @private
     */
    parseFeature: function(obj) {
        var feature, geometry, attributes, bbox;
        attributes = (obj.properties) ? obj.properties : {};
        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;
        try {
            geometry = this.parseGeometry(obj.geometry);
        } catch(err) {
            // deal with bad geometries
            throw err;
        }
        feature = new GeoGlobe.Feature(geometry, attributes);
        if(bbox) {
            feature.bounds = GeoGlobe.LngLatBounds.fromArray(bbox);
        }
        if(obj.id) {
            feature.fid = obj.id;
        }
        return feature;
    },
    
    /**
     * Convert a geometry object from GeoJSON into an GeoGlobe.Geometry.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {Object}obj - An object created from a GeoJSON object
     * @returns {GeoGlobe.Geometry} A geometry.
     * @private
     */
    parseGeometry: function(obj) {
        if (obj == null) {
            return null;
        }
        var geometry, collection = false;
        if(obj.type == "GeometryCollection") {
            if(!(GeoGlobe.Util.isArray(obj.geometries))) {
                throw "GeometryCollection must have geometries array: " + obj;
            }
            var numGeom = obj.geometries.length;
            var components = new Array(numGeom);
            for(var i=0; i<numGeom; ++i) {
                components[i] = this.parseGeometry.apply(
                    this, [obj.geometries[i]]
                );
            }
            geometry = new GeoGlobe.Geometry.Collection(components);
            collection = true;
        } else {
            if(!(GeoGlobe.Util.isArray(obj.coordinates))) {
                throw "Geometry must have coordinates array: " + obj;
            }
            if(!this.parseCoords[obj.type.toLowerCase()]) {
                throw "Unsupported geometry type: " + obj.type;
            }
            try {
                geometry = this.parseCoords[obj.type.toLowerCase()].apply(
                    this, [obj.coordinates]
                );
            } catch(err) {
                // deal with bad coordinates
                throw err;
            }
        }
        // We don't reproject collections because the children are reprojected
        // for us when they are created.
        if (this.internalProjection && this.externalProjection && !collection) {
            geometry.transform(this.externalProjection, 
                               this.internalProjection); 
        }                       
        return geometry;
    },
    
    /**
     *Object with properties corresponding to the GeoJSON geometry types.
     *     Property values are functions that do the actual parsing.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @type {null}
     * @private
     */
    parseCoords: {
        /**
         * Convert a coordinate array from GeoJSON into an
         *     GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         *
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "point": function(array) {
            if (this.ignoreExtraDims == false && 
                  array.length != 2) {
                    throw "Only 2D points are supported: " + array;
            }
            return new GeoGlobe.Geometry.Point(array[0], array[1]);
        },
        
        /**
         * Convert a coordinate array from GeoJSON into an
         *   GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "multipoint": function(array) {
            var points = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["point"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                points.push(p);
            }
            return new GeoGlobe.Geometry.MultiPoint(points);
        },

        /**
         *  Convert a coordinate array from GeoJSON into an
            GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "linestring": function(array) {
            var points = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["point"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                points.push(p);
            }
            return new GeoGlobe.Geometry.LineString(points);
        },
        
        /**
         * Convert a coordinate array from GeoJSON into an
         *     GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object}array -  The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "multilinestring": function(array) {
            var lines = [];
            var l = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                lines.push(l);
            }
            return new GeoGlobe.Geometry.MultiLineString(lines);
        },
        
        /**
         * Convert a coordinate array from GeoJSON into an
             GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "polygon": function(array) {
            var rings = [];
            var r, l;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                r = new GeoGlobe.Geometry.LinearRing(l.components);
                rings.push(r);
            }
            return new GeoGlobe.Geometry.Polygon(rings);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
            GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object} array - The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "multipolygon": function(array) {
            var polys = [];
            var p = null;
            for(var i=0, len=array.length; i<len; ++i) {
                try {
                    p = this.parseCoords["polygon"].apply(this, [array[i]]);
                } catch(err) {
                    throw err;
                }
                polys.push(p);
            }
            return new GeoGlobe.Geometry.MultiPolygon(polys);
        },

        /**
         * Convert a coordinate array from GeoJSON into an
             GeoGlobe.Geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {Object} array - The coordinates array from the GeoJSON fragment.
         * @returns {GeoGlobe.Geometry} A geometry.
         * @private
         */
        "box": function(array) {
            if(array.length != 2) {
                throw "GeoJSON box coordinates must have 2 elements";
            }
            return new GeoGlobe.Geometry.Polygon([
                new GeoGlobe.Geometry.LinearRing([
                    new GeoGlobe.Geometry.Point(array[0][0], array[0][1]),
                    new GeoGlobe.Geometry.Point(array[1][0], array[0][1]),
                    new GeoGlobe.Geometry.Point(array[1][0], array[1][1]),
                    new GeoGlobe.Geometry.Point(array[0][0], array[1][1]),
                    new GeoGlobe.Geometry.Point(array[0][0], array[0][1])
                ])
            ]);
        }

    },

    /**
     * 将要素，几何图形和要素数组序列化为GeoJSON字符串。
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {Object}obj -  GeoGlobe.Feature，GeoGlobe.Geometry，或一系列功能。
     * @param {Boolean}pretty - 用换行符和缩进结构化输出。 默认为false。
     * @returns {String} 输入几何体，要素或要素阵列的GeoJSON字符串表示形式。
     */
    write: function(obj, pretty) {
        var geojson = {
            "type": null
        };
        if(GeoGlobe.Util.isArray(obj)) {
            geojson.type = "FeatureCollection";
            var numFeatures = obj.length;
            geojson.features = new Array(numFeatures);
            for(var i=0; i<numFeatures; ++i) {
                var element = obj[i];
                if(!element instanceof GeoGlobe.Feature) {
                    var msg = "FeatureCollection only supports collections " +
                              "of features: " + element;
                    throw msg;
                }
                geojson.features[i] = this.extract.feature.apply(
                    this, [element]
                );
            }
        } else if (obj.CLASS_NAME.indexOf("GeoGlobe.Geometry") == 0) {
            geojson = this.extract.geometry.apply(this, [obj]);
        } else if (obj instanceof GeoGlobe.Feature) {
            geojson = this.extract.feature.apply(this, [obj]);
            if(obj.layer && obj.layer.projection) {
                geojson.crs = this.createCRSObject(obj);
            }
        }
        return GeoGlobe.Format.JSON.prototype.write.apply(this,
                                                            [geojson, pretty]);
    },

    /**
     *  Create the CRS object for an object.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @param {GeoGlobe.Feature} object -
     * @returns {Object} An object which can be assigned to the crs property
     * @private
     */
    createCRSObject: function(object) {
       var proj = object.layer.projection.toString();
       var crs = {};
       if (proj.match(/epsg:/i)) {
           var code = parseInt(proj.substring(proj.indexOf(":") + 1));
           if (code == 4326) {
               crs = {
                   "type": "name",
                   "properties": {
                       "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
                   }
               };
           } else {    
               crs = {
                   "type": "name",
                   "properties": {
                       "name": "EPSG:" + code
                   }
               };
           }    
       }
       return crs;
    },
    
    /**
     * extract Object with properties corresponding to the GeoJSON types.
       Property values are functions that do the actual value extraction.
     * @memberof GeoGlobe.Format.GeoJSON.prototype
     * @type {null}
     * @private
     */
    extract: {
        /**
         *  Return a partial GeoJSON object representing a single feature.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         *@param {GeoGlobe.Feature}feature -
         *
         *@returns {Object} An object representing the point.
         *@private
         */
        'feature': function(feature) {
            var geom = this.extract.geometry.apply(this, [feature.geometry]);
            var json = {
                "type": "Feature",
                "properties": feature.attributes,
                "geometry": geom
            };
            if (feature.fid != null) {
                json.id = feature.fid;
            }
            return json;
        },
        
        /**
         * Return a GeoJSON object representing a single geometry.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry}geometry
         * @returns {Object} An object representing the geometry.
         * @private
         */
        'geometry': function(geometry) {
            if (geometry == null) {
                return null;
            }
            if (this.internalProjection && this.externalProjection) {
                geometry = geometry.clone();
                geometry.transform(this.internalProjection, 
                                   this.externalProjection);
            }                       
            var geometryType = geometry.CLASS_NAME.split('.')[2];
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);
            var json;
            if(geometryType == "Collection") {
                json = {
                    "type": "GeometryCollection",
                    "geometries": data
                };
            } else {
                json = {
                    "type": geometryType,
                    "coordinates": data
                };
            }
            
            return json;
        },

        /**
         * Return an array of coordinates from a point.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.Point}point -
         * @returns {Array} An array of coordinates representing the point.
         * @private
         */
        'point': function(point) {
            return [point.x, point.y];
        },

        /**
         * Return an array of point coordinates from a multipoint.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.MultiPoint}multipoint -
         *
         * @returns {Array} An array of point coordinate arrays representing
         *     the multipoint.
         * @private
         */
        'multipoint': function(multipoint) {
            var array = [];
            for(var i=0, len=multipoint.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));
            }
            return array;
        },
        
        /**
         * Return an array of coordinate arrays from a linestring.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.LineString}linestring -
         * @returns {Array} An array of coordinate arrays representing
         *     the linestring.
         * @private
         */
        'linestring': function(linestring) {
            var array = [];
            for(var i=0, len=linestring.components.length; i<len; ++i) {
                array.push(this.extract.point.apply(this, [linestring.components[i]]));
            }
            return array;
        },

        /**
         * Return an array of linestring arrays from a linestring.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.MultiLineString}multilinestring -
         * @returns {Array} An array of linestring arrays representing
         *     the multilinestring.
         * @private
         */
        'multilinestring': function(multilinestring) {
            var array = [];
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));
            }
            return array;
        },
        
        /**
         * Return an array of linear ring arrays from a polygon.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.Polygon}polygon -
         * @returns {Array} An array of linear ring arrays representing the polygon.
         * @private
         */
        'polygon': function(polygon) {
            var array = [];
            for(var i=0, len=polygon.components.length; i<len; ++i) {
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));
            }
            return array;
        },

        /**
         * Return an array of polygon arrays from a multipolygon.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.MultiPolygon}multipolygon -
         * @returns {Array} An array of polygon arrays representing
         *     the multipolygon
         * @private
         */
        'multipolygon': function(multipolygon) {
            var array = [];
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {
                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));
            }
            return array;
        },
        
        /**
         *  Return an array of geometries from a geometry collection.
         * @memberof GeoGlobe.Format.GeoJSON.prototype
         * @param {GeoGlobe.Geometry.Collection}collection -
         * @returns {Array} An array of geometry objects representing the geometry
         *     collection.
         * @private
         */
        'collection': function(collection) {
            var len = collection.components.length;
            var array = new Array(len);
            for(var i=0; i<len; ++i) {
                array[i] = this.extract.geometry.apply(
                    this, [collection.components[i]]
                );
            }
            return array;
        }
        

    },

    CLASS_NAME: "GeoGlobe.Format.GeoJSON" 

});     
/**
 * @class  GeoGlobe.Format.VTS
 * @classdesc 根据矢量瓦片服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建矢量瓦片服务数据源source和图层layer。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.VTS = GeoGlobe.Class4OL({

    /**
     * GeoGlobe.Format.VTS构造函数。
     * @memberof  GeoGlobe.Format.VTS.prototype
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },
    /**
     * 获取矢量瓦片服务 capabilities的XML文档信息
     * @memberof GeoGlobe.Format.VTS.prototype
     * @param {string} url - 服务的请求串。
     */
    getVTSCapabilities: function(url){
        this.url = url;
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.VTSCapabilities.v1_0_0();
                capabilities = format.read(data);
            },
            function(){
                alert("VTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //VTSLayer = new OpenLayers.Layer.VTS({url:url});
            });
        return capabilities;
    },
    /**
     * 根据矢量瓦片服务地址url获取服务能力信息。
     *  @memberof GeoGlobe.Format.VTS.prototype
     *  @param {String} url - 矢量瓦片服务地址
     *  @param {Function} successFn-成功回调函数
     *  @param {Function} failFn-失败回调函数
     *  @private
     */
    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("VTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },

    /**
     * 根据矢量瓦片服务地址url创建图层选项信息。
     *  @memberof GeoGlobe.Format.VTS.prototype
     *  @param {String} url-矢量瓦片服务地址
     *  @param {Object} capabilities-服务能力信息
     *  @param {Object} config-配置项
     *  @private
     */
    createLayerOption: function(url, capabilities, config){
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;
        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }
        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                        ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }
        var styleName =[];
        if(config.styleName && config.styleName !=""){
            styleName[0] = config.styleName;
        }else{
            this.GetStyleName(function(result){
                styleName = result
            });
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                        (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
            (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink,
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }
        /*
         var url;
         if (requestEncoding === "REST" && layerDef.resourceUrls) {
         url = [];
         var resourceUrls = layerDef.resourceUrls,
         resourceUrl;
         for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
         resourceUrl = layerDef.resourceUrls[t];
         if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
         url.push(resourceUrl.template);
         }
         }
         } else {
         var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
         url = [];
         var constraint;
         for (var i = 0, ii = httpGet.length; i < ii; i++) {
         constraint = httpGet[i].constraints;
         if (!constraint || (constraint && constraint.
         GetEncoding.allowedValues[requestEncoding])) {
         url.push(httpGet[i].url);
         }
         }
         }
         */
        resolutions.sort(function(a,b){
            return b-a;
        });

        var vts_url = "";
        var layerOption = {
            "layers":[],
            "source":{},
            "source_id":"",
            "url":"",
            "url_tmpl":"",
            "layerType":"VTS"
        };
        //var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        var param = this.getParameterString({
            "SERVICE": "WMTS",
            "REQUEST": "GetTile",
            "VERSION": capabilities.version,
            "LAYER": layerDef.identifier,
            //"STYLE": style.identifier,
            "TILEMATRIXSET": matrixSet.identifier,
            "FORMAT": "protobuf",
            "TILEMATRIX": "{z}",
            "TILEROW": "{y}",
            "TILECOL": "{x}"
        });
        layerOption.url =url;

        if(url.endsWith("?")){
            vts_url = GeoGlobe.ProxyHost + url + param;
        }else{
            vts_url = GeoGlobe.ProxyHost + url + "?" + param;
        }
        layerOption.url_tmpl =vts_url;
        //vts_url = GeoGlobe.Request.makeSameOrigin(vts_url, GeoGlobe.ProxyHost);
        /*
         var options= GeoGlobe.Util.applyDefaults(config, {
         id:layerDef.identifier,
         url:[vts_url]
         });
         var vtsLayer = new GeoGlobe.Layer.VTS(options);
         vtsLayer.matrixSet = matrixSet;
         */

        var randomNum = GeoGlobe.Util.randomStr(10);
        /*
         var layerOption = {
         source:{
         "id": "source_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "tiles": [vts_url],
         "tileSize": 256
         },
         layers:[{
         "id": "layer_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "source": "source_" + layerDef.identifier + "_" + randomNum,
         "paint": {
         "raster-opacity": 1
         }
         }]
         };
         */

        if(layerDef.bounds){
            var bbox = [layerDef.bounds._sw.lng,layerDef.bounds._sw.lat,layerDef.bounds._ne.lng,layerDef.bounds._ne.lat];
        }else if(layerDef.BoundingBox){
            var bbox = layerDef.BoundingBox[0].bounds.toBBOX();
        }
        var link = layerDef.tileMatrixSetLinks[0].tileMatrixSet;
        var zoomoffset =contents.tileMatrixSets[link].matrixIds[0].identifier;

        this.GetStyle(styleName[0], function(result){
                if(result.sprite){
                    var sprite = GeoGlobe.ProxyHost+result.sprite;
                }else{
                    var sprite = "";
                }
                if(result.glyphs){
                    var glyphs = GeoGlobe.ProxyHost+result.glyphs;
                }else{
                    var glyphs = "";
                }
                //扩展图层的字段
                var metadata = {
                    "name": layerDef.identifier,
                    "sprite":sprite,
                    "glyphs":glyphs,
                    "styleName":result.styleName,
                    "srs": projection,
                    "bbox": bbox,
                    "format":layerDef.formats,
                    "zoomoffset":zoomoffset
                };
                var source_id = "source_vts_"+GeoGlobe.Util.randomStr(6);
                layerOption.source_id = source_id;
                layerOption.source ={
                    "type": "vector",
                    "tiles": [vts_url]
                };
                if(result.styleData){
                    for(var i=0;i<result.styleData.layers.length;i++){
                        result.styleData.layers[i].metadata = metadata;
                        result.styleData.layers[i].source =source_id;
                        layerOption.layers[i] =  result.styleData.layers[i];
                    }
                }else{
                    for(var i=0;i<result.layers.length;i++){
                        result.layers[i].metadata = metadata;
                        result.layers[i].source =source_id;
                        layerOption.layers[i] =  result.layers[i];
                    }
                }

            },
            function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
            });
        //var layerOption = {
        //    "id": "layer_" + layerDef.identifier + "_" + randomNum,
        //    "type": "raster",
        //    "source": {
        //        "type": "raster",
        //        "tiles": [vts_url],
        //        "tileSize": 256
        //    },
        //    "metadata":metadata,
        //    "paint": {
        //        "raster-opacity": 1
        //    }
        //};
        return layerOption;
    },
    /*
     //test
     createLayerOptions: function(url){
     var cap = this.getVTSCapabilities(url);
     var layers = cap.contents.layers;
     var layerOptions = [];
     for(var i = 0; i < layers.length; i++){
     var config = {layer: layers[i].identifier};
     var vtsOpt = this.createLayerOption(url, cap, config);
     layerOptions.push(vtsOpt);
     }
     return layerOptions;
     },
     */
    /**
     * 获取多个图层信息。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {string} url - 服务的请求串。
     * @param  {object} options- 放置请求的图层名称和样式名称
     * @param {string} layer - 图层名称，若不填，默认第一个
     * @param {string} styleName -  样式名称，若不填，默认第一个
     */
    createLayer: function(url,options){
        var cap = this.getVTSCapabilities(url);
        options = options ? options : {};
        options.layer = options.layer ? options.layer : cap.contents.layers[0].identifier;
        options.styleName = options.styleName ? options.styleName : "";
        var layerOption = this.createLayerOption(url, cap, options);
        return layerOption;
    },
    /**
     * 获取多个图层信息。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {string} url - 服务的请求串。
     */
    createLayers: function(url){
        var cap = this.getVTSCapabilities(url);
        var layers = cap.contents.layers;
        var layerOptions = [];
        for(var i = 0; i < layers.length; i++){
            var config = {layer: layers[i].identifier};
            var vtsOpt = this.createLayerOption(url, cap, config);
            layerOptions.push(vtsOpt);
        }
        return layerOptions;
    },

    /**
     * 获取样式名称。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {Function}successFn - 请求成功的回调函数。
     * @param {Function}  failFn -请求失败的回调函数。
     */
    GetStyleName: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(result){
                var obj = result.responseText;
                if(!obj){
                    failFn();
                    return false;
                }
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                var styleName =[];
                if(geojson.style){
                    for(var n =0;n <geojson.style.length;n++){
                        styleName.push(geojson.style[n].styleName);
                    }
                }else if(geojson.styleName){
                    for(var s = 0; s < geojson.styleName.length;s++){
                        styleName.push(geojson.styleName[s]);
                    }
                }

                //var style = geojson.style[0];
                successFn(styleName);
            },
            failure: failFn
        });
    },
    /**
     * 获取样式数据（用json描述）。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {Function}successFn -  请求成功的回调函数。
     * @param {Function}  failFn - 请求失败的回调函数。
     */
    GetStyle: function(styleName,successFn, failFn){
        var url = this.url;
        if(styleName =="" || styleName == undefined){
            alert("请查看样式名称是否存在");
            return ;
        }
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0",
            STYLENAME:styleName
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(result){
                var obj = result.responseText;
                if(!obj){
                    failFn();
                    return false;
                }
                var jformat = new GeoGlobe.Format.JSON();
                var style = jformat.read(obj);
                //var style = geojson.style[0];
                successFn(style);
            },
            failure: failFn
        });
    },
    /**
     * 获取参数字符串。
     * @memberof  GeoGlobe.Format.VTS.prototype
     * @param {Object} params - 参数对象。
     * @returns {String} 参数字符串。
     *
     */
    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");

    },

    CLASS_NAME: "GeoGlobe.Format.VTS"
});
/**
 * @class GeoGlobe.Format.WMTS
 * @classdesc 根据网络地图切片服务url，获取服务信息，解析后得到图层配置参数，构建网络切片地图服务的数据源和图层。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.WMTS = GeoGlobe.Class4OL({

    /**
     * GeoGlobe.Format.WMTS构造函数。
     * @memberof  GeoGlobe.Format.WMTS.prototype
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },
    /**
     * 获取网络切片地图服务信息的XML文档信息
     * @memberOf GeoGlobe.Format.WMTS.prototype
     * @param {string} url - 网络切片地图的服务地址
     * @returns {object} 网络切片地图的服务能力信息
     */
    getWMTSCapabilities: function(url){
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.WMTSCapabilities.v1_0_0();
                capabilities = format.read(data);
            },
            function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
            });
        return capabilities;
    },
    /**
     * 根据网络切片地图的服务地址url获取服务能力信息。
     *  @memberof GeoGlobe.Format.WMTS.prototype
     *  @param {String} url-WMTS服务地址
     *  @param {Function} successFn-成功回调函数
     *  @param {Function} failFn-失败回调函数
     *  @private
     */
    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },

    //test
    /**
     * 根据WMTS服务地址url创建图层选项信息。
     *  @memberof GeoGlobe.Format.WMTS.prototype
     *  @param {String} url-WMTS服务地址
     *  @param {Object} capabilities-服务能力信息
     *  @param {Object} config-配置项
     *  @private
     */ 
    createLayerOption: function(url, capabilities, config){
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;
        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }
        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                        ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                        (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
            (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }
        /*
         var url;
         if (requestEncoding === "REST" && layerDef.resourceUrls) {
         url = [];
         var resourceUrls = layerDef.resourceUrls,
         resourceUrl;
         for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
         resourceUrl = layerDef.resourceUrls[t];
         if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
         url.push(resourceUrl.template);
         }
         }
         } else {
         var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
         url = [];
         var constraint;
         for (var i = 0, ii = httpGet.length; i < ii; i++) {
         constraint = httpGet[i].constraints;
         if (!constraint || (constraint && constraint.
         GetEncoding.allowedValues[requestEncoding])) {
         url.push(httpGet[i].url);
         }
         }
         }
         */
        resolutions.sort(function(a,b){
            return b-a;
        });

        var wmts_url = "";
        //var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        var param = this.getParameterString({
            "SERVICE": "WMTS",
            "REQUEST": "GetTile",
            "VERSION": capabilities.version,
            "LAYER": layerDef.identifier,
            "STYLE": style.identifier,
            "TILEMATRIXSET": matrixSet.identifier,
            "FORMAT": format,
            "TILEMATRIX": "{z}",
            "TILEROW": "{y}",
            "TILECOL": "{x}"
        });
        if(url.endsWith("?")){
            wmts_url = GeoGlobe.ProxyHost + url + param;
        }else{
            wmts_url = GeoGlobe.ProxyHost + url + "?" + param;
        }
        //wmts_url = GeoGlobe.Request.makeSameOrigin(wmts_url, GeoGlobe.ProxyHost);
        /*
         var options= GeoGlobe.Util.applyDefaults(config, {
         id:layerDef.identifier,
         url:[wmts_url]
         });
         var wmtsLayer = new GeoGlobe.Layer.WMTS(options);
         wmtsLayer.matrixSet = matrixSet;
         */

        var randomNum = GeoGlobe.Util.randomStr(10);
        /*
         var layerOption = {
         source:{
         "id": "source_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "tiles": [wmts_url],
         "tileSize": 256
         },
         layers:[{
         "id": "layer_" + layerDef.identifier + "_" + randomNum,
         "type": "raster",
         "source": "source_" + layerDef.identifier + "_" + randomNum,
         "paint": {
         "raster-opacity": 1
         }
         }]
         };
         */

        if(layerDef.bounds){
            var bbox = [layerDef.bounds._sw.lng,layerDef.bounds._sw.lat,layerDef.bounds._ne.lng,layerDef.bounds._ne.lat];

        }else if(layerDef.BoundingBox){
            var bbox = layerDef.BoundingBox[0].bounds.toBBOX();
        }
        var link = layerDef.tileMatrixSetLinks[0].tileMatrixSet;
        var zoomoffset =contents.tileMatrixSets[link].matrixIds[0].identifier;
        //扩展图层的字段
        var metadata = {
            "name": layerDef.identifier,
            "srs": projection,
            "bbox": bbox,
            "format":layerDef.formats,
            "zoomoffset":zoomoffset
        };
        var layerOption = {
            "id": "layer_" + layerDef.identifier + "_" + randomNum,
            "type": "raster",
            "source": {
                "type": "raster",
                "tiles": [wmts_url],
                "tileSize": 256
            },
            "metadata":metadata,
            "paint": {
                "raster-opacity": 1
            }
        };
        return layerOption;
    },
    /*
     //test
     createLayerOptions: function(url){
     var cap = this.getWMTSCapabilities(url);
     var layers = cap.contents.layers;
     var layerOptions = [];
     for(var i = 0; i < layers.length; i++){
     var config = {layer: layers[i].identifier};
     var wmtsOpt = this.createLayerOption(url, cap, config);
     layerOptions.push(wmtsOpt);
     }
     return layerOptions;
     },
     */
    /**
     * 获取单个图层信息。
     * @memberof  GeoGlobe.Format.WMTS.prototype
     * @param {string} url - 服务的请求串。
     * @param   {object} options -放置请求服务的信息
     */
    createLayer: function(url,options){
        var cap = this.getWMTSCapabilities(url);
        if(options){
            var config = {layer: options.layer};

        }else{
            var config = {layer: cap.contents.layers[0].identifier};
        }
        var layerOption = this.createLayerOption(url, cap, config);
        return layerOption;
    },
    /**
     * 获取多个图层信息。
     * @memberof  GeoGlobe.Format.WMTS.prototype
     * @param {string} url - 服务的请求串。
     */
    createLayers: function(url){
        var cap = this.getWMTSCapabilities(url);
        var layers = cap.contents.layers;
        var layerOptions = [];
        for(var i = 0; i < layers.length; i++){
            var config = {layer: layers[i].identifier};
            var wmtsOpt = this.createLayerOption(url, cap, config);
            layerOptions.push(wmtsOpt);
        }
        return layerOptions;
    },

    /**
     * 获取参数字符串
     * @memberof  GeoGlobe.Format.WMTS.prototype
     * @param {Object} params-参数数组
     * @returns {String} 参数字符串
     * @private
     */
    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },

    CLASS_NAME: "GeoGlobe.Format.WMTS"
});
﻿/**
 * @class GeoGlobe.Format.WMS
 * @classdesc 根据网络地图服务url，获取服务信息，解析后得到图层配置参数，构建网络地图服务的数据源和图层。
 * 使用此工具前，请先验证服务接口是否正常。
 */
GeoGlobe.Format.WMS = GeoGlobe.Class4OL({

    /**
     * GeoGlobe.Format.WMS构造函数。
     * @memberof  GeoGlobe.Format.WMS.prototype
     */
    initialize: function(options){
        GeoGlobe.Util.extend(this, options);
    },
    /**
     * 获取网络地图服务服务信息的XML文档信息
     * @memberof  GeoGlobe.Format.WMS.prototype
     * @param {String} url - WMS服务地址
     * @returns {Object} 网络地图服务的的XML文档信息。
     */
    getWMSCapabilities: function(url){
        var capabilities = null;
        this.getCapabilities(url, function(result){
                //响应返回capabilities的XML文档信息
                var data = result.responseXML;
                if (!data || !data.documentElement) {
                    data = result.responseText;
                }
                var format = new GeoGlobe.Format.WMSCapabilities.v1_1_1();
                capabilities = format.read(data);
            },
            function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
                //wmsLayer = new OpenLayers.Layer.WMS({url:url});
            });
        return capabilities;
    },
    /**
     * 根据网络地图服务的地址url获取服务能力信息。
     *  @memberof GeoGlobe.Format.WMS.prototype
     *  @param {String} url-网络地图服务的地址
     *  @param {Function} successFn-成功回调函数
     *  @param {Function} failFn-失败回调函数
     *  @private
     */
    getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMS",
            VERSION:"1.1.1"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
    //test
    /**
     * 根据WMS服务地址url创建图层选项信息。
     *  @memberof GeoGlobe.Format.WMS.prototype
     *  @param {String} url-WMS服务地址
     *  @param {Object} capabilities-服务能力信息
     *  @param {Object} config-配置项
     *  @private
     */    
    createLayerOption: function(url, capabilities, config){
        var layer;
        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }
        var contents = capabilities.capability;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].name === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }

        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            for(var f = 0; f < layerDef.formats.length; f++){
                if(layerDef.formats[f] == "image/png"){
                    format = layerDef.formats[f];
                }
            }
            if(format !="image/png"){
                format = layerDef.formats[0];
            }
        }

        var styles = config.styles;
        if (!styles && layerDef.styles && layerDef.styles.length) {
            styles = layerDef.styles[0].name;
        }

        var srs = eval(layerDef.srs);
        var SRS;
        for(var o in srs){
            SRS = o;
        }

        var wms_url = "";
		 var transparent = config.transparent;
        //var param = "SERVICE=WMS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
        //GeoGlobe.Util.getParameterString(param);
        if(config.isTile){
            var param = this.getParameterString({
                "SERVICE": "WMS",
                "REQUEST": "GetMap",
                "VERSION": "1.1.1",
                "LAYERS": layerDef.name,
                "styles":styles,
                "FORMAT": format,
 		"TRANSPARENT":transparent,
                "BBOX": "{bbox-epsg-3857}",
                "WIDTH": "256",
                "HEIGHT": "256",
                "SRS":SRS
            });
            if(url.endsWith("?")){
                wms_url = url + param;
            }else{
                wms_url = url + "?" + param;
            }
            wms_url = GeoGlobe.appendToProxy(wms_url);
            //wms_url = GeoGlobe.Request.makeSameOrigin(wms_url, GeoGlobe.ProxyHost);
            /*
             var options= GeoGlobe.Util.applyDefaults(config, {
             id:layerDef.identifier,
             url:[wms_url]
             });
             var wmsLayer = new GeoGlobe.Layer.WMS(options);
             wmsLayer.matrixSet = matrixSet;
             */

            var randomNum = GeoGlobe.Util.randomStr(10);
            /*
             var layerOption = {
             source:{
             "id": "source_" + layerDef.identifier + "_" + randomNum,
             "type": "raster",
             "tiles": [wms_url],
             "tileSize": 256
             },
             layers:[{
             "id": "layer_" + layerDef.identifier + "_" + randomNum,
             "type": "raster",
             "source": "source_" + layerDef.identifier + "_" + randomNum,
             "paint": {
             "raster-opacity": 1
             }
             }]
             };
             */
            //扩展图层的字段
            var metadata = {
                "name": layerDef.name,
                "srs": SRS,
                "bbox": layerDef.bbox,
                "format":format
            };
            var layerOption = {
                "id": "layer_" + layerDef.name + "_" + randomNum,
                "type": "raster",
                "source": {
                    "type": "raster",
                    "tiles": [wms_url],
                    "tileSize": 256
                },
                "metadata":metadata,
                "paint": {
                    "raster-opacity": 1
                }
            };
            return layerOption;
        }else{

            //根据参数添加wmts图层
             layerOption = new GeoGlobe.Layer.WMS({
                url: url,//地址
                layer: layerDef.name,//图层标识
                format: format,//格式
                version:"1.1.1",
//        tileSize: 256,
                SRS:SRS,
                 styles:styles,
                bbox:layerDef.bbox ,//图层范围
                isTile:false
            });
            return layerOption;

        }

    },
    /**
     * 获取单个图层信息。
     * @memberof  GeoGlobe.Format.WMS.prototype
     * @param {string} url - 服务的请求串。
     * @param  {object} options -放置请求服务的信息。
     * @param {boolean} isTile -是否以瓦片大小方式去请求。
     */
    createLayer: function(url,options,isTile){
    	this.url = url;
    	options = options ? options : {};
        isTile = (isTile === undefined || isTile) ? true : false;
        var transparent = (options && options.transparent === undefined || options.transparent) ? true : false;
        var cap = this.getWMSCapabilities(url);
        var layer = (options && options.layer) ? options.layer : cap.capability.layers[0].name;
        var config = {layer: layer,transparent:transparent ,isTile:isTile};
        var layerOption = this.createLayerOption(url, cap, config);
        return layerOption;


    },
	    /**
     * 获取多个图层信息。
     * @memberof  GeoGlobe.Format.WMS.prototype
     * @param {string} url - 服务的请求串。
     * @param {boolean} isTile - 是否以瓦片大小方式去请求。
     */
   createLayers: function(url,options,isTile){
	   	options = options ? options : {};
		isTile = (isTile === undefined || isTile) ? true : false;
		var transparent = (options && options.transparent === undefined || options.transparent) ? true : false;
		var cap = this.getWMSCapabilities(url);
		var layers = cap.capability.layers;
		var layerOptions = [];
		for(var i = 0; i < layers.length; i++){
		    var config = {layer: layers[i].name,transparent:transparent ,isTile:isTile};
		    var wmsOpt = this.createLayerOption(url, cap, config);
		    layerOptions.push(wmsOpt);
		}
		return layerOptions;
    },
    /**
     * 获取参数字符串
     * @memberof  GeoGlobe.Format.WMS.prototype
     * @param {Object}params-参数对象
     * @returns {String} 参数字符串
     * @private
     */
    getParameterString: function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
        return paramsArray.join("&");
    },

    CLASS_NAME: "GeoGlobe.Format.WMS"
});
/**
 * @class  GeoGlobe.Format.WMSCapabilities
 * @classdesc   阅读WMS功能。
 * @returns {Array} 命名图层列表。
 * @private
 */

GeoGlobe.Format.WMSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * defaultVersion-如果没有找到版本号， 默认值是“1.1.1”。
     * @memberof GeoGlobe.Format.WMSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.1.1",
    
    /**
     * 配置文件 - 如果提供，使用自定义配置文件。
     * 目前支持的配置：
     *- WMSC - 解析WMS-C的提供的特定功能。
     * @memberof GeoGlobe.Format.WMSCapabilities.prototype
     * @type {String}

     */
      profile:null,
    
    /**
     * 为WMS功能创建一个新的分析器。
     * @memberof GeoGlobe.Format.WMSCapabilities.prototype
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  读取功能数据，并返回一个图层列表。
     * @memberof GeoGlobe.Format.WMSCapabilities.prototype
     * @param {String| DOMElement}  data -数据读取/解析。
     */
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities" 

});
/**
 * @class GeoGlobe.Format.WMSCapabilities.v1
 * @classdesc   抽象类不要直接实例化。为WMS 1.1.X和WMS 1.3.X创建公共部分。
 * @returns {Array} 命名图层列表。
 */

GeoGlobe.Format.WMSCapabilities.v1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {
    
    /**
     * namespaces-Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        wms: "http://www.opengis.net/wms",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * @memberof   GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @type {null}
     * @private
     */
    defaultPrefix: "wms",
    
    /**
     * 创建其中一个子类的实例。
     * @memberof   GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @param {Object} options -  一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 从字符串读取功能数据，并返回一个图层列表。
     * @memberof   GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @param {String|DOMElement}  data -数据读取/解析。

     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var raw = data;
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        if (capabilities.service === undefined) {
            // an exception must have occurred, so parse it
            var parser = new GeoGlobe.Format.OGCExceptionReport();
            capabilities.error = parser.read(raw);
        }
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WMSCapabilities.v1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": {
            "Service": function(node, obj) {
                obj.service = {};
                this.readChildNodes(node, obj.service);
            },
            "Name": function(node, obj) {
                obj.name = this.getChildValue(node);
            },
            "Title": function(node, obj) {
                obj.title = this.getChildValue(node);
            },
            "Abstract": function(node, obj) {
                obj["abstract"] = this.getChildValue(node);
            },
            "BoundingBox": function(node, obj) {
                var bbox = {};
                bbox.bbox = [
                    parseFloat(node.getAttribute("minx")),
                    parseFloat(node.getAttribute("miny")),
                    parseFloat(node.getAttribute("maxx")),
                    parseFloat(node.getAttribute("maxy"))
                ];
                var res = {
                    x: parseFloat(node.getAttribute("resx")),
                    y: parseFloat(node.getAttribute("resy"))
                };

                if (! (isNaN(res.x) && isNaN(res.y))) {
                    bbox.res = res;
                }
                // return the bbox so that descendant classes can set the
                // CRS and SRS and add it to the obj
                return bbox;
            },
            "OnlineResource": function(node, obj) {
                obj.href = this.getAttributeNS(node, this.namespaces.xlink, 
                    "href");
            },
            "ContactInformation": function(node, obj) {
                obj.contactInformation = {};
                this.readChildNodes(node, obj.contactInformation);
            },
            "ContactPersonPrimary": function(node, obj) {
                obj.personPrimary = {};
                this.readChildNodes(node, obj.personPrimary);
            },
            "ContactPerson": function(node, obj) {
                obj.person = this.getChildValue(node);
            },
            "ContactOrganization": function(node, obj) {
                obj.organization = this.getChildValue(node);
            },
            "ContactPosition": function(node, obj) {
                obj.position = this.getChildValue(node);
            },
            "ContactAddress": function(node, obj) {
                obj.contactAddress = {};
                this.readChildNodes(node, obj.contactAddress);
            },
            "AddressType": function(node, obj) {
                obj.type = this.getChildValue(node);
            },
            "Address": function(node, obj) {
                obj.address = this.getChildValue(node);
            },
            "City": function(node, obj) {
                obj.city = this.getChildValue(node);
            },
            "StateOrProvince": function(node, obj) {
                obj.stateOrProvince = this.getChildValue(node);
            },
            "PostCode": function(node, obj) {
                obj.postcode = this.getChildValue(node);
            },
            "Country": function(node, obj) {
                obj.country = this.getChildValue(node);
            },
            "ContactVoiceTelephone": function(node, obj) {
                obj.phone = this.getChildValue(node);
            },
            "ContactFacsimileTelephone": function(node, obj) {
                obj.fax = this.getChildValue(node);
            },
            "ContactElectronicMailAddress": function(node, obj) {
                obj.email = this.getChildValue(node);
            },
            "Fees": function(node, obj) {
                var fees = this.getChildValue(node);
                if (fees && fees.toLowerCase() != "none") {
                    obj.fees = fees;
                }
            },
            "AccessConstraints": function(node, obj) {
                var constraints = this.getChildValue(node);
                if (constraints && constraints.toLowerCase() != "none") {
                    obj.accessConstraints = constraints;
                }
            },
            "Capability": function(node, obj) {
                obj.capability = {
                    nestedLayers: [],
                    layers: []
                };
                this.readChildNodes(node, obj.capability);
            },
            "Request": function(node, obj) {
                obj.request = {};
                this.readChildNodes(node, obj.request);
            },
            "GetCapabilities": function(node, obj) {
                obj.getcapabilities = {formats: []};
                this.readChildNodes(node, obj.getcapabilities);
            },
            "Format": function(node, obj) {
                if (GeoGlobe.Util.isArray(obj.formats)) {
                    obj.formats.push(this.getChildValue(node));
                } else {
                    obj.format = this.getChildValue(node);
                }
            },
            "DCPType": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "HTTP": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Get": function(node, obj) {
                obj.get = {};
                this.readChildNodes(node, obj.get);
                // backwards compatibility
                if (!obj.href) {
                    obj.href = obj.get.href;
                }
            },
            "Post": function(node, obj) {
                obj.post = {};
                this.readChildNodes(node, obj.post);
                // backwards compatibility
                if (!obj.href) {
                    obj.href = obj.get.href;
                }
            },
            "GetMap": function(node, obj) {
                obj.getmap = {formats: []};
                this.readChildNodes(node, obj.getmap);
            },
            "GetFeatureInfo": function(node, obj) {
                obj.getfeatureinfo = {formats: []};
                this.readChildNodes(node, obj.getfeatureinfo);
            },
            "Exception": function(node, obj) {
                obj.exception = {formats: []};
                this.readChildNodes(node, obj.exception);
            },
            "Layer": function(node, obj) {
                var parentLayer, capability;
                if (obj.capability) {
                    capability = obj.capability;
                    parentLayer = obj;
                } else {
                    capability = obj;
                }
                var attrNode = node.getAttributeNode("queryable");
                var queryable = (attrNode && attrNode.specified) ? 
                    node.getAttribute("queryable") : null;
                attrNode = node.getAttributeNode("cascaded");
                var cascaded = (attrNode && attrNode.specified) ?
                    node.getAttribute("cascaded") : null;
                attrNode = node.getAttributeNode("opaque");
                var opaque = (attrNode && attrNode.specified) ?
                    node.getAttribute('opaque') : null;
                var noSubsets = node.getAttribute('noSubsets');
                var fixedWidth = node.getAttribute('fixedWidth');
                var fixedHeight = node.getAttribute('fixedHeight');
                var parent = parentLayer || {},
                    extend = GeoGlobe.Util.extend;
                var layer = {
                    nestedLayers: [],
                    styles: parentLayer ? [].concat(parentLayer.styles) : [],
                    srs: parentLayer ? extend({}, parent.srs) : {}, 
                    metadataURLs: [],
                    bbox: parentLayer ? extend({}, parent.bbox) : {},
                    llbbox: parent.llbbox,
                    dimensions: parentLayer ? extend({}, parent.dimensions) : {},
                    authorityURLs: parentLayer ? extend({}, parent.authorityURLs) : {},
                    identifiers: {},
                    keywords: [],
                    queryable: (queryable && queryable !== "") ? 
                        (queryable === "1" || queryable === "true" ) :
                        (parent.queryable || false),
                    cascaded: (cascaded !== null) ? parseInt(cascaded) :
                        (parent.cascaded || 0),
                    opaque: opaque ? 
                        (opaque === "1" || opaque === "true" ) :
                        (parent.opaque || false),
                    noSubsets: (noSubsets !== null) ? 
                        (noSubsets === "1" || noSubsets === "true" ) :
                        (parent.noSubsets || false),
                    fixedWidth: (fixedWidth != null) ? 
                        parseInt(fixedWidth) : (parent.fixedWidth || 0),
                    fixedHeight: (fixedHeight != null) ? 
                        parseInt(fixedHeight) : (parent.fixedHeight || 0),
                    minScale: parent.minScale,
                    maxScale: parent.maxScale,
                    attribution: parent.attribution
                };
                obj.nestedLayers.push(layer);
                layer.capability = capability;
                this.readChildNodes(node, layer);
                delete layer.capability;
                if(layer.name) {
                    var parts = layer.name.split(":"),
                        request = capability.request,
                        gfi = request.getfeatureinfo;
                    if(parts.length > 0) {
                        layer.prefix = parts[0];
                    }
                    capability.layers.push(layer);
                    if (layer.formats === undefined) {
                        layer.formats = request.getmap.formats;
                    }
                    if (layer.infoFormats === undefined && gfi) {
                        layer.infoFormats = gfi.formats;
                    }
                }
            },
            "Attribution": function(node, obj) {
                obj.attribution = {};
                this.readChildNodes(node, obj.attribution);
            },
            "LogoURL": function(node, obj) {
                obj.logo = {
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height")
                };
                this.readChildNodes(node, obj.logo);
            },
            "Style": function(node, obj) {
                var style = {};
                obj.styles.push(style);
                this.readChildNodes(node, style);
            },
            "LegendURL": function(node, obj) {
                var legend = {
                    width: node.getAttribute("width"),
                    height: node.getAttribute("height")
                };
                obj.legend = legend;
                this.readChildNodes(node, legend);
            },
            "MetadataURL": function(node, obj) {
                var metadataURL = {type: node.getAttribute("type")};
                obj.metadataURLs.push(metadataURL);
                this.readChildNodes(node, metadataURL);
            },
            "DataURL": function(node, obj) {
                obj.dataURL = {};
                this.readChildNodes(node, obj.dataURL);
            },
            "FeatureListURL": function(node, obj) {
                obj.featureListURL = {};
                this.readChildNodes(node, obj.featureListURL);
            },
            "AuthorityURL": function(node, obj) {
                var name = node.getAttribute("name");
                var authority = {};
                this.readChildNodes(node, authority);
                obj.authorityURLs[name] = authority.href;
            },
            "Identifier": function(node, obj) {
                var authority = node.getAttribute("authority");
                obj.identifiers[authority] = this.getChildValue(node);
            },
            "KeywordList": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "SRS": function(node, obj) {
                obj.srs[this.getChildValue(node)] = true;
            }
        }
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1" 

});
/**
 * @class   GeoGlobe.Format.WMSCapabilities.v1_1
 * @classdesc  抽象类不要直接实例化。
 * @private
 */


GeoGlobe.Format.WMSCapabilities.v1_1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1, {
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WMSCapabilities.v1_1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "WMT_MS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Keyword": function(node, obj) {
                if (obj.keywords) {
                    obj.keywords.push(this.getChildValue(node));
                }
            },
            "DescribeLayer": function(node, obj) {
                obj.describelayer = {formats: []};
                this.readChildNodes(node, obj.describelayer);
            },
            "GetLegendGraphic": function(node, obj) {
                obj.getlegendgraphic = {formats: []};
                this.readChildNodes(node, obj.getlegendgraphic);
            },
            "GetStyles": function(node, obj) {
                obj.getstyles = {formats: []};
                this.readChildNodes(node, obj.getstyles);
            },
            "PutStyles": function(node, obj) {
                obj.putstyles = {formats: []};
                this.readChildNodes(node, obj.putstyles);
            },
            "UserDefinedSymbolization": function(node, obj) {
                var userSymbols = {
                    supportSLD: parseInt(node.getAttribute("SupportSLD")) == 1,
                    userLayer: parseInt(node.getAttribute("UserLayer")) == 1,
                    userStyle: parseInt(node.getAttribute("UserStyle")) == 1,
                    remoteWFS: parseInt(node.getAttribute("RemoteWFS")) == 1
                };
                obj.userSymbols = userSymbols;
            },
            "LatLonBoundingBox": function(node, obj) {
                obj.llbbox = [
                    parseFloat(node.getAttribute("minx")),
                    parseFloat(node.getAttribute("miny")),
                    parseFloat(node.getAttribute("maxx")),
                    parseFloat(node.getAttribute("maxy"))
                ];
            },
            "BoundingBox": function(node, obj) {
                var bbox = GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
                bbox.srs  = node.getAttribute("SRS");
                obj.bbox[bbox.srs] = bbox;
            },
            "ScaleHint": function(node, obj) {
                var min = node.getAttribute("min");
                var max = node.getAttribute("max");
                var rad2 = Math.pow(2, 0.5);
                var ipm = GeoGlobe.INCHES_PER_UNIT["m"];
                if (min != 0) {
                    obj.maxScale = parseFloat(
                        ((min / rad2) * ipm * 
                            GeoGlobe.DOTS_PER_INCH).toPrecision(13)
                    );
                }
                if (max != Number.POSITIVE_INFINITY) {
                    obj.minScale = parseFloat(
                        ((max / rad2) * ipm * 
                            GeoGlobe.DOTS_PER_INCH).toPrecision(13)
                    );
                }
            },
            "Dimension": function(node, obj) {
                var name = node.getAttribute("name").toLowerCase();
                var dim = {
                    name: name,
                    units: node.getAttribute("units"),
                    unitsymbol: node.getAttribute("unitSymbol")
                };
                obj.dimensions[dim.name] = dim;
            },
            "Extent": function(node, obj) {
                var name = node.getAttribute("name").toLowerCase();
                if (name in obj["dimensions"]) {
                    var extent = obj.dimensions[name];
                    extent.nearestVal = 
                        node.getAttribute("nearestValue") === "1";
                    extent.multipleVal = 
                        node.getAttribute("multipleValues") === "1";
                    extent.current = node.getAttribute("current") === "1";
                    extent["default"] = node.getAttribute("default") || "";
                    var values = this.getChildValue(node);
                    extent.values = values.split(",");
                }
                }
        }, GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1" 

});
/**
 * @class   GeoGlobe.Format.WMSCapabilities/v1_1_0
 * @classdesc  阅读WMS功能版本1.1.0。
 * @private
 */


GeoGlobe.Format.WMSCapabilities.v1_1_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1, {
    
    /**
     *  version-The specific parser version.
     * @memberof  GeoGlobe.Format.WMSCapabilities/v1_1_0.prototype
     * @type {String}
     * @private
     */
    version: "1.1.0",
    
    /**
     *  Create a new parser for WMS capabilities version 1.1.0.
     * @memberof  GeoGlobe.Format.WMSCapabilities/v1_1_0.prototype
     * @param {Object}options - An optional object whose properties will be set on
     *     this instance.
     */

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WMSCapabilities/v1_1_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "SRS": function(node, obj) {
                var srs = this.getChildValue(node);
                var values = srs.split(/ +/);
                for (var i=0, len=values.length; i<len; i++) {
                    obj.srs[values[i]] = true;
                }
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_0" 

});
/**
 * @class  GeoGlobe.Format.WMSCapabilities/v1_1_1
 * @classdesc 阅读WMS功能版本1.1.1。
 */


GeoGlobe.Format.WMSCapabilities.v1_1_1 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1, {
    
    /**
     * version- The specific parser version.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     * @private
     */
    version: "1.1.1",
    
    /**
     * 为WMS功能版本1.1.1创建一个新的解析器。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {Object}  options -一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "SRS": function(node, obj) {
                obj.srs[this.getChildValue(node)] = true;
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_1" 

});
/**
 * @class  GeoGlobe.Format.WMSCapabilities/v1_1_1
 * @classdesc 阅读WMS功能版本1.1.1。
 * @private
 */


GeoGlobe.Format.WMSCapabilities.v1_1_1_WMSC = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_1_1, {
    
    /**
     * version- The specific parser version.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     * @private
     */
    version: "1.1.1",
    
    /**
     * profile-The specific profile
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {String}
     * @private
     */
    profile: "WMSC",
    
    /**
     * 为WMS-C功能版本1.1.1创建一个新的分析器。
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     *  Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_1_1.prototype
     * @type {null}
     * @private
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "VendorSpecificCapabilities": function(node, obj) {
                obj.vendorSpecific = {tileSets: []};
                this.readChildNodes(node, obj.vendorSpecific);
            },
            "TileSet": function(node, vendorSpecific) {
                var tileset = {srs: {}, bbox: {}, resolutions: []};
                this.readChildNodes(node, tileset);
                vendorSpecific.tileSets.push(tileset);
            },
            "Resolutions": function(node, tileset) {
                var res = this.getChildValue(node).split(" ");
                for (var i=0, len=res.length; i<len; i++) {
                    if (res[i] != "") {
                        tileset.resolutions.push(parseFloat(res[i]));
                    }
                }
            },
            "Width": function(node, tileset) {
                tileset.width = parseInt(this.getChildValue(node));
            },
            "Height": function(node, tileset) {
                tileset.height = parseInt(this.getChildValue(node));
            },
            "Layers": function(node, tileset) {
                tileset.layers = this.getChildValue(node);
            },
            "Styles": function(node, tileset) {
                tileset.styles = this.getChildValue(node);
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1_1.prototype.readers["wms"])
    },

    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_1_WMSC" 

});
/**
 * @class  GeoGlobe.Format.WMSCapabilities/v1_3
 * @classdesc  WMS功能版本1.3.X的抽象基类。
 * SLD 1.1.0增加了额外的操作DescribeLayer和GetLegendGraphic，
 * 参阅: http://schemas.opengis.net/sld/1.1.0/sld_capabilities.xsd
 * @private
 */

GeoGlobe.Format.WMSCapabilities.v1_3 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1, {
    
    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_3.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wms": GeoGlobe.Util.applyDefaults({
            "WMS_Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "LayerLimit": function(node, obj) {
                obj.layerLimit = parseInt(this.getChildValue(node));
            },
            "MaxWidth": function(node, obj) {
                obj.maxWidth = parseInt(this.getChildValue(node));
            },
            "MaxHeight": function(node, obj) {
                obj.maxHeight = parseInt(this.getChildValue(node));
            },
            "BoundingBox": function(node, obj) {
                var bbox = GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"].BoundingBox.apply(this, [node, obj]);
                bbox.srs  = node.getAttribute("CRS");
                obj.bbox[bbox.srs] = bbox;
            },
            "CRS": function(node, obj) {
                // CRS is the synonym of SRS
                this.readers.wms.SRS.apply(this, [node, obj]); 
            },
            "EX_GeographicBoundingBox": function(node, obj) {
                // replacement of LatLonBoundingBox
                obj.llbbox = [];
                this.readChildNodes(node, obj.llbbox);
                
            },
            "westBoundLongitude": function(node, obj) {
                obj[0] = this.getChildValue(node);
            },
            "eastBoundLongitude": function(node, obj) {
                obj[2] = this.getChildValue(node);
            },
            "southBoundLatitude": function(node, obj) {
                obj[1] = this.getChildValue(node);
            },
            "northBoundLatitude": function(node, obj) {
                obj[3] = this.getChildValue(node);
            },
            "MinScaleDenominator": function(node, obj) {
                obj.maxScale = parseFloat(this.getChildValue(node)).toPrecision(16);
            },
            "MaxScaleDenominator": function(node, obj) {
                obj.minScale = parseFloat(this.getChildValue(node)).toPrecision(16);
            },
            "Dimension": function(node, obj) {
                // dimension has extra attributes: default, multipleValues, 
                // nearestValue, current which used to be part of Extent. It now
                // also contains the values.
                var name = node.getAttribute("name").toLowerCase();
                var dim = {
                    name: name,
                    units: node.getAttribute("units"),
                    unitsymbol: node.getAttribute("unitSymbol"),
                    nearestVal: node.getAttribute("nearestValue") === "1",
                    multipleVal: node.getAttribute("multipleValues") === "1",
                    "default": node.getAttribute("default") || "",
                    current: node.getAttribute("current") === "1",
                    values: this.getChildValue(node).split(",")
                    
                };
                // Theoretically there can be more dimensions with the same
                // name, but with a different unit. Until we meet such a case,
                // let's just keep the same structure as the WMS 1.1 
                // GetCapabilities parser uses. We will store the last
                // one encountered.
                obj.dimensions[dim.name] = dim;
            },
            "Keyword": function(node, obj) {
                // TODO: should we change the structure of keyword in v1.js?
                // Make it an object with a value instead of a string?
                var keyword = {value: this.getChildValue(node), 
                    vocabulary: node.getAttribute("vocabulary")};
                if (obj.keywords) {
                    obj.keywords.push(keyword);
                }
            }
        }, GeoGlobe.Format.WMSCapabilities.v1.prototype.readers["wms"]),
        "sld": {
            "UserDefinedSymbolization": function(node, obj) {
                this.readers.wms.UserDefinedSymbolization.apply(this, [node, obj]);
                // add the two extra attributes
                obj.userSymbols.inlineFeature = parseInt(node.getAttribute("InlineFeature")) == 1;
                obj.userSymbols.remoteWCS = parseInt(node.getAttribute("RemoteWCS")) == 1;
            },
            "DescribeLayer": function(node, obj) {
                this.readers.wms.DescribeLayer.apply(this, [node, obj]);
            },
            "GetLegendGraphic": function(node, obj) {
                this.readers.wms.GetLegendGraphic.apply(this, [node, obj]);
            }
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_3" 

});
/**
 * @class  GeoGlobe.Format.WMSCapabilities/v1_3_0
 * @classdesc 阅读WMS功能版本1.3.0。
 * SLD 1.1.0增加了额外的操作DescribeLayer和GetLegendGraphic，
 * 参见: http://schemas.opengis.net/sld/1.1.0/sld_capabilities.xsd
 * @private
 */


GeoGlobe.Format.WMSCapabilities.v1_3_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.WMSCapabilities.v1_3, {
    
    /**
     * version- The specific parser version.
     * @memberof GeoGlobe.Format.WMSCapabilities/v1_3_0.prototype
     * @type {String}
     * @private
     */
    version: "1.3.0",
    
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_3_0" 

});
/**
 * @class  GeoGlobe.Format.WMSUtil
 * @classdesc 根据wms的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMS图层。
 * @example
var layers=null;
var Capabilities=null;
var wms = new GeoGlobe.Format.WMSUtil();
layers=wms.createLayer("http://192.168.100.231:8889/WMS_Util/wms");
Capabilities=wms.getWMSCapabilities("http://192.168.100.231:8889/WMTS_Util/wmts");
 */

GeoGlobe.Format.WMSUtil = GeoGlobe.Class4OL({

    /**
     * GeoGlobe.Format.WMSUtil构造函数。
     * @memberof  GeoGlobe.Format.WMSUtil.prototype
     */
    initialize: function(options){
		GeoGlobe.Util.extend(this, options);
    },
	/**
	 * 获取WMS服务的能力信息
	 * @function getWMSCapabilities
	 * @memberof GeoGlobe.Format.WMSUtil
	 * @param {String} url 必填 WMS服务地址
	 * @returns {Array} 返回WMS服务可以提供的能力信息
	 */
    getWMSCapabilities: function(url, config){
        var flag = true;
		var capabilities = null;
        this.getCapabilities(url, config,
		GeoGlobe.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
			if(data == null || data == ""){
            	this.failFn(url);
            	flag = false;
            	return;
            }
            var format = new GeoGlobe.Format.WMSCapabilities();
            capabilities = format.read(data);
        }, this),
		function(){
            alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        if(flag){
        	return capabilities;
        }
    },
    
    /**
     * 根据url创建WMS图层对象。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得图层配置参数，最后生成WMS图层对象。
     * 如果wms服务中含有多个图层配置信息，可设置config中属性layer为对应图层name的值，即取该图层的配置参数，生成WMS图层对象。
     * 如不设置config中属性layer，则默认取第一个图层的配置参数生成WMS图层对象。
     * @memberof  GeoGlobe.Format.WMSUtil.prototype
     * @param {String}  url - WMS服务地址。
     * @param{Object} config - 可选。图层的配置参数。
     * @returns {Object} 一个WMS图层对象。
     * @public
     */
    createLayer: function(url, config){
        var flag = true;
		var wmsLayer = null;
        this.getCapabilities(url, config,
		GeoGlobe.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
			if(data == null || data == ""){
            	this.failFn(url);
            	flag = false;
            	return;
            }
            var format = new GeoGlobe.Format.WMSCapabilities();
            var capabilities = format.read(data);
            wmsLayer = this._createLayer(url,capabilities, config, "2D");
        }, this),
		function(){
            alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        if(flag){
        	return wmsLayer;
        }
    },
    
	failFn: function(url){
        alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
    },
	
    /**
     * 获取服务能力描述信息。
     * @memberof  GeoGlobe.Format.WMSUtil.prototype
     * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn - 请求失败的回调函数。
     * @public
     */
    getCapabilities: function(url, config, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMS",
            VERSION: (config ? config.version : null) ? config.version : "1.1.1"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n版本号：" + params[VERSION] + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
    /**
     * 根据capabilities信息创建WMS图层对象。
     * @memberof  GeoGlobe.Format.WMSUtil.prototype
     * @param {Object}capabilities - capabilities信息。可用GeoGlobe.Format.WMSCapabilities.v1_0_0解析器调用<read>方法返回capabilities信息。
     * @param {Object} config -  可选。图层的配置参数。
     * @returns {} 一个WMS图层对象。
     * @private
     */
    _createLayer: function(url, capabilities, config, mapType){
		//config不存在，则赋值为空的对象
		if(!config){
			config = {};
		}
		if(!mapType){
			mapType = "2D";
		}
		
		var capability = capabilities.capability;
		
		// find the layer definition with the given identifier
        var layers = capability.layers;
        var layerDef;
		//默认取第一个图层
		layerDef = capability.layers[0];
		//如果有设置图层名，则取图层名对应的图层数据
        for (var i = 0, ii = capability.layers.length; i < ii; ++i) {
			if (capability.layers[i].name === config.layer) {
				layerDef = capability.layers[i];
				break;
			}
		}
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        // format 例如tiles
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length>0) {
            format = layerDef.formats[0];
        }

        // transparent
        var transparent = config.transparent;
        if(!transparent || transparent==""){
        	transparent = true;
        }
        
		// name
        var name;;
        if (layerDef.name) {
            name = layerDef.name;
        }
        
        // version
        var version = config.version;
        if (!version && capabilities.version) {
        	version = capabilities.version;
        }
        
        // projection
        var projection = config.srs;
        if (!projection && layerDef.srs) {
        	for(var k in layerDef.srs){
        		projection = k;
        	}
        }
        if(projection == "EPSG:-9999"){
        	projection = "EPSG:4326";
        }
        // maxExtent
        var maxExtent = config.llbbox;
        if (!maxExtent && layerDef.llbbox && layerDef.llbbox.length>0) {
            maxExtent = layerDef.llbbox[0]+","+layerDef.llbbox[1]+","+layerDef.llbbox[2]+","+layerDef.llbbox[3];
        }
		var bounds = GeoGlobe.LngLatBounds.fromArray(layerDef.llbbox);
		
        var param = "SERVICE=WMS&REQUEST=GetMap&VERSION="+version+"&LAYERS="+name+"&styles=default&CRS=EPSG:3857&BBOX={bbox-epsg-3857}&WIDTH=256&HEIGHT=256&SRS="+projection+"&FORMAT="+format+"&TRANSPARENT="+transparent;
        var wmsUrl = null;
        if(url.endsWith("?")){
			wmts_url = url + param;
		}else{
			wmts_url = url + "?" + param;
		}
		return {
			url: wmts_url,
			version: version,
			name: name,
			projection: projection,
			format: format,
			bounds: bounds,
			transparent: transparent
		};
        /*
		switch(mapType){
			case "2D":
				var wmsLayer = new Geo.View2D.Layer.WMS(
		             "WMS",//服务名称   
		             url,//服务地址
		             {   
		             	//服务版本
			            version: version,
			            //图层标识，从服务的getCapabilities描述信息获取
			            layers: name,  
			            //数据格式
			            format: format, 
			            //图层背景是否透明，true表示透明   
			            transparent: transparent  
		             },   
		             {   
		                //图层最大范围   
		                maxExtent: Geo.Bounds.fromString(maxExtent),
		                //投影
		                projection: projection,  
		                //坐标轴顺序,false表示经度、纬度的顺序，true表示纬度、经度的顺序   
		                isReverse: true
		             }   
		         );   
		        return wmsLayer;
				break;
			case "3D":
				var serviceObj = new Geo.Service.WMS("wms", url);
				var wms3dlayer;
            	var wms3dlayer = new Geo.View3D.Layer.WMS(
				"wms", //服务名称 
				url,//服务地址
          		{
            		//服务版本
	           		version: version,
            		//图层标识，从服务的getCapabilities描述信息获取
	            	layers: name, 
				    //数据格式
	            	format: format,
	            	//请求的瓦片背景区域是否透明,默认：TRUE	
				    transparent: transparent            		
            	},
            	{
            		//图层透明度设置，可以设置：0-1，默认：1
            		opacity : 1,
            		//当前图层使用的投影
            		projection: projection,
            		//瓦片宽度，瓦片高度，默认：256，256
            		//tileSize: new Geo.Size(256,256),
					//图层最大范围   
                	maxExtent: Geo.Bounds.fromString(maxExtent)	
				});
				return wms3dlayer;
				break;
		}
		*/
    },
    
    CLASS_NAME: "GeoGlobe.Format.WMSUtil"
});
/**
 * @class GeoGlobe.Format.VTSCapabilities
 * @classdesc 阅读矢量瓦片服务功能。
 * @returns {Object} 有关矢量瓦片服务的功能信息
 */
GeoGlobe.Format.VTSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {

    /**
     * defaultVersion-如果没有找到版本号， 默认值是“1.0.0”。
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.0.0",

    /**
     * yx- yx对象中的成员用于确定CRS URN是否对应于y，x轴顺序的CRS。 
     * 成员名称是CRS URN，值是布尔值。 
     * 默认情况下，假定以下CRS URN与y，x轴顺序对应的CRS：
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @type {Object}
     */
    yx: {
        "urn:ogc:def:crs:EPSG::4326": true
    },

    /**
     * 为VTS功能创建一个新的分析器。
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 从字符串中读取有用数据，并返回有关服务的信息（主要是提供和观察属性）。
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @param {String} or {DOMElement}data -  数据读取/解析。
     */

    /**
     * 给定一个功能对象创建一个VTS图层。
     * @memberof GeoGlobe.Format.VTSCapabilities.prototype
     * @param {Object} capabilities -该对象从读取调用返回到此格式。
     * @param {Object}config -  图层的配置属性。 如果没有提供，该图层的默认值将适用。
     * @param {String} Required 配置属性：layer - 图层标识符。
     *
     * @param {String} Optional config属性：matrixSet - 矩阵集标识符，如果图层功能中存在多个矩阵集，则为必需。
     * projection - {String}没有指定matrixSet时所需的CRS。例如：“EPSG：3857”。 
     * 如果所需投影不可用，则会抛出错误。
     * @param {String} style   样式的名称
     * @param {String} format 图层的图像格式。 默认是第一个格式在GetCapabilities响应中返回。
     * @param {Object}  dimensions 值例如：{“Year”：“2012”}
     * @returns {GeoGlobe.Layer.VTS} 一个正确配置的VTS图层。如果配置不完整会报错，
     * 如果未使用提供的配置创建图层，则返回undefined.
     */
    createLayer: function(capabilities, config) {
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                    ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                    GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }

        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        } else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }

        resolutions.sort(function(a,b){
            return b-a;
        });
        
        /*var options = GeoGlobe.Util.applyDefaults(config, {
            url: url,
            requestEncoding: requestEncoding,
            name: layerDef.title,
            style: style && style.identifier || "",
            format: format,
            matrixIds: reducedMatrixIds.length ? 
                reducedMatrixIds : matrixSet.matrixIds,
            matrixSet: matrixSet.identifier,
            projection: projection,
            units: units,
            tileFullExtent: matrixSet.bounds,
            dimensions: dimensions,
            params: params,
            resolutions: config.isBaseLayer === false ? undefined :
                resolutions,
            serverResolutions: resolutions,
            minScale: 1/Math.ceil(maxScaleDenominator),
            maxScale: 1/Math.floor(minScaleDenominator)
        });*/
		var VTS_url = "";
		var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
		if(url[0].endsWith("?")){
            VTS_url = url[0] + param;
		}else{
            VTS_url = url[0] + "?" + param;
		}
        //var wmts_url = url+"?SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layers[0].identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format; 
        var options= GeoGlobe.Util.applyDefaults(config, {
        	id:layerDef.identifier,
            url:[VTS_url]
        });
        var VTSLayer = new GeoGlobe.Layer.VTS(options);
        VTSLayer.matrixSet = matrixSet;
        VTSLayer.identifier = layerDef.identifier;
        VTSLayer.bounds = layerDef.bounds;
        return VTSLayer;
    },

    CLASS_NAME: "GeoGlobe.Format.VTSCapabilities"
});
/**
 * @class  GeoGlobe.Format.VTSCapabilities.v1_0_0
 * @classdesc Read VTS Capabilities version 1.0.0.
 * @private
 */

GeoGlobe.Format.VTSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.OWSCommon.v1_1_0, {
        
    /**
     * version-The parser version ("1.0.0").
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {String}
     */
    version: "1.0.0",

    /**
     * namespaces-Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * yx- Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  Defaults come from the
     *     GeoGlobe.Format.VTSCapabilities prototype.
     * @memberof GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    yx: null,

    /**
     * defaultPrefix- The default namespace alias for creating element nodes.
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {String}
     * @private
     */
    defaultPrefix: "wmts",

    /**
     * 为VTS功能版本1.0.0创建一个新的解析器。
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @classdesc  GeoGlobe.Format.VTSCapabilities.v1_0_0
     * @param {Object} options - 一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.options = options;
        var yx = GeoGlobe.Util.extend(
            {}, GeoGlobe.Format.VTSCapabilities.prototype.yx
        );
        this.yx = GeoGlobe.Util.extend(yx, this.yx);
    },

    /**
     * 从字符串读取能力数据，并返回关于VTS的信息。
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @param {String} or {DOMElement} data -数据读取/解析.
     * @returns {Object} 有关SOS服务的信息。
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        capabilities.version = this.version;
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.VTSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    dimensions: [],
                    tileMatrixSetLinks: []
                };
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of VTS:Contents or VTS:TileMatrixSetLink
                // duck type VTS:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrixSetLimits": function(node, obj) {
                obj.tileMatrixSetLimits = [];
                this.readChildNodes(node, obj);
            },
            "TileMatrixLimits": function(node, obj) {
                var tileMatrixLimits = {};
                this.readChildNodes(node, tileMatrixLimits);
                obj.tileMatrixSetLimits.push(tileMatrixLimits);
            },
            "MinTileRow": function(node, obj) {
                obj.minTileRow = parseInt(this.getChildValue(node)); 
            },
            "MaxTileRow": function(node, obj) {
                obj.maxTileRow = parseInt(this.getChildValue(node)); 
            },
            "MinTileCol": function(node, obj) {
                obj.minTileCol = parseInt(this.getChildValue(node)); 
            },
            "MaxTileCol": function(node, obj) {
                obj.maxTileCol = parseInt(this.getChildValue(node)); 
            },
            "TileMatrix": function(node, obj) {
                // node could be child of VTS:TileMatrixSet or VTS:TileMatrixLimits
                if (obj.identifier) {
                    // node is child of VTS:TileMatrixSet
                    var tileMatrix = {
                        supportedCRS: obj.supportedCRS
                    };
                    this.readChildNodes(node, tileMatrix);
                    obj.matrixIds.push(tileMatrix);
                } else {
                    obj.tileMatrix = this.getChildValue(node);
                }
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {                
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
                    yx = !!this.yx[crs];
                }
                if (yx) {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[1], coords[0]
                    );
                } else {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[0], coords[1]
                    );
                }
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },
            "ResourceURL": function(node, obj) {
                obj.resourceUrl = obj.resourceUrl || {};
                var resourceType = node.getAttribute("resourceType");
                if (!obj.resourceUrls) {
                    obj.resourceUrls = [];
                }
                var resourceUrl = obj.resourceUrl[resourceType] = {
                    format: node.getAttribute("format"),
                    template: node.getAttribute("template"),
                    resourceType: resourceType
                };
                obj.resourceUrls.push(resourceUrl);
            },
            "LegendURL": function(node, obj) {
                obj.legends = obj.legends || [];
                var legend = {
                    format: node.getAttribute("format"),
                    href: node.getAttribute("xlink:href")
                };
                var width = node.getAttribute("width"),
                    height = node.getAttribute("height"),
                    minScaleDenominator = node.getAttribute("minScaleDenominator"),
                    maxScaleDenominator = node.getAttribute("maxScaleDenominator");
                if (width !== null) {
                    legend.width = parseInt(width);
                }
                if (height !== null) {
                    legend.height = parseInt(height);
                }
                if (minScaleDenominator !== null) {
                    legend.minScaleDenominator = parseInt(minScaleDenominator);
                }
                if (maxScaleDenominator !== null) {
                    legend.maxScaleDenominator = parseInt(maxScaleDenominator);
                }
                obj.legends.push(legend);
            },
            "InfoFormat": function(node, obj) {
                obj.infoFormats = obj.infoFormats || [];
                obj.infoFormats.push(this.getChildValue(node));
            },
            // not used for now, can be added in the future though
            /*"Themes": function(node, obj) {
                obj.themes = [];
                this.readChildNodes(node, obj.themes);
            },
            "Theme": function(node, obj) {
                var theme = {};                
                this.readChildNodes(node, theme);
                obj.push(theme);
            },*/
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <WSDL> element                
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <ServiceMetadataURL> element                
            },
            "Dimension": function(node, obj) {
                var dimension = {values: []};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
            "Default": function(node, obj) {
                obj["default"] = this.getChildValue(node);
            },
            "Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.VTSCapabilities.v1_0_0"

});
/**
 * @class  GeoGlobe.Format.WMTSCapabilities
 * @classdesc  网络切片地图服务功能描述。
 */


GeoGlobe.Format.WMTSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {

    /**
     * 默认版本-如果没有找到版本号， 默认值是“1.0.0”。
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.0.0",

    /**
     * yx-yx对象中的成员用于确定CRS URN是否对应于具有y，x轴顺序的CRS。 
     * 成员名称是CRS URN，值是布尔值。 
     * 默认情况下，假定以下CRS URN与y，x轴顺序对应的CRS：
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @type {Object}

     */
    yx: {
        "urn:ogc:def:crs:EPSG::4326": true
    },

    /**
     *  为WMTS功能创建一个新的解析器。
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @param {Object}options - 选项中的值在实例中设置。
     */

    /**
     * 从文档中读取WMTS能力数据，并返回有关服务的信息（主要是提供和观察属性）。
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @param {String} or {DOMElement} data - 数据读取/解析。
     * @returns {Object} 有关WMTS功能的信息。
     */

    /**
     * 根据提供的功能对象创建一个WMTS层。
     * @memberof GeoGlobe.Format.WMTSCapabilities.prototype
     * @param {Object} capabilities -  读取后获知的能力信息。
     * @param {Object} config -  图层的配置属性。 如果没有提供，将是默认值。
     * @param {String} layer -  图层标识符。
     *
     * 可选的配置属性：
     *  @param {String}matrixSet -  矩阵集标识符，如果图层功能中存在多个矩阵集，则需要该标识符集。
     * @param {String} projection -  没有指定matrixSet时所需的CRS。 例如：“EPSG：3857”。 如果所需投影不可用，则会抛出错误。
     * @param {String} style -  样式名称。
     * @param {String} format -  图层的图像格式。 默认值是GetCapabilities响应中返回的第一种格式。
     * @param {Object} param -  维度值。例如：{“Year”：“2012”}
     * @returns {GeoGlobe.Layer.WMTS} 正确配置的WMTS图层。 
     * 如果提供了不完整的配置，则会引发错误。 
     * 如果未使用提供的配置创建图层，则返回undefined。
     */
    createLayer: function(capabilities, config) {
        var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                    ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                    GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }

        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        } else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }

        resolutions.sort(function(a,b){
            return b-a;
        });
        
        /*var options = GeoGlobe.Util.applyDefaults(config, {
            url: url,
            requestEncoding: requestEncoding,
            name: layerDef.title,
            style: style && style.identifier || "",
            format: format,
            matrixIds: reducedMatrixIds.length ? 
                reducedMatrixIds : matrixSet.matrixIds,
            matrixSet: matrixSet.identifier,
            projection: projection,
            units: units,
            tileFullExtent: matrixSet.bounds,
            dimensions: dimensions,
            params: params,
            resolutions: config.isBaseLayer === false ? undefined :
                resolutions,
            serverResolutions: resolutions,
            minScale: 1/Math.ceil(maxScaleDenominator),
            maxScale: 1/Math.floor(minScaleDenominator)
        });*/
		var wmts_url = "";
		var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
		if(url[0].endsWith("?")){
			wmts_url = url[0] + param;
		}else{
			wmts_url = url[0] + "?" + param;
		}
        //var wmts_url = url+"?SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layers[0].identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format; 
        var options= GeoGlobe.Util.applyDefaults(config, {
        	id:layerDef.identifier,
            url:[wmts_url]
        });
        //var wmtsLayer = new GeoGlobe.Layer.WMTS(options);
		var wmtsLayer = {
            id:options.id,
            layer:{
                "id": options.id,
                "type": "raster",
                "source":options.id
            },
            source:{
                "type": "raster",
                "tiles": options.url,
                "tileSize": 256
            }
        };
        wmtsLayer.matrixSet = matrixSet;
        wmtsLayer.identifier = layerDef.identifier;
        wmtsLayer.bounds = layerDef.bounds;
        return wmtsLayer;
    },

    CLASS_NAME: "GeoGlobe.Format.WMTSCapabilities"
});
/**
 * @class  GeoGlobe.Format.WMTSCapabilities.v1_0_0
 * @classdesc 阅读网络切片地图服务功能版本1.0.0。
 */


GeoGlobe.Format.WMTSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.OWSCommon.v1_1_0, {
        
    /**
     * version- The parser version ("1.0.0").
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {String}
     * @private
     */
    version: "1.0.0",

    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },    
    
    /**
     * yx- Members in the yx object are used to determine if a CRS URN
     *     corresponds to a CRS with y,x axis order.  Member names are CRS URNs
     *     and values are boolean.  Defaults come from the
     *     GeoGlobe.Format.WMTSCapabilities prototype.
     * @memberof GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     */
    yx: null,

    /**
     * defaultPrefix- The default namespace alias for creating element nodes.
     * @memberof GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {String}
     * @private
     */
    defaultPrefix: "wmts",

    /**
     * 为网络切片地图服务功能版本1.0.0创建一个新的分析器。
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @param {Object}options -  一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
        this.options = options;
        var yx = GeoGlobe.Util.extend(
            {}, GeoGlobe.Format.WMTSCapabilities.prototype.yx
        );
        this.yx = GeoGlobe.Util.extend(yx, this.yx);
    },

    /**
     * 从字符串中读取能力数据，并返回关于网络切片地图服务的信息。
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @param {String} or {DOMElement}data -  数据读取/解析。
     * @returns {Object} 有关SOS服务的信息。
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        capabilities.version = this.version;
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WMTSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {        
        "wmts": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "Contents": function(node, obj) {
                obj.contents = {};                
                obj.contents.layers = [];
                obj.contents.tileMatrixSets = {};                
                this.readChildNodes(node, obj.contents);
            },
            "Layer": function(node, obj) {
                var layer = {
                    styles: [],
                    formats: [],
                    dimensions: [],
                    tileMatrixSetLinks: []
                };
                this.readChildNodes(node, layer);
                obj.layers.push(layer);
            },
            "Style": function(node, obj) {
                var style = {};
                style.isDefault = (node.getAttribute("isDefault") === "true");
                this.readChildNodes(node, style);
                obj.styles.push(style);
            },
            "Format": function(node, obj) {
                obj.formats.push(this.getChildValue(node)); 
            },
            "TileMatrixSetLink": function(node, obj) {
                var tileMatrixSetLink = {};
                this.readChildNodes(node, tileMatrixSetLink);
                obj.tileMatrixSetLinks.push(tileMatrixSetLink);
            },
            "TileMatrixSet": function(node, obj) {
                // node could be child of wmts:Contents or wmts:TileMatrixSetLink
                // duck type wmts:Contents by looking for layers
                if (obj.layers) {
                    // TileMatrixSet as object type in schema
                    var tileMatrixSet = {
                        matrixIds: []
                    };
                    this.readChildNodes(node, tileMatrixSet);
                    obj.tileMatrixSets[tileMatrixSet.identifier] = tileMatrixSet;
                } else {
                    // TileMatrixSet as string type in schema
                    obj.tileMatrixSet = this.getChildValue(node);
                }
            },
            "TileMatrixSetLimits": function(node, obj) {
                obj.tileMatrixSetLimits = [];
                this.readChildNodes(node, obj);
            },
            "TileMatrixLimits": function(node, obj) {
                var tileMatrixLimits = {};
                this.readChildNodes(node, tileMatrixLimits);
                obj.tileMatrixSetLimits.push(tileMatrixLimits);
            },
            "MinTileRow": function(node, obj) {
                obj.minTileRow = parseInt(this.getChildValue(node)); 
            },
            "MaxTileRow": function(node, obj) {
                obj.maxTileRow = parseInt(this.getChildValue(node)); 
            },
            "MinTileCol": function(node, obj) {
                obj.minTileCol = parseInt(this.getChildValue(node)); 
            },
            "MaxTileCol": function(node, obj) {
                obj.maxTileCol = parseInt(this.getChildValue(node)); 
            },
            "TileMatrix": function(node, obj) {
                // node could be child of wmts:TileMatrixSet or wmts:TileMatrixLimits
                if (obj.identifier) {
                    // node is child of wmts:TileMatrixSet
                    var tileMatrix = {
                        supportedCRS: obj.supportedCRS
                    };
                    this.readChildNodes(node, tileMatrix);
                    obj.matrixIds.push(tileMatrix);
                } else {
                    obj.tileMatrix = this.getChildValue(node);
                }
            },
            "ScaleDenominator": function(node, obj) {
                obj.scaleDenominator = parseFloat(this.getChildValue(node)); 
            },
            "TopLeftCorner": function(node, obj) {                
                var topLeftCorner = this.getChildValue(node);
                var coords = topLeftCorner.split(" ");
                // decide on axis order for the given CRS
                var yx;
                if (obj.supportedCRS) {
                    // extract out version from URN
                    var crs = obj.supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):.+:(\w+)$/, 
                        "urn:ogc:def:crs:$1::$2"
                    );
                    yx = !!this.yx[crs];
                }
                if (yx) {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[1], coords[0]
                    );
                } else {
                    obj.topLeftCorner = new GeoGlobe.LngLat(
                        coords[0], coords[1]
                    );
                }
            },
            "TileWidth": function(node, obj) {
                obj.tileWidth = parseInt(this.getChildValue(node)); 
            },
            "TileHeight": function(node, obj) {
                obj.tileHeight = parseInt(this.getChildValue(node)); 
            },
            "MatrixWidth": function(node, obj) {
                obj.matrixWidth = parseInt(this.getChildValue(node)); 
            },
            "MatrixHeight": function(node, obj) {
                obj.matrixHeight = parseInt(this.getChildValue(node)); 
            },
            "ResourceURL": function(node, obj) {
                obj.resourceUrl = obj.resourceUrl || {};
                var resourceType = node.getAttribute("resourceType");
                if (!obj.resourceUrls) {
                    obj.resourceUrls = [];
                }
                var resourceUrl = obj.resourceUrl[resourceType] = {
                    format: node.getAttribute("format"),
                    template: node.getAttribute("template"),
                    resourceType: resourceType
                };
                obj.resourceUrls.push(resourceUrl);
            },
            "LegendURL": function(node, obj) {
                obj.legends = obj.legends || [];
                var legend = {
                    format: node.getAttribute("format"),
                    href: node.getAttribute("xlink:href")
                };
                var width = node.getAttribute("width"),
                    height = node.getAttribute("height"),
                    minScaleDenominator = node.getAttribute("minScaleDenominator"),
                    maxScaleDenominator = node.getAttribute("maxScaleDenominator");
                if (width !== null) {
                    legend.width = parseInt(width);
                }
                if (height !== null) {
                    legend.height = parseInt(height);
                }
                if (minScaleDenominator !== null) {
                    legend.minScaleDenominator = parseInt(minScaleDenominator);
                }
                if (maxScaleDenominator !== null) {
                    legend.maxScaleDenominator = parseInt(maxScaleDenominator);
                }
                obj.legends.push(legend);
            },
            "InfoFormat": function(node, obj) {
                obj.infoFormats = obj.infoFormats || [];
                obj.infoFormats.push(this.getChildValue(node));
            },
            // not used for now, can be added in the future though
            /*"Themes": function(node, obj) {
                obj.themes = [];
                this.readChildNodes(node, obj.themes);
            },
            "Theme": function(node, obj) {
                var theme = {};                
                this.readChildNodes(node, theme);
                obj.push(theme);
            },*/
            "WSDL": function(node, obj) {
                obj.wsdl = {};
                obj.wsdl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <WSDL> element                
            },
            "ServiceMetadataURL": function(node, obj) {
                obj.serviceMetadataUrl = {};
                obj.serviceMetadataUrl.href = node.getAttribute("xlink:href");
                // TODO: other attributes of <ServiceMetadataURL> element                
            },
            "Dimension": function(node, obj) {
                var dimension = {values: []};
                this.readChildNodes(node, dimension);
                obj.dimensions.push(dimension);
            },
            "Default": function(node, obj) {
                obj["default"] = this.getChildValue(node);
            },
            "Value": function(node, obj) {
                obj.values.push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.WMTSCapabilities.v1_0_0" 

});
/**
 * @class GeoGlobe.Format.WMTSUtil
 * @classdesc 根据wmts的服务url，获取GetCapabilities信息，解析后得到图层配置参数，构建WMTS数据源source和图层layer。
 * 使用此工具前，请先验证服务接口是否正常。
 * @example
var layers=null;
var Capabilities=null;
var wmts = new GeoGlobe.Format.WMTSUtil();
layers=wmts.createLayers("http://192.168.100.231:8889/WMTS_Util/wmts");
Capabilities=wmts.getWMTSCapabilities("http://192.168.100.231:8889/WMTS_Util/wmts");
 */
GeoGlobe.Format.WMTSUtil = GeoGlobe.Class4OL({

    /**
     * GeoGlobe.Format.WMTSUtil构造函数。
     * @memberof  GeoGlobe.Format.WMTSUtil.prototype
     */
    initialize: function(options){
		GeoGlobe.Util.extend(this, options);
    },
    /**
     * 获取WMTS服务的能力信息
     * @function getWMTSCapabilities
     * @memberof GeoGlobe.Format.WMTSUtil.prototype
     * @param {String} url 必填 WMTS服务地址
     * @returns {Array} 返回WMTS服务可以提供的能力信息
     */
	getWMTSCapabilities: function(url){
		var capabilities = null;
		this.getCapabilities(url, function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new GeoGlobe.Format.WMTSCapabilities.v1_0_0();
            capabilities = format.read(data);
        },
		function(){
            alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
			//wmtsLayer = new OpenLayers.Layer.WMTS({url:url});
        });
        return capabilities;
	},
    /**
     * 获取服务的能力信息
     * @function getCapabilities
     * @memberof GeoGlobe.Format.WMTSUtil.prototype
     * @param {String} url 必填 服务地址
     * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn - 请求失败的回调函数。
     * @returns {Array} 返回服务可以提供的能力信息或弹出警告
     */
	getCapabilities: function(url, successFn, failFn){
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("WMTS服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
    /**
     * 创建图层选项
     * @function createLayerOption
     * @memberof GeoGlobe.Format.WMTSUtil.prototype
     * @param {String} url 必填 服务地址
     * @param {Object} capabilities - capabilities信息。可用GeoGlobe.Format.WMTSCapabilities.v1_0_0解析器调用<read>方法返回capabilities信息
     * @param {Object} config -  可选。图层的配置参数
     * @returns {Object} 返回图层选项信息
     * @private
     */
    createLayerOption: function(url, capabilities, config){
    	var layer;

        // confirm required properties are supplied in config
        if (!('layer' in config)) {
            throw new Error("Missing property 'layer' in configuration.");
        }

        var contents = capabilities.contents;

        // find the layer definition with the given identifier
        var layers = contents.layers;
        var layerDef;
        for (var i=0, ii=contents.layers.length; i<ii; ++i) {
            if (contents.layers[i].identifier === config.layer) {
                layerDef = contents.layers[i];
                break;
            }
        }
        if (!layerDef) {
            throw new Error("Layer not found");
        }
        
        var format = config.format;
        if (!format && layerDef.formats && layerDef.formats.length) {
            format = layerDef.formats[0];
        }

        // find the matrixSet definition
        var matrixSet;
        if (config.matrixSet) {
            matrixSet = contents.tileMatrixSets[config.matrixSet];
        } else if (config.projection) {
            for (var i=0,l=layerDef.tileMatrixSetLinks.length;i<l;i++) {
                if (contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet
                    ].supportedCRS.replace(
                        /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"
                    ) === config.projection) {

                    matrixSet = contents.tileMatrixSets[
                        layerDef.tileMatrixSetLinks[i].tileMatrixSet];
                    break;
                }
            }
        } else if (layerDef.tileMatrixSetLinks.length >= 1) {
            matrixSet = contents.tileMatrixSets[
                layerDef.tileMatrixSetLinks[0].tileMatrixSet];
        }
        if (!matrixSet) {
            throw new Error("matrixSet not found");
        }

        // get the default style for the layer
        var style;
        for (var i=0, ii=layerDef.styles.length; i<ii; ++i) {
            style = layerDef.styles[i];
            if (style.isDefault) {
                break;
            }
        }

        var requestEncoding = config.requestEncoding;
        if (!requestEncoding) {
            requestEncoding = "KVP";
            if (capabilities.operationsMetadata.GetTile.dcp.http && false) {
                var http = capabilities.operationsMetadata.GetTile.dcp.http;
                // Get first get method
                if (http.get[0].constraints) {
                    var constraints = http.get[0].constraints;
                    var allowedValues = constraints.GetEncoding.allowedValues;
                    // The OGC documentation is not clear if we should use
                    // REST or RESTful, ArcGis use RESTful,
                    // and GeoGlobe use REST.
                    if (!allowedValues.KVP &&
                            (allowedValues.REST || allowedValues.RESTful)) {
                        requestEncoding = "REST";
                    }
                }
            }
        }

        var dimensions = [];
        var params = config.params || {};
        // to don't overwrite the changes in the applyDefaults
        delete config.params;
        for (var id = 0, ld = layerDef.dimensions.length ; id < ld ; id++) {
            var dimension = layerDef.dimensions[id];
            dimensions.push(dimension.identifier);
            if (!params.hasOwnProperty(dimension.identifier)) {
                params[dimension.identifier] = dimension['default'];
            }
        }

        var projection = config.projection || matrixSet.supportedCRS.replace(
                /urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3");
        var units = config.units ||
                (projection === ("EPSG:4326" || "OGC:CRS84") ? "degrees" : "m");

        // compute server-supported resolutions array
        var resolutions = [], minScaleDenominator, maxScaleDenominator,
            reducedMatrixIds = [], tileMatrixSetLink,
            tileMatrixSetLinks = layerDef.tileMatrixSetLinks;
        var buildResolutionsArray = function(scaleDenominator) {
            resolutions.push(
                scaleDenominator * 0.28E-3 / GeoGlobe.METERS_PER_INCH /
                    GeoGlobe.INCHES_PER_UNIT[units]
            );
            if (!minScaleDenominator || minScaleDenominator > scaleDenominator) {
                minScaleDenominator = scaleDenominator;
            }
            if (!maxScaleDenominator || maxScaleDenominator < scaleDenominator) {
                maxScaleDenominator = scaleDenominator;
            }
        };
        for (var j=0, l=tileMatrixSetLinks.length; j<l; j++) {
            tileMatrixSetLink = tileMatrixSetLinks[j];
            if (tileMatrixSetLink.tileMatrixSet === matrixSet.identifier) {
                if (tileMatrixSetLink.tileMatrixSetLimits) {
                    // reformat matrixSet.matrixIds so that identifiers become keys
                    var tmpMatrixIds = {}, mid;
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        tmpMatrixIds[matrixSet.matrixIds[k].identifier] = matrixSet.matrixIds[k];
                    }
                    // compute resolutions array + scale limits
                    for (var k=0, ll=tileMatrixSetLink.tileMatrixSetLimits.length; k<ll; k++) {
                        mid = tmpMatrixIds[tileMatrixSetLink.tileMatrixSetLimits[k].tileMatrix];
                        reducedMatrixIds.push(mid);
                        buildResolutionsArray(mid.scaleDenominator);
                    }
                } else {
                    // if there are no limits in the tileMatrixSetLink, 
                    // use the resolutions from the full tile matrix set
                    for (var k=0, ll=matrixSet.matrixIds.length; k<ll; k++) {
                        buildResolutionsArray(matrixSet.matrixIds[k].scaleDenominator);
                    };
                }
                break;
            }
        }
		/*
        var url;
        if (requestEncoding === "REST" && layerDef.resourceUrls) {
            url = [];
            var resourceUrls = layerDef.resourceUrls,
                resourceUrl;
            for (var t = 0, tt = layerDef.resourceUrls.length; t < tt; ++t) {
                resourceUrl = layerDef.resourceUrls[t];
                if (resourceUrl.format === format && resourceUrl.resourceType === "tile") {
                    url.push(resourceUrl.template);
                }
            }
        } else {
            var httpGet = capabilities.operationsMetadata.GetTile.dcp.http.get;
            url = [];
            var constraint;
            for (var i = 0, ii = httpGet.length; i < ii; i++) {
                constraint = httpGet[i].constraints;
                if (!constraint || (constraint && constraint.
                        GetEncoding.allowedValues[requestEncoding])) {
                    url.push(httpGet[i].url);
                }
            }
        }
		*/
        resolutions.sort(function(a,b){
            return b-a;
        });
        
		var wmts_url = "";
		//var param = "SERVICE=WMTS&REQUEST=GetTile&VERSION="+capabilities.version+"&LAYER="+layerDef.identifier+"&STYLE="+style.identifier+"&TILEMATRIXSET="+ matrixSet.identifier+"&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT="+format;
		//GeoGlobe.Util.getParameterString(param);
		var param = this.getParameterString({
			"SERVICE": "WMTS",
			"REQUEST": "GetTile",
			"VERSION": capabilities.version,
			"LAYER": layerDef.identifier,
			"STYLE": style.identifier,
			"TILEMATRIXSET": matrixSet.identifier,
			"FORMAT": format,
			"TILEMATRIX": "{z}",
			"TILEROW": "{y}",
			"TILECOL": "{x}"
		});
		if(url.endsWith("?")){
			wmts_url = GeoGlobe.ProxyHost + url + param;
		}else{
			wmts_url = GeoGlobe.ProxyHost + url + "?" + param;
		}
		//wmts_url = GeoGlobe.Request.makeSameOrigin(wmts_url, GeoGlobe.ProxyHost);
        /*
		var options= GeoGlobe.Util.applyDefaults(config, {
        	id:layerDef.identifier,
            url:[wmts_url]
        });
        var wmtsLayer = new GeoGlobe.Layer.WMTS(options);
        wmtsLayer.matrixSet = matrixSet;
		*/
		
		var randomNum = GeoGlobe.Util.randomStr(10);
		/*
		var layerOption = {
			source:{
		        "id": "source_" + layerDef.identifier + "_" + randomNum,
		        "type": "raster",
		        "tiles": [wmts_url],
		        "tileSize": 256
		    },
			layers:[{
		        "id": "layer_" + layerDef.identifier + "_" + randomNum,
		        "type": "raster",
		        "source": "source_" + layerDef.identifier + "_" + randomNum,
		        "paint": {
					"raster-opacity": 1
				}
		    }]
		};
		*/
		var layerOption = {
	        "id": "layer_" + layerDef.identifier + "_" + randomNum,
	        "type": "raster",
	        "source": {
                "type": "raster",
                "tiles": [wmts_url],
                "tileSize": 256
            },
	        "paint": {
				"raster-opacity": 1
			}
	    };
        return layerOption;
    },
	/*
    //test
    createLayerOptions: function(url){
		var cap = this.getWMTSCapabilities(url);
		var layers = cap.contents.layers;
		var layerOptions = [];
    	for(var i = 0; i < layers.length; i++){
			var config = {layer: layers[i].identifier};
			var wmtsOpt = this.createLayerOption(url, cap, config);
			layerOptions.push(wmtsOpt);
		}
		return layerOptions;
    },
	*/
    //test
    /**
     * 创建一个图层（默认创建第一个图层）
     * @function createLayer
     * @memberof GeoGlobe.Format.WMTSUtil.prototype
     * @param {String} url 必填 包含图层信息的URL
     * @returns {Array} 返回第一个图层的信息
     */
    createLayer: function(url){
		var cap = this.getWMTSCapabilities(url);
		var config = {layer: cap.contents.layers[0].identifier};
		var layerOption = this.createLayerOption(url, cap, config);
		return layerOption;
    },
    /**
     * 创建多个图层
     * @function createLayers
     * @memberof GeoGlobe.Format.WMTSUtil.prototype
     * @param {String} url 必填 包含多个图层信息的URL
     * @returns {Array} 返回多个图层的信息
     */
    createLayers: function(url){
		var cap = this.getWMTSCapabilities(url);
		var layers = cap.contents.layers;
		var layerOptions = [];
    	for(var i = 0; i < layers.length; i++){
			var config = {layer: layers[i].identifier};
			var wmtsOpt = this.createLayerOption(url, cap, config);
			layerOptions.push(wmtsOpt);
		}
		return layerOptions;
    },
	
	
	getParameterString: function(params) {
		var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                //var encodedKey = encodeURIComponent(key);
                //var encodedValue = encodeURIComponent(value);
                paramsArray.push(key + "=" + value);
            }
        }
	    return paramsArray.join("&");
	},
    /**
     * 计算顶部图层的范围和zoomOffset值
     * @function CalculationTopTileExtentAndZoomOffset
     * @memberof GeoGlobe.Format.WMTSUtil.prototype
     * @param {Object} capabilitieOptions 必填 读取的capabilitie XML文档信息选项
     * @param capabilitieOptions.identifier - {Number} 必填 顶部图层ID，例如：从&lt;ows:Identifier>0&lt;/ows:Identifier>中取0
     * @param capabilitieOptions.scaleDenominator - {Number} 必填 顶部图层比例尺分母，例如：从&lt;ScaleDenominator>377976.1904761904&lt;/ScaleDenominator>中取377976.1904761904
     * @param capabilitieOptions.topLeftCorner - {Array} 必填 顶部图层左上角点坐标（格式为[x,y]），例如：从&lt;TopLeftCorner>-200.0 178200.525&lt;/TopLeftCorner>中取-200.0 178200.525，写成[-200.0,178200.525]
     * @param capabilitieOptions.tileSize - {Number} 必填 顶部图层每个瓦片大小，例如：从&lt;TileWidth>256&lt;/TileWidth>、&lt;TileHeight>256&lt;/TileHeight>中取共同值256
     * @param capabilitieOptions.matrixWidth - {Number} 必填 顶部图层横向所需瓦片个数，例如：从&lt;MatrixWidth>5&lt;/MatrixWidth>中取5
     * @param capabilitieOptions.matrixHeight - {Number} 必填 顶部图层纵向所需瓦片个数，例如：从&lt;MatrixHeight>3&lt;/MatrixHeight>中取3
     *
     *
     * @param capabilitieOptions.inchConvertMeterRatio - {Number} 可选 英寸转米的系数, 默认：0.0254，其它参考值：0.0254000508001016、0.025399998
     * @param capabilitieOptions.degreeConvertMeterRatio - {Number} 可选 度转米的系数, 默认：111000
     * @param capabilitieOptions.dpi - {Number} 可选 图像每英寸面积内的像素点数, 默认：96，其它参考值:90.714
     * @param capabilitieOptions.units - {String} 可选 投影单位, 参考可选值：m、degrees
     * @param capabilitieOptions.resolution - {Number} 可选 顶部图层的分辨率，如该项填值，则程序舍弃由比例尺、dpi等参数计算出的分辨率而优先选用该值
     * @returns {Object} 返回顶部图层的范围、zoomOffset值及推荐的zoom值、中心点坐标（推荐值仅供参考）
     * @example
     var capabilitieOptions={
            identifier:0,
            scaleDenominator:1058271.9496196122,
            topLeftCorner:[1.00021E7,3.38768E7],
            tileSize:256,
            matrixWidth:81,
            matrixHeight:88，
            //inchConvertMeterRatio:0.025399998,
            //degreeConvertMeterRatio:111000,
            //dpi:96,
			//units:"m",
			//resolution:""
        };
     var wmts = new GeoGlobe.Format.WMTSUtil();
     var result = wmts.CalculationTopTileExtentAndZoomOffset(capabilitieOptions);
     //包含source和layer的样式，cartodb地图
     Cfg.style = {
	        "version": 8,
	        "sources": {
	            "arcgis": {
	                "type": "raster",
	                "tiles": [Cfg.proxyHostUrl + "http://61.144.226.44:6080/arcgis/rest/services/basemap/szmap_basemap_201608_01/MapServer/WMTS?SERVICE=WMTS&REQUEST=GetTile&LAYER=basemap_szmap_basemap_201608_01&TILEMATRIXSET=nativeTileMatrixSet&FORMAT=image/png&VERSION=1.0.0&STYLE=default&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}"],
	                "tileSize": 256,
	                //填入zoomOffset值
					"zoomOffset": result.zoomOffset
	            }
	        },
	        "layers": [{
	            "id": "1",
	            "type": "raster",
	            "source": "arcgis"
	        }]
	    };
     var map = new GeoGlobe.Map({
			mapCRS: {
			    //填入topTileExtent值
				topTileExtent:result.topTileExtent,
	            coordtransform:"none",
	            tileSize: 256
	    	},
			units: 'm',
	        style: Cfg.style,
	        container: 'map',
	        //填入推荐的zoom值
	        zoom:result.proposalZoom,
	        //填入推荐的centerPoint值
	        //中心点的计算值只是建议值，建议通过其他方法确定地图的中心点（Arcgis server服务可通过bbox计算，GeoGlobe server服务可通过其他途径）
			center:result.centerPoint,
	        maxTileCacheSize: 0,
			isIntScrollZoom: true,//缩放级别是否为整数处理模式
			renderWorldCopies: false,
	        isAttributionControl: false
	    });
     */
    CalculationTopTileExtentAndZoomOffset:function(capabilitieOptions){
        var resultOption={};
        var resolution=null;
        var InchConvertMeterRatio=0.0254;
        var DegreeConvertMeterRatio=111000;
        var DPI=96;
        var topTileExtent=[];
        var centerPoint=[];
        if(capabilitieOptions.hasOwnProperty("inchConvertMeterRatio")){
            InchConvertMeterRatio=capabilitieOptions.inchConvertMeterRatio;
        };
        if(capabilitieOptions.hasOwnProperty("degreeConvertMeterRatio")){
            DegreeConvertMeterRatio=capabilitieOptions.degreeConvertMeterRatio;
        };
        if(capabilitieOptions.hasOwnProperty("dpi")){
            DPI=capabilitieOptions.dpi;
        }
        //瓦片个数取最大值，为下一步计算zoomOffset做准备
        var maxTileNumber=Math.max(Number(capabilitieOptions.matrixWidth),Number(capabilitieOptions.matrixHeight));
        //计算当前层级
        var currentLevel=Math.ceil(Math.log(maxTileNumber)/Math.LN2);
        //计算出最大最合适的顶层瓦片个数
        var maxAppropriateTileNumber=Math.pow(2,currentLevel);
        //计算分辨率（resolution）
        if(capabilitieOptions.hasOwnProperty('resolution')){
            if(capabilitieOptions.resolution!==""){
                resolution=capabilitieOptions.resolution;
            }else{
                alert("请输入resolution值，或者将该属性注释");
                return;
            };
        }else{
            if(!capabilitieOptions.hasOwnProperty("units")){
                if(Math.abs(capabilitieOptions.topLeftCorner[0])<=800&&Math.abs(capabilitieOptions.topLeftCorner[1])<=800){
                    resolution=capabilitieOptions.scaleDenominator*InchConvertMeterRatio/(DPI*DegreeConvertMeterRatio);
                }else{
                    resolution=capabilitieOptions.scaleDenominator*InchConvertMeterRatio/DPI;
                };
            }else{
                if(capabilitieOptions.units=="m"){
                    resolution=capabilitieOptions.scaleDenominator*InchConvertMeterRatio/DPI;
                };
                if(capabilitieOptions.units=="degrees"){
                    resolution=capabilitieOptions.scaleDenominator*InchConvertMeterRatio/(DPI*DegreeConvertMeterRatio);
                };
                if(capabilitieOptions.units!=="m"&&capabilitieOptions.units!=="degrees"){
                    alert("请确定单位是m还是degrees");
                    return;
                }
            };
        }
        //计算顶部瓦片的范围
        topTileExtent[0]=capabilitieOptions.topLeftCorner[0];
        topTileExtent[3]=capabilitieOptions.topLeftCorner[1];
        topTileExtent[1]=topTileExtent[3]-capabilitieOptions.tileSize*resolution*maxAppropriateTileNumber;
        topTileExtent[2]=topTileExtent[0]+capabilitieOptions.tileSize*resolution*maxAppropriateTileNumber;
        //zoomOffset值
        var zoomOffset=currentLevel-Number(capabilitieOptions.identifier);

        //地图中心点坐标（建议值）
        centerPoint[0]=(topTileExtent[0]+topTileExtent[2])/2;
        centerPoint[1]=(topTileExtent[1]+topTileExtent[3])/2;
        //zoom（建议值）
        var proposalZoom=zoomOffset-1;

        resultOption.topTileExtent=topTileExtent;
        resultOption.zoomOffset=zoomOffset;
        resultOption.centerPoint=centerPoint;
        resultOption.proposalZoom=proposalZoom;

        return resultOption;
    },
    CLASS_NAME: "GeoGlobe.Format.WMTSUtil"
});
/**
 * @class  GeoGlobe.Format.WPSCapabilities
 * @classdesc  获知网络处理服务具有的功能。
 * @returns {Object} 返回网络处理服务具有的功能
 */

GeoGlobe.Format.WPSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    
    /**
     * defaultVersion-如果没有找到版本号， 默认值是“1.0.0”。
     * @memberof  GeoGlobe.Format.WPSCapabilities.prototype
     * @type {String}
     */
    defaultVersion: "1.0.0",
    
    /**
     * 为WPS功能创建一个新的解析器。
     * @memberof  GeoGlobe.Format.WPSCapabilities.prototype
     * @param {Object} options -在实例化时所需的选项值。
     */

    /**
     * 读取功能描述信息，并返回有关该服务的信息。
     * @memberof  GeoGlobe.Format.WPSCapabilities.prototype
     * @param {String| DOMElement} data -  数据读取/解析。
     */
    
    CLASS_NAME: "GeoGlobe.Format.WPSCapabilities" 

});
/**
 * @class  GeoGlobe.Format.WPSCapabilities.v1_0_0
 * @classdesc 阅读网络处理服务功能版本1.0.0。
 */

GeoGlobe.Format.WPSCapabilities.v1_0_0 = GeoGlobe.Class4OL(
    GeoGlobe.Format.XML, {

    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.WPSCapabilities.v1_0_0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wps: "http://www.opengis.net/wps/1.0.0",
        xlink: "http://www.w3.org/1999/xlink"
    },

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.WPSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },
    
    /**
     * 为网络处理服务功能版本1.0.0创建一个新的分析器。
     * @memberof GeoGlobe.Format.网络处理服务Capabilities.v1_0_0.prototype
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**
     * 从字符串中读取能力数据，并返回关于网络处理服务的信息。
     * @memberof GeoGlobe.Format.WPSCapabilities.v1_0_0.prototype
     * @param {String} or {DOMElement}data - 数据读取/解析。
     * @returns {Object} 有关网络处理服务的信息。
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var capabilities = {};
        this.readNode(data, capabilities);
        return capabilities;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof GeoGlobe.Format.WPSCapabilities.v1_0_0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wps": {
            "Capabilities": function(node, obj) {
                this.readChildNodes(node, obj);
            },
            "ProcessOfferings": function(node, obj) {
                obj.processOfferings = {};
                this.readChildNodes(node, obj.processOfferings);
            },
            "Process": function(node, processOfferings) {
                var processVersion = this.getAttributeNS(node, this.namespaces.wps, "processVersion");
                var process = {processVersion: processVersion};
                this.readChildNodes(node, process);
                processOfferings[process.identifier] = process;
            },
            "Languages": function(node, obj) {
                obj.languages = [];
                this.readChildNodes(node, obj.languages);
            },
            "Default": function(node, languages) {
                var language = {isDefault: true};
                this.readChildNodes(node, language);
                languages.push(language);
            },
            "Supported": function(node, languages) {
                var language = {};
                this.readChildNodes(node, language);     
                languages.push(language);
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },    
    
    CLASS_NAME: "GeoGlobe.Format.WPSCapabilities.v1_0_0" 

});
/**
 * @class GeoGlobe.Format.WCSGetCoverage version 1.1.0
 * @classdesc GeoGlobe.Format.WCSGetCoverage version 1.1.0类
 * @private
 */

GeoGlobe.Format.WCSGetCoverage = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wcs: "http://www.opengis.net/wcs/1.1",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {null}
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {String}
     * @private
     */
    VERSION: "1.1.2",

    /**
     * schemaLocation- Schema location
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/wcs/1.1 http://schemas.opengis.net/wcs/1.1/wcsGetCoverage.xsd",

    /**
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @classdesc GeoGlobe.Format.WCSGetCoverage
     * @param {Object} options - An optional object whose properties will be set on
     *     this instance.
     * @private
     */

    /**
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @param {Object} options -Optional object.
     * @returns {String} A WCS GetCoverage request XML string.
     * @private
     */
    write: function(options) {
        var node = this.writeNode("wcs:GetCoverage", options);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof  GeoGlobe.Format.WCSGetCoverage version 1.1.0.prototype
     * @type {null}
     * @private
     *
     */
    writers: {
        "wcs": {
            "GetCoverage": function(options) {
                var node = this.createElementNSPlus("wcs:GetCoverage", {
                    attributes: {
                        version: options.version || this.VERSION,
                        service: 'WCS'
                    } 
                }); 
                this.writeNode("ows:Identifier", options.identifier, node);
                this.writeNode("wcs:DomainSubset", options.domainSubset, node);
                this.writeNode("wcs:Output", options.output, node);
                return node; 
            },
            "DomainSubset": function(domainSubset) {
                var node = this.createElementNSPlus("wcs:DomainSubset", {});
                this.writeNode("ows:BoundingBox", domainSubset.boundingBox, node);
                if (domainSubset.temporalSubset) {
                    this.writeNode("wcs:TemporalSubset", domainSubset.temporalSubset, node);
                }
                return node;
            },
            "TemporalSubset": function(temporalSubset) {
                var node = this.createElementNSPlus("wcs:TemporalSubset", {});
                for (var i=0, len=temporalSubset.timePeriods.length; i<len; ++i) {
                    this.writeNode("wcs:TimePeriod", temporalSubset.timePeriods[i], node);
                }
                return node;
            },
            "TimePeriod": function(timePeriod) {
                var node = this.createElementNSPlus("wcs:TimePeriod", {});
                this.writeNode("wcs:BeginPosition", timePeriod.begin, node);
                this.writeNode("wcs:EndPosition", timePeriod.end, node);
                if (timePeriod.resolution) {
                    this.writeNode("wcs:TimeResolution", timePeriod.resolution, node);
                }
                return node;
            },
            "BeginPosition": function(begin) {
                var node = this.createElementNSPlus("wcs:BeginPosition", {
                    value: begin
                });
                return node;
            },
            "EndPosition": function(end) {
                var node = this.createElementNSPlus("wcs:EndPosition", {
                    value: end
                });
                return node;
            },
            "TimeResolution": function(resolution) {
                var node = this.createElementNSPlus("wcs:TimeResolution", {
                    value: resolution
                });
                return node;
            },
            "Output": function(output) {
                var node = this.createElementNSPlus("wcs:Output", {
                    attributes: {
                        format: output.format,
                        store: output.store
                    }
                });
                if (output.gridCRS) {
                    this.writeNode("wcs:GridCRS", output.gridCRS, node);
                }
                return node;
            },
            "GridCRS": function(gridCRS) {
                var node = this.createElementNSPlus("wcs:GridCRS", {});
                this.writeNode("wcs:GridBaseCRS", gridCRS.baseCRS, node);
                if (gridCRS.type) {
                    this.writeNode("wcs:GridType", gridCRS.type, node);
                }
                if (gridCRS.origin) {
                    this.writeNode("wcs:GridOrigin", gridCRS.origin, node);
                }
                this.writeNode("wcs:GridOffsets", gridCRS.offsets, node);
                if (gridCRS.CS) {
                    this.writeNode("wcs:GridCS", gridCRS.CS, node);
                }
                return node;
            },
            "GridBaseCRS": function(baseCRS) {
                return this.createElementNSPlus("wcs:GridBaseCRS", {
                    value: baseCRS
                });
            },
            "GridOrigin": function(origin) {
                return this.createElementNSPlus("wcs:GridOrigin", {
                    value: origin
                });
            },
            "GridType": function(type) {
                return this.createElementNSPlus("wcs:GridType", {
                    value: type
                });
            },
            "GridOffsets": function(offsets) {
                return this.createElementNSPlus("wcs:GridOffsets", {
                    value: offsets
                });
            },
            "GridCS": function(CS) {
                return this.createElementNSPlus("wcs:GridCS", {
                    value: CS
                });
            }
        },
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },
    
    CLASS_NAME: "GeoGlobe.Format.WCSGetCoverage" 

});
/**
 * @class GeoGlobe.Format.WPSExecute version 1.0.0
 * @private
 */

GeoGlobe.Format.WPSExecute = GeoGlobe.Class4OL(GeoGlobe.Format.XML,
    GeoGlobe.Format.Filter.v1_1_0, {
    
    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        gml: "http://www.opengis.net/gml",
        wps: "http://www.opengis.net/wps/1.0.0",
        wfs: "http://www.opengis.net/wfs",
        ogc: "http://www.opengis.net/ogc",
        wcs: "http://www.opengis.net/wcs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {null}
     * @private
     *
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {String}
     * @private
     */
    VERSION: "1.0.0",

    /**
     * schemaLocation- Schema location
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {String}
     */
    schemaLocation: "http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd",

    schemaLocationAttr: function(options) {
        return undefined;
    },

    /**
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @param  {Object} options -实例化时所需的选项值。
     */

    /**
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @param {Object} options -  Optional object.
     * @returns {String} An WPS Execute request XML string.
     * @private
     */
    write: function(options) {
        var doc;
        if (GeoGlobe.Format.XML.supportActiveX) {
            doc = new ActiveXObject("Microsoft.XMLDOM");
            this.xmldom = doc;
        } else {
            doc = document.implementation.createDocument("", "", null);
        }
        var node = this.writeNode("wps:Execute", options, doc);
        this.setAttributeNS(
            node, this.namespaces.xsi,
            "xsi:schemaLocation", this.schemaLocation
        );
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    }, 

    /**
     *  解析WPS执行过程并返回执行结果。
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @param {String} or {DOMElement}data - 数据读取/解析。
     * @returns {Object}
     */
    read: function(data) {
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var info = {};
        this.readNode(data, info);
        return info;
    },

    /**
     * As a compliment to the readers property, this structure contains public
     *     writing functions grouped by namespace alias and named like the
     *     node names they produce.
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {null}
     * @private
     *
     */
    writers: {
        "wps": {
            "Execute": function(options) {
                var node = this.createElementNSPlus("wps:Execute", {
                    attributes: {
                        version: this.VERSION,
                        service: 'WPS'
                    } 
                }); 
                this.writeNode("ows:Identifier", options.identifier, node);
                this.writeNode("wps:DataInputs", options.dataInputs, node);
                this.writeNode("wps:ResponseForm", options.responseForm, node);
                return node; 
            },
            "ResponseForm": function(responseForm) {
                var node = this.createElementNSPlus("wps:ResponseForm", {});
                if (responseForm.rawDataOutput) {
                    this.writeNode("wps:RawDataOutput", responseForm.rawDataOutput, node);
                }
                if (responseForm.responseDocument) {
                    this.writeNode("wps:ResponseDocument", responseForm.responseDocument, node);
                }
                return node;
            },
            "ResponseDocument": function(responseDocument) {
                var node = this.createElementNSPlus("wps:ResponseDocument", {
                    attributes: {
                        storeExecuteResponse: responseDocument.storeExecuteResponse,
                        lineage: responseDocument.lineage,
                        status: responseDocument.status
                    }
                });
                if (responseDocument.outputs) {
                    for (var i = 0, len = responseDocument.outputs.length; i < len; i++) {
                        this.writeNode("wps:Output", responseDocument.outputs[i], node);
                    }
                }
                return node;
            },
            "Output": function(output) {
                var node = this.createElementNSPlus("wps:Output", {
                    attributes: {
                        asReference: output.asReference,
                        mimeType: output.mimeType,
                        encoding: output.encoding,
                        schema: output.schema
                    }
                });
                this.writeNode("ows:Identifier", output.identifier, node);
                this.writeNode("ows:Title", output.title, node);
                this.writeNode("ows:Abstract", output["abstract"], node);
                return node;
            },
            "RawDataOutput": function(rawDataOutput) {
                var node = this.createElementNSPlus("wps:RawDataOutput", {
                    attributes: {
                        mimeType: rawDataOutput.mimeType,
                        encoding: rawDataOutput.encoding,
                        schema: rawDataOutput.schema
                    }
                });
                this.writeNode("ows:Identifier", rawDataOutput.identifier, node);
                return node;
            },
            "DataInputs": function(dataInputs) {
                var node = this.createElementNSPlus("wps:DataInputs", {});
                for (var i=0, ii=dataInputs.length; i<ii; ++i) {
                    this.writeNode("wps:Input", dataInputs[i], node);
                }
                return node;
            },
            "Input": function(input) {
                var node = this.createElementNSPlus("wps:Input", {});
                this.writeNode("ows:Identifier", input.identifier, node);
                if (input.title) {
                    this.writeNode("ows:Title", input.title, node);
                }
                if (input.data) {
                    this.writeNode("wps:Data", input.data, node);
                }
                if (input.reference) {
                    this.writeNode("wps:Reference", input.reference, node);
                }
                if (input.boundingBoxData) {
                    this.writeNode("wps:BoundingBoxData", input.boundingBoxData, node);
                }
                return node;
            },
            "Data": function(data) {
                var node = this.createElementNSPlus("wps:Data", {});
                if (data.literalData) {
                    this.writeNode("wps:LiteralData", data.literalData, node);
                } else if (data.complexData) {
                    this.writeNode("wps:ComplexData", data.complexData, node);
                } else if (data.boundingBoxData) {
                    this.writeNode("ows:BoundingBox", data.boundingBoxData, node);
                }
                return node;
            },
            "LiteralData": function(literalData) {
                var node = this.createElementNSPlus("wps:LiteralData", {
                    attributes: {
                        uom: literalData.uom
                    },
                    value: literalData.value
                });
                return node;
            },
            "ComplexData": function(complexData) {
                var node = this.createElementNSPlus("wps:ComplexData", {
                    attributes: {
                        mimeType: complexData.mimeType,
                        encoding: complexData.encoding,
                        schema: complexData.schema
                    } 
                });
                var data = complexData.value;
                if (typeof data === "string") {
                    node.appendChild(
                        this.getXMLDoc().createCDATASection(complexData.value)
                    );
                } else {
                    node.appendChild(data);
                }
                return node;
            },
            "Reference": function(reference) {
                var node = this.createElementNSPlus("wps:Reference", {
                    attributes: {
                        mimeType: reference.mimeType,
                        "xlink:href": reference.href,
                        method: reference.method,
                        encoding: reference.encoding,
                        schema: reference.schema
                    }
                });
                if (reference.body) {
                    this.writeNode("wps:Body", reference.body, node);
                }
                return node;
            },
            "BoundingBoxData": function(node, obj) {
                this.writers['ows']['BoundingBox'].apply(this, [node, obj, "wps:BoundingBoxData"]);
            },
            "Body": function(body) {
                var node = this.createElementNSPlus("wps:Body", {});
                if (body.wcs) {
                    this.writeNode("wcs:GetCoverage", body.wcs, node);
                }
                else if (body.wfs) {
                    // GeoGlobe.Format.WFST expects these to be on the 
                    // instance and not in the options
                    this.featureType = body.wfs.featureType;
                    this.version = body.wfs.version;
                    this.writeNode("wfs:GetFeature", body.wfs, node);
                } else {
                    this.writeNode("wps:Execute", body, node);
                }
                return node;                
            }
        },
        "wcs": GeoGlobe.Format.WCSGetCoverage.prototype.writers.wcs,
        "wfs": GeoGlobe.Format.WFST.v1_1_0.prototype.writers.wfs,
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers.ogc,
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     * @memberof  GeoGlobe.Format.WPSExecute version 1.0.0.prototype
     * @type {null}
     * @private
     *
     */
    readers: {
        "wps": {
            "ExecuteResponse": function(node, obj) {
                obj.executeResponse = {
                    lang: node.getAttribute("lang"),
                    statusLocation: node.getAttribute("statusLocation"),
                    serviceInstance: node.getAttribute("serviceInstance"),
                    service: node.getAttribute("service")
                };
                this.readChildNodes(node, obj.executeResponse);
            },
            "Process":function(node,obj) {
                obj.process = {};
                this.readChildNodes(node, obj.process);
            },
            "Status":function(node,obj) {
                obj.status = {
                    creationTime: node.getAttribute("creationTime")
                };
                this.readChildNodes(node, obj.status);
            },
            "ProcessSucceeded": function(node,obj) {
                obj.processSucceeded = true;
            },
            "ProcessOutputs": function(node, processDescription) {
                processDescription.processOutputs = [];
                this.readChildNodes(node, processDescription.processOutputs);
            },
            "Output": function(node, processOutputs) {
                var output = {};
                this.readChildNodes(node, output);
                processOutputs.push(output);
            },
            "Reference": function(node, output) {
                output.reference = {
                    href: node.getAttribute("href"),
                    mimeType: node.getAttribute("mimeType"),
                    encoding: node.getAttribute("encoding"),
                    schema: node.getAttribute("schema")
                };
            },
            "Data": function(node, output) {
                output.data = {};
                this.readChildNodes(node, output);
            },
            "LiteralData": function(node, output) {
                output.literalData = {
                    dataType: node.getAttribute("dataType"),
                    uom: node.getAttribute("uom"),
                    value: this.getChildValue(node)
                };
            },
            "ComplexData": function(node, output) {
                output.complexData = {
                    mimeType: node.getAttribute("mimeType"),
                    schema: node.getAttribute("schema"),
                    encoding: node.getAttribute("encoding"),
                    value: ""
                };
                
                // try to get *some* value, ignore the empty text values
                if (this.isSimpleContent(node)) {
                    var child;
                    for(child=node.firstChild; child; child=child.nextSibling) {
                        switch(child.nodeType) {
                            case 3: // text node
                            case 4: // cdata section
                                output.complexData.value += child.nodeValue;
                        }
                    }
                }
                else {
                    for(child=node.firstChild; child; child=child.nextSibling) {
                        if (child.nodeType == 1) {
                            output.complexData.value = child;
                        }
                    }
                }

            },
            "BoundingBox": function(node, output) {
                output.boundingBoxData = {
                    dimensions: node.getAttribute("dimensions"),
                    crs: node.getAttribute("crs")
                };
                this.readChildNodes(node, output.boundingBoxData);
            }
        },

        // TODO: we should add Exception parsing here
        "ows": GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers["ows"]
    },
    
    CLASS_NAME: "GeoGlobe.Format.WPSExecute" 

});
/**
 * @class  GeoGlobe.Format.OGCExceptionReport
 * @classdesc 读取各种OGC服务和版本的异常报告。
 */

GeoGlobe.Format.OGCExceptionReport = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {

    /**
     * namespaces- Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        ogc: "http://www.opengis.net/ogc"
    },

    /**
     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @type {null}
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**
     * defaultPrefix
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @type {null}
     * @private
     */
    defaultPrefix: "ogc",

    /**
     * 为OGC例外报告创建一个新的分析器。
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @classdesc GeoGlobe.Format.OGCExceptionReport
     * @param {Object}options - 一个可选对象，其属性将在此实例上设置。
     */

    /**
     * 从字符串中读取OGC异常报告数据，并返回一个包含异常信息的对象。
     * @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     * @param {String| DOMElement}data -  数据读取/解析。
     * @returns {Object} 返回异常信息。
     */
    read: function(data) {
        var result;
        if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var root = data.documentElement;
        var exceptionInfo = {exceptionReport: null}; 
        if (root) {
            this.readChildNodes(data, exceptionInfo);
            if (exceptionInfo.exceptionReport === null) {
                // fall-back to OWSCommon since this is a common output format for exceptions
                // we cannot easily use the ows readers directly since they differ for 1.0 and 1.1
                exceptionInfo = new GeoGlobe.Format.OWSCommon().read(data);
            }
        }
        return exceptionInfo;
    },

    /**
     * Contains public functions, grouped by namespace prefix, that will
     *     be applied when a namespaced node is found matching the function
     *     name.  The function will be applied in the scope of this parser
     *     with two arguments: the node being read and a context object passed
     *     from the parent.
     *  @memberof GeoGlobe.Format.OGCExceptionReport.prototype
     *  @private
     */
    readers: {
        "ogc": {
            "ServiceExceptionReport": function(node, obj) {
                obj.exceptionReport = {exceptions: []};
                this.readChildNodes(node, obj.exceptionReport);
            },
            "ServiceException": function(node, exceptionReport) {
                var exception = {
                    code: node.getAttribute("code"),
                    locator: node.getAttribute("locator"),
                    text: this.getChildValue(node)
                };
                exceptionReport.exceptions.push(exception);
            }
        }
    },
    
    CLASS_NAME: "GeoGlobe.Format.OGCExceptionReport"
    
});
/**
 * @class GeoGlobe.Format.QueryStringFilter
 * @classdesc 解析器用于读取查询字符串并创建一个简单的过滤器。
 */

GeoGlobe.Format.QueryStringFilter = (function() {


    var cmpToStr = {};
    cmpToStr[GeoGlobe.Filter.Comparison.EQUAL_TO] = "eq";
    cmpToStr[GeoGlobe.Filter.Comparison.NOT_EQUAL_TO] = "ne";
    cmpToStr[GeoGlobe.Filter.Comparison.LESS_THAN] = "lt";
    cmpToStr[GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO] = "lte";
    cmpToStr[GeoGlobe.Filter.Comparison.GREATER_THAN] = "gt";
    cmpToStr[GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO] = "gte";
    cmpToStr[GeoGlobe.Filter.Comparison.LIKE] = "ilike";

    /**
     * 将值从正则表达式字符串转换为Web服务已知的LIKE / ILIKE字符串。
     * @memberof GeoGlobe.Format.QueryStringFilter.prototype
     * @param {String}value - 正则表达式字符串。
     * @returns {String} 转换后的字符串。
     */
    function regex2value(value) {

        // highly sensitive!! Do not change this without running the
        // Protocol/HTTP.html unit tests

        // convert % to \%
        value = value.replace(/%/g, "\\%");

        // convert \\. to \\_ (\\.* occurences converted later)
        value = value.replace(/\\\\\.(\*)?/g, function($0, $1) {
            return $1 ? $0 : "\\\\_";
        });

        // convert \\.* to \\%
        value = value.replace(/\\\\\.\*/g, "\\\\%");

        // convert . to _ (\. and .* occurences converted later)
        value = value.replace(/(\\)?\.(\*)?/g, function($0, $1, $2) {
            return $1 || $2 ? $0 : "_";
        });

        // convert .* to % (\.* occurnces converted later)
        value = value.replace(/(\\)?\.\*/g, function($0, $1) {
            return $1 ? $0 : "%";
        });

        // convert \. to .
        value = value.replace(/\\\./g, ".");

        // replace \* with * (watching out for \\*)
        value = value.replace(/(\\)?\\\*/g, function($0, $1) {
            return $1 ? $0 : "*";
        });

        return value;
    }
    
    return GeoGlobe.Class4OL(GeoGlobe.Format, {
        
        /**
         * wildcarded.- If true percent signs are added around values
         *     read from LIKE filters, for example if the protocol
         *     read method is passed a LIKE filter whose property
         *     is "foo" and whose value is "bar" the string
         *     "foo__ilike=%bar%" will be sent in the query string;
         *     defaults to false.
         *@type {Boolean}
         *@private
         */
        wildcarded: false,

        /**
         * srsInBBOX - 在BBOX查询字符串参数中包含SRS标识符。
         * 默认为false。 如果为true并且该图层设置了投影对象，则将使用标识投影的第五项序列化任何BBOX滤镜。 
         * 例如。BBOX=-1000，-1000,1000,1000，EPSG：900913
         * @memberof GeoGlobe.Format.QueryStringFilter.prototype
         * @type {Boolean}
         */
        srsInBBOX: false,

        /**
         * 使用查询字符串参数的“简单”过滤器语法序列化GeoGlobe.Filter对象。
         * 该功能必须作为协议实例的一种方法被调用。
         * @memberof GeoGlobe.Format.QueryStringFilter.prototype
         * @param {GeoGlobe.Filter}filter - 过滤器转换.
         * @param {Object} params -  参数对象.
         * @returns {Object} 结果参数对象.
         */
        write: function(filter, params) {
            params = params || {};
            var className = filter.CLASS_NAME;
            var filterType = className.substring(className.lastIndexOf(".") + 1);
            switch (filterType) {
                case "Spatial":
                    switch (filter.type) {
                        case GeoGlobe.Filter.Spatial.BBOX:
                            params.bbox = filter.value.toArray();
                            if (this.srsInBBOX && filter.projection) {
                                params.bbox.push(filter.projection.getCode());
                            }
                            break;
                        case GeoGlobe.Filter.Spatial.DWITHIN:
                            params.tolerance = filter.distance;
                            // no break here
                        case GeoGlobe.Filter.Spatial.WITHIN:
                            params.lon = filter.value.x;
                            params.lat = filter.value.y;
                            break;
                        default:
                            GeoGlobe.Console.warn(
                                "Unknown spatial filter type " + filter.type);
                    }
                    break;
                case "Comparison":
                    var op = cmpToStr[filter.type];
                    if (op !== undefined) {
                        var value = filter.value;
                        if (filter.type == GeoGlobe.Filter.Comparison.LIKE) {
                            value = regex2value(value);
                            if (this.wildcarded) {
                                value = "%" + value + "%";
                            }
                        }
                        params[filter.property + "__" + op] = value;
                        params.queryable = params.queryable || [];
                        params.queryable.push(filter.property);
                    } else {
                        GeoGlobe.Console.warn(
                            "Unknown comparison filter type " + filter.type);
                    }
                    break;
                case "Logical":
                    if (filter.type === GeoGlobe.Filter.Logical.AND) {
                        for (var i=0,len=filter.filters.length; i<len; i++) {
                            params = this.write(filter.filters[i], params);
                        }
                    } else {
                        GeoGlobe.Console.warn(
                            "Unsupported logical filter type " + filter.type);
                    }
                    break;
                default:
                    GeoGlobe.Console.warn("Unknown filter type " + filterType);
            }
            return params;
        },
        
        CLASS_NAME: "GeoGolobe.Format.QueryStringFilter"
        
    });


})();
/**
 * @class GeoGlobe.Format.BusCapabilities
 * @classdesc 公交换乘服务Capabilities操作解析类，继承自GeoGlobe.Format.XML类，具有该类的所有属性与方法，并在此基础上进行了扩展。
 */

GeoGlobe.Format.BusCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML,{
	
    /**
     * 常量"NETWORK_Capabilities" ,根据该服务的getCapabilities请求返回而定。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @type {String}
     */
	tagName: "NETWORK_Capabilities",

	 /**
      * * 解析一个XML串并返回capabilitiesObj｛Object｝对象。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {String} data - 一个XML字符串。
     * @returns {object}- capabilitiesObj
     */
    read: function(data){
		if(typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
		
		var capabilitiesNode;
		if(data.nodeName != this.tagName){
			capabilitiesNode = data.getElementsByTagName(this.tagName);
		} else {
			capabilitiesNode = [data];
		}
		
		var capabilitiesObj = {};
		if(capabilitiesNode.length > 0){
			this.runChildNodes(capabilitiesObj, capabilitiesNode[0]);
		}
		return capabilitiesObj;
	},


    /**
     * 解析每一个节点字符串并把相对应值赋给传入最终返回的对象obj。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} obj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     * @param {String} parentPath -解析方法拼去，这里使用"capabilities"。
     */
	runChildNodes: function(obj, node, parentPath) {
        var children = node.childNodes;
        var childNode, processor;
        for(var i=0; i<children.length; ++i) {
            childNode = children[i];
            if(childNode.nodeType == 1) {
				if(parentPath){
					processor = this["read_" + parentPath + "_" + childNode.nodeName];
				} else{
					processor = this["read_" + childNode.nodeName];
				}
                
                if(processor) {
                    processor.apply(this, [obj, childNode]);
                }
            }
        }
    },

	/**
     * 解析节点Service的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}capabilitiesObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Service: function(capabilitiesObj, node){
		var serviceObj = {};
		this.runChildNodes(serviceObj, node, "Service");
		capabilitiesObj.service = serviceObj;
	},

	/**
     * 解析节点为Name的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}servcieObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Service_Name: function(servcieObj,node){
		var name = this.getChildValue(node);
		if(name) {
            servcieObj.name = name;
        }
	},

	/**
     *  解析节点为Title的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}servcieObj -  最终返回的对象
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Service_Title: function(servcieObj,node){
		var title = this.getChildValue(node);
		if(title) {
            servcieObj.title = title;
        }
	},

	/**
     * 解析节点为Abstract的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}servcieObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Service_Abstract: function(servcieObj,node){
		var serviceAbstract = this.getChildValue(node);
		if(serviceAbstract) {
            servcieObj.serviceAbstract = serviceAbstract;
        }
	},

	/**
     * 解析节点为KeywordList的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} userScenarioObj -最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Service_KeywordList: function(userScenarioObj,node){
	},

	/**
     * 解析节点为OnlineResource的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} servcieObj -最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Service_OnlineResource: function(servcieObj,node){
		var onlineResource = this.getChildValue(node);
		if(servcieObj) {
            servcieObj.onlineResource = onlineResource;
        }
	},

	/**
     * 解析节点为Capability的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}capabilitiesObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability: function(capabilitiesObj,node){
		var capaObj = {};
		this.runChildNodes(capaObj, node, "Capability");
		capabilitiesObj.capability = capaObj;
	},

	/**
     *  解析节点为Request的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}｛capaObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request: function(capaObj,node){
		var requestObj = {};
		this.runChildNodes(requestObj, node, "Capability_Request");
		capaObj.request = requestObj;
	},

	/**
     * 解析节点为GetCapabilities的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param  {Object}requestObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_GetCapabilities: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var getCapaObj ={};
		if(httpNode[0]){
			this.runChildNodes(getCapaObj, httpNode[0], "Capability_Request_GetCapabilities_DCPType_HTTP");
		}
		requestObj.getCapabilities = getCapaObj;
		
	},

	/**
     *  解析节点为DCPType_HTTP_Get的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}getCapaObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Get: function(getCapaObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            getCapaObj.getUrl = getUrl;
        }
	},

	/**
     * 解析节点为DCPType_HTTP_Post的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}getCapaObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Capability_Request_GetCapabilities_DCPType_HTTP_Post: function(getCapaObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            getCapaObj.postUrl = postUrl;
        }
	},
	
	/**
     * 解析节点为queryStation的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}requestObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryStation: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryStationObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryStationObj, httpNode[0], "Capability_Request_queryStation_DCPType_HTTP");
		}
		requestObj.queryStation = queryStationObj;
		
	},

	/**
     * 解析节点为DCPType_HTTP_Get的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} queryStationObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */	
	read_Capability_Request_queryStation_DCPType_HTTP_Get: function(queryStationObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryStationObj.getUrl = getUrl;
        }
	},
	
	read_Capability_Request_queryStation_DCPType_HTTP_Post: function(queryStationObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryStationObj.postUrl = postUrl;
        }
	},

	/**
     * 解析节点为queryLine的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}requestObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryLine: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryLineObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryLineObj, httpNode[0], "Capability_Request_queryLine_DCPType_HTTP");
		}
		requestObj.queryLine = queryLineObj;
		
	},

	/**
    * 解析节点为DCPType_HTTP_Get的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}queryLineObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */			
	read_Capability_Request_queryLine_DCPType_HTTP_Get: function(queryLineObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryLineObj.getUrl = getUrl;
        }
	},

	/**
    * 解析节点为DCPType_HTTP_Post的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}queryLineObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryLine_DCPType_HTTP_Post: function(queryLineObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryLineObj.postUrl = postUrl;
        }	
	},

	/**
     * 解析节点为queryChange的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object} requestObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryChange: function(requestObj,node){
		var httpNode = node.getElementsByTagName("HTTP");
		var queryChangeObj = {};
		if(httpNode[0]){
			this.runChildNodes(queryChangeObj, httpNode[0], "Capability_Request_queryChange_DCPType_HTTP");
		}
		
	},

	/**
     * 解析节点为DCPType_HTTP_Get的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}queryChangeObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Get: function(queryChangeObj,node){
		var getUrl = node.getAttribute("onlineResource");
		if(getUrl) {
            queryChangeObj.getUrl = getUrl;
        }
	},

	/**
     * 解析节点为DCPType_HTTP_Post的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param read_Capability_Request_queryChange_DCPType_HTTP_Post
     * @param {Object}queryChangeObj - 最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Request_queryChange_DCPType_HTTP_Post: function(queryChangeObj,node){
		var postUrl = node.getAttribute("onlineResource");
		if(postUrl) {
            queryChangeObj.postUrl = postUrl;
        }	
	},

	/**
     * 解析节点为Networks的节点。
     * @memberof GeoGlobe.Format.BusCapabilities.prototype
     * @param {Object}capabilitiesObj -  最终返回的对象。
     * @param {DOMElement} node   需要解析的节点对象
     */		
	read_Capability_Networks: function(capabilitiesObj,node){		
		var networkNodes = node.getElementsByTagName("Name");
		var networks = [];
		for(var i=0; i<networkNodes.length; i++){
			var network = this.getChildValue(networkNodes[i]);
			if(network){
				networks.push(network);
			}			
		}
		capabilitiesObj.networks = networks;
	},
	
	CLASS_NAME:"GeoGlobe.Format.BusCapabilities"
});/**
 * @class GeoGlobe.Format.XML2JSON
 * @classdesc 将可扩展标记语言文件解析成Javascript对象。
 */
GeoGlobe.Format.XML2JSON = GeoGlobe.Class4OL({
	
	/**
     *GeoGlobe.Format.XML2JSON构造函数。
     * @memberof  GeoGlobe.Format.XML2JSON.prototype
	 */
	initialize: function(){
		
	},
	
    /**
     * 将传入的可扩展标记语言字符串解析成Javascript对象并返回。
     * @memberof GeoGlobe.Format.XML2JSON.prototype
	 * @param {String}  xmlcode -XML字符串。
	 */	
	read: function(xmlcode,ignoretags,debug){
		if(!ignoretags){ignoretags=""};
		xmlcode=xmlcode.replace(/\s*\/>/g,'/>');
		xmlcode=xmlcode.replace(/<\?[^>]*>/g,"").replace(/<\![^>]*>/g,"");
		if (!ignoretags.sort){ignoretags=ignoretags.split(",")};
		var x=this.no_fast_endings(xmlcode);
		x=this.attris_to_tags(x);
		x=escape(x);
		x=x.split("%3C").join("<").split("%3E").join(">").split("%3D").join("=").split("%22").join("\"");
		for (var i=0;i<ignoretags.length;i++){
			x=x.replace(new RegExp("<"+ignoretags[i]+">","g"),"*$**"+ignoretags[i]+"**$*");
			x=x.replace(new RegExp("</"+ignoretags[i]+">","g"),"*$***"+ignoretags[i]+"**$*")
		};
		x='<JSONTAGWRAPPER>'+x+'</JSONTAGWRAPPER>';
		this.xmlobject={};
		
		//---------------------修正禁止属性小写后,出现jsontagwrapper变成数组
		var y=this.xml_to_object(x).JSONTAGWRAPPER;
		//var y=this.xml_to_object(x).jsontagwrapper;
		
		if(debug){y=this.show_json_structure(y,debug)};
		return y
	},
	
	xml_to_object:function(xmlcode){
		var x=xmlcode.replace(/<\//g,"?");
		x=x.split("<");
		var y=[];
		var level=0;
		var opentags=[];
		for (var i=1;i<x.length;i++){
			var tagname=x[i].split(">")[0];
			opentags.push(tagname);
			level++
			y.push(level+"<"+x[i].split("?")[0]);
			while(x[i].indexOf("?"+opentags[opentags.length-1]+">")>=0){level--;opentags.pop()}
		};
		var oldniva=-1;
		var objname="this.xmlobject";
		for (var i=0;i<y.length;i++){
			var preeval="";
			var niva=y[i].split("<")[0];
			var tagnamn=y[i].split("<")[1].split(">")[0];
			
			//---------------------修正:禁止将属性和标签统一成小写,并将命名空间的冒号转成下划线
			tagnamn = tagnamn.replace(/%3A/,"_");
			//tagnamn=tagnamn.toLowerCase();
			
			var rest=y[i].split(">")[1];
			if(niva<=oldniva){
				var tabort=oldniva-niva+1;
				for (var j=0;j<tabort;j++){objname=objname.substring(0,objname.lastIndexOf("."))}
			};
			objname+="."+tagnamn;
			var pobject=objname.substring(0,objname.lastIndexOf("."));
			if (eval("typeof "+pobject) != "object"){preeval+=pobject+"={value:"+pobject+"};\n"};
			var objlast=objname.substring(objname.lastIndexOf(".")+1);
			var already=false;
			for (k in eval(pobject)){if(k==objlast){already=true}};
			var onlywhites=true;
			for(var s=0;s<rest.length;s+=3){
				if(rest.charAt(s)!="%"){onlywhites=false}
			};
			if (rest!="" && !onlywhites){
				if(rest/1!=rest){
					rest="'"+rest.replace(/\'/g,"\\'")+"'";
					rest=rest.replace(/\*\$\*\*\*/g,"</");
					rest=rest.replace(/\*\$\*\*/g,"<");
					rest=rest.replace(/\*\*\$\*/g,">")
				}
			} 
			else {rest="{}"};
			if(rest.charAt(0)=="'"){rest='unescape('+rest+')'};
			if (already && !eval(objname+".sort")){preeval+=objname+"=["+objname+"];\n"};
			var before="=";after="";
			if (already){before=".push(";after=")"};
			var toeval=preeval+objname+before+rest+after;
			eval(toeval);
			if(eval(objname+".sort")){objname+="["+eval(objname+".length-1")+"]"};
			oldniva=niva
		};
		return this.xmlobject
	},
	show_json_structure:function(obj,debug,l){
		var x='';
		if (obj.sort){x+="[\n"} else {x+="{\n"};
		for (var i in obj){
			if (!obj.sort){x+=i+":"};
			if (typeof obj[i] == "object"){
				x+=this.show_json_structure(obj[i],false,1)
			}
			else {
				if(typeof obj[i]=="function"){
					var v=obj[i]+"";
					//v=v.replace(/\t/g,"");
					x+=v
				}
				else if(typeof obj[i]!="string"){x+=obj[i]+",\n"}
				else {x+="'"+obj[i].replace(/\'/g,"\\'").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r")+"',\n"}
			}
		};
		if (obj.sort){x+="],\n"} else {x+="},\n"};
		if (!l){
			x=x.substring(0,x.lastIndexOf(","));
			x=x.replace(new RegExp(",\n}","g"),"\n}");
			x=x.replace(new RegExp(",\n]","g"),"\n]");
			var y=x.split("\n");x="";
			var lvl=0;
			for (var i=0;i<y.length;i++){
				if(y[i].indexOf("}")>=0 || y[i].indexOf("]")>=0){lvl--};
				tabs="";for(var j=0;j<lvl;j++){tabs+="\t"};
				x+=tabs+y[i]+"\n";
				if(y[i].indexOf("{")>=0 || y[i].indexOf("[")>=0){lvl++}
			};
			if(debug=="html"){
				x=x.replace(/</g,"&lt;").replace(/>/g,"&gt;");
				x=x.replace(/\n/g,"<BR>").replace(/\t/g,"&nbsp;&nbsp;&nbsp;&nbsp;")
			};
			if (debug=="compact"){x=x.replace(/\n/g,"").replace(/\t/g,"")}
		};
		return x
	},
	no_fast_endings:function(x){
		x=x.split("/>");
		for (var i=1;i<x.length;i++){
			var t=x[i-1].substring(x[i-1].lastIndexOf("<")+1).split(" ")[0];
			x[i]="></"+t+">"+x[i]
		}	;
		x=x.join("");
		return x
	},
	attris_to_tags: function(x){
		var d=' ="\''.split("");
		x=x.split(">");
		for (var i=0;i<x.length;i++){
			var temp=x[i].split("<");
			for (var r=0;r<4;r++){temp[0]=temp[0].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")};
			if(temp[1]){
				temp[1]=temp[1].replace(/'/g,'"');
				temp[1]=temp[1].split('"');
				for (var j=1;j<temp[1].length;j+=2){
					for (var r=0;r<4;r++){temp[1][j]=temp[1][j].replace(new RegExp(d[r],"g"),"_jsonconvtemp"+r+"_")}
				};
				temp[1]=temp[1].join('"')
			};
			x[i]=temp.join("<")
		};
		x=x.join(">");
		x=x.replace(/ ([^=]*)=([^ |>]*)/g,"><$1>$2</$1");
		x=x.replace(/>"/g,">").replace(/"</g,"<");
		for (var r=0;r<4;r++){x=x.replace(new RegExp("_jsonconvtemp"+r+"_","g"),d[r])}	;
		return x
	},
	
    CLASS_NAME: "GeoGlobe.Format.XML2JSON"
});/**
 * @class GeoGlobe.Format.CSWGetRecords
 * @classdesc Default version is 2.0.2.
 * @returns {GeoGlobe.Format} 给定版本的CSWGetRecords格式。
 * @private
 */


GeoGlobe.Format.CSWGetRecords = function(options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Format.CSWGetRecords.DEFAULTS
    );
    var cls = GeoGlobe.Format.CSWGetRecords["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "Unsupported CSWGetRecords version: " + options.version;
    }
    return new cls(options);
};

GeoGlobe.Format.CSWGetRecords.DEFAULTS = {
    "version": "2.0.2"
};
/** Copyright (c) 2006-2013 by GeoGlobe Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the GeoGlobe distribution or repository for the
 * full text of the license. */



/**
 * @class GeoGlobe.Format.CSWGetRecords.v2_0_2
 * @classdesc   用于创建网络目录服务记录 v2.0.2事务的格式。
 * 使用GeoGlobe.Format.CSWGetRecords.v2_0_2构造函数创建一个新实例。
 *
 * Inherits from:
 *  - GeoGlobe.Format.XML
 */
GeoGlobe.Format.CSWGetRecords.v2_0_2 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    
    /**
     * Mapping of namespace aliases to namespace URIs.
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {Object}
     * @private
     */
    namespaces: {
        csw: "http://www.opengis.net/cat/csw/2.0.2",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        gmd: "http://www.isotc211.org/2005/gmd",
        geonet: "http://www.fao.org/geonetwork",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    
    /**
     * The default prefix (used by Format.XML).
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     *@type {String}
     *@private
     */
    defaultPrefix: "csw",
    
    /**
     * CSW version number.
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     *@type {String}
     *@private
     */
    version: "2.0.2",
    
    /**
     * http://www.opengis.net/cat/csw/2.0.2
     * http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     * @private
     */
    schemaLocation: "http://www.opengis.net/cat/csw/2.0.2 http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd",

    /**
     * GetRecords元素的requestId属性的值。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    requestId: null,

    /**
     * GetRecords元素的resultType属性的值指定GetRecords响应中的结果类型，“hits”是默认值。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    resultType: null,

    /**
     *GetRecords元素的outputFormat属性的值指定GetRecords响应的格式，“application / xml”是默认值。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    outputFormat: null,

    /**
     * GetRecords元素的outputSchema属性的值指定了GetRecords响应的模式。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    outputSchema: null,

    /**
     *GetRecords元素的startPosition属性值指定GetRecords响应的起始位置（偏移+ 1），默认值为1。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    startPosition: null,

    /**
     *GetRecords元素的maxRecords属性值指定GetRecords响应中的最大记录数，默认值为10。
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     *@type {String}
     */
    maxRecords: null,

    /**
     *csw的值：DistributedSearch元素，用于编写csw：GetRecords文档时使用。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    DistributedSearch: null,

    /**
     *写入csw：GetRecords文档时使用的csw：ResponseHandler元素的值。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @type {String}
     */
    ResponseHandler: null,

    /**
     *当写入csw：GetRecords文档时使用的csw：Query元素的值。
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     *@type {String}
     */
    Query: null,

    /**

     * Compiled regular expressions for manipulating strings.
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @private
     */
    regExes: {
        trimSpace: (/^\s*|\s*$/g),
        removeSpace: (/\s*/g),
        splitSpace: (/\s+/),
        trimComma: (/\s*,\s*/g)
    },

    /**

     * 解析和生成CSWGetRecords v2.0.2事务的类。
     *@memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype

     * @param {Object}options -  可选对象的属性将在实例上设置。
     *
     * 有效选项属性（记录为类属性）：
     * - requestId
     * - resultType
     * - outputFormat
     * - outputSchema
     * - startPosition
     * - maxRecords
     * - DistributedSearch
     * - ResponseHandler
     * - Query
     */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

    /**

     * 解析来自GetRecords请求的响应。
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     */
    read: function(data) {
        if(typeof data == "string") { 
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            data = data.documentElement;
        }
        var obj = {};
        this.readNode(data, obj);
        return obj;
    },
    
    /**

     * Contains public functions, grouped by namespace prefix, that will
     * be applied when a namespaced node is found matching the function
     * name.  The function will be applied in the scope of this parser
     * with two arguments: the node being read and a context object passed
     * from the parent.
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @private
     */
    readers: {
        "csw": {
            "GetRecordsResponse": function(node, obj) {
                obj.records = [];
                this.readChildNodes(node, obj);
                var version = this.getAttributeNS(node, "", 'version');
                if (version != "") {
                    obj.version = version;
                }
            },
            "RequestId": function(node, obj) {
                obj.RequestId = this.getChildValue(node);
            },
            "SearchStatus": function(node, obj) {
                obj.SearchStatus = {};
                var timestamp = this.getAttributeNS(node, "", 'timestamp');
                if (timestamp != "") {
                    obj.SearchStatus.timestamp = timestamp;
                }
            },
            "SearchResults": function(node, obj) {
                this.readChildNodes(node, obj);
                var attrs = node.attributes;
                var SearchResults = {};
                for(var i=0, len=attrs.length; i<len; ++i) {
                    if ((attrs[i].name == "numberOfRecordsMatched") ||
                        (attrs[i].name == "numberOfRecordsReturned") ||
                        (attrs[i].name == "nextRecord")) {
                        SearchResults[attrs[i].name] = parseInt(attrs[i].nodeValue);
                    } else {
                        SearchResults[attrs[i].name] = attrs[i].nodeValue;
                    }
                }
                obj.SearchResults = SearchResults;
            },
            "SummaryRecord": function(node, obj) {
                var record = {type: "SummaryRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "BriefRecord": function(node, obj) {
                var record = {type: "BriefRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "DCMIRecord": function(node, obj) {
                var record = {type: "DCMIRecord"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "Record": function(node, obj) {
                var record = {type: "Record"};
                this.readChildNodes(node, record);
                obj.records.push(record);
            },
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                obj[name] = this.getChildValue(node);
            }
        },
        "geonet": {
            "info": function(node, obj) {
                var gninfo = {};
                this.readChildNodes(node, gninfo);
                obj.gninfo = gninfo;
            }
        },
        "dc": {
            // audience, contributor, coverage, creator, date, description, format,
            // identifier, language, provenance, publisher, relation, rights,
            // rightsHolder, source, subject, title, type, URI
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(GeoGlobe.Util.isArray(obj[name]))) {
                    obj[name] = [];
                }
                var dc_element = {};
                var attrs = node.attributes;
                for(var i=0, len=attrs.length; i<len; ++i) {
                    dc_element[attrs[i].name] = attrs[i].nodeValue;
                }
                dc_element.value = this.getChildValue(node);
                if (dc_element.value != "") {
                    obj[name].push(dc_element);
                }
            }
        },
        "dct": {
            // abstract, modified, spatial
            "*": function(node, obj) {
                var name = node.localName || node.nodeName.split(":").pop();
                if (!(GeoGlobe.Util.isArray(obj[name]))) {
                    obj[name] = [];
                }
                obj[name].push(this.getChildValue(node));
            }
        },
        "ows": GeoGlobe.Util.applyDefaults({
            "BoundingBox": function(node, obj) {
                if (obj.bounds) {
                    obj.BoundingBox = [{crs: obj.projection, value: 
                        [
                            obj.bounds._sw.lng,
                            obj.bounds._sw.lat,
                            obj.bounds._ne.lng,
                            obj.bounds._ne.lat
                    ]
                    }];
                    delete obj.projection;
                    delete obj.bounds;
                }
                GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"]["BoundingBox"].apply(
                    this, arguments);
            }
        }, GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers["ows"])
    },
    
    /**

     * Given an configuration js object, write a CSWGetRecords request. 
     * @memberof GeoGlobe.Format.CSWGetRecords.v2_0_2.prototype
     * @param {Object}options -  A object mapping the request.
     *
     * @returns {String} A serialized CSWGetRecords request.
     * @private
     */
    write: function(options) {
        var node = this.writeNode("csw:GetRecords", options);
        node.setAttribute("xmlns:gmd", this.namespaces.gmd);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [node]);
    },

    /**

     * As a compliment to the readers property, this structure contains public
     * writing functions grouped by namespace alias and named like the
     * node names they produce.
     * @memberof GeoGlobe.v2_0_2.prototype
     * @private
     */
    writers: {
        "csw": {
            "GetRecords": function(options) {
                if (!options) {
                    options = {};
                }
                var node = this.createElementNSPlus("csw:GetRecords", {
                    attributes: {
                        service: "CSW",
                        version: this.version,
                        requestId: options.requestId || this.requestId,
                        resultType: options.resultType || this.resultType,
                        outputFormat: options.outputFormat || this.outputFormat,
                        outputSchema: options.outputSchema || this.outputSchema,
                        startPosition: options.startPosition || this.startPosition,
                        maxRecords: options.maxRecords || this.maxRecords
                    }
                });
                if (options.DistributedSearch || this.DistributedSearch) {
                    this.writeNode(
                        "csw:DistributedSearch",
                        options.DistributedSearch || this.DistributedSearch,
                        node
                    );
                }
                var ResponseHandler = options.ResponseHandler || this.ResponseHandler;
                if (GeoGlobe.Util.isArray(ResponseHandler) && ResponseHandler.length > 0) {
                    // ResponseHandler must be a non-empty array
                    for(var i=0, len=ResponseHandler.length; i<len; i++) {
                        this.writeNode(
                            "csw:ResponseHandler",
                            ResponseHandler[i],
                            node
                        );
                    }
                }
                this.writeNode("Query", options.Query || this.Query, node);
                return node;
            },
            "DistributedSearch": function(options) {
                var node = this.createElementNSPlus("csw:DistributedSearch", {
                    attributes: {
                        hopCount: options.hopCount
                    }
                });
                return node;
            },
            "ResponseHandler": function(options) {
                var node = this.createElementNSPlus("csw:ResponseHandler", {
                    value: options.value
                });
                return node;
            },
            "Query": function(options) {
                if (!options) {
                    options = {};
                }
                var node = this.createElementNSPlus("csw:Query", {
                    attributes: {
                        typeNames: options.typeNames || "csw:Record"
                    }
                });
                var ElementName = options.ElementName;
                if (GeoGlobe.Util.isArray(ElementName) && ElementName.length > 0) {
                    // ElementName must be a non-empty array
                    for(var i=0, len=ElementName.length; i<len; i++) {
                        this.writeNode(
                            "csw:ElementName",
                            ElementName[i],
                            node
                        );
                    }
                } else {
                    this.writeNode(
                        "csw:ElementSetName",
                        options.ElementSetName || {value: 'summary'},
                        node
                    );
                }
                if (options.Constraint) {
                    this.writeNode(
                        "csw:Constraint",
                        options.Constraint,
                        node
                    );
                }
                if (options.SortBy) {
                    this.writeNode(
                        "ogc:SortBy",
                        options.SortBy,
                        node
                    );
                }
                return node;
            },
            "ElementName": function(options) {
                var node = this.createElementNSPlus("csw:ElementName", {
                    value: options.value
                });
                return node;
            },
            "ElementSetName": function(options) {
                var node = this.createElementNSPlus("csw:ElementSetName", {
                    attributes: {
                        typeNames: options.typeNames
                    },
                    value: options.value
                });
                return node;
            },
            "Constraint": function(options) {
                var node = this.createElementNSPlus("csw:Constraint", {
                    attributes: {
                        version: options.version
                    }
                });
                if (options.Filter) {
                    var format = new GeoGlobe.Format.Filter({
                        version: options.version
                    });
                    node.appendChild(format.write(options.Filter));
                } else if (options.CqlText) {
                    var child = this.createElementNSPlus("CqlText", {
                        value: options.CqlText.value
                    });
                    node.appendChild(child);
                }
                return node;
            }
        },
        "ogc": GeoGlobe.Format.Filter.v1_1_0.prototype.writers["ogc"]
    },
   
    CLASS_NAME: "GeoGlobe.Format.CSWGetRecords.v2_0_2"
});
/*
 Copyright 2011-2013 Abdulla Abdurakhmanov
 Original sources are available at https://code.google.com/p/x2js/

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

(function (root, factory) {
	/*//标签式引入，不需要这段判断代码
     if (typeof define === "function" && define.amd) {
         define([], factory);
     } else if (typeof exports === "object") {
         module.exports = factory();
     } else {
         root.X2JS = factory();
     }
	 */
	root.GeoGlobe.Format.X2JS = factory();
	root.GeoGlobe.Format.X2JS.CLASS_NAME = "GeoGlobe.Format.X2JS";
 }(window, function () {
	return function (config) {
		'use strict';
			
		var VERSION = "1.2.0";
		
		config = config || {};
		initConfigDefaults();
		initRequiredPolyfills();
		
		function initConfigDefaults() {
			if(config.escapeMode === undefined) {
				config.escapeMode = true;
			}
			
			config.attributePrefix = config.attributePrefix || "_";
			config.arrayAccessForm = config.arrayAccessForm || "none";
			config.emptyNodeForm = config.emptyNodeForm || "text";		
			
			if(config.enableToStringFunc === undefined) {
				config.enableToStringFunc = true; 
			}
			config.arrayAccessFormPaths = config.arrayAccessFormPaths || []; 
			if(config.skipEmptyTextNodesForObj === undefined) {
				config.skipEmptyTextNodesForObj = true;
			}
			if(config.stripWhitespaces === undefined) {
				config.stripWhitespaces = true;
			}
			config.datetimeAccessFormPaths = config.datetimeAccessFormPaths || [];
	
			if(config.useDoubleQuotes === undefined) {
				config.useDoubleQuotes = false;
			}
			
			config.xmlElementsFilter = config.xmlElementsFilter || [];
			config.jsonPropertiesFilter = config.jsonPropertiesFilter || [];
			
			if(config.keepCData === undefined) {
				config.keepCData = false;
			}
		}
	
		var DOMNodeTypes = {
			ELEMENT_NODE 	   : 1,
			TEXT_NODE    	   : 3,
			CDATA_SECTION_NODE : 4,
			COMMENT_NODE	   : 8,
			DOCUMENT_NODE 	   : 9
		};
		
		function initRequiredPolyfills() {		
		}
		
		function getNodeLocalName( node ) {
			var nodeLocalName = node.localName;			
			if(nodeLocalName == null) // Yeah, this is IE!! 
				nodeLocalName = node.baseName;
			if(nodeLocalName == null || nodeLocalName=="") // =="" is IE too
				nodeLocalName = node.nodeName;
			return nodeLocalName;
		}
		
		function getNodePrefix(node) {
			return node.prefix;
		}
			
		function escapeXmlChars(str) {
			if(typeof(str) == "string")
				return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
			else
				return str;
		}
	
		function unescapeXmlChars(str) {
			return str.replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, '&');
		}
		
		function checkInStdFiltersArrayForm(stdFiltersArrayForm, obj, name, path) {
			var idx = 0;
			for(; idx < stdFiltersArrayForm.length; idx++) {
				var filterPath = stdFiltersArrayForm[idx];
				if( typeof filterPath === "string" ) {
					if(filterPath == path)
						break;
				}
				else
				if( filterPath instanceof RegExp) {
					if(filterPath.test(path))
						break;
				}				
				else
				if( typeof filterPath === "function") {
					if(filterPath(obj, name, path))
						break;
				}
			}
			return idx!=stdFiltersArrayForm.length;
		}
		
		function toArrayAccessForm(obj, childName, path) {
			switch(config.arrayAccessForm) {
				case "property":
					if(!(obj[childName] instanceof Array))
						obj[childName+"_asArray"] = [obj[childName]];
					else
						obj[childName+"_asArray"] = obj[childName];
					break;
				/*case "none":
					break;*/
			}
			
			if(!(obj[childName] instanceof Array) && config.arrayAccessFormPaths.length > 0) {
				if(checkInStdFiltersArrayForm(config.arrayAccessFormPaths, obj, childName, path)) {
					obj[childName] = [obj[childName]];
				}			
			}
		}
		
		function fromXmlDateTime(prop) {
			// Implementation based up on http://stackoverflow.com/questions/8178598/xml-datetime-to-javascript-date-object
			// Improved to support full spec and optional parts
			var bits = prop.split(/[-T:+Z]/g);
			
			var d = new Date(bits[0], bits[1]-1, bits[2]);			
			var secondBits = bits[5].split("\.");
			d.setHours(bits[3], bits[4], secondBits[0]);
			if(secondBits.length>1)
				d.setMilliseconds(secondBits[1]);
	
			// Get supplied time zone offset in minutes
			if(bits[6] && bits[7]) {
				var offsetMinutes = bits[6] * 60 + Number(bits[7]);
				var sign = /\d\d-\d\d:\d\d$/.test(prop)? '-' : '+';
	
				// Apply the sign
				offsetMinutes = 0 + (sign == '-'? -1 * offsetMinutes : offsetMinutes);
	
				// Apply offset and local timezone
				d.setMinutes(d.getMinutes() - offsetMinutes - d.getTimezoneOffset())
			}
			else
				if(prop.indexOf("Z", prop.length - 1) !== -1) {
					d = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));					
				}
	
			// d is now a local time equivalent to the supplied time
			return d;
		}
		
		function checkFromXmlDateTimePaths(value, childName, fullPath) {
			if(config.datetimeAccessFormPaths.length > 0) {
				var path = fullPath.split("\.#")[0];
				if(checkInStdFiltersArrayForm(config.datetimeAccessFormPaths, value, childName, path)) {
					return fromXmlDateTime(value);
				}
				else
					return value;			
			}
			else
				return value;
		}
		
		function checkXmlElementsFilter(obj, childType, childName, childPath) {
			if( childType == DOMNodeTypes.ELEMENT_NODE && config.xmlElementsFilter.length > 0) {
				return checkInStdFiltersArrayForm(config.xmlElementsFilter, obj, childName, childPath);	
			}
			else
				return true;
		}	
	
		function parseDOMChildren( node, path ) {
			if(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {
				var result = new Object;
				var nodeChildren = node.childNodes;
				// Alternative for firstElementChild which is not supported in some environments
				for(var cidx=0; cidx <nodeChildren.length; cidx++) {
					var child = nodeChildren.item(cidx);
					if(child.nodeType == DOMNodeTypes.ELEMENT_NODE) {
						var childName = getNodeLocalName(child);
						result[childName] = parseDOMChildren(child, childName);
					}
				}
				return result;
			}
			else
			if(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {
				var result = new Object;
				result.__cnt=0;
				
				var nodeChildren = node.childNodes;
				
				// Children nodes
				for(var cidx=0; cidx <nodeChildren.length; cidx++) {
					var child = nodeChildren.item(cidx); // nodeChildren[cidx];
					var childName = getNodeLocalName(child);
					
					if(child.nodeType!= DOMNodeTypes.COMMENT_NODE) {
						var childPath = path+"."+childName;
						if (checkXmlElementsFilter(result,child.nodeType,childName,childPath)) {
							result.__cnt++;
							if(result[childName] == null) {
								result[childName] = parseDOMChildren(child, childPath);
								toArrayAccessForm(result, childName, childPath);					
							}
							else {
								if(result[childName] != null) {
									if( !(result[childName] instanceof Array)) {
										result[childName] = [result[childName]];
										toArrayAccessForm(result, childName, childPath);
									}
								}
								(result[childName])[result[childName].length] = parseDOMChildren(child, childPath);
							}
						}
					}								
				}
				
				// Attributes
				for(var aidx=0; aidx <node.attributes.length; aidx++) {
					var attr = node.attributes.item(aidx); // [aidx];
					result.__cnt++;
					result[config.attributePrefix+attr.name]=attr.value;
				}
				
				// Node namespace prefix
				var nodePrefix = getNodePrefix(node);
				if(nodePrefix!=null && nodePrefix!="") {
					result.__cnt++;
					result.__prefix=nodePrefix;
				}
				
				if(result["#text"]!=null) {				
					result.__text = result["#text"];
					if(result.__text instanceof Array) {
						result.__text = result.__text.join("\n");
					}
					//if(config.escapeMode)
					//	result.__text = unescapeXmlChars(result.__text);
					if(config.stripWhitespaces)
						result.__text = result.__text.trim();
					delete result["#text"];
					if(config.arrayAccessForm=="property")
						delete result["#text_asArray"];
					result.__text = checkFromXmlDateTimePaths(result.__text, childName, path+"."+childName);
				}
				if(result["#cdata-section"]!=null) {
					result.__cdata = result["#cdata-section"];
					delete result["#cdata-section"];
					if(config.arrayAccessForm=="property")
						delete result["#cdata-section_asArray"];
				}
				
				if( result.__cnt == 0 && config.emptyNodeForm=="text" ) {
					result = '';
				}
				else
				if( result.__cnt == 1 && result.__text!=null  ) {
					result = result.__text;
				}
				else
				if( result.__cnt == 1 && result.__cdata!=null && !config.keepCData  ) {
					result = result.__cdata;
				}			
				else			
				if ( result.__cnt > 1 && result.__text!=null && config.skipEmptyTextNodesForObj) {
					if( (config.stripWhitespaces && result.__text=="") || (result.__text.trim()=="")) {
						delete result.__text;
					}
				}
				delete result.__cnt;			
				
				if( config.enableToStringFunc && (result.__text!=null || result.__cdata!=null )) {
					result.toString = function() {
						return (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');
					};
				}
				
				return result;
			}
			else
			if(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {
				return node.nodeValue;
			}	
		}
		
		function startTag(jsonObj, element, attrList, closed) {
			var resultStr = "<"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+":"):"") + element;
			if(attrList!=null) {
				for(var aidx = 0; aidx < attrList.length; aidx++) {
					var attrName = attrList[aidx];
					var attrVal = jsonObj[attrName];
					if(config.escapeMode)
						attrVal=escapeXmlChars(attrVal);
					resultStr+=" "+attrName.substr(config.attributePrefix.length)+"=";
					if(config.useDoubleQuotes)
						resultStr+='"'+attrVal+'"';
					else
						resultStr+="'"+attrVal+"'";
				}
			}
			if(!closed)
				resultStr+=">";
			else
				resultStr+="/>";
			return resultStr;
		}
		
		function endTag(jsonObj,elementName) {
			return "</"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+":"):"")+elementName+">";
		}
		
		function endsWith(str, suffix) {
			return str.indexOf(suffix, str.length - suffix.length) !== -1;
		}
		
		function jsonXmlSpecialElem ( jsonObj, jsonObjField ) {
			if((config.arrayAccessForm=="property" && endsWith(jsonObjField.toString(),("_asArray"))) 
					|| jsonObjField.toString().indexOf(config.attributePrefix)==0 
					|| jsonObjField.toString().indexOf("__")==0
					|| (jsonObj[jsonObjField] instanceof Function) )
				return true;
			else
				return false;
		}
		
		function jsonXmlElemCount ( jsonObj ) {
			var elementsCnt = 0;
			if(jsonObj instanceof Object ) {
				for( var it in jsonObj  ) {
					if(jsonXmlSpecialElem ( jsonObj, it) )
						continue;			
					elementsCnt++;
				}
			}
			return elementsCnt;
		}
		
		function checkJsonObjPropertiesFilter(jsonObj, propertyName, jsonObjPath) {
			return config.jsonPropertiesFilter.length == 0
				|| jsonObjPath==""
				|| checkInStdFiltersArrayForm(config.jsonPropertiesFilter, jsonObj, propertyName, jsonObjPath);	
		}
		
		function parseJSONAttributes ( jsonObj ) {
			var attrList = [];
			if(jsonObj instanceof Object ) {
				for( var ait in jsonObj  ) {
					if(ait.toString().indexOf("__")== -1 && ait.toString().indexOf(config.attributePrefix)==0) {
						attrList.push(ait);
					}
				}
			}
			return attrList;
		}
		
		function parseJSONTextAttrs ( jsonTxtObj ) {
			var result ="";
			
			if(jsonTxtObj.__cdata!=null) {										
				result+="<![CDATA["+jsonTxtObj.__cdata+"]]>";					
			}
			
			if(jsonTxtObj.__text!=null) {			
				if(config.escapeMode)
					result+=escapeXmlChars(jsonTxtObj.__text);
				else
					result+=jsonTxtObj.__text;
			}
			return result;
		}
		
		function parseJSONTextObject ( jsonTxtObj ) {
			var result ="";
	
			if( jsonTxtObj instanceof Object ) {
				result+=parseJSONTextAttrs ( jsonTxtObj );
			}
			else
				if(jsonTxtObj!=null) {
					if(config.escapeMode)
						result+=escapeXmlChars(jsonTxtObj);
					else
						result+=jsonTxtObj;
				}
			
			return result;
		}
		
		function getJsonPropertyPath(jsonObjPath, jsonPropName) {
			if (jsonObjPath==="") {
				return jsonPropName;
			}
			else
				return jsonObjPath+"."+jsonPropName;
		}
		
		function parseJSONArray ( jsonArrRoot, jsonArrObj, attrList, jsonObjPath ) {
			var result = ""; 
			if(jsonArrRoot.length == 0) {
				result+=startTag(jsonArrRoot, jsonArrObj, attrList, true);
			}
			else {
				for(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {
					result+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);
					result+=parseJSONObject(jsonArrRoot[arIdx], getJsonPropertyPath(jsonObjPath,jsonArrObj));
					result+=endTag(jsonArrRoot[arIdx],jsonArrObj);
				}
			}
			return result;
		}
		
		function parseJSONObject ( jsonObj, jsonObjPath ) {
			var result = "";	
	
			var elementsCnt = jsonXmlElemCount ( jsonObj );
			
			if(elementsCnt > 0) {
				for( var it in jsonObj ) {
					
					if(jsonXmlSpecialElem ( jsonObj, it) || (jsonObjPath!="" && !checkJsonObjPropertiesFilter(jsonObj, it, getJsonPropertyPath(jsonObjPath,it))) )
						continue;			
					
					var subObj = jsonObj[it];						
					
					var attrList = parseJSONAttributes( subObj )
					
					if(subObj == null || subObj == undefined) {
						result+=startTag(subObj, it, attrList, true);
					}
					else
					if(subObj instanceof Object) {
						
						if(subObj instanceof Array) {					
							result+=parseJSONArray( subObj, it, attrList, jsonObjPath );					
						}
						else if(subObj instanceof Date) {
							result+=startTag(subObj, it, attrList, false);
							result+=subObj.toISOString();
							result+=endTag(subObj,it);
						}
						else {
							var subObjElementsCnt = jsonXmlElemCount ( subObj );
							if(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {
								result+=startTag(subObj, it, attrList, false);
								result+=parseJSONObject(subObj, getJsonPropertyPath(jsonObjPath,it));
								result+=endTag(subObj,it);
							}
							else {
								result+=startTag(subObj, it, attrList, true);
							}
						}
					}
					else {
						result+=startTag(subObj, it, attrList, false);
						result+=parseJSONTextObject(subObj);
						result+=endTag(subObj,it);
					}
				}
			}
			result+=parseJSONTextObject(jsonObj);
			
			return result;
		}
		
		this.parseXmlString = function(xmlDocStr) {
			var isIEParser = window.ActiveXObject || "ActiveXObject" in window;
			if (xmlDocStr === undefined) {
				return null;
			}
			var xmlDoc;
			if (window.DOMParser) {
				var parser=new window.DOMParser();			
				var parsererrorNS = null;
				// IE9+ now is here
				if(!isIEParser) {
					try {
						parsererrorNS = parser.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI;
					}
					catch(err) {					
						parsererrorNS = null;
					}
				}
				try {
					xmlDoc = parser.parseFromString( xmlDocStr, "text/xml" );
					if( parsererrorNS!= null && xmlDoc.getElementsByTagNameNS(parsererrorNS, "parsererror").length > 0) {
						//throw new Error('Error parsing XML: '+xmlDocStr);
						xmlDoc = null;
					}
				}
				catch(err) {
					xmlDoc = null;
				}
			}
			else {
				// IE :(
				if(xmlDocStr.indexOf("<?")==0) {
					xmlDocStr = xmlDocStr.substr( xmlDocStr.indexOf("?>") + 2 );
				}
				xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
				xmlDoc.async="false";
				xmlDoc.loadXML(xmlDocStr);
			}
			return xmlDoc;
		};
		
		this.asArray = function(prop) {
			if (prop === undefined || prop == null)
				return [];
			else
			if(prop instanceof Array)
				return prop;
			else
				return [prop];
		};
		
		this.toXmlDateTime = function(dt) {
			if(dt instanceof Date)
				return dt.toISOString();
			else
			if(typeof(dt) === 'number' )
				return new Date(dt).toISOString();
			else	
				return null;
		};
		
		this.asDateTime = function(prop) {
			if(typeof(prop) == "string") {
				return fromXmlDateTime(prop);
			}
			else
				return prop;
		};
	
		this.xml2json = function (xmlDoc) {
			return parseDOMChildren ( xmlDoc );
		};
		
		this.xml_str2json = function (xmlDocStr) {
			var xmlDoc = this.parseXmlString(xmlDocStr);
			if(xmlDoc!=null)
				return this.xml2json(xmlDoc);
			else
				return null;
		};
	
		this.json2xml_str = function (jsonObj) {
			return parseJSONObject ( jsonObj, "" );
		};
	
		this.json2xml = function (jsonObj) {
			var xmlDocStr = this.json2xml_str (jsonObj);
			return this.parseXmlString(xmlDocStr);
		};
		
		this.getVersion = function () {
			return VERSION;
		};	
	}
}));/**
 * @class GeoGlobe.Analysis
 * @classdesc 分析类基类。
 */

/**
 * @class GeoGlobe.Analysis.BufferAnalysis
 * @classdesc 缓冲区分析类。
 */
GeoGlobe.Analysis.BufferAnalysis = GeoGlobe.Class4OL({

	/**
     * 缓冲分析操作所需要的WPS服务地址
      *@memberof GeoGlobe.Analysis.BufferAnalysis.prototype
     * @type {String}
     * @default null
     */	
	url: null,

	/**
     * 缓冲区的端点类型，默认值为GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND。
     * 可以为GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND、GeoGlobe.Analysis.BufferAnalysis.CAP_BUTT、
     * GeoGlobe.Analysis.BufferAnalysis.CAP_SQUARE三者之一。
     * @memberof GeoGlobe.Analysis.BufferAnalysis.prototype
     * @type {int}
     */
	type: 1,
	
	/**
     * 缓冲的拟合精度。默认值为32。
     * @memberof GeoGlobe.Analysis.BufferAnalysis.prototype
     * @type {int}
     */
	accuracy: 32,

	/**
	 *
	 * GeoGlobe.Analysis.BufferAnalysis类构造函数。
	 * @memberof GeoGlobe.Analysis.BufferAnalysis.prototype
	 * @param {String}url -  WPS服务地址。
	 * @param {Object} options -  相关属性的设置项，可选。
	 */	
	initialize: function(url,options){
		this.url = url;
		GeoGlobe.Util.extend(this, options);
	},
	
    
    /**
     * 构造查询字串。将要缓冲的要素和缓冲半径来构造用于Post查询的字符串。
     * 参数:
     * @memberof GeoGlobe.Analysis.BufferAnalysis.prototype
     * @param {Object} features - 要执行缓冲分析的要素。
     * @param {Number} distance - 缓冲半径。
	 * @private
     */
	_buildPostXML: function(features,distance){
				
		var gmlParser = new GeoGlobe.Format.GML();
        var geoStr = gmlParser.write(features);
		var xmlstr = 
            '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' + 
			    '<wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd">' + 
			    '<ows:Identifier>Buffer</ows:Identifier>' +
			    '<wps:DataInputs><wps:Input><ows:Identifier>InputPolygon</ows:Identifier><wps:Data><wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' + 
			    geoStr + '</wps:ComplexData></wps:Data></wps:Input>' + 
			'<wps:Input><ows:Identifier>BufferDistance</ows:Identifier><wps:Data><wps:LiteralData>' + distance + '</wps:LiteralData></wps:Data>' + 
			'</wps:Input><wps:Input><ows:Identifier>BufferType</ows:Identifier><wps:Data><wps:LiteralData>' + this.type + '</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>BufferAccuracy</ows:Identifier><wps:Data><wps:LiteralData>' + this.accuracy + '</wps:LiteralData></wps:Data></wps:Input></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>BufferedPolygon</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:Execute>';
        return xmlstr;
	},

    /**
     * 获取所有要素范围之合的中心点。
     * 
     * 参数:
     * @memberof GeoGlobe.Analysis.BufferAnalysis.prototype
     * @param features - 要执行缓冲分析的要素。
     * @returns {GeoGlobe.LngLat} 中心点的坐标。
	 * @private
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * 获取要素数组范围之合。
	 * 参数:
     * @memberof GeoGlobe.Analysis.BufferAnalysis.prototype
	 * @param features - 要查看的要素数组。
	 * 
	 * 返回值:
	 * @returns {GeoGlobe.LngLatBounds} 要素数组的总的范围。
	 * @private
	 */
	_getFeaturesExtent: function (features) {
        if(!(GeoGlobe.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new GeoGlobe.LngLatBounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	
	/**

	 * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
	 *@memberof GeoGlobe.Analysis.BufferAnalysis.prototype

	 * @param {GeoJSON} geojson - 要分析的要素。
	 * @param  {Integer} distance -缓冲半径。
	 * @param {String} unit- 长度计量单位。取值"m","km","degree"，可选，默认值为"m"。
	 * 
	 * Example:
	 * (code)
	 * //绘制一个被缓冲的中心点
	 * var point = {
     *     "type": "Feature",
     *     "geometry": {
     *           "type": "Point",
     *           "coordinates": [105,35]
     *      }
     * };
     * var geojsonPoint = {
	 *	   "type": "FeatureCollection",
	 *	   "features": [point]
	 * };
	 * //设置缓冲距离500米
     * var distance = 500;
     * 
     * //缓冲单位
     * var unit = "m";
     * 
     * //开始缓冲分析
     * ba.startAnalysis(geojsonPoint, distance, unit);
     * (end)
	 */
	startAnalysis: function(geojson,distance,unit){
		var unitList = ["m","km","degree"];
		//将geojson转化为feature
		var gj = new GeoGlobe.Format.GeoJSON();
		var feature = gj.read(geojson);
		
		var lnglat = this._getFeaturesCenter(feature);
		
		//距离单位默认为米
		if(!unit || (GeoGlobe.Util.indexOf(unitList,unit) == -1)){
			unit = "m";
		}
		
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lnglat);				
		}
		var postStr = this._buildPostXML(feature,distance);
		var xhr = new GeoGlobe.Request.POST({
			url: this.url,
			data: postStr,
			scope: this,
			success:function(result){
				if("" == result.responseText || null == result.responseText){
					this.failFn();
					return;
				}
                var feature = this._parserResult(result);
                //将feature转化为geojson数据
                var gj = new GeoGlobe.Format.GeoJSON();
                var geojsonStr = gj.write(feature);
                var j = new GeoGlobe.Format.JSON();
                var geojsonPloygon = j.read(geojsonStr);
                this.successFn(geojsonPloygon);
            },
			failure:this.failFn
			
		});
	},
	
	/**
	 * 根据地理坐标位置，将米转换成经纬度。
	 *
	 * 参数:
     * @memberof GeoGlobe.Analysis.BufferAnalysis.prototype
	 * @param {string} meter - 要转换的地理坐标。
	 * @param {string} lonlat - 经纬度。
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(GeoGlobe.Util.rad(templat)) );
	},
	
	/**
	 *
	 * 缓冲分析操作成功的回调函数，由用户使用自己定义的方法替代。
	 * @memberof GeoGlobe.Analysis.BufferAnalysis.prototype

	 * @param {Array(GeoGlobe.Feature)} features -  结果要素数组。
	 */	
	successFn:function(features){
	},

	/**
	 *
	 * 缓冲分析操作失败回调函数，默认提示"缓冲分析操作失败，请检测服务是否正常运行。"，
	 * 用户可以使用自定义方法覆写。
     *  @memberof GeoGlobe.BufferAnalysis.prototype
	 */		
	failFn:function(){
		alert("缓冲分析操作失败，请检测服务是否正常运行。");
	},
	

	_parserResult: function(result){
		var feature = null;
		var xmlParser = new GeoGlobe.Format.XML();
		if(!result.responseXML){
			result.responseXML = xmlParser.read(result.responseText);
		}
		var gmlParser = new GeoGlobe.Format.GML();		
			feature = gmlParser.read(result.responseXML);
		return feature;
	},

	CLASS_NAME: "GeoGlobe.Analysis.BufferAnalysis"
});

/**
 * Constant: GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 圆形缓冲区端点。
 */
GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND = 1;

/**
 * Constant: GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 平角缓冲区端点。
 */
GeoGlobe.Analysis.BufferAnalysis.CAP_BUTT = 2;


/**
 * Constant: GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND
 * {Integer} 矩形缓冲区端点。
 */
GeoGlobe.Analysis.BufferAnalysis.CAP_SQUARE = 3;﻿/**
 *  @class GeoGlobe.Analysis.GetFeature
 * @classdesc 叠置分析类。
 *
 */
GeoGlobe.Analysis.GetFeature = GeoGlobe.Class4OL({

    /**
     * 缓冲分析操作所需要的WPS服务地址
     * @memberof GeoGlobe.Analysis.GetFeature.prototype
     * @type {String}
     * @default null

     */
    url: null,

    /**
     * 缓冲分析操作所需要的WPS服务地址
     * 叠置分析操作类型。
     *  @memberof GeoGlobe.Analysis.GetFeature.prototype
     * @type {string}

     */
    type:"intersection",


    //请求串模板
    //_reqStrTemplate:"{'GetFeature': {'service': 'OverlapService','version': '1.0.0',"+"'Query': [{'typeName':'${dataInputs}'}],"+"'maxFeatures': '','startPosition': '','resultType': ''}}",
	_reqStrTemplate: "{'GetFeature': {'service': 'OverlapService','version': '1.0.0','dataSource':'${sourceInputs}','Query': [{'typeName':'${dataInputs}'}],'maxFeatures': '','startPosition': '','outPutFormat': 'GeoJSON','resultType': ''}}",

    /**

     * GeoGlobe.Analysis.SuperposeAnalysis类构造函数。
     *  @memberof GeoGlobe.Analysis.GetFeature.prototype

     * @param {String}  url -  服务地址。
     *  @param {Object} options -  相关属性的设置项，可选。
     */
    initialize: function(url,options){
        this.url = url;
        GeoGlobe.Util.extend(this, options);
    },

    //构造查询字串
    _buildReqStr: function(){
        var string = GeoGlobe.String.format(this._reqStrTemplate,{
            type: this.type,
            dataInputs: this.typeName,
            sourceInputs: this.DataSource
        });
        return string;
    },

    /**

     * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
     *  @memberof GeoGlobe.Analysis.GetFeature.prototype
     */
    startAnalysis: function(pageNum){
        //查询前做设置方面检查
        if(this._checkSet()){
            return false;
        }

        //发送分析请求
        var postStr = this._buildReqStr();
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: postStr,
            scope: this,
            success:function(result){
                if("" == result.responseText || null == result.responseText){
                    this.failFn();
                    return;
                }
                this.successFn(result);
            },
            failure:this.failFn

        });
    },
    //检查相关参数设置
    _checkSet: function(){
        if(!this.url){
            return false;
        }
    },

    /**

     * 分析操作成功的回调函数
     *  @memberof GeoGlobe.Analysis.GetFeature.prototype

     * @param  {Array(GeoGlobe.Feature)} features -  结果要素数组。
     */
    successFn:function(features){

    },
    /**

     * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
     * 用户可以使用自定义方法替代。
     *  @memberof GeoGlobe.Analysis.GetFeature.prototype
     */
    failFn:function(){
        alert("服务请求操作失败，请检测服务是否正常运行。");
    },

    CLASS_NAME:"GeoGlobe.Analysis.GetFeature"

});﻿/**
 * @class GeoGlobe.Analysis.SpatialAnalysis
 * @classdesc 叠置分析类。
 *
 */
GeoGlobe.Analysis.SpatialAnalysis = GeoGlobe.Class({

    /**
     *缓冲分析操作所需要的WPS服务地址
     * @memberof GeoGlobe.Analysis.SpatialAnalysis.prototype
     * @type {String}
     * @default null
     */
    url: null,

    /**
     *
     * 叠置分析操作类型
     * @memberof GeoGlobe.Analysis.SpatialAnalysis.prototype
     * @type {String}

     */
    type:"intersection",


    //请求串模板
    _requestStrTemplate:
    "{'SpatialAnalysis': {'service': 'OverlapService','version': '1.0.0',"+
    "'origionLayerNames': ['${origionLayerNames}'],'targetLayerNames': ['${targetLayerNames}'],"+
    "'outPutFormat': 'GeoJSON','operator': '${dataInputs}','isSynchronization': 'true','tolerance': '${tolerance}'}}",
    /**

     * GeoGlobe.Analysis.SuperposeAnalysis类构造函数。
     * @memberof GeoGlobe.Analysis.SpatialAnalysis.prototype

     * @param {String}  url -  服务地址
     *  @param {Object} options -  相关属性的设置项，可选
     */
    initialize: function(url,options){
        this.url = url;

        GeoGlobe.Util.extend(this, options);
    },

    //构造查询字串
    _buildRequestStr: function(){
        var string = GeoGlobe.String.format(this._requestStrTemplate,{
            type: this.type,
            dataInputs: this.operator,
            origionLayerNames:this.origionLayerNames,
            targetLayerNames:this.targetLayerNames,
			tolerance:this.tolerance
        });
        return string;
    },

    /**

     * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
     * @memberof GeoGlobe.Analysis.SpatialAnalysis.prototype
     */
    startAnalysis: function(pageNum){
        //查询前做设置方面检查
        if(this._checkSet()){
            return false;
        }

        //发送分析请求
        var postStr = this._buildRequestStr();
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: postStr,
            scope: this,
            success:function(result){
                if("" == result.responseText || null == result.responseText){
                    this.failFn();
                    return;
                }
                //var features = this._parserResult(result);
                this.successFn(result,pageNum);
            },
            failure:this.failFn

        });
    },

    //检查相关参数设置
    _checkSet: function(){
        if(!this.url){
            return false;
        }
    },

    /**

     * 分析操作成功的回调函数
     * @memberof GeoGlobe.Analysis.SpatialAnalysis.prototype

     * @param {Array(GeoGlobe.Feature)}features -  结果要素数组
     */
    successFn:function(features){

    },

    /**

     * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
     * 用户可以使用自定义方法替代。
     * @memberof GeoGlobe.Analysis.SpatialAnalysis.prototype
     */
    failFn:function(){
        alert("叠置分析操作失败，请检测服务是否正常运行。");
    },
    CLASS_NAME:"GeoGlobe.Analysis.SpatialAnalysis"

});
﻿/**
 * @class GeoGlobe.Analysis.CoreBufferAnalysis
 * @classdesc 基于内核的缓冲分析类。

 */
GeoGlobe.Analysis.CoreBufferAnalysis = GeoGlobe.Class({

    /**
     *缓冲分析操作所需要的WPS服务地址
     * @memberof GeoGlobe.Analysis.CoreBufferAnalysis.prototype
     * @type {String}
     * @default null
     */
    url: null,

    /**
     * 缓冲分析操作类型
     * @memberof GeoGlobe.Analysis.CoreBufferAnalysis.prototype
     * @type {String}
     */
    type:"intersection",

    //请求串模板
    _requestStrTemplate:
    "{'BufferAnalysis': {'service': 'OverlapService','version': '1.0.0',"+
    "'layerName': '${layerName}','bufferRadius': '${bufferRadius}','bufferStyle':'${bufferStyle}',"+
    "'outPutFormat': 'JSON','bufferType': '${bufferType}','isSynchronization': 'true'}}",
    /**
     *
     * GeoGlobe.Analysis.CoreBufferAnalysis类构造函数。
     * @memberof GeoGlobe.Analysis.CoreBufferAnalysis.prototype

     * @param {String}url -  服务地址。
     * @param {Object} options -  相关属性的设置项，可选。
     */
    initialize: function(url,options){
        this.url = url;

        GeoGlobe.Util.extend(this, options);
    },

    //构造查询字串
    _buildRequestStr: function(){
        var string = GeoGlobe.String.format(this._requestStrTemplate,{
            type: this.type,
            layerName:this.layerName,
            bufferRadius:this.bufferRadius,
            bufferStyle:this.bufferStyle,
            bufferType:this.bufferType
        });
        return string;
    },

    /**

     * 开始执行分析，如果服务端正确返回结果会触发successFn回调函数。
     * @memberof GeoGlobe.Analysis.CoreBufferAnalysis.prototype
     */
    startAnalysis: function(pageNum){
        //查询前做设置方面检查
        if(this._checkSet()){
            return false;
        }

        //发送分析请求
        var postStr = this._buildRequestStr();
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: postStr,
            scope: this,
            success:function(result){
                if("" == result.responseText || null == result.responseText){
                    this.failFn();
                    return;
                }
                //var features = this._parserResult(result);
                this.successFn(result,pageNum);
            },
            failure:this.failFn

        });
    },

    //检查相关参数设置
    _checkSet: function(){
        if(!this.url){
            return false;
        }
    },

    /**

     * 分析操作成功的回调函数
     * @memberof GeoGlobe.Analysis.CoreBufferAnalysis.prototype
     * @param {Array(GeoGlobe.Feature)}features - 结果要素数组。
     */
    successFn:function(features){

    },

    /**

     * 叠置分析操作失败回调函数，默认提示"叠置分析操作失败，请检测服务是否正常运行。"，
     * 用户可以使用自定义方法替代。
     * @memberof GeoGlobe.Analysis.CoreBufferAnalysis.prototype
     */
    failFn:function(){
        alert("缓冲分析操作失败，请检测服务是否正常运行");
    },
    CLASS_NAME:"GeoGlobe.Analysis.CoreBufferAnalysis"

});/**
 * @class GeoGlobe.Query.Service
 * @classdesc 服务类。本类是服务类的基类，需要由子类去实现。
 *
 */
GeoGlobe.Query.Service = GeoGlobe.Class4OL({
	
	/**
     * 服务名称。
     * @memberof GeoGlobe.Query.Service.prototype
     *  @type {String}
     */
	name: null,
	
	/**
     * 服务地址。
     * @memberof GeoGlobe.Query.Service.prototype
     * @type {String}
     */	
	url: null,
	
	/**
     * 服务版本号。
     * @memberof GeoGlobe.Query.Service.prototype
     * @type {String}
     */		
	version: null,

	
	/**
     * 用户名。
     * @memberof GeoGlobe.Query.Service.prototype
     * @type {String}
     */			
	userid: "test@liferay.com",
	
	/**
     * GeoGlobe.Query.BusQuery类的构造函数。
     * @memberof GeoGlobe.Query.Service.prototype
     * @param {String} name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		GeoGlobe.Util.extend(this, options);
	},


	/**
     * 获取服务能力描述信息，由子类实现。
     * @memberof GeoGlobe.Query.Service.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * 检查服务是否存在，由子类实现。
     * @memberof GeoGlobe.Query.Service.prototype
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * 服务操作失败响应回调函数。
     * @memberof GeoGlobe.Query.Service.prototype
     * @param {Object} operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new GeoGlobe.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "GeoGlobe.Query.Service"
	
});/**
 * @class GeoGlobe.Query.RouteQuery
 * @classdesc
 * >说明：本类的findRoute方法以及getRouteInfo方法的成功回调中如果包含exceptionInfo节点，则表示服务查询发生异常。
 * >findRoute方法以及getRouteInfo方法成功回调中返回的异常信息包含两个节点（exceptionInfo节点和exceptionCode节点）。
 * >异常信息的数据结构举例：
 * >{
 * >	exceptionInfo:"终点附近无导航链路",
 * >	exceptionCode:"1002"
 * >}
 * >其中exceptionInfo表示异常信息的描述;exceptionCode表示异常编码;异常编码取值说明：
 * >1000：服务逻辑或功能异常。
 * >1001：服务未配置路网数据集。（当服务未配置路网数据集并且请求FindRoute与GetRouteInfo接口将返回此异常）。
 * >1002：导航查询的两点之间无通路。（请求FindRoute接口如果无解决方案则返回此异常）。
 * >1003：无匹配的路段信息。（请求GetRouteInfo接口如果无关联请求路段ID的内容则返回此异常）。
 * >1004：请求参数内容不正确。
 * 本类继承GeoGlobe.Query类。
 *
 */
GeoGlobe.Query.RouteQuery = GeoGlobe.Class4OL(GeoGlobe.Query.Service, {
	
	/**
	 * @Property  _format  - 结果解析器。
     * @memberof GeoGlobe.Query.RouteQuery.prototype
	 * @private
	 */
	_format: null,
	
	/**
     * GeoGlobe.Query.Route类的构造函数。
     * @memberof GeoGlobe.Query.RouteQuery.prototype
     * @param {String} name  -  服务名称。
     * @param {String} url - 服务地址。
     * @param {Object} options - 备用参数，目前暂不使用。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
		this._format = new GeoGlobe.Format.RouteQuery();
		GeoGlobe.Util.extend(this, options);
	},
	
	/**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Query.RouteQuery.prototype
     * @param {Function} successFn  - 请求成功的回调函数
     * @param {Function} failFn  -  请求失败的回调函数。
     */	
	getCapabilities: function(successFn,failFn) {
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};
		GeoGlobe.loadURL(url,params,this,successFn,failFn);
	},
	
	/**
	 * 返回请求起始坐标对应路网模型的导航链路信息。
	 * @memberof GeoGlobe.Query.RouteQuery.prototype
	 * @param {Object} options - 请求参数。
	 * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn - 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * @param {String}  data   - （必选）路网名称。
	 * @param {String} orig  - （必选）起点坐标。   例如："120,30"。
	 * @param {String} dest    -  （必选）终点坐标。
	 * @param {Number} radius  -(可选) 抓取起点与终点距离有效道路的半径范围，单位为米，默认值为10米。
	 * @param {Number} queryType   - (可选)导航查询类型。0表示最快时间；1表示最短路径，默认为按最短路径查询。
	 * @param {String} midpos   - (可选) 途径点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * @param {String} avoidPos   - (可选) 规避点坐标集，多个坐标之间以分号分隔，XY坐标之间以逗号分隔。（如：x1,y1;x2,y2）
	 * @param {Number} filterRoute  - (可选) 导航查询的途径路段类型过滤，可选值：0 – 不进行过滤；1 – 过滤高速公路；2 – 过滤小路；默认值为0。
	 * @param {Number} resultCount  - (可选) 导航查询返回的最大解决方案数目，参数值必须为正整数，参数默认值为1。
     * 
	 * @example
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new GeoGlobe.Query.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.findRoute({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routes){
	 *
	 *			});
	 *   (end)
	 */
	findRoute: function(options, successFn, failFn) {
		var params = {
			REQUEST: "FindRoute",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
        var required = {
            data: true,
            orig: true,
            dest: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("Missing property '" + prop + "'");
            }
        }
		params.DATA = options.data;
		params.ORIG = options.orig;
		params.DEST = options.dest;
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
	  	if(options.radius !== null && options.radius !== undefined){
            params.RADIUS = options.radius;
        }
        
        if(options.queryType !== null && options.queryType !== undefined){
            params.QUERYTYPE = options.queryType;
        }
		
		if(options.midpos !== null && options.midpos !== undefined){
            params.MIDPOS = options.midpos;
        }
		if(options.avoidPos !== null && options.avoidPos !== undefined){
            params.AVOIDPOS = options.avoidPos;
        }
		if(options.filterRoute !== null && options.filterRoute !== undefined){
            params.FILTERROUTE = options.filterRoute;
        }
		if(options.resultCount !== null && options.resultCount !== undefined){
            params.RESULTCOUNT = options.resultCount;
        }
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
			async:false,
            scope: this,
            success: function(result){
				var routes = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routes.exceptionInfo === "string") {
					 successFn(routes);
					 return;
				}
				var routeInfo = new GeoGlobe.Query.RoutesResult(routes);
				//将路线数据转化为GeoJSON类型
				var routeLine = routeInfo.routes;
				var gj = new GeoGlobe.Format.GeoJSON();
				var gjstr = gj.write(routeLine);
				var j = new GeoGlobe.Format.JSON();
				geojsonRoute = j.read(gjstr);
				routeInfo.geojsonRoute = geojsonRoute;
                successFn(routeInfo);
            },
            failure: failFn
        });
	},
	
	/**
	 *  getRouteInfo  - 返回请求编号查询到路段的详细信息。
	 * @memberof GeoGlobe.Query.RouteQuery.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String} data  - （必选）路网名称
	 * @param {String} id - （必选）查询路段的ID名称，可以有0个或多个，多个ID之间以逗号分隔。
	 *
	 * @example
	 *   (code) 
	 *   	//创建路网查询对象
	 *   	var ShortestPath =new GeoGlobe.Query.Route("shortPath","http://10.4.6.248:7009/Route_L/route");
	 *   	ShortestPath.getRouteInfo({
	 *				data:"XZ",
	 *				id:"706,347"
	 *			},function(routeInfo){});
	 *   (end)
	 */
	getRouteInfo: function(options, successFn, failFn) {
		var params = {
			REQUEST: "GetRouteInfo",
			SERVICE:"ROUTE",
			VERSION:"1.0.0"
		};
		if(!options.data || !options.id){
            throw "Error!Not data and id for bus query.";
            return;
        }
		params.DATA = options.data;
		params.ID = options.id;
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var routeInfo = this._format.read(result.responseText);
				//处理异常情况，当发生异常时，直接返回异常串
				if(typeof routeInfo.exceptionInfo === "string") {
					 successFn(routeInfo);
					 return;
				}
				routeInfo = new GeoGlobe.Query.RouteInfoResult(routeInfo);
            	successFn(routeInfo);
            },
            failure: failFn
        });
	},	

	CLASS_NAME: "GeoGlobe.Query.RouteQuery"
	
});

/**
 * @class GeoGlobe.Util.Format.RouteQuery
 * @classdesc 路网导航查询结果解析类，本类供内部调用，用户一般无需使用。
 *
 */
GeoGlobe.Format.RouteQuery = new GeoGlobe.Class4OL(GeoGlobe.Format.XML,{

	/**
	 * 构造函数。
	 * @memberof GeoGlobe.Util.Format.RouteQuery.prototype
	 * @param {Object} data  - 服务端生成的原始JSON数据。
	 */
    initialize: function(options) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [options]);
    },

	/**
	 * 读入服务端响应的XML内容并解析为JSON对象返回。
	 * @memberof GeoGlobe.Util.Format.RouteQuery.prototype
	 * @param  {String} data  - 服务端响应的XML。
	 * 
     * @returns {Object | String}  -  JSON对象
     * 说明：当返回结果为字符串时表示查询发生异常。
     */	
    read: function(data) {
        var result = {};
		var routes = [];
		var dataTemp = data;
        if(typeof data == "string") {
			//调用父类的read方法。将xml串转换为dom对象。
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        if(data && data.nodeType == 9) {
            routes = [];
			//获得根节点名称
			var elName = GeoGlobe.Format.XML.prototype.getChildEl.apply(this, [data]).nodeName;
			//处理异常情况：
			if("ServiceExceptionReport" === elName) {
				//var serviceException = data.getElementsByTagName("ogc:ServiceException")[0];
				var serviceException = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(data, "*", "ServiceException")[0];
				var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [serviceException]);
				var code = serviceException.getAttribute("code");
				return {
					exceptionInfo: text,
					exceptionCode: code
				};
			}
			
			//获取跟节点的子元素
			var nodes = data.getElementsByTagName(elName)[0].childNodes;
			//Todo 如果elName不带前缀的，取整个elName。如果elName带前缀的，则取前缀之后的名称。
			//var nodes = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(data, "*", elName)[0];
			//遍历子节点
            for(var i=0; i<nodes.length; i++){
                var node = nodes[i];
				//获取节点名称
                var nodeName = node.nodeName;
				//判断方法是否存在
                if(this._resultPaser[elName][nodeName]) {
					//使用apply方法改变调用方法的上下文环境
					this._resultPaser[elName][nodeName].apply(this, [node, routes]);
                }
            }
        }
		elName = elName.toLowerCase();
		if("routeinfo" === elName) {
			result["items"] = routes;
		}else {
			result[elName] = routes;
		}
		
        return result;
    },
	
	/**
	 * 查询结果解析器。
     * @memberof GeoGlobe.Util.Format.RouteQuery.prototype
	 * @private
	 */
    _resultPaser: {
		"RouteInfo":{
			"Item": function(node, obj) {
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
	            var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
						this._resultPaser["RouteInfo"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.push(item);
			},
	        "Name": function(node, obj){
				//调用父类的getChildValue方法，并且使用本对象的上下文环境。
				var name = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
	        "Toll": function(node, obj){
				var toll = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.toll = toll;
	        },
			"Level": function(node, obj) {
				var level = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
				obj.level = level;
			},
			"Length": function(node, obj) {
				var length = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Geometry": function(node, obj) {
				//获取gml:LineString节点对象。
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new GeoGlobe.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new GeoGlobe.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Directions": function(node, obj) {
				obj.directions = [];
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["RouteInfo"][nodeName]){
	                    this._resultPaser["RouteInfo"][nodeName](node,obj.directions);
	                }
	            }
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				//获取节点的属性值
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.push(dir);
			}
			//TODO：是否还有可选属性没有加进来，待查
	    },
		"Routes": {
			"Route": function(node, obj) {
				var nodes = node.childNodes;
	            var route = {};
	            for(var i=0; i<nodes.length; i++){
	                var node = nodes[i];
					var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,route]);
	                }
	            }
				obj.push(route);
			},
			"Item": function(node, obj) {
				if(!GeoGlobe.Util.isArray(obj.items)) {
					obj.items = [];
				}
				var nodes = node.childNodes;
				var id = node.getAttribute("id");
				var item = {};
				if(id) {
					item = {
						id: id
					}
				}
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,item]);
	                }
	            }
				obj.items.push(item);
			},
			"Distance": function(node, obj){
				var distance = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.distance = distance;
			},
			"Name": function(node, obj){
				var name = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            if(name) {
	                obj.name = name;
	            }
	        },
			"Length": function(node, obj) {
				var length = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.length = length;
			},
			"Direction": function(node, obj) {
				var dir = {};
				var direction = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            dir.direction = direction;
				dir.nextID = node.getAttribute("nextID");
				dir.nextItem = node.getAttribute("nextItem");
				obj.direction = dir;
			},
			"Geometry": function(node, obj) {
				//var geometryDom = node.getElementsByTagName("gml:LineString")[0];//chrome下解析不到
				var geometryDom = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(node, "*", "LineString")[0];
				if(geometryDom) {
					var text = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [geometryDom]);
					if(typeof text === "string" && text.length > 0) {
						var pointArrStr = text.split(" ");
						var points = [];
						for(var i = 0, len = pointArrStr.length; i < len; i++) {
							var pois = pointArrStr[i].split(",");
							points.push(new GeoGlobe.Geometry.Point(new Number(pois[0]),new Number(pois[1])));
						}
						var lineString = new GeoGlobe.Geometry.LineString(points);
						obj.geometry = lineString;
					}
				}
			},
			"Duration": function(node, obj) {
				var duration = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.duration = duration;
			},
			"BoundingBox": function(node, obj) {
				var nodes = node.childNodes;
	            for(var i=0; i<nodes.length; i++){
	                 var node = nodes[i];
					 var nodeName = node.nodeName;
	                if(this._resultPaser["Routes"][nodeName]){
						this._resultPaser["Routes"][nodeName].apply(this, [node,obj]);
	                }
	            }
			},
            "LowerCorner": function(node, obj) {
				var str = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.left = pointList[0];
                obj.bottom = pointList[1];
            },
            "UpperCorner": function(node, obj) {
				var str = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]).replace(
                    (/^\s*|\s*$/g), "");
                str = str.replace((/\s*,\s*/g), ",");
                var pointList = str.split(",");
                obj.right = pointList[0];
                obj.top = pointList[1];
                //obj.bounds = new GeoGlobe.Bounds(obj.left, obj.bottom,obj.right, obj.top);
                obj.bounds = new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(obj.left, obj.bottom),new GeoGlobe.LngLat(obj.right, obj.top));
				//left,bottom,right,top只是临时使用，所以用完后需要清掉。
                delete obj.left;
                delete obj.bottom;
                delete obj.right;
                delete obj.top;
            },
			"Count": function(node, obj) {
				var count = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [node]);
	            obj.count = count;
			}
		}
	}
});/**
 * @class GeoGlobe.Query.RoutesResult
 * @classdesc 导航链路信息结果对象。结果对象中包含起点到目的地的所有行走方案。
 *
 */
GeoGlobe.Query.RoutesResult = GeoGlobe.Class4OL({
	
	/**
	 * 解析服务返回的XML后，得到的完整JSON对象。
     * @memberof GeoGlobe.Query.RoutesResult.prototype
     * @type {Object}
	 */
	data: null,
	
	/**
	 * 起点到终点的所有行走方案。
     * @memberof GeoGlobe.Query.RoutesResult.prototype
     * @type {Array(GeoGlobe.Query.RouteResult)}
	 */
	routes: null,
	
	/**
     * GeoGlobe.Service.GeoRoutesResult类的构造函数。
     * @memberof GeoGlobe.Query.RoutesResult.prototype
     * @param {Object} data  -  JSON对象
     *
     */
	initialize: function(data) {
		this.routes = [];
		var routes = null;
		if(data && data.routes) {
			this.data = data;
			routes = data.routes;
		}
		if(GeoGlobe.Util.isArray(routes)) {
			for(var i = 0, len = routes.length;i < len; i++) {
				var routeObj = new GeoGlobe.Query.RouteResult();
				for(var route in routes[i]) {
					routeObj[route] = routes[i][route];
				}
				this.routes.push(routeObj);
			}
        }
	},

	CLASS_NAME: "GeoGlobe.Query.RoutesResult"
	
});

/**
 * @class GeoGlobe.Query.RouteResult
 * @classdesc 起点到终点的一条行走方案。
 *
 */
GeoGlobe.Query.RouteResult = GeoGlobe.Class4OL({
	
	/**
	 * 两点间的一条通路的范围
     * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {GeoGlobe.LngLatBounds}
	 */
	bounds: null,
	
	/**
	 * 导航线路包含的路段总数。
     * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {Integer}
	 */
	count: null,
	
	/**
	 * 导航线路总里程，单位为米。
     * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {Number}
	 */
	distance: null,
	
	/**
	 * 导航行驶总时间，单位为分钟。
	 *	（导航行驶总时间根据由总里程换算而来，具体换算公式由服务定制）
     *@memberof GeoGlobe.Query.RouteResult.prototype
     *  @type {Integer}
	 */
	duration: null,
	
	/**
	 * 线路的几何信息。
     * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {GeoGlobe.Geometry}
	 */
	geometry: null,
	
	/**
	 * 路段元素，可以有零或多个；每个元素包含一个属性id，标识路段的唯一编号；
	 * 	如果路段不在道路上（如起点到某条道路），将不包含路段编号与路段名称。
	 * @memberof GeoGlobe.Query.RouteResult.prototype
     * @type {Array<object>}
     *
     * @example
	 * 数组中的对象结构举例:
	 * {
	 * 	id:"33",
	 * 	length: "161",
	 * 	name: "玉兰路",
	 * 	geometry:值为GeoGlobe.Geometry对象,
	 * 	direction: {
	 * 		text:"4",
	 * 		nextID:"8414",
	 * 		nextItem:"佳园路"
	 * 	}
	 * }
	 * 示例中节点说明：
	 * id: 路段id
	 * name:路段名称
	 * length：路段总长，单位为米
	 * geometry:路段行走路线
	 * text:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 */
	items: null,
	
	/**
     * GeoGlobe.Query.RouteResult类的构造函数。
     * @memberof GeoGlobe.Query.RouteResult.prototype
     */
	initialize: function() {
		
	},

	CLASS_NAME: "GeoGlobe.Query.RouteResult"
	
});
/**
 * @class GeoGlobe.Query.RouteInfoResult
 * @classdesc 路段信息结果类。用于记录路段所在道路的详细信息。
 *
 */
GeoGlobe.Query.RouteInfoResult = GeoGlobe.Class4OL({
	
	/**
	 * 解析服务返回的XML后，得到的完整JSON对象。
     * @memberof GeoGlobe.Query.RouteInfoResult.prototype
     * @type {Object}
	 */
	data: null,
	
	/**
	 *  路段数组。
     * @memberof GeoGlobe.Query.RouteInfoResult.prototype
	 */
	items: null,
	
	/**
     * GeoGlobe.Query.RouteInfoResult类的构造函数。
     * @memberof GeoGlobe.Query.RouteInfoResult.prototype
     * @param {Object} data  - JSON对象。
     */
	initialize: function(data) {
		this.items = [];
		if(data && data.items) {
			this.data = data;
			var items = data.items;
		}
		if(GeoGlobe.Util.isArray(items)){
			for(var i = 0, len = items.length;i < len; i++) {
				var routeInfoItem = new GeoGlobe.Query.RouteInfoItem();
				for(var route in items[i]) {
					routeInfoItem[route] = items[i][route];
				}
				this.items.push(routeInfoItem);
			}
        }
	},

	CLASS_NAME: "GeoGlobe.Query.RouteInfoResult"
	
});

/**
 * @class GeoGlobe.Query.RouteInfoItem
 * @classdesc 路段对象。从出发点到目的地的路程由一个或多个路段组成。
 */
GeoGlobe.Query.RouteInfoItem = GeoGlobe.Class4OL({
	
	/**
	 * 路段编号。
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     * @type {String}
	 */
	id:  null,
	
	/**
	 * 路段名称。
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     * @type {String}
	 */
	name: null,
	
	/**
	 *  - 路段收费信息，元素值定义：
	 *	0 – 免费路段；
	 *	1 – 部分收费路段；
	 *	2 – 收费路段。
	 *	（路段收费信息匹配路网数据库的特定属性，如果没有该属性则默认值为“0”免费路段）
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     *  @type {Number}
	 */
	toll: null,
	
	/**
	 * 路段行驶的里程，单位为米。
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     * @type {Number}
	 */
	length: null,
	
	/**
	 * 线路几何信息
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     * @type {GeoGlobe.Geometry}
	 */
	geometry: null,
	
	/**
	 * 道路级别，由路网数据库定义。
	 *	（路段级别一般标识路段的类型；例如路段级别分为1-3级，级别1为普通小路，级别2为城镇公路，级别3为高速公路；如果路网数据库未指定路段级别则默认值为0）
	 * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     *  @type {String}
     */
	level: null,
	
	/**
	 * 路段朝向。
	 * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     *  @type {Array<Object>}
     * @example
	 * 数组中的对象结构举例:
	 * [
	 * 	{
	 *  	nextID: "4211",
	 *  	nextItem: "红钢二街",
	 *  	direction: 1
	 *  }
	 * ]
	 * 
	 * 示例中节点说明：
	 * direction:方位,0代表正西方向，7代表西北方向，4代表正北方向，2代表东北方向，1代表正东方向，3代表东南方向，5代表正南方向，8代表西南方向。
	 * nextID:下一路段编号
	 * nextItem:下一路段名称
	 */
	directions: null,
	
	/**
     * GeoGlobe.Service.GeoRouteInfoItem类的构造函数。
     * @memberof GeoGlobe.Query.RouteInfoItem.prototype
     */
	initialize: function() {
		
	},

	CLASS_NAME: "GeoGlobe.Query.RouteInfoItem"
	
});﻿/**
 * @class GeoGlobe.Query.BusQuery
 * @classdesc 公交服务类。
 *
 */
GeoGlobe.Query.BusQuery = GeoGlobe.Class4OL(GeoGlobe.Query.Service,{
	
	/**
	 * 网络名称。
     * @memberof GeoGlobe.Query.BusQuery.prototype
	 */
	networkName: null,
	
	/**
	 * 换乘方案信息。
     *  @memberof GeoGlobe.Query.BusQuery.prototype
	 */
	transferScheme: null,
	
	/**
     * GeoGlobe.Query.BusQuery类的构造函数。
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {String} name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options - 实例的选项设置，此参数可选。
     * 
     * @example
     * (code)
     *  var url = "http://map.geostar.com.cn:9001/bus_sdk_new/bus";
     *  var busService = new GeoGlobe.Query.BusQuery("公交服务", url);
     * (end)
     */
	initialize: function(name, url,  options){ 
		this.name = name;
		this.url = url;
		GeoGlobe.Util.extend(this, options);
	},

	/**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var params = {
           REQUEST: "GetCapabilities"
        };
        if (typeof failFn != "function") {
            failFn = function(){
                alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
                "请求地址：" + this.url + "\n操作类型：GetCapabilities");
            };
        }
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: function(result){
                if (typeof successFn == "function") {
                    successFn(result);
                }
            },
            failure: failFn
        });
    },
	
	/**
     * 将向服务发送"GetCapabilities"同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     *  @memberof GeoGlobe.Query.BusQuery.prototype
     * @returns {Boolean}  - 服务是否存在。
     */	
	isExist: function(){
		var isExist = false;
		var url = this.url;
		var params = {
			REQUEST:"GetCapabilities"
		};		
		var xhr = GeoGlobe.Request.GET({
            url: url,
            scope: this,
			async: false,
            success: function(){
                isExist = true;
            }
        });
		return isExist;
	},	
	
	/**
     * 站点查询操作。
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  - 请求参数。
     * @param {Function} successFn  -  请求成功的回调函数。
     * @param {Function}  failFn  - 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * @param {String} networkName  - (必选) 网络模型名称。
     * @param {String} stationName -  (可选) 站点名称。
     * @param {Integer} stationId - (可选) 站点ID  必须为正整型。
     * @param {Integer} lineId  - (可选) 线路ID。
     * @param {String} lineName  -  (可选) 线路名称。
     * @param {String} coordinate  - (可选) 站点位置  用逗号分隔XY轴坐标如(X,Y)。
     * @param {String} bbox  - (可选) 矩形范围。
	 *     
     * @example
     * (code)
     *  //示例1 根据站点名称查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     *  //示例2 根据站点ID查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  //示例3 根据矩形范围查询:
     *  busService.queryStation({
     *      networkName: "BusChangeModule",
     *      bbox : '-1,-1,1,1'
     *  }
     *  (end)
     */	
    queryStation:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStation"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
		
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }
		
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
		
		if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
		
		if(options.coordinate !== null && options.coordinate !== undefined){
        	params.COORDINATE = options.coordinate;
        }   
		
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },

	/**
     * 线路查询操作。
     *  @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options   -  请求参数。
     * @param  {Function} successFn  - 请求成功的回调函数。
     * @param  {Function} failFn  - 请求失败的回调函数。
     *
	 * options请求参数属性可为:
     * @param {String} networkName - (必选) 网络模型名称。
     * @param {String} lineName  -(可选) 线路名称。
     * @param {Integer} lineId - (可选) 线路ID。
     * @param {String} stationName - (可选) 站点名称。
     * @param {Integer} stationId - (可选) 站点ID。
     * @param {String} coordinate - (可选) 站点位置。
     * @param {String} bbox  - (可选) 矩形范围。
     *
     * @example
     * (code)
     *  //示例1 根据站点名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationName: encodeURIComponent('口'),
     *  }
     * //示例2 根据站点ID查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     * //示例3 根据路线名称查询
     *  busService.queryLine({
     *      networkName: "BusChangeModule",
     *      lineName : '4'
     *  }
     *  (end)
     */	
    queryLine: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLine"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.lineName !== null && options.lineName !== undefined){
            params.LINENAME = options.lineName;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.stationName !== null && options.stationName !== undefined){
            params.STATIONNAME = options.stationName;
        }    
        
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }    
                
        if(options.coordinate !== null && options.coordinate !== undefined){
            params.COORDINATE = options.coordinate;
        }   
                     
        if(options.bbox !== null && options.bbox !== undefined){
            params.BOX = options.bbox;
        }
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
                
                var features = this._parserFeatures(result.responseText);
                successFn(features);
            },
            failure: failFn
        });

    },
    
	/**
     * 公交换乘方案查询操作。
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param  {Object} options  - 请求参数。
     * @param  {Function} successFn  - 请求成功的回调函数。
     * @param  {Function} failFn  - 请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * @param {String} networkName  - (必选) 网络模型名称。
     * @param {Integer} startStationId  - (可选) 起始站点ID。
     * @param {Integer} endStationId  - (可选) 终止站点ID。
     * @param {String} startCoordinate  - (可选) 起始站点坐标。
     * @param {String} endCoordinate  - (可选) 起始站点坐标。
     * @param {Integer} maxDepth  - (可选) 最大边数范围,正整型参数,没有则默认值为5。
     * @param {Float} maxCost  - (可选) 最大权值范围,正双精度符点型参数,没有则默认为100.0。
     * @param {Integer} maxSolutions - (可选) 最多解决方案数量,正整型参数,没有则默认为5。
     * @param {String} orderType - (可选) 值为LeastCost时表示较快捷，值为LeastWalk时表示少步行，值为LeastChange时表示少换乘。
     * 
     * @example
     * (code)
     *  busService.queryChange({
     *      networkName: "BusChangeModule",
     *        startStationId: "238",
     *        endStationId: "25",
	 *		  maxDepth:5,
	 *		  maxCost:100.0,
	 *		  maxSolutions:5,
	 *		  //orderType表示换乘的类型。LeastCost表示较快捷，用户还可以选择LeastWalk或LeastChange，LeastWalk表示少步行，值为LeastChange时表示少换乘
	 *		  orderType:"LeastCost" 
     *  })
     *  (end)
     */	
    queryChange: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryChange"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.startStationId !== null && options.startStationId !== undefined){
            params.STARTSTATIONID = options.startStationId;
        }
        
        if(options.endStationId !== null && options.endStationId !== undefined){
            params.ENDSTATIONID = options.endStationId;
        }
		
		if(options.orderType !== null && options.orderType !== undefined){
            params.ORDERTYPE = options.orderType;
        }
        
        if(options.startCoordinate !== null && options.startCoordinate !== undefined){
            params.STARTCOORDINATE = options.startCoordinate;
        }    
        
        if(options.endCoordinate !== null && options.endCoordinate !== undefined){
            params.ENDCOORDINATE = options.endCoordinate;
        }  
		
		if(options.maxDepth !== null && options.maxDepth !== undefined){
            params.MAXDEPTH = options.maxDepth;
        } 
		
		if(options.maxCost !== null && options.maxCost !== undefined){
            params.MAXCOST = options.maxCost;
        }  
		
		if(options.maxSolutions !== null && options.maxSolutions !== undefined){
            params.MAXSOLUTIONS = options.maxSolutions;
        }  
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		  
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
            	var  featureCollection = [];
				var resXML;//= result.responseXML;
				if (!result.responseXML.documentElement) {
					resXML = format.read(result.responseText);
				}
				else {         
					resXML = result.responseXML;
				}       

				var docElement = resXML.selectNodes("/Features/FeatureCollection");
				
            	var xmlparser = new GeoGlobe.Format.XML();
				
            	for(var i = 0; i < docElement.length; i++) {
					//获取FeatureCollection元素节点的属性
					var featureCollectionElement = docElement[i];
					var attArray = ['cost','price','walkingDistance','transferTimes'];
					var attributionObj = this._getAttibutionOfNode(featureCollectionElement, attArray);
					
					var str = xmlparser.write(docElement[i]);
					var features = this._parserFeatures(str);
					//features或featureCollectionElement相当于一个FeatureCollection
					features.attributes= attributionObj;
					var featureMember = featureCollectionElement.selectNodes("featureMember");
					for(var j = 0; j < featureMember.length; j++) {
						var road = featureMember[j].selectNodes("Road");
						//线路添加是否步行属性：isOnFoot
						features[j]["isOnFoot"] = road[0].getAttribute("isOnFoot");
					}
	            	featureCollection.push(features);
            	}

                successFn(featureCollection);
            },
            failure: failFn
        });

    },
	
	//根据节点得到节点的属性
	_getAttibutionOfNode: function(node, keyArray) {
		//获取FeatureCollection属性信息
		var fcAttibution = {};
		if(node.tagName){
			for(var i = 0; i < keyArray.length; i++) {
				fcAttibution[keyArray[i]] = node.getAttribute(keyArray[i])
			}
	    }
		return fcAttibution;
	},
   
    _getGeometryType: function(geometry){
        var maping = {
            "GeoGlobe.Geometry.Point": "point",
            "GeoGlobe.Geometry.LineString": "line",
            "GeoGlobe.Geometry.Polygon": "polygon"
        };
        return "polygon";
    },
    
    _pagingToString: function(curPage,maxPerPage){
        maxPerPage = maxPerPage || this.maxPerPage;
        curPage = curPage || 1;
        return "<numPerPage>" + maxPerPage + "</numPerPage>"+
                "<curPage>" + curPage + "</curPage>";
    },
    
    _orderByToString: function(property,type){
        var str = "<orderBy>"+
    	            "<PropertyName>" + property + "</PropertyName>"+
    	        "</orderBy>";
        return property ? str : "";
    },
    
    _geometryToString: function(geometry){
        return '<geometry>'+
                    '<Polygon>'+
                        '<outerBoundaryIs>'+
                            '<LinearRing>'+
                                '<coordinates decimal="." cs="," ts=" ">20,30 21,41 52,42 53,33 20,30</coordinates>'+
                            '</LinearRing>'+
                        '</outerBoundaryIs>'+
                    '</Polygon>'+
                '</geometry>';
    },
    
    _stringToGeometry: function(string){
        return GeoGlobe.Geometry.Polygon.createRegularPolygon(
            new GeoGlobe.Geometry.Point( Math.random()*360 - 160, 
                                           Math.random()*90 - 70 ),
            Math.round(Math.random()*20),
            Math.round(Math.random()*10)
        );
    },
	
    _parserFeatures: function(resultString){
        var parser = new GeoGlobe.Format.GML();
        parser.gmlns = "*";
        var features = parser.read(resultString);
        return features;
    },
	
	// 把节点名称所在的节点外套上<featureMember></featureMember>
	_parserResponseText: function(resultString, nodeName){
		if(nodeName){
			var re1 = new RegExp("<" + nodeName + ">", ["g"]);
	        var re2 = new RegExp("</" + nodeName + ">", ["g"]);
			
	        resultString = resultString.replace(re1, "<featureMember><" + nodeName + ">");
	        resultString = resultString.replace(re2, "</" + nodeName + "></featureMember>");
		}
		
		resultString = resultString.replace(/<gml:LineString>/g,"<gml:LineString><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:LineString>/g,"</gml:coordinates></gml:LineString>");
		resultString = resultString.replace(/<gml:Point>/g,"<gml:Point><gml:coordinates>");
		resultString = resultString.replace(/<\/gml:Point>/g,"</gml:coordinates></gml:Point>");
		return resultString;
	},
	
	_parserFeaturesNew: function(resultString, featureName){
		var parser = new GeoGlobe.Format.GML();
        parser.gmlns = "*";
		if(featureName){
			parser.featureName = featureName;
		}
        var features = parser.read(resultString);
        return features;
    },
    
	_parserSuccessResult: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);

	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Format.XML2JSON();
		return parser.read(result);
	},
	
	/**
	 * 根据始终点的空间坐标或一组起始站点ID和一组终止站点的ID，查询公交换乘的文字信息，必要时也查询出第一条方案的几何信息。（公交2.0）
	 * @memberof GeoGlobe.Query.BusQuery.prototype
	 * @param {Object} options   -  请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String} networkName  - (必选) 网络模型名称。
	 * @param {Integer} transferMode  - (必选) 换乘模式  ,有三种值：0-较快捷   1-少换乘  2-少步行。
	 * @param {String} startInput  - (必选) 始点信息，可以是坐标信息也可也是ID类型（坐标类型,格式为:x y。分隔符为空格符；ID类型,格式为:id,… ,id。分隔符为逗号）。
	 * @param {String} endInput  - (必选)终点信息支持坐标与ID类型:坐标类型,格式为:x y。分隔符为空格符ID类型,格式为:id,… ,id。分隔符为逗号。
	 * @param {Integer} inputMode  - (可选)始终点输入模式,值为0|1|2: 0-坐标,1-车站外部唯一编号,2-车站内部唯一编号（当前服务没有外部唯一编号）。
	 * @param ComputeModel
	 * @param transferSubset
	 * @param existGoTime
	 * @param startTime
	 * @param specificSubset
	 * @param maxSearchDistance
	 * @param computeSort
	 * @param transferPolicy
	 * @param resultSort
	 * @param prioritySubset
	 * @param existAbsolutePriority
	 * @param lagSubset
	 * @param outputPage
	 * @param pageSize
	 * @param changeCount
     * @private
	 */
	queryTransferScheme: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferScheme",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		//四个必选参数
		var required = {
			networkName:true,
            transferMode: true,
            startInput: true,
			endInput: true
        };
        for (var prop in required) {
            if (!(prop in options)) {
                throw new Error("缺少必选属性：'" + prop + "'。");
            }
        }
		params.networkName = options.networkName;
		
		//这样判断的原因是为了避免0,1这样的值在进行if判断的时候被当做false把参数给过滤掉；""串不需要被过滤，这个已经向服务组确认
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if(options.transferMode !== null && options.transferMode !== undefined) {
			params.TRANSFERMODE = options.transferMode;
        }
		if(options.startInput !== null && options.startInput !== undefined) {
			params.STARTINPUT = options.startInput;
        }
		if(options.endInput !== null && options.endInput !== undefined) {
			params.ENDINPUT = options.endInput;
        }
		if(options.inputMode !== null && options.inputMode !== undefined) {
			params.INPUTMODEL = options.inputMode;
        }
		if (options.ExistGoTime !== null && options.ExistGoTime !== undefined) {
			params.EXISTGOTIME = options.ExistGoTime;
        }
		if (options.StartTime !== null && options.StartTime !== undefined) {
			params.STARTTIME = options.StartTime;
        }
		if (options.MaxSearchDistance !== null && options.MaxSearchDistance !== undefined) {
			params.MAXSEARCHDISTANCE = options.MaxSearchDistance;
		}
		if (options.PrioritySubset !== null && options.PrioritySubset !== undefined) {
			params.PRIORITYSUBSET = options.PrioritySubset;
        }
		if (options.ExistAbsolutePriority !== null && options.ExistAbsolutePriority !== undefined) {
			params.EXISTABSOLUTEPRIORITY = options.ExistAbsolutePriority;
        }
		if (options.LagSubset !== null && options.LagSubset !== undefined) {
			params.LAGSUBSET = options.LagSubset;
        }
		if (options.OutputPage !== null && options.OutputPage !== undefined) {
			params.OUTPUTPAGE = options.OutputPage;
        }
		if (options.PageSize !== null && options.PageSize !== undefined) {
			params.PAGESIZE = options.PageSize;
        }
		if (options.ChangeCount !== null && options.ChangeCount !== undefined) {
			params.CHANGECOUNT = options.ChangeCount;
        }
		
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            async: false,//true表示异步，false表示同步
            scope: this,
            success: GeoGlobe.Function.bind(function(result){
				var resXML = result.responseXML;
                var features = {
                    startPoint: [],
                    transferScheme: [],
                    endPoint: []
                };	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				
				var element = resXML.selectNodes("/QueryTransferSchemeResponse");	
				var elementXMLStr = xmlparser.write(element[0]);
				// XML解析成json对象
				var jsonObj = this._parseToJSON(elementXMLStr);
				var startPoint = jsonObj.QueryTransferSchemeResponse.StartPoint;
				if (!GeoGlobe.Util.isArray(startPoint)) {
		            startPoint = [startPoint];
		        }
				var endPoint = jsonObj.QueryTransferSchemeResponse.EndPoint;
				if (!GeoGlobe.Util.isArray(endPoint)) {
		            endPoint = [endPoint];
		        }
				var transferScheme = jsonObj.QueryTransferSchemeResponse.TransferScheme;
				
				// 起点要素
                var startPointGeometry = this._getPointGeometryByGMLPointStr(startPoint[0].Geometry.gml_Point);
            	var startPointFeature = new GeoGlobe.Feature(startPointGeometry);
				// 终点要素
                var endPointGeometry = this._getPointGeometryByGMLPointStr(endPoint[0].Geometry.gml_Point);
            	var endPointFeature = new GeoGlobe.Feature(endPointGeometry);
				// 换乘要素
				var transferSchemeFeatures = this._parserTransferScheme(transferScheme);
				
                features = {
                    startPoint: startPointFeature,
                    transferScheme: transferSchemeFeatures,
                    endPoint: endPointFeature
                };
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	// 解析换乘要素
    _parserTransferScheme: function(transferSchemeObjs){
		if (!GeoGlobe.Util.isArray(transferSchemeObjs)) {
            transferSchemeObjs = [transferSchemeObjs];
        }
        var transferSchemeFeatures = new Array();
        for (var i = 0; i < transferSchemeObjs.length; i++) {
			var transferSchemeObj = transferSchemeObjs[i];
			// 解析片段信息
			var SectionInfo = this._parserSectionInfo(transferSchemeObj.SectionInfo);
			// 解析片段步行
			var SectionRoutingFeatures = this._parserSectionRouting(transferSchemeObj.SectionRouting);
            
			var transferSchemeFeature = {
                Cost: transferSchemeObjs[i].Cost,
                SectionInfo: SectionInfo,
                SectionRouting: SectionRoutingFeatures,
                TotalDistance: transferSchemeObjs[i].TotalDistance,
                TransferCount: transferSchemeObjs[i].TransferCount
            };
            transferSchemeFeatures.push(transferSchemeFeature);
        }
        return transferSchemeFeatures;
    },
	
	// 解析片段信息
    _parserSectionInfo: function(sectionInfoObjs){
		if (!GeoGlobe.Util.isArray(sectionInfoObjs)) {
            sectionInfoObjs = [sectionInfoObjs];
        }
		var sectionInfos = new Array();
		for (var i = 0; i < sectionInfoObjs.length; i++) {
			
			// 上车点要素
			var fromStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation);
			if (sectionInfoObjs[i].FromStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].FromStation.PassagewayRouting);
				if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
                fromStationFeature.attributes.PassagewayRouting = fromStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 下车点要素
			var toStationFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation);
			if (sectionInfoObjs[i].ToStation.PassagewayRouting) {
                var passagewayRoutingFeature = this._getPointFeatureByObj(sectionInfoObjs[i].ToStation.PassagewayRouting);
                if(passagewayRoutingFeature.SectionRouting){
                    passagewayRoutingFeature.attributes.SectionRouting = passagewayRoutingFeature.data.SectionRouting = this._parserSectionRouting(passagewayRoutingFeature.SectionRouting);
				}
				toStationFeature.attributes.PassagewayRouting = toStationFeature.data.PassagewayRouting = passagewayRoutingFeature;
            }
			
			// 线路要素
			var sectionLine = this._parserSectionLines(sectionInfoObjs[i].SectionLines.SectionLine);
			var sectionRouting = this._parserSectionRouting(sectionInfoObjs[i].SectionRouting);
			
			sectionInfos.push({
				FromStation: fromStationFeature,
				SectionLine: sectionLine,
				ToStation: toStationFeature,
				SectionRouting: sectionRouting
			});
		}
		return sectionInfos;
	},
	
	// 解析片段信息内的片段线路
    _parserSectionLines: function(sectionLineObjs){
        if (!GeoGlobe.Util.isArray(sectionLineObjs)) {
            sectionLineObjs = [sectionLineObjs];
        }
		var sectionLineFeatures = new Array();
		for (var i = 0; i < sectionLineObjs.length; i++) {
            var sectionLineFeature = new GeoGlobe.Feature(null, sectionLineObjs[i]);
			sectionLineFeatures.push(sectionLineFeature);
		}
		return sectionLineFeatures;
	},
	
	// 解析片段步行
    _parserSectionRouting: function(sectionRoutingObjs){
		// TODO
        if (!GeoGlobe.Util.isArray(sectionRoutingObjs)) {
            sectionRoutingObjs = [sectionRoutingObjs];
        }
		var sectionRoutingFeatures = new Array();
		for (var i = 0; i < sectionRoutingObjs.length; i++) {
			sectionRoutingFeatures.push(sectionRoutingObjs[i]);
		}
		return sectionRoutingFeatures;
	},
	
	// -----根据点串得到点对象
	_getPointGeometryByGMLPointStr: function(pointStr) {
		var pointArr = pointStr.split(",");
		var point = new GeoGlobe.Geometry.Point(parseFloat(pointArr[0]),parseFloat(pointArr[1]));
		return point;
	},
	
	// 解析站点或出入口点的要素
    _getPointFeatureByObj: function(pointInfoObj){
        var pointGeometry = null;
        if (pointInfoObj.Geometry && pointInfoObj.Geometry.gml_Point) {
            pointGeometry = this._getPointGeometryByGMLPointStr(pointInfoObj.Geometry.gml_Point);
        }
        var pointFeature = new GeoGlobe.Feature(pointGeometry, pointInfoObj);
        return pointFeature;
    },
	
	// -----根据id等信息获取geometry串并生成geometry对象
    _getLineGeometryByGMLLineStr: function(geometryStr){
        if (!geometryStr) {
            return null;
        }
        var pointStrArr = geometryStr.split(" ");
        var pointArr = [];
        for (var i = 0, j = pointStrArr.length; i < j; i++) {
            var pointGeometry = this._getPointGeometryByGMLPointStr(pointStrArr[i]);
            pointArr.push(pointGeometry);
        }
        var lineGeometry = new GeoGlobe.Geometry.LineString(pointArr);
        return lineGeometry;
    },
	
	/**
	 * 根据线路ID或者步行ID来获取相应的线要素（公交2.0。注意：这些线要素不包含属性信息）。
	 * @memberof GeoGlobe.Query.BusQuery.prototype
	 * @param {Object} options  - 请求参数。
	 * 
	 * options请求参数属性可为:
	 * @param {String} networkName - (必选) 网络模型名称。
	 * @param {Arrays} parameterInfo - 取值格式：[[geometryTypeID,geometryInfoID,FromOrdinal,ToOrdinal]]例如[[0,10,22,24]]。
	 * @param {Integer} geometryTypeID - (必选) 0-线路内部ID,1-步行路由内部ID。如果这个属性的值为1，那么FromOrdinal和ToOrdinal这两个属性的的值就都为0。
	 * @param {Integer} geometryInfoID - 几何信息 的ID。
	 * @param {Integer} FromOrdinal -  (必选) 起点序号。
	 * @param {Integer} ToOrdinal -  (必选) 终点序号。
	 */
	queryTransferGeometry: function(options, successFn, failFn) {
		var params = {
			request: "QueryTransferGeometry",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.parameterInfo === null || options.parameterInfo === undefined || options.parameterInfo === ""){
            throw "Error!Not parameterInfo for bus query.";
            return;
        }
		params.networkName = options.networkName;
		params.PARAMETERINFO = "";
        for (var i = 0; i < options.parameterInfo.length; i++) {
            params.PARAMETERINFO += options.parameterInfo[i].toString();
            if (i != options.parameterInfo.length - 1) {
                params.PARAMETERINFO += "_";
            }
        }
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: false,//true表示异步，false表示同步
            success: GeoGlobe.Function.bind(function(result){
				var features = this._parseQueryTransferGeometryResult(result);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析QueryTransferGeometry接口返回结果 -----获取线路要素
	_parseQueryTransferGeometryResult: function(result) {
		resXML = result.responseXML;
		var features = [];
		if(!resXML) {
			return features;
		}
		var xmlparser = new GeoGlobe.Format.XML();
		var geometrysStrTemp = resXML.selectNodes("/QueryTransferGeometryResponse");	
		//没有查询到数据的情况
		if(geometrysStrTemp && geometrysStrTemp.length <= 0) {
			return features;
		}
		var geometrysXMLStr = xmlparser.write(geometrysStrTemp[0]);
		var geometrysXMLObj = this._parseToJSON(geometrysXMLStr);
		var geometrys = geometrysXMLObj.QueryTransferGeometryResponse.SectionGeometry;	
		
		if(geometrys) {
			if(!GeoGlobe.Util.isArray(geometrys)) {
				geometrys = [geometrys];
			}
			//得到一个个站点
			for(var i = 0 ;i < geometrys.length; i++)  {
				//得到几何对象
				var geometryTemp = this._getLineGeometryByGMLLineStr(geometrys[i].Geometry.gml_LineString);
				//得到线要素
                var lineFeature = new GeoGlobe.Feature(geometryTemp, {
                    ID: geometrys[i].ID
                });
				features.push(lineFeature);
			}
		}
		return features;
	},
	
	/**
	 * 根据关键字来获取线路信息或者站点信息或者出入口信息。（公交2.0）
	 *  @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  - 请求参数。
	 * 
	 * options请求参数属性可为:
	 * @param {String} networkName  - (必选) 网络模型名称。
	 * @param {String} keyWord  - (必选)查询关键字。
	 * @param {Integer} searchType  - (可选) 查询类型，默认值为 2，查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊默认值为2。
	 * @param {Integer} keyWordType  - (可选) 查询关键字类型，默认值为 -1，可供选择的值为-1|0|1|2:-1:先查线路，然后查车站，最后查出入口0-查线路，1-查车站，2-查出入口。
	 *     
	 * @returns {Array(GeoGlobe.Feature)}  - 返回的是出入口、站点、线路要素。
	 */
	queryKeyWord: function(options, successFn, failFn) {
		var params = {
			REQUEST: "QueryKeyWord",
			SERVICE: "BUS",
			VERSION: "1.0.0",
			SEARCHTYPE: 2
		};
		if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.keyWord === null || options.keyWord === undefined || options.keyWord === ""){
            throw "Error!Not keyWord for bus query.";
            return;
        }
		params.NETWORKNAME = options.networkName;
		params.KEYWORD = options.keyWord;
		
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		if (options.searchType !== null && options.searchType !== undefined) {
        	params.SEARCHTYPE = options.searchType;
        }
		if (options.keyWordType !== null && options.keyWordType !== undefined) {
        	params.KEYWORDTYPE = options.keyWordType;
        }
		var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            async: false,//true表示异步，false表示同步
            scope: this,
            success: GeoGlobe.Function.bind(function(result){
				var features = this._parserQueryKeyWordResult(result,options.keyWordType);
				successFn(features);
            },this)
			,
            failure: failFn
        });
	},
	
	//解析queryKeyWord接口返回结果 -----获取站点或出入口或线路文字描述信息
	_parserQueryKeyWordResult: function(result,keyWordType) {
		var resXML = result.responseXML;
		var features = [];	
		if(!resXML) {
			return features;
		}
		var xmlparser = new GeoGlobe.Format.XML();
		var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
		//没有查询到数据的情况
		if(errorTemp && errorTemp.length > 0) {
			return features;
		}
		var objectsStrTemp = resXML.selectNodes("/QueryKeyWordResponse");	
		var objectsXMLStr = xmlparser.write(objectsStrTemp[0]);
		var objectsXMLObj = this._parseToJSON(objectsXMLStr);
		
		// 0-查线路，1-查车站，2-查出入口
        if (keyWordType === 1) {
            var stations = objectsXMLObj.QueryKeyWordResponse.Stations.Station;
			if (stations && !(GeoGlobe.Util.isArray(stations))) {
				stations = [stations];
			}
            for (var i = 0; i < stations.length; i++) {
                var pointFeature = this._getPointFeatureByObj(stations[i]);
                features.push(pointFeature);
            }
        } else if (keyWordType === 2) {
            var passageways = objectsXMLObj.QueryKeyWordResponse.Passageways.Passageway;
			if (passageways && !(GeoGlobe.Util.isArray(passageways))) {
				passageways = [passageways];
			}
            for (var i = 0; i < passageways.length; i++) {
                var pointFeature = this._getPointFeatureByObj(passageways[i]);
                features.push(pointFeature);
            }
        } else {
            var lines = objectsXMLObj.QueryKeyWordResponse.Lines.Line;
			if (lines && !(GeoGlobe.Util.isArray(lines))) {
				lines = [lines];
			}
            for (var i = 0; i < lines.length; i++) {
                var lineFeature = new GeoGlobe.Feature(null,lines[i]);
                features.push(lineFeature);
            }
        }
		return features;
	},
	
	/**
     * 站点查询操作。（公交2.0）
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  - 请求参数。
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * @param {String} networkName  - (必选) 网络模型名称。
     * @param {Integer} stationId  - (必选) 站点ID  必须为正整型。
     *   
     *       
     * @example
     * (code)
     *  busService.queryStationInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */	
    queryStationInfo:function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryStationInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.stationId === null || options.stationId === undefined || options.stationId === ""){
            throw "Error!Not stationId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
        if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
		
        if(options.stationId !== null && options.stationId !== undefined){
            params.STATIONID = options.stationId;
        }
        
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				resXML = result.responseXML;
				if(!resXML) {
					var features = {
						lines:[],
						passageways:[]
					};
	                successFn(features);
					return;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				
				//根据节点名字，解析成对象
				var lines = this._parserQueryStationInfoNode("Lines", xmlparser, resXML);
				var passageways = this._parserQueryStationInfoNode("Passageways", xmlparser, resXML);
                
				//解析后转feature
				var passagewaysFeature = new Array();
                for (var i = 0; i < passageways.length; i++) {
					var pointFeature = this._getPointFeatureByObj(passageways[i]);
					passagewaysFeature.push(pointFeature);
                }
		
				var features = {
					lines: lines,
					passageways: passagewaysFeature
				};
                successFn(features);
            },
            failure: failFn
        });

    },
	
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryStationInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Lines":
                //解析lines
	            var element = resXML.selectNodes("/QueryStationInfoResponse/StationInfo/Lines");
	            var lines = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
	                lines = jsonObj.Lines.Line;
	                if (!(GeoGlobe.Util.isArray(lines))) {
	                    lines = [lines];
	                }
	            }
	            return lines;
                break;
            case "Passageways":
                //解析Passageways
	            var element = resXML.selectNodes("/QueryStationInfoResponse");
	            var passageways = new Array();
	            if (element.length > 0) {
	                var xmlObj = xmlparser.write(element[0]);
	                var jsonObj = this._parseToJSON(xmlObj);
					var passagewaysJson = jsonObj.QueryStationInfoResponse.StationInfo.Passageways;
					if(passagewaysJson){
						passageways = passagewaysJson.Passageway;
		                if (!(GeoGlobe.Util.isArray(passageways))) {
		                    passageways = [passageways];
		                }
					}
	            }
	            return passageways;
                break;
            default:
				return [];
                break;
        }
    },
    
    /**
     * 线路查询操作。（公交2.0）
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  -  请求参数。
     * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * 
	 * options请求参数属性可为:
     * @param {String} networkName - (必选) 网络模型名称。
     * @param {Integer} lineId - (必选) 线路ID。
     * @param {String} STARTNODENUMBER - (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * @param  {String} ENDNODENUMBER - (可选) 线路中某一个站点的序号。多个序号采用逗号分割。
     * 
     * @example
     * (code)
     *  busService.queryLineInfo({
     *      networkName: "BusChangeModule",
     *      stationId : 2
     *  }
     *  (end)
     */
    queryLineInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryLineInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.lineId === null || options.lineId === undefined || options.lineId === ""){
            throw "Error!Not lineId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.lineId !== null && options.lineId !== undefined){
            params.LINEID = options.lineId;
        }
        
        if(options.startNodeNumber !== null && options.startNodeNumber !== undefined){
            params.STARTNODENUMBER = options.startNodeNumber;
        }    
                
        if(options.endNodeNumber !== null && options.endNodeNumber !== undefined){
            params.ENDNODENUMBER = options.endNodeNumber;
        }   
                     
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
//				// 传入包含gml的结点名称
//				var resultString = this._parserResponseText(result.responseText, "Line");
//				var features = this._parserFeaturesNew(resultString);
//				
//				// 线路所包含的站点要素
//				var resultStationString = this._parserResponseText(result.responseText, "Station");
//				var stationFeatures = this._parserFeaturesNew(resultStationString);
//                features[0].attributes.Stations = features[0].data.Stations = stationFeatures;
//				
//				successFn(features);
//				return;
				
				var features = [];
				var resXML = null;
				if(result.responseXML) {         
					resXML = result.responseXML;
					var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
					//没有查询到数据的情况
					if(errorTemp && errorTemp.length > 0) {
						successFn(features);
						return;
					}
					var xmlparser = new GeoGlobe.Format.XML();
					//根据节点名字，解析成对象
					var line = this._parserQueryLineInfoNode("Line", xmlparser, resXML);
					//解析后转feature
					var lineFeatures = new Array();
	                for (var i = 0; i < line.length; i++) {
						//线路内站点信息转要素
						var stationFeatures = new Array();
	                    for (var j = 0; j < line[i].VIAStations.Station.length; j++) {
							//得到点要素
	                    	var stationFeature = this._getPointFeatureByObj(line[i].VIAStations.Station[j]);
							stationFeatures.push(stationFeature);
	                    }
						line[i].Stations = stationFeatures;
						//得到线几何对象
						var lineGeometry = this._getLineGeometryByGMLLineStr(line[i].Geometry.gml_LineString);
						//得到线要素
	                    var lineFeature = new GeoGlobe.Feature(lineGeometry, line[i]);
						lineFeatures.push(lineFeature);
	                }
			
					features = lineFeatures;
				}
				successFn(features);
            },
            failure: failFn
        });

    },
	//解析queryStationInfo接口返回的结果中的xml串
    _parserQueryLineInfoNode: function(nodeName, xmlparser, resXML){
		switch (nodeName) {
            case "Line":
                //解析line
	            var element = resXML.selectNodes("/QueryLineInfoResponse");
				var xmlObj = xmlparser.write(element[0]);
                var jsonObj = this._parseToJSON(xmlObj);
				var l = jsonObj.QueryLineInfoResponse.Line;
				
	            var lines = new Array();
                if (l && !(GeoGlobe.Util.isArray(l))) {
                    lines = [l];
                }else{
					lines = l;
				}
	            return lines;
                break;
            default:
				return [];
                break;
        }
    },
	
	/**
     * 根据出入口ID获取与此出入口有关的站点信息，包括出入口所对应的车站信息。（公交2.0）
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {Object} options  - 请求参数。
     * @param {Function} successFn   - 请求成功的回调函数。
     * @param {Function} failFn  -  请求失败的回调函数。
     * 
     * options请求参数属性可为:
     * @param {String} networkName  - (必选) 网络模型名称。
     * @param {Integer} passagewayId  - (必选) 出入口ID。
     * 
     * @example
     * (code)
     *  busService.queryPassagewayInfo({
     *      networkName: "BusChangeModule",
     *      passagewayId : 2
     *  }
     *  (end)
     */
    queryPassagewayInfo: function(options, successFn, failFn){
        
        var params = {
			REQUEST: "QueryPassagewayInfo",
			SERVICE: "BUS",
			VERSION: "1.0.0"
		};
        
        if(!options.networkName){
            throw "Error!Not network name for bus query.";
            return;
        }
		if(options.passagewayId === null || options.passagewayId === undefined || options.passagewayId === ""){
            throw "Error!Not passagewayId for bus query.";
            return;
        }
        params.NETWORKNAME = options.networkName;
        
		if(options.service !== null && options.service !== undefined){
            params.SERVICE = options.service;
        }
		
		if(options.version !== null && options.version !== undefined){
            params.VERSION = options.version;
        }
        
        if(options.passagewayId !== null && options.passagewayId !== undefined){
            params.PASSAGEWAYID = options.passagewayId;
        }
        var xhr = GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            success: function(result){
				var resXML = result.responseXML;
				var features = [];	
				if(!resXML) {
					successFn(features);
					return features;
				}
				var xmlparser = new GeoGlobe.Format.XML();
				var errorTemp = resXML.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
				//没有查询到数据的情况
				if(errorTemp && errorTemp.length > 0) {
					successFn(features);
					return features;
				}
				var responseText = this._parserResponseText(result.responseText);
				features = this._parserFeaturesNew(responseText, "Stations");
				successFn(features);
            }
        });
	},
	
	
	/**
     * 根据起点终点名称得到对应的坐标信息
     * 根据坐标信息请求_queryTransferScheme查询换乘方案信息
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {String} startName - 起点名称。
     * @param {String} endName - 终点名称。
     * @param {String} transferMode - 选择方式
     *
     * @returns {Object}   - 换乘方案信息
     * 
     * 返回对象属性包含：
     * @param startPoint  - 起点要素
     * @param transferScheme  - 所有换乘方案信息
     * @param endPoint  - 终点要素
     * @private
     */
    _queryByName: function(startName,endName,transferMode){
    	var that = this;
    	var featuresInfo = null;
    	 //查询起点信息
         that.queryKeyWord({
             networkName: that.networkName,
             keyWord: startName,
             keyWordType: 1,// 0-查线路，1-查车站，2-查出入口//-1:先查线路，然后查车站，最后查出入口
             SEARCHTYPE: 2//查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊,默认值为2；
         }, function(feature){
               if (feature.length == 0) {
				   alert("没有查询到起点");
	               return;
               }
			   var startPoint = feature[0].geometry.x + " " +feature[0].geometry.y;
			   //查询终点信息
			   that.queryKeyWord({
	               networkName: that.networkName,
	               keyWord: endName,
	               keyWordType: 1,// 0-查线路，1-查车站，2-查出入口//-1:先查线路，然后查车站，最后查出入口
	               SEARCHTYPE: 2//查询类型，其值为0|1|2:0-完全配匹，1-模糊查询，2-先完全后模糊,默认值为2；
       		  }, function(feature){
		            if (feature.length == 0) {
						alert("没有查询到终点");
		           		return;
		      		}
		   			var endPoint = feature[0].geometry.x + " " + feature[0].geometry.y;
		   			featuresInfo = that._queryTransferScheme(startPoint,endPoint,transferMode);//查询换乘方案信息
		    	});
			});
			return featuresInfo;
    },
	
	/**
     * 根据parameter1、parameter2、transferMode查询公交换乘方案。
     * 请求url，响应返回capabilities的XML文档信息，解析该XML文档，获得服务的networkName。
     * 根据得到的参数请求_queryTransferScheme方法得到换乘方案信息 
     * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {GeoGlobe.LngLat | String} parameter1  - 起点经纬度或者起点名称。
     * @param {GeoGlobe.LngLat | String} parameter2  - 终点经纬度或者终点名称。
     * @param {String} transferMode - 选择方式 0-较快捷   1-少换乘  2-少步行
     *
     * @returns {Object}  - 换乘方案信息
     * {flag:服务正常返回换乘信息为true,否则为false,featuresInfo：换乘方案信息}
     *
     */
    queryBus: function(parameter1, parameter2,transferMode){
    	var that = this;
    	var featuresInfo = null;
    	that.getCapabilities(GeoGlobe.Function.bind(function(result){
			//响应返回capabilities的XML文档信息
            var data = result.responseXML;
            if (!data || !data.documentElement) {
                data = result.responseText;
            }
            var format = new GeoGlobe.Format.BusCapabilities();
            var capabilities = format.read(data);
			if(capabilities.capability){
	            var layerName = capabilities.capability.networks[0];
	            that.networkName = layerName;
	            if(typeof(parameter1) == "string" && typeof(parameter2) == "string"){//站点名称查询
	            	featuresInfo = that._queryByName(parameter1,parameter2,transferMode);
	            }else{//坐标查询
	            	var startPoint = parameter1.lng + " " +parameter1.lat;
	            	var endPoint = parameter2.lng + " " + parameter2.lat;
	            	featuresInfo = that._queryTransferScheme(startPoint,endPoint,transferMode);//查询换乘方案信息
	            }
			}else{
				alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            	"请求地址：" + url + "\n操作类型：GetCapabilities");
			}
        }, this),
		function(){
            alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
        });
        var featureData = {
        	flag:featuresInfo ? true : false,
        	featuresInfo:featuresInfo
        }
        return featureData;
    },
    
    
    failFn: function(){
		alert("公交服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" +
            "请求地址：" + url + "\n操作类型：GetCapabilities");
	},
	
	 /**
	  * 查询换乘方案信息
	  * 根据startPoint、endPoint、transferMode、networkName查询公交换乘方案。
	  * @memberof GeoGlobe.Query.BusQuery.prototype
      * @param {String}  url  - 公交服务地址。
      * @param {GeoGlobe.Geometry.Point} startPoint  -  起点坐标。
      * @param {GeoGlobe.Geometry.Point}  endPoint  - 终点坐标。
      * @param {String} transferMode - 选择方式 0-较快捷   1-少换乘  2-少步行
      *
      * @returns {Object}  - 换乘方案信息
      * 
      * 返回对象属性包含：
      * @param startPoint  - 起点要素
      * @param transferScheme  - 所有换乘方案信息
      * @param endPoint  - 终点要素
      * @private
	  *
	  */
	_queryTransferScheme: function(startPoint,endPoint,transferMode){
		var lineFeatures =  null;
        this.queryTransferScheme({
	         networkName: this.networkName,
	         transferMode: transferMode ? transferMode : 0,//0-较快捷   1-少换乘  2-少步行
	         inputMode: 0,//默认为0。0：传坐标。2：传ID。
	         startInput: startPoint,
	         endInput: endPoint
	    }, function(features){
	     	featuresInfo = features;
	    });
	    this.transferScheme = featuresInfo.transferScheme;
	    return featuresInfo;
	},
	
	/**
	 *
	 * 根据sortIndex查询单条换乘方案几何信息。
	 * @memberof GeoGlobe.Query.BusQuery.prototype
     * @param {String} sortIndex  - 换乘方案索引值。
     *
     * @returns {Object}    -  换乘方案几何信息
     * {lineFeatures:方案线要素 ,stationFeatures:换乘方案的起始点要素}
	 *
	 */
	queryBusTransferSchemeByIndex: function(sortIndex){
		var busSer = null;
		var lineData = null;
		var sortIdx = parseInt(sortIndex);
        var transferScheme = this.transferScheme[sortIdx];
        var sectionInfo = transferScheme.SectionInfo;
        
        //查询参数。
        var parameterInfo = new Array();
        var transferPointFeatures = new Array();
        for (i = 0; i < sectionInfo.length; i++) {
            var type = 0;
            var lineFeature = sectionInfo[i].SectionLine[0];
            var lineId = lineFeature.data.ID;
            var fromOrdinal = lineFeature.data.FromOrdinal;
            var toOrdinal = lineFeature.data.ToOrdinal;
            
            parameterInfo.push([type, lineId, fromOrdinal, toOrdinal]);
            transferPointFeatures.push(sectionInfo[i].FromStation);
            transferPointFeatures.push(sectionInfo[i].ToStation);
        }
        
        this.queryTransferGeometry({
            networkName: this.networkName,
            //单条几何信息的ID的类型(0或者1)，几何信息的ID(line:LID)，起点序号(upStation:NodeNumber)，终点序号(downStation:NodeNumber)；
            parameterInfo: parameterInfo//[[0, 67, 24, 60], [0, 221, 31, 85]]
        }, function(features){
            var lineFeatures = features;
            //将lineFeatures和transferPointFeatures转化为geojson数据类型
            var gjformat = new GeoGlobe.Format.GeoJSON();
			var geojsonRouteStr = gjformat.write(lineFeatures);
			var geojsonStationStr = gjformat.write(transferPointFeatures);
			var jformat = new GeoGlobe.Format.JSON();
			var geojsonRoute = jformat.read(geojsonRouteStr);
			var geojsonStation = jformat.read(geojsonStationStr);
			
            var data = {
            	lineFeatures:lineFeatures,
            	geojsonRoute:geojsonRoute,
            	stationFeatures: transferPointFeatures,
            	geojsonStation:geojsonStation
            }
            lineData = data;
        });
        return lineData;
	},
	
	
	
	CLASS_NAME: "GeoGlobe.Query.BusQuery"
});

//FF,chrome兼容selectNodes,selectSingleNode
(function xmlNodesTool(){
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectNodes = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            //name space resolver defined  
            function nsResolver(prefix){
                var ns = {
                    'csw': 'http://www.opengis.net/cat/csw',
                    'smmd': 'http://data.sbsm.gov.cn/smmd/2007',
                    'wfs': 'http://www.opengis.net/wfs',
                    'gml': 'http://www.opengis.net/gml',
                    'geoglobe': 'http://www.geostar.com.cn/geoglobe'
                };
                return ns[prefix] || null;
            }
            //var oNSResolver = this.createNSResolver(this.documentElement||this.ownerDocument.documentElement)||nsResolver;
            var aItems = this.evaluate(cXPathString, xNode, nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
            var aResult = [];
            for (var i = 0; i < aItems.snapshotLength; i++) {
                aResult[i] = aItems.snapshotItem(i);
            }
            return aResult;
        };
        
        // prototying the Element 
        Element.prototype.selectNodes = function(cXPathString){
            if (this.ownerDocument.selectNodes) {
                return this.ownerDocument.selectNodes(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
        
    }
    if (document.implementation.hasFeature("XPath", "3.0")) {
        // prototying the XMLDocument 
        XMLDocument.prototype.selectSingleNode = function(cXPathString, xNode){
            if (!xNode) {
                xNode = this;
            }
            var xItems = this.selectNodes(cXPathString, xNode);
            if (xItems.length > 0) {
                return xItems[0];
            }
            else {
                return null;
            }
        };
        
        // prototying the Element 
        Element.prototype.selectSingleNode = function(cXPathString){
            if (this.ownerDocument.selectSingleNode) {
                return this.ownerDocument.selectSingleNode(cXPathString, this);
            }
            else {
                throw "For XML Elements Only";
            }
        };
    }
})();/**
 * @class GeoGlobe.Query.WFSQuery
 * @classdesc WFS地图要素服务查询类。本类也适用于聚合网络要素服务（Aggregation Web Feature Service简称AWFS）和地名地址要素服务（Web Feature Service Gazetteer简称WFS-G）的查询。
 *
 */
GeoGlobe.Query.WFSQuery = GeoGlobe.Class4OL({
	
    /**
     *  WFS服务地址。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
	url: null,
	
	/**
     *  WFS服务版本
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
	version: "1.0.0",

    /**
     *  要素命名空间
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
    featureNS: null,
	
	/**
	 * 是否对请求结果中的几何信息进行轴序反转，默认值为false,
	 * 当取值为false时，对请求结果不做反转操作。
	 * 当取值为true时，对请求结果做反转操作。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {Boolean}
	 */
	isReverse: false,
	
	/**
	 * 要素类型前缀，默认值""
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
	 */
	featurePrefix:"",
	
    /**
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {Array}
     */	
	featureType: "",
	
    /**
     * 最大结果数。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String | Array(String)}
     */	
	maxFeatures: 10,
	
    /**
     *  查询条件。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {GeoGlobe.Filter}
     */
	filter: null,
    
    /**
     * 要素中geometry属性的名称，默认为"the_geom"。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
    geometryName: "the_geom",


    /**
     *  WFS查询协议对象。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {GeoGlobe.Protocol}
     */	
	protocol: null,

    /**
     *  用于对查询操作返回结果进行解析的格式解析器，默认为GML解析器。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {GeoGlobe.Format}
     */
	format: null,
    
    /**
     * 格式解析器构造参数。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {GeoGlobe.Format}
     */    
    formatOptions: null,
    
    /**
     * 设置是否将查询结果按图层名分类。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {Boolean}
     */  
    isSeparate: false,
	
    /**
     * 空间参考名。默认值为"EPSG:4326"。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
    srsName: "EPSG:4326",
	
    /**
     * 可选的。版本时间，此参数只针对多时态矢量数据集。默认为查询最新版本时间。时间格式：2015-5-19 12:12:01
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
	time: null,
	
    /**
     * 可选的。是否追溯(取值范围：true或false，true为返回最近匹配，false则精确匹配，默认值为true)
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {String}
     */
	userecent: true,
	
	/**
	 * 设置WFS查询结果的排序参数，该参数为一个数组对象。
     *  > sortBy数组内对象所包含的属性:
     *  > property - {String} 查询出的要素的某一属性的名称，根据该属性进行排序。
     *  > order - {String} 设置正序("ASC")或倒序("DESC")。
     *
	 * 说明：
	 * 1.wfsg和wfs服务都支持排序；如果wfsg服务中的Post请求串中没有sort节点，那么该服务就不进行排序了（此时用其他字段排序也不起作用了）。当服务在查询中
	 * 有sort节点的时候， 建议用户选择STANDARDNAME和sort字段之一进行排序。如果使用DoMainName作为查询关键字，也可以使用DoMainName进行作为排序字段。
	 * 
	 * 2.wfsg服务和wfs服务默认是以sort字段进行排序，sort字段的值是数字，如果用户以sort字段进行排序，那么sort字段的值（数字）越大，
	 * 在结果列表中越排在后面，相反，sort字段的值越小，则在结果列表中排在越前面，如果sort字段的值相同，则按照其在数据库中读出来的先后顺序排列，
	 * 如果sort字段没值，则排在结果的最后面。
	 * 
	 * 3.若是以STANDARDNAME作为排序字段，如果STANDARDNAME的值是中文，那么排序就是第一个汉字的拼音的首字母的先后顺序作为排序字段（如北京和安徽，
	 * 北京是b为拼音首字母，安徽是a为拼音首字母，那么就是安徽排在北京的前面），若值的第一个汉字拼音首字母相同，则是以第一个汉字拼音的第二个字
	 * 母的先后顺序排列；如果STANDARDNAME的值是英文，也一样，依次类推。
	 *@memberof GeoGlobe.Query.WFSQuery.prototype
     * @type {Array}
	 * @example
	 * (code)
	 *		 wfsQueryObj.sortBy = [{
     *              property: "STANDARDNAME",
     *              order: "DESC"
     *          }]
	 * (end)
	 */
	sortBy: null,

	groupBy: null,
	
	resultType: "Results",
	
	startPosition: null,

	/**
	 * GeoGlobe.Query.WFSQuery类构造函数。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {String} url  -  WFS服务地址。
	 * @param {String} featureType  -  要素类型。
	 * @param {Object} options  - 相关属性的设置项，可选。
	 */	
	initialize: function(url,featureType,options){
		this.url = url;
		this.featureType = featureType;
		var xy = null;
		if(options) {
			if(options.isReverse === true) {
				this.isReverse = options.isReverse;
				xy = !options.isReverse;
			}else if(options.isReverse === false) {
				this.isReverse = options.isReverse;
				//xy顺序即是不反转
				xy = !options.isReverse;
			}else {
				//默认不反转
				xy = !this.isReverse;
			}
			if(!options.format) {
				this.format = new GeoGlobe.Format.GML({xy:xy});
			}else if(options.format instanceof GeoGlobe.Format.GML.v2 ||options.format instanceof GeoGlobe.Format.GML.v3) {
				options.format.setFeatureType_(featureType);
			}
		}
		GeoGlobe.Util.extend(this, options);
	},

	/**
	 * 开始查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.Filter}  filter  - 过滤器。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new GeoGlobe.LngLatBounds([-90,-180],[90,180]);
	 * 
	 * @param successFn - {Function} 请求成功的回调函数。
	 * > 该回调函数会提供一个形参，该形参是一个数组，名为features。在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 * > 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * @param failFn - {Function} 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * @example
	 * (code)
	 *  	//查询范围
	 *		var queryBBOX = new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 *		 //范围过滤
	 *		 var filter = new GeoGlobe.Filter.Spatial({
	 *           type: GeoGlobe.Filter.Spatial.BBOX,
	 *           property: this.geometryName,            
	 *		    value: queryBBOX
	 *       });
	 *		 wfsQueryObj.query(filter,successFn,failFn);
	 * (end)
	 */
	query: function(filter,successFn,failFn){
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
            formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent,//是否追溯
			srsName: this.srsName
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var features = result.features
            
            //根据要求进行按图层名分捡要素
            if(this.isSeparate){
                features = this._separateFeatures(features);
            }
            //对于容错给予提示的节点
            var trueNames = this._read_trueName(result);
			trueNames ? (features.trueNames = trueNames) : features;
			//querySuccessFn(features);
			
			var gjformat = new GeoGlobe.Format.GeoJSON();
			var gjStr = gjformat.write(features);
			var jformat = new GeoGlobe.Format.JSON();
			var gjObj = jformat.read(gjStr);
			querySuccessFn({
				features: features,
				geojson: gjObj
			});
			
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			filter: queryFilter,
			callback: callback
		});
	},
	
	/**
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.Filter} filter  - 过滤器。
	 * @param {Function} successFn  - 请求成功的回调函数。
	 *    > 该回调函数会提供一个形参，该形参是一个数组，名为features。在地名查询2.0及其以上的版本中，features有一个属性叫trueNames，
	 *    > 该属性用于存放纠错词信息。在地名查询2.0以下的版本中不提供trueNames属性。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * @param {Object} options  - 参数选项。
     * 
	 */
	queryPage: function(filter, successFn, failFn, options){
	    var perPageNumber = (options && options.perPageNumber) || 15,
	        pageNumber = (options && options.pageNumber) || 1;
	    
	    var startPosition = (pageNumber - 1) * perPageNumber + 1;
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
			multi:true,
	        formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
	        maxFeatures: perPageNumber,
	        startPosition: startPosition,
	        featurePrefix:this.featurePrefix,
	        url: this.url,
	        featureNS: this.featureNS,
			version: this.version,
			geometryName : this.geometryName,
	        featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent,//是否追溯
			srsName:this.srsName
	    });
		
	    //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
	    var queryFilter = filter || this.filter;
	    var querySuccessFn = successFn || this.successFn;
	    var queryFailFn = failFn || this.failFn;
	    
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}
	
			var features = result.features
	        
	        //根据要求进行按图层名分捡要素
	        if(this.isSeparate){
	            features = this._separateFeatures(features);
	        }
	        //对于容错给予提示的节点
	        var trueNames = this._read_trueName(result);
			features.trueNames = trueNames;
			//querySuccessFn(features);
			
			var gjformat = new GeoGlobe.Format.GeoJSON();
			var gjStr = gjformat.write(features);
			var jformat = new GeoGlobe.Format.JSON();
			var gjObj = jformat.read(gjStr);
			querySuccessFn({
				features: features,
				geojson: gjObj
			});
			
			
		},this);
		this.response = this.protocol.read({
			sortBy:this.sortBy,
	//		maxFeatures: this.maxFeatures,
			filter: queryFilter,
			callback: callback
		});
	},
	
	/**
	 * 查询总数据的总条数。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.Filter} filter  - 过滤器。
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
	 * 
	 */
	queryTotalNumber: function(filter,successFn,failFn){

        var hitsParser = new GeoGlobe.Format.WFSHits();

		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: hitsParser,
			propertyNames: this.propertyNames,
            resultType: "hits",
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent//是否追溯
        });
		
        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;
        
		var callback = GeoGlobe.Function.bind(function(result){
				
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}

			var hitsResult = result.features
            
			querySuccessFn(hitsResult);
			
		},this);

		this.response = this.protocol.read({
			filter: queryFilter,
			callback: callback
		});

	},
    
	//读取容错提示节点
	_read_trueName: function(result) {
		var trueNames = [];
		if(result.priv && result.priv.responseText) {
			if(null == this.format){
				return null;
			}
			var trueNameDocs = this.format.getXMLDoc().getElementsByTagName("trueName");
			if (trueNameDocs == null || trueNameDocs.length == 0) {
                return null;
            }
			for(var i = 0; i < trueNameDocs.length; i++) {
				trueNames.push(trueNameDocs[i].text);
			}
			return trueNames;
		}
		return trueNames;
	},
	
	/**
	 *  得到缓冲区域。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @param {GeoGlobe.Feature} point  - 点要素。
     * @param {Integer} distance  - 半径。
     * @param {String} unit  - 缓冲单位。
     * 
	 * @returns {GeoGlobe.Geometry.Polygon}  - 几何多边形。
	 */
	getBufferRegion: function(point,distance,unit) {
		var lonlat = this._getFeaturesCenter(point);
		switch(unit){
			case "km":
				distance = 1000 * distance;
			case "m":
				distance = this._meterToDegree(distance,lonlat);				
		}
		return GeoGlobe.Geometry.Polygon.createRegularPolygon(point.geometry,distance,40,360); 
	},
	
    /**
     *  获取所有要素范围之合的中心点。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @param features  - 要执行缓冲分析的要素。
     * 
     * @returns {GeoGlobe.LonLat}  - 中心点的坐标。
	 * @private
     */
	_getFeaturesCenter: function(features){		
		var bounds = this._getFeaturesExtent(features);
		return bounds.getCenterLonLat();
	},
	
	/**
	 * 获取要素数组范围之合。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param features - 要查看的要素数组
	 * 
	 * @returns  {GeoGlobe.LngLatBounds}  - 要素数组的总的范围。
	 * @private
	 */
	_getFeaturesExtent: function (features) {
        if(!(GeoGlobe.Util.isArray(features))){
			features = [features];
		}
        var maxExtent = null;
        if(features && (features.length > 0)) {
            maxExtent = new GeoGlobe.LngLatBounds();
            var geometry = null;
            for(var i=0, len=features.length; i<len; i++) {
                geometry = features[i].geometry;
                if (geometry) {
                    maxExtent.extend(geometry.getBounds());
                }
            }
        }
        return maxExtent;
    },
	
	/**
	 * 根据地理坐标位置，将米转换成经纬度。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param meter  - 要转换的地理坐标。
	 * @param lonlat  - 经纬度。
	 * @private
	 */
	_meterToDegree: function(meter,lonlat){
		var a = 0.00000899; //赤道上的距离1公里=0.000008993220293度
		var templat = lonlat.lat;
		return meter * ( a / Math.cos(GeoGlobe.Util.rad(templat)) );
	},
	
	/**
	 * 点查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param  {GeoGlobe.Geometry.Point} point  - 点要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的point参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个点要素为例：new GeoGlobe.Geometry.Point(112,20)。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该点要素应写成new GeoGlobe.Geometry.Point(20,112)
	 * @param {Number} distance  - 缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 * @param {String} unit  - 单位  值为"m"或degree。
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * @example
	 * (code)
	 *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
	 *   //点要素
	 *	 var queryPoint = new GeoGlobe.Geometry.Point(110.40056,39.93202);
	 *   wfsQueryObj.pointQuery(queryPoint,distance,unit,successFn,failFn);
	 * (end)
	 */
    pointQuery: function(point,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new GeoGlobe.Filter.Spatial({
            //type: GeoGlobe.Filter.Spatial.INTERSECTS,
            type: GeoGlobe.Filter.Spatial.DWITHIN, //GeoGlobe.Filter.Spatial.DWITHIN
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: point
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * 线查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 *  @param {GeoGlobe.Geometry.LineString} path  - 线要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的path参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个线要素为例：new GeoGlobe.Geometry.LineString([new GeoGlobe.Geometry.Point(118,20),new GeoGlobe.Geometry.Point(118.8,20.8)])。
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该线要素应写成
     * 		new GeoGlobe.Geometry.LineString([new GeoGlobe.Geometry.Point(20,118),new GeoGlobe.Geometry.Point(20.8,118.8)])。
	 *  @param {Number} distance  - 缓冲半径。它是指指定线的距离范围。服务利用这个属性可以对线进行缓冲区分析得到一个面，再用面去进行查询。
 	 *		distance的取值范围：大于等于零。
	 * 		例如：如果距离是5，单位是米，那么服务内部会将这个线以5米为半径对其进行缓冲区分析得到成一个面，再使用面做查询。
	 *  @param {String} unit  -  单位  值为"m"或degree。
	 *  @param {Function} successFn  - 请求成功的回调函数。
     *  @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * @example
     * (code)
     *   //距离
	 *	 var distance = 50000000;
	 *	 //单位
     *	 var unit = "m";
     *   //线要素
	 *	 var queryPath = new GeoGlobe.Geometry.LineString([
     *         new GeoGlobe.Geometry.Point(110,35),
     *         new GeoGlobe.Geometry.Point(110,36)
     *    ]);
     * 	 wfsQueryObj.pathQuery(queryPath, distance, unit, successFn,failFn);
     * (end)
	 */
    pathQuery: function(path,distance,unit,successFn,failFn){
        distance = distance || 0;
        unit = unit || "degree";
        var filter = new GeoGlobe.Filter.Spatial({
            type:GeoGlobe.Filter.Spatial.DWITHIN,
            property: this.geometryName, 
            distance: distance,
            distanceUnits: unit,
            value: path
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * 面查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.Geometry.Polygon} polygon  - 面要素。
	 * 说明：当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，本查询的polygon参数需要设置为纬度，经度顺序。
     * 		举例说明：
     * 		以一个面要素为例：
     * 		new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(177.76672363281,37.655639648436),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(177.8884299300619,38.21858951787163)
     *       ])
     * 		在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该面要素应写成
     * 		new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(37.655639648436,177.76672363281),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619),
     *       new GeoGlobe.Geometry.Point(38.21858951787163,177.8884299300619)
     *       ])
	 * 
	 * @param {Boolean} isContain  - 是包含还是相交。
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * @example
     * (code)
     * 	 var isContain = false;
	 *	 var queryPolygon = new GeoGlobe.Geometry.Polygon([
     *   	 new GeoGlobe.Geometry.LinearRing([
     *       new GeoGlobe.Geometry.Point(77.76672363281,37.655639648436),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163),
     *       new GeoGlobe.Geometry.Point(77.8884299300619,38.21858951787163)
     *       ])                
     *   ]);
     * 	 wfsQueryObj.polygonQuery(queryPolygon, isContain, successFn,failFn);
     * (end)
	 */
    polygonQuery: function(polygon,isContain,successFn,failFn){
        var filterType = isContain ? GeoGlobe.Filter.Spatial.CONTAINS : 
                                     GeoGlobe.Filter.Spatial.INTERSECTS;
        var filter = new GeoGlobe.Filter.Spatial({
            type: filterType,
            property: this.geometryName, 
            value: polygon
        });
        this.query(filter,successFn,failFn);
    },
    
    /**
	 * 范围查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {GeoGlobe.LngLatBounds} bbox  - 范围。
	 * 说明：
	 * 1.当且仅当以OGC标准发布服务，并且服务版本为1.1.0时，参数filter中的
	 * 所有几何参数都需要改为纬度，经度的顺序。举例说明：
	 * 以矩形范围为例：
	 * new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 在以OGC标准发布服务，并且服务版本为1.1.0的环境下做本查询时，该矩形范围应写成
	 * new GeoGlobe.LngLatBounds([-90,-180],[90,180]);
	 * 
	 * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
	 * @example
	 * (code)
	 *   //查询范围
		 var queryBBOX = new GeoGlobe.LngLatBounds([-180,-90],[180,90]);
	 * 	 wfsQueryObj.bboxQuery(queryBBOX, successFn,failFn);
	 * (end)
	 */
    bboxQuery: function(bbox,successFn,failFn){
        var filter = new GeoGlobe.Filter.Spatial({
            type: GeoGlobe.Filter.Spatial.BBOX,
            property: this.geometryName,            
		    value: bbox
        });
        this.query(filter,successFn,failFn);
    },
    
	/**
	 * 属性查询。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {String}  type  - 比较类型。
	 * @param {String} property  -  属性名。
	 * @param {Number} or {String} value  -  属性值。
	 * @param {Object} options  - 可选参数。
	 * @param {Number} or {String}  lowerBoundary  - 值小的边界。
	 * @param {Number} or {String} upperBoundary  -  值大的边界。
	 * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn - 请求失败的回调函数，如果指定该参数为一个非函数对象则默认值为本实例的failFn属性。
     * 
     * @example
     * (code)
     *   var type = GeoGlobe.Filter.Comparison.LIKE;
	 *		var property = "label";
	 *		var value = "*";
	 *		wfsQueryObj.attributeQuery(type,property,value,{
	 *			matchCase : true
	 *	 },successFn,failFn);
     * (end)
	 * 
	 */
    attributeQuery: function(type, property, value, options, successFn,failFn){
        
        var matchCase = options && options.matchCase;
        var lowerBoundary = options ? options.lowerBoundary : null;
        var upperBoundary = options ? options.upperBoundary : null;
        
        var filter = new GeoGlobe.Filter.Comparison({
            type: type,
            property: property,            
		    value: value,
            matchCase: matchCase,
            lowerBoundary: lowerBoundary,
            upperBoundary: upperBoundary
        });
        this.query(filter,successFn,failFn);
    },

	statisticsQuery: function(filter,successFn,failFn){
		this.protocol = new GeoGlobe.Protocol.WFS({
			readFormat: this.format,
			formatOptions: this.formatOptions,
			propertyNames: this.propertyNames,
            resultType: "statistics",
			maxFeatures: this.maxFeatures,
            featurePrefix:this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
			version: this.version,
			geometryName : this.geometryName,
            featureType: this.featureType,
			time: this.time,//多时态，时间格式：2015-5-19 12:12:01
			userecent: this.userecent//是否追溯
        });

        //兼容老接口，如果未指定成功或失败回调函数，则使用successFn或failFn属性
        var queryFilter = filter || this.filter;
        var querySuccessFn = successFn || this.successFn;
        var queryFailFn = failFn || this.failFn;

		var callback = GeoGlobe.Function.bind(function(result){
			//显示查询失败信息
			if(!result.success()){
				queryFailFn();
				return;
			}
			try{
				/*var object = null;
				var x2j = new GeoGlobe.Util.Format.XML2JSON();			
				var text = result.priv.responseText;
				if (null != text && "" != text && undefined != text) {			
					object = x2j.read(result.priv.responseText);
				} else {
					var xmlParser = new GeoGlobe.Format.XML();
					text = xmlParser.write(result.priv.responseXML);
					object = x2j.read(text);
				}*/
				var doc = result.priv.responseXML;
				var StatisticsResult = this._analysis_StatisticsResult(doc);
			}catch(e) {
				querySuccessFn(result.priv.responseText);
				return;
			}
			querySuccessFn(StatisticsResult);
		},this);

		this.response = this.protocol.read({
			sortBy: this.sortBy,
			groupBy: this.groupBy,
			filter: queryFilter,
			callback: callback
		});
	},

	/**
	 *  解析返回的结果
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param 	doc
	 * @private
	 */
	_analysis_StatisticsResult: function(doc) {
		var StatisticsResult = {};
		var featureCollection = doc.documentElement;
		//var results = featureCollection.firstElementChild;
        var results = featureCollection.firstChild;
		var layerArray = results.childNodes;
		if(0 < layerArray.length){
			StatisticsResult.layers = this._analysis_StatisticsResult_results(layerArray);
		}
		return StatisticsResult;
	},

	/**
	 * 统计结果第二级结构
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param 	layerArray
	 * @private
	 */
	_analysis_StatisticsResult_results: function(layerArray) {
		var layers = [];
		for(var i = 0; i < layerArray.length; i++) {
			var layer = {};
			var results = [];
			var resultArray = layerArray[i].childNodes;
			for(var j = 0; j < resultArray.length; j++) {
				var result = {};
				result.layerName = resultArray[j].parentNode.nodeName;
                //根据浏览器类型进入不同的方法
                if(navigator.appName=="Microsoft Internet Explorer"){
                    //IE 浏览器
                    result.result = this._analysis_StatisticsResult_results_result_IE(resultArray[j]);
                }else{
                    //谷歌浏览器
                    result.result = this._analysis_StatisticsResult_results_result_google(resultArray[j]);
                }
				results.push(result);
			}
			layer.results = results;
			layers.push(layer);
		}
		return layers;
	},

	/**
	 * 统计结果第三级结构
	 * IE浏览器
     * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param 	result
	 * @private
	 */
	_analysis_StatisticsResult_results_result_IE: function(result) {
		var object = {};
		var i = 0;
		var nodeName = result.childNodes[0].nodeName;
		if("Key" == nodeName) {
			object.Key = result.childNodes[0].text;
			i = 1;
		}
		var names = [];
		var values = [];
		for(; i < result.childNodes.length; i++) {
			var name = {};
			var value = {};
			name.name = result.childNodes[i].getAttribute("name");
			value.Value = result.childNodes[i].text;
			names.push(name);
			values.push(value);
		}
        object.name = names;
		object.values = values;
		return object;
	},

    /**
     * 统计结果第三级结构
     * 谷歌浏览器
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     * @param 	result
	 * @private
     */
    _analysis_StatisticsResult_results_result_google: function(result) {
        var object = {};
        var i = 0;
        var nodeName = result.childNodes[0].nodeName;
        if("Key" == nodeName) {
            object.Key = result.childNodes[0].innerHTML;
            i = 1;
        }
        var names = [];
        var values = [];
        for(; i < result.childNodes.length; i++) {
            var name = {};
            var value = {};
            name.name = result.childNodes[i].getAttribute("name");
            value.Value = result.childNodes[i].innerHTML;
            names.push(name);
            values.push(value);
        }
        object.name = names;
        object.values = values;
        return object;
    },

    /**
     * 查询成功后的回调函数，用户可以自定义此方法。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {Array(GeoGlobe.Feature)} features - 结果要素数组。
     */
	successFn: function(features){
        
    },

    /**
     * WFS查询失败响应方法，默认提示"对不起,查询失败,请查询服务是否正常"，用户可以根据需要覆盖此方法。
     * @memberof GeoGlobe.Query.WFSQuery.prototype
     */
    failFn: function(){
    	alert("对不起,查询失败,请查询服务是否正常。");
    },
    
    //私有,按图层类型分离要素
    _separateFeatures: function(features){
        var result = {};
        for(var i=0; i<features.length; i++){
            var f = features[i];
            var featureType;
            
            //如果是经GML2解析器则判断gml属性中的featureType，如果是GML3则判断type
            if (f.gml) {
                featureType = f.gml.featureType;
            }
            else {
                featureType = f.type;
            }
            
            if(!result[featureType]){
                result[featureType] = [];
            }
            result[featureType].push(f);
        }
        return result;
    },
	
    /**
     * 设置时间。时间格式：2015-5-19 12:12:01
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
     *
	 * @param {String}  time  - 结果要素数组。
     */
	setTime: function(time){
		this.time = time;
	},
	
    /**
     *  设置是否追溯。
	 * @memberof GeoGlobe.Query.WFSQuery.prototype
	 * @param {Boolean} userecent - 结果要素数组。
     */
	setUserecent: function(userecent){
		this.userecent = userecent;
	},
    	
	CLASS_NAME: "GeoGlobe.Query.WFSQuery"
});

GeoGlobe.Query.WFSQuery.reverseGeometryXY = function(geometry) {
	
	var geometryTypes = {
        "GeoGlobe.Geometry.Point": "Point",
        "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
        "GeoGlobe.Geometry.LineString": "LineString",
        "GeoGlobe.Geometry.MultiLineString": "MultiLineString",
        "GeoGlobe.Geometry.Polygon": "Polygon",
        "GeoGlobe.Geometry.MultiPolygon": "MultiPolygon",
        "GeoGlobe.Geometry.Collection": "GeometryCollection"
    };
	var types = {
		"Point": function(geometry,types) {
			var pointx = geometry.x;
			var pointy = geometry.y;
			var point = geometry.clone(geometry);
			point.x = pointy;
			point.y = pointx;
			return point;
		},
		"LineString": function(geometry,types) {
			var lineString = geometry.clone(geometry);
			for(var i = 0; i < lineString.components.length; i++) {
				var point = types["Point"](lineString.components[i]);
				lineString.components[i] = point;
			}
			return lineString;
		},
		"Polygon": function(geometry,types) {
			var polygon = geometry.clone(geometry);
			for(var i = 0; i < polygon.components.length; i++) {
				for(var j = 0; j <polygon.components[i].components.length - 1; j++) {
					var point = types["Point"](polygon.components[i].components[j]);
					polygon.components[i].components[j] = point;
				}
			}
			return polygon;
		}
	}
	var ageometry = types[geometryTypes[geometry.CLASS_NAME]](geometry,types);
	return ageometry;
};

GeoGlobe.Format.WFSHits = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {

    wfsns: "http://www.opengis.net/wfs",
    
    featureCollection: "FeatureCollection",
    
    read: function(data){
        if (typeof data == "string") {
            data = GeoGlobe.Format.XML.prototype.read.apply(this, [data]);
        }
        var featureCollectionNodes = data.documentElement;
        var numberOfFeatures = parseInt(featureCollectionNodes.getAttribute("numberOfFeatures"));
        return {
            numberOfFeatures: numberOfFeatures
        }
    }
	
});/**
* @class GeoGlobe.Query.GeoCodingQuery
* @classdesc 地址匹配查询类。默认版本是1.0.0。
*
 * @example
 * (code)
 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
 *			version:"1.1.0"
 *		});
 * (end)
 */
GeoGlobe.Query.GeoCodingQuery = function(url, options) {
    options = GeoGlobe.Util.applyDefaults(
        options, GeoGlobe.Query.GeoCodingQuery.DEFAULTS
    );
    var cls = GeoGlobe.Query.GeoCodingQuery["v"+options.version.replace(/\./g, "_")];
    if(!cls) {
        throw "不支持的地址匹配服务版本: " + options.version;
    }
    return new cls(url, options);
};

GeoGlobe.Query.GeoCodingQuery.DEFAULTS = {
    "version": "1.0.0"
};
/**
 * @class GeoGlobe.Query.GeoCodingQuery.v1
 * @classdesc 地址匹配服务查询接口的抽象类,抽象类不能实例化。
 *
 * @example
 * (code)
 *      //根据范围和地址进行查询：
 * 		var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.42.76:7021/GeoCoding/geocoding");
 * 		coding.getCategoryByCode(1012001008000000,
 * 		function(GeoCoding){},function(){});
 * (end)
 */
GeoGlobe.Query.GeoCodingQuery.v1 = GeoGlobe.Class4OL({
	
	/**
	 * 服务版本，默认值是"1.0.0"。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 */
	version:"1.0.0",
	
	/**
     * 服务地址。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
     *  @type {String}
     */
	url: null,
	
	/**
     * GeoGlobe.Query.GeoCodingQuery.v1类的构造函数。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
     * @param {String} url  - 服务地址。
     * @param {Object} options   - 相关属性的设置项，可选。
     *
     * 服务版本。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
     * @type {String}
     */
	initialize: function(url, options){
		this.url = url;
        GeoGlobe.Util.extend(this,options);
		this.format = new GeoGlobe.Format.JSON();
	},
	
	/**
	 * 获取公共的参数
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param options
	 * @private
	 */
	getCommonParams: function(options) {
		var params = {
			request: "GetCategory",
			service:"GeoCoding",
			version:this.version,
			output:"json"
		};
        GeoGlobe.Util.extend(params,options);
		return params;
	},
	
	/**
	 * 根据类别名称查询类别及子类别。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {String} name   - 类别名称。
	 * @param {Function} successFn   - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * @param {Function} failFn   - 请求失败的回调函数。
	 */
	getCategoryByName:function(name,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof name === "string" && name.length !== 0) {
			params.categoryName = name;
		}
		var failFn = failFn || this.failFn;
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},

	/**
	 * 根据类别编码查询类别及子类别。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {Number} code  - 类别编码。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * @param {Function}  failFn  - 请求失败的回调函数。
	 *
	 */
	getCategoryByCode: function(code,successFn,failFn) {
		var params = this.getCommonParams();
		if(typeof code === "number") {
			params.categoryCode = code;
		}
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * 查询所有类别信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {Function} successFn   - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：GetCategory.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 */
	getAllCategory: function(successFn,failFn) {
		var params = this.getCommonParams();
        GeoGlobe.Function.bind(this._requestCategory,this)(params,successFn,failFn);
	},
	
	/**
	 * 执行get请求操作
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param   params
	 * @param   successFn
	 * @param   failFn
	 * @private
	 */
	_requestCategory:function(params,successFn,failFn) {
		var failFn = failFn || this.failFn;
        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var category = this.format.read(result.responseText);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(category);
		},failFn);
	},
	
	/**
	 * 解析返回的结果，getCoder接口查询结果第一级结构
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param json
	 * @private
	 */
	_analysis_GeoCodeResult: function(json) {
		var queryResult = {
			status:json.status
		};
		switch(json.status) {
			case "OK":
				var results = json.results;
				if(results) {
					queryResult.results = this._analysis_GeoCodeResult_results(results);
				}
			break;
			case "INVALID_REQUEST":
				
			break;
			case "NO_RESULTS":
				
			break;
			case "UNKNOWN_ERROR":
				
			break;
			default:
				queryResult = {
					requestKeyWord:json.requestKeyWord,
					count:json.count,
					statisticsLevel:json.statisticsLevel,
					statisticsLevelName:json.statisticsLevelName
				};

				if(json && json.count > 0){
					var results = json.results;
					if(results) {
						queryResult.results = this._analysis_GeoCodeResult_statistics(results);
					}
				}
			break;
		}
		return queryResult;
	},
	
	/**
	 * getCoder接口查询结果第二级结构
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param  results
	 * @private
	 */
	_analysis_GeoCodeResult_results: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(GeoGlobe.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				result.requestKeyWord = results[i].requestKeyWord;
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}
				//匹配结果总数
				result.count = results[i].count;
				if(results[i].result) {
					result.result = this._analysis_GeoCodeResult_results_result(results[i].result);
				}
				aresults.push(result);
			}
			return aresults;
		}
	},

	/**
	 * getCoder接口按行政区划统计结果值第二级结构
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param  results
	 * @private
	 */
	_analysis_GeoCodeResult_statistics: function(results) {
		var aresults = [];
		//如果存在results节点，那么它就是一个数组
		if(GeoGlobe.Util.isArray(results)) {
			for(var i = 0,j = results.length; i < j;i++) {
				var result = {};
				if(results[i].errorCorrectionTips) {
					result.errorCorrectionTips = results[i].errorCorrectionTips;
				}

				if(results[i]) {
					result.name = results[i].name;
					result.value = results[i].value;
					result.remark = results[i].remark;
				}
				aresults.push(result);
			}
			return aresults;
		}
	},
	
	/**
	 * getCoder接口查询结果第三级结构
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param   result
	 * @private
	 */
	_analysis_GeoCodeResult_results_result: function(result) {
		var addresss = [];
		for(var i = 0,j = result.length; i < j;i++) {
			var address = {};
            var street_path = {};
			//匹配结果的类型
			address.resultType = result[i].resultType;
			//匹配地址是否为精确地址
			address.precise = result[i].precise;
			//该条匹配结果是否为摘要信息
			address.isBrief = result[i].isBrief;
			//匹配结果与请求关键字的匹配度，值域为1到100，值越大匹配度就越高
			address.score = result[i].score;
            if(result[i].addressComponent.street){
                street_path = result[i].addressComponent.street;
            }
			if(address.isBrief == false) {
				address.addressComponent = this._analysis_GeoCodeResult_results_result_address(result[i].addressComponent,address.resultType);
			}
			address.poiArray = this._analysispoiArray(result[i].poiArray);
			if(result[i].location) {
				address.location = result[i].location;
			}
			//TODO:referenceAddressArray
			if(address.precise == 0) {
				address.referenceAddressArray = result[i].referenceAddressArray;
			}
            if(street_path){
                address.street_path = street_path;
            }
			addresss.push(address);
		}
		return addresss;
	},
	
	/**
	 * getCoder接口查询结果第四级结构，当前匹配结果的地址详细信息
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param addressComponent
	 * @param 	resultType
	 * @private
	 */
	_analysis_GeoCodeResult_results_result_address:function(addressComponent,resultType) {
		var addressC = {
			country: addressComponent.country
		};
		//行政区划的第二级-省、直辖市、自治区
		if(addressComponent.province) {
			addressC.province = addressComponent.province;
		}
		//行政区划第三级-市
		if(addressComponent.city) {
			addressC.city = addressComponent.city;
		}
		//行政区划第四级-区或县
		if(addressComponent.district) {
			addressC.district = addressComponent.district;
		}
		//行政区划第五级-乡镇
		if(addressComponent.town) {
			addressC.town = addressComponent.town;
		}
		if(addressComponent.street) {
			addressC.street = {
				name:addressComponent.street.name
			};
			
			if(resultType === "street") {
				//需要增加对线的json串的解析
				if(addressComponent.street.geometry) {
					//var sgeometry = addressComponent.street.geometry;
					var sgeometry = this.format.read(addressComponent.street.geometry);
					var streetGeometry = null;
					if(sgeometry["paths"]) {
						//这个需要做测试，这里的几何信息一般来说是线，不过也有可能不是线
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}else if(sgeometry["rings"]){
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}else if(sgeometry["x"] && sgeometry["y"]){
						streetGeometry = this._getGeometry(sgeometry);
						addressC.street.geometry = streetGeometry;
					}
				}
			}
		}
		if(addressComponent.streetNumber) {
			addressC.streetNumber = addressComponent.streetNumber;
		}
		if(addressComponent.buildingNumber) {
			addressC.buildingNumber = addressComponent.buildingNumber;
		}
		if(resultType === "adminArea") {
			//当前匹配最小级行政区划的空间信息,本属性需要被转换成GeoGlobe.Geometry类型
			if(addressComponent.geometry) {
				//var geometry = addressComponent.geometry;
				var geometry = this.format.read(addressComponent.geometry);
				var areaGeometry = null;
				//如果它是面，我们解析它
				if(geometry["rings"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(geometry["paths"]) {
					areaGeometry = this._getGeometry(geometry);
					addressC.geometry = areaGeometry;
				}else if(typeof geometry["x"] === "number" && typeof geometry["y"] === "number") {
					addressC.geometry = this._getGeometry(geometry);
				}
			}
			//当前匹配最小级行政区划下属的其它行政区划名称，多个以逗号隔开
			if(addressComponent.subordinate) {
				addressC.subordinate = addressComponent.subordinate;
			}
			//行政区的邮政编码
			if(addressComponent.zipCode) {
				addressC.zipCode = addressComponent.zipCode;
			}
			//电话长途区划
			if(addressComponent.callingCode) {
				addressC.callingCode = addressComponent.callingCode;
			}
		}
		return addressC;
	},
	
	/**
	 * result节点的儿子节点
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param poiArray
	 * @private
	 */
	_analysispoiArray: function(poiArray) {
		var pointFeatures = [];
		for(var i = 0,j = poiArray.length; i < j;i++) {
			var point = {};
			for(var pro in poiArray[i]) {
				point[pro] = poiArray[i][pro];
			}
			if("" != point.geometry && undefined != point.geometry){
				var geometry = this.format.read(point.geometry);
				point.geometry = this._getGeometry(geometry);
			}
			pointFeatures.push(point);
		}
		return pointFeatures;
	},
	
	/**
	 * result节点的儿子节点
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param location
	 * @private
	 */
	_analysisLocation:function(location) {
		
	},
	
	/**
	 * 得到GeoGlobe几何对象
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {Object} geometry
	 * @private
	 */
	_getGeometry: function(geometry) {
		for(var pro in geometry) {
			//服务组封装的地图服务返回的geometry节点中包含spatialReference,加了这个判断，初步估计服务组封装的查询服务的返回结果结构有问题
			if("spatialReference" == pro) {
				return;
			}
			if(geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
				var geometry = new GeoGlobe.Geometry.Point(geometry["x"],geometry["y"]);
			}else if(geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("ymin")&& geometry.hasOwnProperty("xmax")&& geometry.hasOwnProperty("ymax"))
			{
				var geometry = new GeoGlobe.Bounds(geometry.xmin,geometry.ymin,geometry.xmax,geometry.ymax).toGeometry();
				//需要增加多点类型
			}else {
				var geometry = this._geometryType[pro](geometry[pro]);
			}
			return geometry;
		}
	},
	
	/**
	 * 将几何信息的json表示转换成
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
	 * @param {Object} geometry
	 * @private
	 */	
	_geometryType: {
		"points": function(geometry) {
			var points = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var point = new GeoGlobe.Geometry.Point(geometry[i][0], geometry[i][1]);
					points.push(point);
				}
			}
			return points;
		},
		"paths": function(geometry) {
			var lines = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new GeoGlobe.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new GeoGlobe.Geometry.LineString(ps);
					lines.push(line);
				}
				var paths = new GeoGlobe.Geometry.MultiLineString(lines);
			}
			return paths;
		},
		"rings": function(geometry) {
			var lines = [];
			if(GeoGlobe.Util.isArray(geometry)) {
				for(var i = 0, j = geometry.length; i < j; i++) {
					var ps = [];
					for(var p = 0,points = geometry[i].length; p < points;p++) {
						ps.push(new GeoGlobe.Geometry.Point(geometry[i][p][0],geometry[i][p][1]));
					}
					var line = new GeoGlobe.Geometry.LinearRing(ps);
					lines.push(line);
				}
				var Polygon = new GeoGlobe.Geometry.Polygon(lines);
			}
			return Polygon;
		}
	},
	
	/**
     * 请求失败的回调函数，可以用自定义函数覆盖。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1.prototype
     *  @type {Function}
     */
	failFn: function(error) {
		if(typeof error == "string") {
			alert(error);
		}
		alert("对不起，查询请求失败！请检查地址匹配服务是否正常运行。\n" + 
				"当前服务地址为：" + this.url);
	},

	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1"
});
/**
 * @class GeoGlobe.Query.GeoCodingQuery.v1_0_0
 * @classdesc 地址匹配服务查询接口1.0.0版本，继承GeoGlobe.Query.GeoCodingQuery.v1，本类可以实现如下功能：
 *
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 */
GeoGlobe.Query.GeoCodingQuery.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Query.GeoCodingQuery.v1, {
	
	/**
     * GeoGlobe.Query.GeoCodingQuery.v1_0_0类的构造函数。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
     * @param  {String} url  - 服务地址。
     * @param  {Object} options  - 相关属性的设置项，可选。
     *
     * 服务版本。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
     *  @type {String}
     */
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String | Array(String)} address  - (必选) 查询的地址名称集合。
	 * @param {Integer} categoryCode  - (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.LngLatBounds | GeoGlobe.Geometry.Polygon} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {Boolean} fuzzyMatch  - (可选) 是否模糊匹配，true表示精确匹配，false表示模糊匹配。默认值为false。
	 * @param {String} resultType   - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) ：查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer}  startPosition  - (可选) ： 从第几条开始查询，缺省值是1。
	 * 无customWeight参数 ，1.0.0版本当前只按匹配度排序。
	 * 
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(typeof options.address === "string") {
			params.address = options.address;
		}else if(GeoGlobe.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.address = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if(options.extent instanceof mapboxgl.LngLatBounds) {
			params.bbox = options.extent.toBBOX(null,true);
		} else if(options.extent instanceof GeoGlobe.Geometry.Polygon) {
			//params.bbox = options.extent.getComponentsString();
			var polygon = options.extent;
			var strings = [];
			for(var i=0, len=polygon.components.length; i<len; i++) {
				var items = polygon.components[i].components;
				for(var j = 0; j < items.length; j++){
					strings.push(items[j].toShortString());
				}
			}
			params.bbox = strings.join(",");
		}
		if(typeof options.fuzzyMatch === "boolean") {
			params.fuzzyMatch = options.fuzzyMatch;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}

        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				//var GeoCodingResult = this._analysis_GeoCodeResult(json);
                if(params.resultType == "result"){
                    var GeoCodingResult = this._parseQueryResultToFeature(json);
                }else{
                    var GeoCodingResult = this._analysis_GeoCodeResult(json);
                }
                //var res = this._parseQueryResultToFeature_v_0(GeoCodingResult);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
	},

	/**
	 * 根据位置查找匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat   - (必选) 位置。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} resultType  - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  - (可选) 从第几条开始查询，缺省值是1。
	 * 
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.0.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		if(options.lonlat) {
			params.latlng = options.lonlat.lat+","+options.lonlat.lng;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
        GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				//var GeoCodingResult = this._analysis_GeoCodeResult(json);
                if(params.resultType == "result"){
                    var GeoCodingResult = this._parseQueryResultToFeature(json);
                }else{
                    var GeoCodingResult = this._analysis_GeoCodeResult(json);
                }
                //var res = this._parseQueryResultToFeature_v_0(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult,json);
		},this.failFn);
	},
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * @param {Function} failFn   - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String| Array(String)} address  - (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param {Integer} categoryCode  - (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.LngLatBounds} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {String} resultType  - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  - (可选) 从第几条开始查询，缺省值是1。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocations({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 		},function() {});
	 * (end)
	 */
	getLocations: function(options, successFn, failFn){
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn)
	},
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息-分页查询。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Featur } – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String| Array(String)} address  - (可选) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param categoryCode {Integer}  - (可选) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.LngLatBounds} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocationsByPage({
	 *			extent:GeoGlobe.LngLatBounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 		},function() {});
	 * (end)
	 */
	getLocationsByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * 根据位置查找匹配的地址信息。
	 *  @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature } – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat  - (必选) 位置。
	 * @param {Number} tolerance   -  (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String}resultType  -  (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  - (可选) 从第几条开始查询，缺省值是1。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddresses: function(options, successFn, failFn){
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn);
	},
	
	/**
	 * 根据位置查找匹配的地址信息-分页查询。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat  - (必选) 位置。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddressesByPage({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddressesByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * 根据地址/坐标匹配查询结果解析为包含状态和feature数组的对象
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
	 * @param {Object} params  - 键值对
	 *
	 * @returns {Object}  - 包含状态和feature数组的对象
	 * @private
	 */
	_parseQueryResultToFeature: function(queryResult){
		var features = [];
		if(queryResult.status == "OK"){
			if(queryResult.results){
				for(var i = 0; i < queryResult.results.length; i++){
					var result = queryResult.results[i].result;
					if(result){
						for(var j = 0; j < result.length; j++){
							var attribute = {};
							var geometry = null;
							attribute.requestKeyWord = queryResult.results[i].requestKeyWord;
							
							if(GeoGlobe.Util.isArray(result[j].poiArray)){
								for(var k = 0; k < result[j].poiArray.length; k++){
									attribute.CONTINENT = result[j].poiArray[k].CONTINENT;
									attribute.GBCODE = result[j].poiArray[k].GBCODE;
									attribute.STANDARDNAME = result[j].poiArray[k].STANDARDNAME;
									attribute.name = result[j].poiArray[k].name;
								}
							}
							if(result[j].addressComponent){
								var addressComponent = result[j].addressComponent;
								attribute.address = this._getAddress(addressComponent, attribute.name);
								attribute.country = result[j].addressComponent.country;
								attribute.province = result[j].addressComponent.province;
								attribute.city = result[j].addressComponent.city;
								attribute.district = result[j].addressComponent.district;
								if(result[j].addressComponent.street){
									attribute.streetName = result[j].addressComponent.street.name;
                                    attribute.streetgeometry = result[j].addressComponent.street.geometry;
								}else{
									attribute.streetName = "";
								}
								attribute.streetNumber = result[j].addressComponent.streetNumber;
							}
							if(result[j].location){
								if(result[j].location.lng){
									attribute.lng = result[j].location.lng;
								}
								if(result[j].location.lat){
									attribute.lat = result[j].location.lat;
								}
								geometry = new GeoGlobe.Geometry.Point(result[j].location.lng, result[j].location.lat);
							}
							
							attribute.isBrief = result[j].isBrief;
							attribute.precise = result[j].precise;
							attribute.resultType = result[j].resultType;
							attribute.score = result[j].score;
							//创建feature
							var feature = new GeoGlobe.Feature(geometry,attribute);
							features.push(feature);
						}
					}
				}
			}
		}
        var gjformat = new GeoGlobe.Format.GeoJSON();
        var geojsonStr = gjformat.write(features);
        var jsonformat = new GeoGlobe.Format.JSON;
        var geojsonFeature = jsonformat.read(geojsonStr);
		return {
			status: queryResult.status,
			features: features,
            geojsonFeatures:geojsonFeature
		};
	},
	
	/**
     * 拼装详细地址。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_0_0.prototype
     * @param {Object} addressComponent  - 地址对象。
     * @param {String}  name  - 名称。
     *
     * @returns {String}  - 详细地址。
	 * @private
     */
	_getAddress: function(addressComponent, name){
		var address = "";
		if(addressComponent["country"]){
			address += addressComponent["country"];
		}
		if(addressComponent["province"]){
			address += addressComponent["province"];
		}
		if(addressComponent["city"]){
			address += addressComponent["city"];
		}
		if(addressComponent["district"]){
			address += addressComponent["district"];
		}
		if(addressComponent["street"]){
			if(addressComponent["street"]["name"]){
				address += addressComponent["street"]["name"];
			}
			/*if(addressComponent["street"]["streetNumber"]){
				address += addressComponent["street"]["streetNumber"]+"号";//门牌号
			}*/
			if(addressComponent["streetNumber"]){
				address += addressComponent["streetNumber"]+"号";//门牌号
			}
		}
		if(name){ //名称
			address += name;
		}
		return address
	},
	
	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1_0_0"
});
/**
 * @class GeoGlobe.Query.GeoCodingQuery.v1_1_0
 * @classdesc 地址匹配服务查询接口1.1.0版本，继承GeoGlobe.Query.GeoCodingQuery.v1类，本类可以实现如下功能：
 *
 * > 1.根据地址(例如：湖北省武汉市江夏区武大园一路9号)获取地理坐标(例如纬度29.58123 和经度113.41321)或者执行反向转换。
 * > 2.根据地理坐标获取地址信息。
 * > 3.可以根据地名地址分类名称或者地名地址分类编码获取地名地址分类信息。
 * > 4.可以根据多个地址信息查询到地理坐标信息。
 * > 5.可以根据多个地理坐标值获取地址信息。
 * > 说明:本类提供的五个接口的成功回调的返回内容存在两种情况：第一：是返回json对象，第二：是返回xml串。如果返回xml串，
 * > 表示服务器内部发生错误或者客户端解析服务返回的结果时，发生了错误。
 *
 */
GeoGlobe.Query.GeoCodingQuery.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Query.GeoCodingQuery.v1, {
	
	/**
	 * 数据请求方式，默认值是"get"。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 */
	method: "get",
	
	/**
     * GeoGlobe.Query.GeoCodingQuery.v1_1_0类的构造函数。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 相关属性的设置项，可选。
     * 
     * options请求参数属性可为:
     * 服务版本。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
     */
	initialize: function(url, options){
        GeoGlobe.Util.extend(this,options);
		this.filterFormat = new GeoGlobe.Format.Filter();
        GeoGlobe.Query.GeoCodingQuery.v1.prototype.initialize.apply(this, arguments);
	},
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String | Array(String)} address  - (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param {Integer} categoryCode  - (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.Bounds | GeoGlobe.Geometry.Polygon} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {String}  resultType  - (可选) 返回匹配结果的类型。 可供选择的值：(1)hits：返回匹配结果的总数；(2)result：返回匹配结果；(3)statistics：统计结果值。缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  -  (可选) 从第几条开始查询，缺省值是1。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  -(可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @param {Integer} statisticsLevel  - (可选) 统计级别。可供选择的值：1(省级)；2(市(县)级)；3(区级)。默认值为2。
	 * @param {Boolean} customWeight  - (可选) 是否启动自定义权重排序，缺省为true。如设置为false，则按匹配度排序。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.addressesToLocations({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {},function() {});
	 * (end)
	 */
	addressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = false;
		if(typeof options.address === "string") {
			params.keyword = options.address;
		}
		if(typeof options.categoryCode === "number") {
			params.categoryCode  = options.categoryCode;
		}
		if((options.address == undefined || options.address == null) && 
				(options.categoryCode == undefined || options.categoryCode == null)) {
			throw "address是必选参数！";
		}
		if(options.extent instanceof mapboxgl.LngLatBounds) {
			params.bbox = options.extent.toBBOX(null,true);
		} else if(options.extent instanceof GeoGlobe.Geometry.Polygon) {
			//params.bbox = options.extent.getComponentsString();
			var polygon = options.extent;
			var strings = [];
			for(var i=0, len=polygon.components.length; i<len; i++) {
				var items = polygon.components[i].components;
				for(var j = 0; j < items.length; j++){
					strings.push(items[j].toShortString());
				}
			}
			params.bbox = strings.join(",");
		}
		if(options.filter instanceof GeoGlobe.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = GeoGlobe.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(options.resultType == "statistics") {
			params.statisticsLevel = options.statisticsLevel;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.semanticAnalysis  === "boolean") {
			params.semanticAnalysis = options.semanticAnalysis;
		}
		if(typeof options.customWeight  === "boolean") {
			params.customWeight = options.customWeight;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		
	},
	
	/**
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object}	params  - 键值对
	 * @param {Function}  successFn  - 成功回调
	 * @param {Function} failFn  - 失败回调
	 * @private
	 */
	_getCodingRequest: function(params,successFn,failFn) {
		if(this.method == "get") {
			GeoGlobe.loadURL(this.url,params,this,function(result) {
				try{
					var json = this.format.read(result.responseText);
                    //_parseQueryResultToFeature
                    if(params.resultType == "result"){
                        var GeoCodingResult = this._parseQueryResultToFeature(json);
                    }else{
                        var GeoCodingResult = this._analysis_GeoCodeResult(json);
                    }

				}catch(e) {
					successFn(result.responseText);
					return;
				}
				successFn(GeoCodingResult);
			},this.failFn);
		}else {
			var paramsStr = GeoGlobe.Util.getParameterString(params);
            GeoGlobe.Request.POST({
	            url: this.url,
	            data: paramsStr,
	            success: function(result) {
					try{
						var json = this.format.read(result.responseText);
						var GeoCodingResult = this._analysis_GeoCodeResult(json);
					}catch(e) {
						successFn(result.responseText);
						return;
					}
					successFn(GeoCodingResult);
				},
	            failure: this.failFn,
	            scope: this
	        });
		}
	},
	
	/**
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object}	params  - 键值对
	 * @param	options
	 * @private
	 */
	_setGeoCoderCommonProperty: function(params,options) {
		if(typeof options.sortFields  === "string") {
			params.sortFields = options.sortFields;
		}
		if(typeof options.scoreFilter  === "string") {
			params.scoreFilter = options.scoreFilter;
		}
	},
	
	/**
	 * 根据位置查找匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat - (必选) 位置。
	 * @param {Number}  tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} resultType  - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition - (可选) 从第几条开始查询，缺省值是1。
	 * @param {String} sortFields - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * 
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.locationToAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *
	 *		},function() {});
	 * (end)
	 */
	locationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "GeoCoder"
		});
		params.reverseMatch = true;
		if(options.lonlat) {
			params.keyword = options.lonlat.lat+","+options.lonlat.lng;
		}else  {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.resultType  === "string") {
			params.resultType = options.resultType;
		}
		if(options.resultType == "statistics") {
			params.statisticsLevel = options.statisticsLevel;
		}
		if(typeof options.maxCount  === "number") {
			params.maxCount = options.maxCount;
		}
		if(typeof options.startPosition  === "number") {
			params.startPosition = options.startPosition;
		}
		if(typeof options.customWeight  === "boolean") {
			params.customWeight = options.customWeight;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
	},

	/**
	 * 根据一到多个地址查询坐标位置信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param  {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {Array(String)} address  - (必选) 查询的地址名称集合。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * @param {Integer} singleKeywordResultCount  - (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchAddressesToLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			
	 *		},function() {});
	 * (end)
	 */
	batchAddressesToLocations: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = false;
		if(GeoGlobe.Util.isArray(options.address)) {
			var address = "";
			for(var i = 0; i < options.address.length;i++) {
				address += (options.address[i] + ",");
			}
			address = address.substr(0, address.length - 1);
			params.keywords = address;
		}else if(options.address == undefined || options.address == null) {
			throw "address是必选参数！";
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		if(options.filter instanceof GeoGlobe.Filter) {
			var domFilter = this.filterFormat.write(options.filter);
			var filterStr = GeoGlobe.Format.XML.prototype.write.apply(
				this.filterFormat, [domFilter]
			);
			params.filter = filterStr;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		/*
         GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		*/
	},
	
	/**
	 * 根据多个坐标位置查找匹配的地址信息。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，请参考：地址匹配结果.xsd。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param Array(GeoGlobe.LonLat)} lonlats  - {(必选) 坐标位置数组。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @param {Integer} singleKeywordResultCount  - (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchLocationToAddresses({
	 *			lonlats:[new GeoGlobe.LonLat(123.43888042, 41.759929371),new GeoGlobe.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *
	 *		},function() {});
	 * (end)
	 */
	batchLocationToAddresses: function(options, successFn, failFn) {
		var params = this.getCommonParams({
			request: "BatchGeoCoder",
			service:"GeoCoding"
		});
		params.reverseMatch = true;
		if(options.lonlats instanceof GeoGlobe.LonLat) {
			options.lonlats = [options.lonlats];
		//	params.keywords = options.lonlat.lat+","+options.lonlat.lng;
		}else  if(!GeoGlobe.Util.isArray(options.lonlats)) {
			throw "address是必选参数！请填写正确的数据类型！";
		}
		if(GeoGlobe.Util.isArray(options.lonlats)) {
			var lonlatsStr = "";
			for(var i = 0; i < options.lonlats.length;i++) {
				lonlatsStr += options.lonlats[i].lat+","+options.lonlats[i].lng+";";
			}
			lonlatsStr = lonlatsStr.substr(0, lonlatsStr.length - 1);
			params.keywords = lonlatsStr;
		}
		if(typeof options.tolerance === "number") {
			params.tolerance  = options.tolerance;
		}
		if(typeof options.unit === "string") {
			params.unit  = options.unit;
		}
		if(typeof options.singleKeywordResultCount === "number") {
			params.singleKeywordResultCount  = options.singleKeywordResultCount;
		}
		this._setGeoCoderCommonProperty(params,options);
		this._getCodingRequest(params,successFn,failFn);
		/*
         GeoGlobe.loadURL(this.url,params,this,function(result) {
			try{
				var json = this.format.read(result.responseText);
				var GeoCodingResult = this._analysis_GeoCodeResult(json);
			}catch(e) {
				successFn(result.responseText);
				return;
			}
			successFn(GeoCodingResult);
		},this.failFn);
		*/
	},
	
	/**
     * 拼装详细地址。
     * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} addressComponent  - 地址对象。
     * @param {String} name  - 名称。
     *
     * @returns {String}  - 详细地址。
	 * @private
     */
	_getAddress: function(addressComponent, name){
		var address = "";
		if(addressComponent["country"]){
			address += addressComponent["country"];
		}
		if(addressComponent["province"]){
			address += addressComponent["province"];
		}
		if(addressComponent["city"]){
			address += addressComponent["city"];
		}
		if(addressComponent["district"]){
			address += addressComponent["district"];
		}
		if(addressComponent["street"]){
			if(addressComponent["street"]["name"]){
				address += addressComponent["street"]["name"];
			}
			/*if(addressComponent["street"]["streetNumber"]){
				address += addressComponent["street"]["streetNumber"]+"号";//门牌号
			}*/
			if(addressComponent["streetNumber"]){
				address += addressComponent["streetNumber"]+"号";//门牌号
			}
		}
		if(name){ //名称
			address += name;
		}
		return address
	},
	
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息。成功回调返回的结果数据为地址信息要素({GeoGlobe.Feature})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object }options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{GeoGlobe.Feature} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String | Array(String)} address  - (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param {Integer} categoryCode  - (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.Bounds} extent  - (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {String} resultType  - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount  - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition  - (可选) 从第几条开始查询，缺省值是1。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocations({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getLocations: function(options, successFn, failFn){
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn)
	},
	
	/**
	 * 根据地址匹配查询参数查询匹配的地址信息-分页查询。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {String| Array(String)} address  - (可选，address和categoryCode必选一) 查询的地址名称集合。如果类别编码不为空，则地址名称可以为空。如果类别编码为空，则地址名称不能为空。
	 * @param {Integer} categoryCode  - (可选，address和categoryCode必选一) 类别编码，该编码值可以通过获取分类的接口获取。
	 * @param {GeoGlobe.Bounds} extent -  (可选) 查询的空间范围。缺省情况无查询范围限制。
	 * @param {Integer} maxCount  -  (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Boolean} semanticAnalysis  - (可选) 针对匹配关键字是否做语义分析，默认值为true。
	 * @param {String} sortFields - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getLocationsByPage({
	 *			extent:GeoGlobe.Bounds.fromString("-180,-90,180,90"),
	 *			address:"法库县"
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getLocationsByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.addressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * 根据位置查找匹配的地址信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat - (必选) 位置。
	 * @param {Number} tolerance - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} resultType - (可选) 返回匹配结果的类型。 可供选择的值：hits：返回匹配结果的总数，result：返回匹配结果，缺省值：result。
	 * @param {Integer} maxCount - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {Integer} startPosition - (可选) 从第几条开始查询，缺省值是1。
	 * @param {String} sortFields - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddresses({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddresses: function(options, successFn, failFn){
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult,total));
		}, this), failFn);
	},
	
	/**
	 * 根据位置查找匹配的地址信息-分页查询。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {GeoGlobe.LonLat} lonlat  - (必选) 位置。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {Integer} maxCount   - (可选) 查询多少条数据。缺省情况是查询满足条件的所有结果。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.getAddressesByPage({
	 *			lonlat:new GeoGlobe.LonLat(41.79427361488343,123.3541488647461),
	 *			tolerance:0.000899
	 *		},function(GeoCoding) {
	 *			//返回值 GeoCoding - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	getAddressesByPage: function(options, successFn, failFn){
		options.resultType = "hits";
		this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			if(queryResult.status == "OK"){
				options.resultType = "result";
				var total = queryResult.results[0].count;
				if(options.maxCount == undefined || options.maxCount == null){
					options.maxCount = 3;
				}
				options.startPosition = (options.startPosition - 1) * options.maxCount + 1;
				this.locationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
					successFn(this._parseQueryResultToFeature(queryResult,total));
				}, this), failFn)
			}else{
				alert("没有查询到任何数据");
				return;
			}
		}, this), failFn);
	},
	
	/**
	 * 根据多个坐标位置查找匹配的地址信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options - 请求参数。
	 * @param {Function} successFn  -  请求成功的回调函数。关于成功回调返回内容的结构，{<GeoGlobe.Feature>} – 地址信息要素。
	 * @param {Function} failFn -  请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {Array(GeoGlobe.LonLat)} lonlats  - (必选) 坐标位置数组。
	 * @param {Number} tolerance  - (可选) 容差范围，默认值为100。如果unit属性设置为degree，则对应的值为0.000899。
	 * @param {String} unit  - (可选)容差的单位，参数可设置为（degree、meter、km）。默认值为"meter"。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95。
	 * @param {Integer} singleKeywordResultCount  - (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 *   
	 * @example
	 * (code)
	 * 		//根据坐标位置和容差进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchGetAddresses({
	 *			lonlats:[new GeoGlobe.LonLat(123.43888042, 41.759929371),new GeoGlobe.LonLat(123.423848649, 41.771748608)],
	 *			singleKeywordResultCount:2,
	 *			tolerance:0.5,
	 *			unit:"degree",
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			//返回值 GeoCodingResult - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	batchGetAddresses: function(options, successFn, failFn){
		this.batchLocationToAddresses(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult));
		}, this), failFn);
	},
	
	/**
	 * 根据一到多个地址查询坐标位置信息。成功回调返回的结果数据为地址信息要素({<GeoGlobe.Feature>})。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} options  - 请求参数。
	 * @param {Function} successFn  - 请求成功的回调函数。关于成功回调返回内容的结构，{ GeoGlobe.Feature} – 地址信息要素。
	 * @param {Function} failFn  - 请求失败的回调函数。
	 * 
	 * options请求参数属性可为:
	 * @param {Array(String)} address  - (必选) 查询的地址名称集合。
	 * @param {String} sortFields  - (可选) 查询结果按照哪些字段排序，语法为："字段名称.ASC/DESC"，多个排序规则之间使用逗号隔开，例如："LCODE.ASC,CNAME.DESC"
	 * @param {GeoGlobe.Filter} filter  - (可选) 匹配附加过滤条件.该参数与address参数的逻辑关系为且。
	 * @param {String} scoreFilter  - (可选) 匹配度过滤，匹配结果的匹配度符合过滤条件时才输出，匹配度满分为100，过滤条件例如：score>=80、score<=70、90<=scosre<=95
	 * @param {Integer} singleKeywordResultCount  - (可选) 单个关键字匹配地址个数，用于限制服务返回的匹配结果数,默认值为1。
	 * 
	 * @example
	 * (code)
	 * 		//根据范围和地址进行查询
	 *     	var coding = new GeoGlobe.Query.GeoCodingQuery("http://192.168.40.69:7001/Test001/geocoding", {
	 *			version:"1.1.0"
	 *		});
	 * 		coding.batchGetLocations({
	 *			address:["小学"],
	 *			singleKeywordResultCount:2,
	 *			sortFields:"address.desc",
	 *			scoreFilter:"0<=score<=88"
	 *		
	 *		},function(GeoCodingResult) {
	 *			//返回值 GeoCodingResult - {Object} 对象属性包含:status, features
	 *		},function() {});
	 * (end)
	 */
	batchGetLocations: function(options, successFn, failFn){
		this.batchAddressesToLocations(options, GeoGlobe.Function.bind(function(queryResult){
			successFn(this._parseQueryResultToFeature(queryResult));
		}, this), failFn);
	},
	
	/**
	 * 根据地址/坐标匹配查询结果解析为包含状态和feature数组的对象。
	 * @memberof GeoGlobe.Query.GeoCodingQuery.v1_1_0
	 * @param {Object} params  - 键值对
	 *
	 * @returns {Object}   - 包含状态和feature数组的对象
	 * @private
	 */
	_parseQueryResultToFeature: function(queryResult){
		var features = [];
		if(queryResult.status == "OK"){
			if(queryResult.results){
				for(var i = 0; i < queryResult.results.length; i++){
					var result = queryResult.results[i].result;
					if(result){
						for(var j = 0; j < result.length; j++){
							var attribute = {};
							var geometry = null;
							attribute.requestKeyWord = queryResult.results[i].requestKeyWord;
							
							if(GeoGlobe.Util.isArray(result[j].poiArray)){
								for(var k = 0; k < result[j].poiArray.length; k++){
									attribute.CONTINENT = result[j].poiArray[k].CONTINENT;
									attribute.GBCODE = result[j].poiArray[k].GBCODE;
									attribute.STANDARDNAME = result[j].poiArray[k].STANDARDNAME;
									attribute.name = result[j].poiArray[k].name;
								}
							}
							if(result[j].addressComponent){
								var addressComponent = result[j].addressComponent;
								attribute.address = this._getAddress(addressComponent, attribute.name);
								attribute.country = result[j].addressComponent.country;
								attribute.province = result[j].addressComponent.province;
								attribute.city = result[j].addressComponent.city;
								attribute.district = result[j].addressComponent.district;
								if(result[j].addressComponent.street){
									attribute.streetName = result[j].addressComponent.street.name;
                                    attribute.streetgeometry = result[j].addressComponent.street.geometry;
								}else{
									attribute.streetName = "";
								}
								attribute.streetNumber = result[j].addressComponent.streetNumber;
							}
							if(result[j].location){
								if(result[j].location.lng){
									attribute.lng = result[j].location.lng;
								}
								if(result[j].location.lat){
									attribute.lat = result[j].location.lat;
								}
								geometry = new GeoGlobe.Geometry.Point(result[j].location.lng, result[j].location.lat);
							}
							
							attribute.isBrief = result[j].isBrief;
							attribute.precise = result[j].precise;
							attribute.resultType = result[j].resultType;
							attribute.score = result[j].score;
							//创建feature
							var feature = new GeoGlobe.Feature(geometry,attribute);
							features.push(feature);
						}
					}
				}
			}
		}

        var gjformat = new GeoGlobe.Format.GeoJSON();
        var geojsonStr = gjformat.write(features);
        var jsonformat = new GeoGlobe.Format.JSON;
        var geojsonFeature = jsonformat.read(geojsonStr);
		return {
			status: queryResult.status,
			features: features,
            geojsonFeatures:geojsonFeature
		};
	},
	
	CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1_1_0"
});/**
 * @class GeoGlobe.HeatMap

 * Inherits from:
 *  - <GeoGlobe.HeatMap>
 *      @classdesc 热图控件类，继承于GeoGlobe.HeatMap 为二维地图提供热图功能。
 * @private
 */
GeoGlobe.HeatMap = GeoGlobe.Class4OL({

    /**
     *添加的地图容器
     * @memberof GeoGlobe.HeatMap.prototype
     * @type {String}

     */
    map: null,
	
	/**
     * 热力点的缓冲范围。
     * @memberof GeoGlobe.HeatMap.prototype
     * @type {Number}

     */
	size: 25,


	/**
     *  添加的热力的强度， 0-1
     * @memberof GeoGlobe.HeatMap.prototype
     * @type {Number}
     *
     */
	intensity: 0.5,

    /**

     * GeoGlobe.HeatMap构造函数。
     * @memberof GeoGlobe.HeatMap.prototype
     * @param {Object}map - HeatMap相关选项设置。
	 * @param {Object}data - HeatMap数据（可选）
     */
    initialize: function(map, data){
        this.heatmap = new mapboxgl.heatmap(map);
        var heatMap = this.heatmap;
        this.map = map;
        var map = this.map;
		if(data){
			this.datas = data;
			this.setData(data);
		}else{
			 this.datas = [];
		}
     	this._updataLayer = GeoGlobe.Function.bind(this.updateLayer, this);
        map.on('zoom', this._updataLayer);
        map.on('move', this._updataLayer);
    },

    /**

     * 添加热图点
     * @memberof GeoGlobe.HeatMap.prototype
     * @param
     * {number} lnglat -  地图的坐标点
     * {number} size -  热力点的缓冲范围.
     *  {number} intensity - 添加的热力的强度
     */
    addPoint:function(lnglat,size,intensity){
        var poi = this.map.project([lnglat[0],lnglat[1]]);
        this.heatmap.heatmap.addPoint(poi.x, poi.y, size, intensity);
    },

    /**

     * 绘制数据点
     * @memberof GeoGlobe.HeatMap.prototype
     */
    update:function(){
        this.heatmap.heatmap.update();
    },

    /**

     * 更新热图数据
     * @memberof GeoGlobe.HeatMap.prototype
     */
    updateLayer: function(){
        this.setData(this.datas);
    },

    /**

     * 设置热图数据
     * @memberof GeoGlobe.HeatMap.prototype
     */
    setData: function (data){
        this.clear();
        this.datas = data;
        if(this.datas){
            for(var i =0;i<this.datas.length;i++){
                this.addPoint(this.datas[i], this.size, this.intensity);
            }
        }
    },

    /**

     * 显示热图
     * @memberof GeoGlobe.HeatMap.prototype
     */
    display:function(){
        return this.heatmap.heatmap.display();
    },

    /**

     * 增加热图的数值
     * @memberof GeoGlobe.HeatMap.prototype
     * @param {number}value -  热图的增加值.
     */
    multiply:function(value){
        this.heatmap.heatmap.multiply(value);
    },

    /**

     * 图各个值之间锁定的值
     * @memberof GeoGlobe.HeatMap.prototype
     * @param
     * {number}clamp1 -  最小值.
     * {number}clamp2 -  最大值.
     */
    clamp:function(clamp1,clamp2){
        this.heatmap.heatmap.clamp(clamp1,clamp1);
    },

    /**

     * 热图模糊程度
     * @memberof GeoGlobe.HeatMap.prototype
     */
    blur:function(){
        this.heatmap.heatmap.blur();
    },

    /**

     * 清除
     * @memberof GeoGlobe.HeatMap.prototype
     */
    clear:function(){
        this.heatmap.heatmap.clear();
		this.datas = [];
    },

    /**

     * 移除并销毁。
     * @memberof GeoGlobe.HeatMap.prototype
     */
    remove: function(){
        this.clear();
		map.off('zoom', this._updataLayer);
        map.off('move', this._updataLayer);
		
		this.heatmap.heatmap_canvas.parentNode.removeChild(this.heatmap.heatmap_canvas);
		//this.heatmap.heatmap_canvas.remove();
		this.heatmap.heatmap_canvas = null;
		this.heatmap = null;
		this.map = null;
    },
    CLASS_NAME: "GeoGlobe.HeatMap"
});﻿/**
 * @class GeoGlobe.LayerGroup
 * @classdesc 基础图层组类，可以将多个图层对象组合在一起，进行统一的加载和卸载操作。该图层组中的图层 将做为地图中的底图置于所有图层的最下方。
 * @private
 */
GeoGlobe.LayerGroup = GeoGlobe.Class4OL({

    /**
     * 地图容器
     * @memberof GeoGlobe.LayerGroup.prototype
     * @type {GeoGlobe.map}
     * @default null

     */
    map: null,

    /**
     *
     * GeoGlobe.Control构造函数。
     * @memberof GeoGlobe.LayerGroup.prototype

     * @param {Object} options -  LayerGroup相关选项设置。
     */
    initialize: function(options){
    },


    /**

     * 在地图上添加一个图层组。
     * @memberof GeoGlobe.LayerGroup.prototype

     * @param {GeoGlobe.Map}  map - 地图对象。
     *  @param {string} id -  id The id of the new group
     *  @param {ArrayObject}layers - layers The Mapbox style spec layers of the new group
     *  @param {string}beforeId - [beforeId] The layer id or group id after which the group
     *     will be inserted. If ommitted the group is added to the bottom of the style.
     *
     */
    addGroup:function(map, id, layers, beforeId){
        mapboxgl.LayerGroup.addGroup(map, id, layers, beforeId);
    },

    /**

     * 在图层组上添加单个图层.
     * @memberof GeoGlobe.LayerGroup.prototype

     * @param {Map}map
     * @param {string}groupId -  groupId The id of group
     * @param {Object} layer -  layer The Mapbox style spec layer
     * @param {string}beforeId  [beforeId] An existing layer id after which the new layer
     *     will be inserted. If ommitted the layer is added to the bottom of
     *     the group.
     */
    addLayerToGroup: function(map, groupId, layer, beforeId) {
        mapboxgl.LayerGroup.addLayerToGroup(map, groupId, layer, beforeId);
    },

    /**

     * 移除图层组中单个图层.
     * @memberof GeoGlobe.LayerGroup.prototype

     * @param {Map} map
     * @param {string} ids The  layer's id of the group to be removed.
     * @param {string} groupId -  groupId The id of group
     */
    removeLayerFromGroup: function(map, id,groupId) {
        var layers = map.getStyle().layers;
        for (var i = 0; i < layers.length; i++) {
            if (layers[i].metadata && layers[i].metadata.group === groupId) {
                if(layers[i].id == id ){
                map.removeLayer(layers[i].id);
               
		}
            }
        }
    },

    /**

     * 移除全部图层组.
     * @memberof GeoGlobe.LayerGroup.prototype

     * @param {Map} map
     * @param {string} id The id of the group to be removed.
     */
   removeGroup: function(map, id) {
        mapboxgl.LayerGroup.removeGroup(map, id);
    },
    /**

     * 移动整个图层组.
     * @memberof GeoGlobe.LayerGroup.prototype
     *

     * @param {Map}map- map
     *  @param {string}id - id The id of the group to be removed.
     * @param {string} groupId - groupId The id of group
     */
   moveGroup: function(map, id, beforeId) {
        mapboxgl.LayerGroup.moveGroup(map, id, beforeId);
    },

    /**

     * 获取图层组里第一个图层id.
     * @memberof GeoGlobe.LayerGroup.prototype
     *

     * @param {Map} map - map
     * @param {string} id- id The id of the group.
     * @param {string}
     */
    getGroupFirstLayerId: function(map, id) {
        return mapboxgl.LayerGroup.getGroupFirstLayerId(map, id);
    },

    /**

     * 获取图层组里最后一个图层id.
     * @memberof GeoGlobe.LayerGroup.prototype

     * @param {Map} map -  map
     * @param {string} id - id The id of the group.
     *  @returns {string}
     */
    getGroupLastLayerId: function(map, id) {
        return mapboxgl.LayerGroup.getGroupLastLayerId(map, id);
    },
    CLASS_NAME: "GeoGlobe.LayerGroup"
});

 /**
  * @class GeoGlobe.Service
  * @classdesc 服务类。本类是服务类的基类，需要由子类去实现。
  *
  */
GeoGlobe.Service = GeoGlobe.Class({
	
	/**
     * 服务名称。
     * @memberof GeoGlobe.Service.prototype
     * @type {String}
     */
	name: null,
	
	/**
     *  服务地址。
     * @memberof GeoGlobe.Service.prototype
     * @type {String}
     */	
	url: null,
	
	/**
     * 服务版本号。
     * @memberof GeoGlobe.Service.prototype
     * @type {String}
     */		
	version: null,

	
	/**
     *用户名。
     * @memberof GeoGlobe.Service.prototype
     * @type {String}
     */			
	userid: "test@liferay.com",
	
	/**
     * GeoGlobe.Service.Bus类的构造函数。
     * @memberof GeoGlobe.Service.prototype
     * @param  {String} name  -  服务名称。
     * @param  {String} url  - 服务地址。
     * @param  {Object} options  - 实例的选项设置，此参数可选。
     *
     */
	initialize: function(name, url,  options){
		this.name = name;
		this.url = url;
        GeoGlobe.Util.extend(this, options);
	},


	/**
     * 获取服务能力描述信息，由子类实现。
     * @memberof GeoGlobe.Service.prototype
     * @param  {Function} successFn - 请求成功的回调函数。
     * @param  {Function} failFn - 请求失败的回调函数。
     */		
	getCapabilities: function(successFn,failFn){
		//由子类实现
	},

	/**
     * 检查服务是否存在，由子类实现。
     * @memberof GeoGlobe.Service.prototype
     */		
	isExist: function(){
		//由子类实现
	},


	/**
     * 服务操作失败响应回调函数。
     *  @memberof GeoGlobe.Service.prototype
     * @param  {Object} operate - 失败的操作类型。
     */		
	failFn: function(operate){
		alert("服务请求失败，请检查服务是否正常运行或请求地址是否正确。\n" + 
			"请求地址：" + this.url + "\n操作类型：" + operate);
	},

	//将结果解析成XML
	_parseToXML: function(result){
		var doc = result.responseXML;
        if(!doc || !doc.documentElement) {
            doc = result.responseText;
        }
		var xmlParser = new GeoGlobe.Format.XML();
		return xmlParser.read(doc);
	},
	
	//对返回结果进行检查，是否为错误信息
	_checkIsError: function(xmlString){
		var xmlparser = new GeoGlobe.Format.XML();
		var xml = xmlparser.read(xmlString);
		var exceptions = xml.selectNodes("ServiceExceptionReport");
        if(exceptions.length > 0){
            return this._parseToJSON(xmlString);
        }
        return null;
	},
	
	//对解析后的JSON对象进行判断是否为服务抛出的异常
	_isException:function(result){
		if(result && result.ServiceExceptionReport){
			return true;
		}
		return false;
		
	},
	
	_parseToJSON: function(result){
		var parser = new GeoGlobe.Util.Format.XML2JSON();
		return parser.read(result);
	},
	
	CLASS_NAME: "GeoGlobe.Service"
	
});/**
 * @class GeoGlobe.Service.WFST
 * @classdesc OGC-WFST服务类。继承GeoGlobe.Service类，Web要素服务-T（Web Feature Service-Transaction简称WFST）遵循OGC的WFS1.0.0规范，
 * 本服务提供对要素的增加、修改、删除等事务操作。
 *
 */
GeoGlobe.Service.WFST = GeoGlobe.Class4OL(GeoGlobe.Service, {
	
    /**
     * 值为true时，为(x,y)顺序。值为false时，为(y,x)顺序。
     * @memberof GeoGlobe.Service.WFST.prototype
     *  @type {Boolaen}
     */ 
    xy: true,

    /**
     * GeoGlobe.Service.WFST类的构造函数。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {String} name  -  服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },
    
    /**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },

    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    /**
     *  获取要素类型描述操作。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {Object} params  - 请求参数，具体内容参考OGC-WFS标准。
     *   params有三个参数(service,version,request)默认可以不填，其中version默认值是1.0.0，如果要设置其他版本请设置version参数。
     * @param {Function} successFn  -  请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     *
     * @example
     * (code)
     * serviceObj.describeFeatureType({
     *     TypeName: "RES1_T_PN"
     * }, showResult);
     * (end)
     */
    describeFeatureType: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "DescribeFeatureType"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * 获取要素操作。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {Object} params  - 请求参数，具体内容参考OGC-WFS标准。
     * @param {String} TypeName  -  必选 类型名称。
     * @param {String} version  - 版本，默认值是1.0.0,如果用户请求的服务版本不是1.0.0，请设置该参数。
     * @param {Integer} MaxFeatures  - 可选 查询的返回的结果总数。
     * @param  {GeoGlobe.Filter} filter  - 可选 过滤器。
     *  以上是常用的属性，其他属性请参考OGC-WFS标准。
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  -  请求失败的回调函数。
     *
     * @example
     * (code)
     * 	 serviceObj.getFeature({
     *      TypeName: "RES1_T_PN",
     *      MaxFeatures: 10
     *   }, function(){});
     * (end)
     */
    getFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "WFS",
            VERSION: "1.0.0",
            REQUEST: "GetFeature"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },
    
    /**
     * 锁定要素操作。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {Object} params - 请求参数，具体内容参考OGC-WFS标准。
     * @param {String} typeName - 必选 指定操作的图层类型名称。
     * @param {String}  version - 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     * @param {Number} expiry - 可选 锁定的分钟数，如果没有则默认为1分钟。
     * @param {String} lockAction - 可选 指定如何获得锁，如果没有则默认为"ALL"。
     * @param {GeoGlobe.Filter} filter -  可选 操作要素的条件过滤器。
     * @param {Function} successFn - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    lockFeature: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "LockFeature",
            expiry: 1,
            lockAction: "ALL"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
        
		//解析filter对象，转换为XML字符串。
		var filterXMLString = this._parserFilterToString(params.filter);
        
        var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<LockFeature version="${version}" service="${service}" lockAction="${lockAction}" expiry="${expiry}" ' +
	        'xmlns:wfs=" http://www.opengis.net/wfs" ' +
	        'xmlns:gml=" http://www.opengis.net/gml" ' +
	        'xmlns:myns=" http://www.someserver.com/myns" ' +
	        'xmlns:ogc=" http://www.opengis.net/ogc" ' +
	        'xmlns:xsi=" http://www.w3.org/2001/XMLSchema-instance" ' +
	        'xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd">' +
	        '<Lock typeName="${typeName}">' +
		        '${filterXMLString}' +
	        '</Lock>' +
        '</LockFeature>';
        
        var requestString = GeoGlobe.String.format(requestStringTemplate, {
            version: params.version,
            service: params.service,
            lockAction: params.lockAction,
            expiry: params.expiry,
            typeName: params.typeName,
            filterXMLString: filterXMLString
        });
        
        
        if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
        
        var xhr = new GeoGlobe.Request.POST({
            url: this.url,
            data: requestString,
            scope: this,
            success: successFn,
            failure: failFn
        });
        
        //        GeoGlobe.loadURL(url, params, this, function(result){
        //            successFn(result);
        //        }, failFn);
    },
    
    /**
     * 要素的事务操作，可以对服务中的要素内容进行增加、删除和修改操作。
     * @memberof GeoGlobe.Service.WFST.prototype
     *  @param {Object} params  - 请求参数，具体内容参考OGC-WFS标准。
     * 	@param {String} version  - 可选 版本号，默认值是1.0.0，如果用户请求的服务版本不是1.0.0，请设置该参数。
     * 	@param {String} releaseAction  - 可选 指定如何释放锁，提供有"ALL"和"SOME"两种方式，默认值是"ALL"。
     *             在做更新或删除要素的时候，releaseAction="ALL"或"SOME"决定LockId对应的所有要素是否全部释放。
     *             如果是"ALL",表示LockId对应的所有要素全部解锁释放。
     *             如果是"SOME",表示LockId只对正在操作的要素解锁释放，其他要素还是保持锁定状态。
     *  @param {String} lockId  - 可选 锁定编号。
     *  @param {Object} inserts - 添加要素的请求参数。
     *  @param {Array(GeoGlobe.Feature)} features  - 必选 一系列要素的集合。
     *  @param {String} typeName  - 必选 指定操作的图层类型名称。
     *  @param {Object} updates - 修改要素的请求参数。
     *  @param {Array(GeoGlobe.Feature)} features  - 必选 一系列要素的集合。
     *  @param {String} typeName   - 必选 指定操作的图层类型名称。
     *  @param {GeoGlobe.Filter} filter  - 可选 操作要素的条件过滤器。
     *  @param {Object} deletes  - 删除要素的请求参数。
     *  @param {String} typeName  - 必选 指定操作的图层类型名称。
     *  @param {GeoGlobe.Filter} filter  - 可选 操作要素的条件过滤器。
     *  @param {Function} successFn  - 请求成功的回调函数。
     *  @param {Function} failFn  - 请求失败的回调函数。
     */
    transaction: function(params, inserts, updates, deletes, successFn, failFn){
		var url = this.url;
		//默认参数
        var DEFAULT_PARAMS = {
            service: "WFS",
            version: "1.0.0",
            request: "Transaction",
            releaseAction: "ALL"
        };
		//合并默认参数，获得实际请求参数
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);
		
		//定义post请求模板
		var requestStringTemplate = '<?xml version="1.0" encoding="UTF-8"?>' +
        '<wfs:Transaction releaseAction="${releaseAction}" handle="Transaction 01" version="${version}" service="${service}" '+
		'xmlns="http://www.someserver.com/myns" ' +
		'xmlns:gml="http://www.opengis.net/gml" ' +
		'xmlns:ogc="http://www.opengis.net/ogc" ' +
		'xmlns:wfs="http://www.opengis.net/wfs" ' +
		'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">' +
	        '${lockIdString}' +
	        '${transactionString}' +
        '</wfs:Transaction>';
		
		//lockId的请求标签
        var lockId = params.lockId;
		var lockIdString = "";
		if(lockId){
			lockIdString += '<LockId>' + lockId + '</LockId>';
		}
		
		var transactionString = "";
		//添加
        if (inserts) {
            transactionString += this._getInsertString(inserts);
        }
		//修改
		if(updates){
			transactionString += this._getUpdateString(updates);
		}
		//删除
		if(deletes){
			transactionString += this._getDeleteString(deletes);
		}
		//根据模板，获得post请求串
        var requestString = GeoGlobe.String.format(requestStringTemplate, {
            releaseAction: params.releaseAction,
            version: params.version,
            service: params.service,
            lockIdString: lockIdString,
            transactionString: transactionString
        });
		
		//请求失败的回调函数
		if (!failFn) {
            failFn = function(){
                this.failFn(params.request);
            };
        }
		
		//发送post请求
		var xhr = new GeoGlobe.Request.POST({
            url: url,
            data: requestString,
            scope: this,
            success: successFn,
//          success: function(result){
//				if(typeof successFn == "function"){
//	            	successFn(this._parseTransactionResult(result));
//	            }
//			},
            failure: failFn
        });
	},
	
	/**
     * 解析服务返回的要素事务操作的响应结果。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object} result  - 服务返回的要素事务操作的响应结果。
     *
     * @returns {object}  - 返回要素事务操作的JSON返回结果。
	 */
    parseTransactionResult: function(result){
	    var format = new GeoGlobe.Format.XML2JSON();
	    var obj = format.read(result.responseText);
	    var res = new Array();
	    var wfs_Status = this._objToArray(obj.wfs_WFS_TransactionResponse.wfs_TransactionResult.wfs_Status);
	    var wfs_InsertResults = this._objToArray(obj.wfs_WFS_TransactionResponse.wfs_InsertResults);
	    //不存在则返回空数组。
	    if(!wfs_Status){
	    	return res;
	    }
	    for (var i = 0; i < wfs_Status.length; i++) {
	        if (wfs_Status[i].wfs_SUCCESS !== undefined) {
	            res.push({
	                status: "SUCCESS",
	                fid: (wfs_InsertResults && wfs_InsertResults[i]) ? wfs_InsertResults[i].ogc_FeatureId.fid : null
	            });
	        }
	        else {
	            res.push({
	                status: "FAILED",
	                fid: null
	            });
	        }
	    }
	    return res;
	},
	
	/**
     * 对象转数组。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object} obj  - 对象。
     *
     * @returns {Array}  - 返回数组。
     * @private
	 */
    _objToArray: function(obj){
		if (obj && !(obj instanceof Array)) {
	        obj = [obj];
	    }
	    return obj;
	},
	
	/**
     * 获取插入的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object} insert  - 添加要素的参数对象。
     *
     * @returns {String}  - 返回插入的XML字符串。
     * @private
	 */
    _getInsertString: function(inserts){
		var features = inserts.features;
		var typeName = inserts.typeName;
		var insertStr = "";
        for (var i = 0; i < features.length; i++) {
            var feature = features[i];
            insertStr += '<wfs:Insert handle="Insert ' + i + '">' +
			this._getInsertFeatureString(feature, typeName) +
			'</wfs:Insert>';
        };
		return insertStr;
	},
	
	/**
     * 获取保存要素所需的外部属性串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {GeoGlobe.Feature} feature  - 要素。
     * @param {String} typeName  - 指定操作的图层类型名称。
     *
     * @returns {String}   - 返回保存要素所需的外部属性串。
     * @private
	 */
    _getInsertFeatureString: function(feature, typeName){
        var str = "";
        
        var featureTemplate = '<${typeName}>${content}</${typeName}>';
        var geoTemplate = "<GEOMETRY>${geometry}</GEOMETRY>";
        
        var attrTemplate = "<${tag}><![CDATA[${value}]]></${tag}>"
        
        for (var item in feature.attributes) {
            if (item == "OID") {
                continue;
            }
            str += GeoGlobe.String.format(attrTemplate, {
                value: (feature.attributes[item] ? feature.attributes[item] : ""),
                tag: item
            });
        }
        str += GeoGlobe.String.format(geoTemplate, {
            geometry: this._getGeometryStringByFeature(feature)
        });
        
        str = GeoGlobe.String.format(featureTemplate, {
            typeName: typeName,
            content: str
        });
        return str;
    },
	
	/**
     * 获取插入的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object}  updates  - 修改要素的参数对象。
     *
     * @returns {String}  - 返回XML字符串。
     * @private
	 */
	 /*
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var feature = updates.feature;
        
        //要素的要修改的属性和值的XML字符串
        var propertyString = this._getUpdatePropertyString(feature);
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        var updateStr = '<wfs:Update typeName="' + typeName + '" handle="Update 1">' +
	        propertyString +
	        filterXMLString +
        '</wfs:Update>';
        
        return updateStr;
    },
    */
    _getUpdateString: function(updates){
        var filter = updates.filter;
        var typeName = updates.typeName;
        var features = updates.features;
        var updateStr = '';
        for (var i = 0; i < features.length; i++) {
        	if(features[i].geometry){
		        //要素的要修改的属性和值的XML字符串
		        var propertyString = this._getUpdatePropertyString(features[i]);
		        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [typeName + "." + features[i].attributes.OID]});
		        //解析filter对象，转换为XML字符串。
		        var filterXMLString = this._parserFilterToString(filterTmp);
		        updateStr += '<wfs:Update typeName="' + typeName + '" handle="Update ' + i + '">' +
			        propertyString +
			        filterXMLString +
		        '</wfs:Update>';
        	}
        }
        return updateStr;
        /*
        for (var i = 0; i < filter.fids.length; i++) {
	        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete ' + i + '">';
	        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [filter.fids[i]]});
	        //解析filter对象，转换为XML字符串。
	        deleteStr += this._parserFilterToString(filterTmp);
	        deleteStr += '</wfs:Delete>';
        };
        */
    },
	
	/**
     * 获取修改的要素属性的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param  {GeoGlobe.Feature} feature  - 要素。
     *
     * @returns {String}  - 返回修改的要素属性的XML字符串。
     * @private
	 */
    _getUpdatePropertyString: function(feature){
        var str = "";
        for (var item in feature.data) {
            if (item == "OID") {
                continue;
            }
                if(feature.data[item]){
                str += '<wfs:Property>' +
                '<wfs:Name><![CDATA[' +
                item +
                ']]></wfs:Name>' +
                '<wfs:Value><![CDATA[' +
                (feature.data[item] ? feature.data[item] : "") +
                ']]></wfs:Value>' +
                '</wfs:Property>';
            }
        }
        str += '<wfs:Property>' +
	        '<wfs:Name>Geometry</wfs:Name>' +
	        '<wfs:Value>' +
	        this._getGeometryStringByFeature(feature) +
	        '</wfs:Value>' +
        '</wfs:Property>';
        return str;
    },
	
	/**
     * 获取修改的要素geometry的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {GeoGlobe.Feature} feature  - 要素。
     *
     * @returns {String}   - 返回修改的要素geometry的XML字符串。
     * @private
	 */
	_getGeometryStringByFeature: function(feature){
		var gmlFormat = new GeoGlobe.Format.GML({xy: this.xy});
        gmlFormat.buildCoordinatesNode = GeoGlobe.Function.bind(function(geometry){
			var coordinatesNode = this.createElementNS(this.gmlns, "gml:coordinates");
            coordinatesNode.setAttribute("decimal", ".");
            coordinatesNode.setAttribute("cs", ",");
            coordinatesNode.setAttribute("ts", " ");

            var parts = [];

            if (geometry instanceof GeoGlobe.LngLatBounds) {
                if (this.xy) {
                    parts.push(geometry.left + "," + geometry.bottom);
                    parts.push(geometry.right + "," + geometry.top);
                }
                else {
                    parts.push(geometry.bottom + "," + geometry.left);
                    parts.push(geometry.top + "," + geometry.right);
                }
            }
            else {
                var points = (geometry.components) ? geometry.components : [geometry];
                for (var i = 0; i < points.length; i++) {
                    if (this.xy) {
                        parts.push(points[i].x + "," + points[i].y);
                    }
                    else {
                        parts.push(points[i].y + "," + points[i].x);
                    }
                }
            }

            var txtNode = this.createTextNode(parts.join(" "));
            coordinatesNode.appendChild(txtNode);

            return coordinatesNode;

        }, gmlFormat);

		//DOMElement. A GML polygon node.
		var gmlDOMElement = gmlFormat.buildGeometryNode(feature.geometry);
		//gmlDOMElement.setAttribute("srsName", "urn:ogc:def:crs:EPSG:6.9:4326");
		var xmlParser = new GeoGlobe.Format.XML();
		var geometrtXmlStr = xmlParser.write(gmlDOMElement);
		return geometrtXmlStr;
    },

	/**
     * 获取插入的XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     * @param {object} deletes  - 删除要素的参数对象。
     *
     * @returns {String}  - 返回插入的XML字符串。
     * @private
	 */
	 /*
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        
        //解析filter对象，转换为XML字符串。
        var filterXMLString = this._parserFilterToString(filter);
        
        var deleteStr = "";
        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete 1">';
        deleteStr += filterXMLString;
        deleteStr += '</wfs:Delete>';
        return deleteStr;
    },
    */
    _getDeleteString: function(deletes){
        var filter = deletes.filter;
        var typeName = deletes.typeName;
        var deleteStr = "";
		for (var i = 0; i < filter.fids.length; i++) {
	        deleteStr += '<wfs:Delete typeName="' + typeName + '" handle="Delete ' + i + '">';
	        var filterTmp = new GeoGlobe.Filter.FeatureId({fids: [filter.fids[i]]});
	        //解析filter对象，转换为XML字符串。
	        deleteStr += this._parserFilterToString(filterTmp);
	        deleteStr += '</wfs:Delete>';
        };
        return deleteStr;
    },
	
	/**
     * 解析filter对象，转换为XML字符串。
     * @memberof GeoGlobe.Service.WFST.prototype
     *  @param {GeoGlobe.Filter} filter  -  可选 操作要素的条件过滤器。
     *
     * @returns {String}  - 过滤器字符串。
     * @private
	 */
    _parserFilterToString: function(filter){
		//解析filter对象，转换为XML字符串。
		var filterXMLString = "";
        if (filter) {
            var filterFormatter = new GeoGlobe.Format.Filter.v1();
            var result = filterFormatter.write(filter);//{DOMElement} An ogc:Filter element.
			var xmlParser = new GeoGlobe.Format.XML();
			filterXMLString = xmlParser.write(result);
			return filterXMLString;
        }
		return filterXMLString;
	},
	
    CLASS_NAME: "GeoGlobe.Service.WFST"
});
﻿/**
 * @class GeoGlobe.Service.CTS
 * @classdesc CTS坐标转换服务。继承GeoGlobe.Service类。
 * 坐标转换服务是GeoGlobe Server的应用服务之一。
 * 主要用于坐标投影转换、坐标仿射变换
 *
 */
GeoGlobe.Service.CTS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * GeoGlobe.Service.CTS类的构造函数。
     * @memberof GeoGlobe.Service.CTS.prototype
     *
     * @param {String} name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  -  实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * 获取服务能力描述信息的XML。
     * @memberof GeoGlobe.Service.CTS.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CTS"
            //VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            successFn(result);
        }, failFn);
    },

    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.CTS.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "CTS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    /**
     * 坐标投影转换,并返回变换的结果。
     * @memberof GeoGlobe.Service.CTS.prototype
     * @param {Object} params  - 请求参数
     * @param {string} FORMAT  - 输出方式(XML或JSON)，默认为XML
     * @param {string} FROMEPSG  - 原始EPSG号
     * @param {string} TOEPSG   - 目标EPSG号
     * @param {string} COORDINATE  - 需转换的坐标串，中间以逗号隔开
     * @param {string} DIM  - 二维(2)，缺省值为2
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     *
     */
    TransCoords: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "CTS",
            //VERSION: "1.0.0",
            REQUEST: "TransCoords"
        };

        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);

        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            if(params.FORMAT == "xml"){
                var json = {};
                var xml = result.responseXML;
                GeoGlobe.Function.bind(this.xmltoJson, this);
                var obj = this.xmltoJson(xml);
                json.attributes = obj.CTS_TransResult["cts:Coordinate"].attributes.dim;
                var coords = obj.CTS_TransResult["cts:Coordinate"].text;
                var arr = coords.split(",");
                var intcoord = [];
                for(var i = 0; i< arr.length;i++){
                    intcoord.push(arr[i]);
                }
                json.coordvalue = intcoord;
            }else if(params.FORMAT == "json"){
                var json = {};
                var obj = result.responseText;
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                json.attributes = geojson.CTS_TransResult.dim;
                json.coordvalue = geojson.CTS_TransResult.Coordinate;
            }
            successFn(json);
        }, failFn);
    },
    xmltoJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmltoJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmltoJson(item));
                }
            }
        }
        return obj;
    },
    /**
     *  坐标仿射变换。
     * @memberof GeoGlobe.Service.CTS.prototype
     * @param {Object} params  - 请求参数。
     * @param {string} FORMAT  - 输出方式(XML或JSON)，默认为XML
     * @param {string} COORDINATE  -  需转换的坐标串，中间以逗号隔开
     * @param {string}  DIM  - 二维(2)，缺省值为2
     * @param {Function} successFn  -  请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     *
     */
    AffineTransform: function(params, successFn, failFn){
        var url = this.url;
        var DEFAULT_PARAMS = {
            SERVICE: "CTS",
            //VERSION: "1.0.0",
            REQUEST: "AffineTransform"
        };
        GeoGlobe.Util.applyDefaults(params, DEFAULT_PARAMS);

        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.loadURL(url, params, this, function(result){
            if(params.FORMAT == "xml"){
                var json = {};
                var xml = result.responseXML;
                GeoGlobe.Function.bind(this.xmltoJson, this);
                var obj = this.xmltoJson(xml);
                json.attributes = obj.CTS_AffineTransResult["cts:Coordinate"].attributes.dim;
                var coords = obj.CTS_AffineTransResult["cts:Coordinate"].text;
                var arr = coords.split(",");
                var intcoord = [];
                for(var i = 0; i< arr.length;i++){
                    intcoord.push(arr[i]);
                }
                json.coordvalue = intcoord;
            }else if(params.FORMAT == "json"){
                var json = {};
                var obj = result.responseText;
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                json.attributes = geojson.CTS_AffineTransResult.dim;
                json.coordvalue = geojson.CTS_AffineTransResult.Coordinate;
            }
            successFn(json);
        }, failFn);
    },

    CLASS_NAME: "GeoGlobe.Service.CTS"
});
/**
 * @class GeoGlobe.Service.VTS
 * @classdesc VTS服务类。继承GeoGlobe.Service类，矢量瓦片服务,主要用于支持MapBox的protobuffer格式的矢量瓦片数据，并兼容OGC的WMTS服务
 * 本服务提供获取矢量瓦片的样式、和数据。
 *
 */
GeoGlobe.Service.VTS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * GeoGlobe.Service.WFST类的构造函数。
     * @memberof GeoGlobe.Service.VTS.prototype
     * @param {String} name  - 服务名称。
     * @param {String} url - 服务地址。
     * @param {Object} options - 实例的选项设置，此参数可选。
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Service.VTS.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
                        var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            var info =[];
            var capabilities;
            var layers =[];
            json = json.Capabilities;
            if(json.Contents.Layer.length){
                for(var i =0; i <json.Contents.Layer.length;i++){
                    layers.push(json.Contents.Layer[i]);
                }
            }else{
                layers.push(json.Contents.Layer);
            }

            for(var s =0 ; s < layers.length; s++){
                capabilities = {};
                capabilities.version = json.attributes.version;
                capabilities.format = layers[s].Format[4].text;
                capabilities.LayerIdentifier = layers[s].Identifier.text;
                capabilities.StyleIdentifier =  layers[s].Style.Identifier.text;
                capabilities.MatrixSet = layers[s].TileMatrixSetLink[0].TileMatrixSet.text;
                if(layers[s].BoundingBox){
                    capabilities.Bounding = layers[s].BoundingBox;
                }
                var Scales = "";
                for(var m = 0; m < json.Contents.TileMatrixSet.length; m++){
                    if(json.Contents.TileMatrixSet[m].Identifier.text == capabilities.MatrixSet){
                        var Matrix = json.Contents.TileMatrixSet[m];
                    }
                }
                capabilities.mapCRS = Matrix.SupportedCRS.text;
                var matrixs = Matrix.TileMatrix[0];
                capabilities.initZoom = matrixs.Identifier.text;
                if(matrixs.length > 0) {
                    for(var i=0, len=matrixs.length; i<len; i++) {
                        if(i == len){
                            break;
                        }
                        Scales += (matrixs[i].ScaleDenominator.text + ",");
                    }
                    capabilities.Scales =  Scales.substr(0,Scales.length - 1);
                    capabilities.zoomOffset = matrixs[0].Identifier.text;
                }else if(matrixs){
                    Scales += (matrixs.ScaleDenominator.text + ",");
                    capabilities.Scales =  Scales.substr(0,Scales.length - 1);
                    capabilities.zoomOffset = matrixs.Identifier.text;
                }
                info[s] = capabilities;
            }
            successFn(info,json);
        }, failFn);
    },

    xmlToJson:function(xml){
    // Create the return object
    var obj = {};
    if (xml.nodeType == 1) { // element
        // do attributes
        if (xml.attributes.length > 0) {
            obj["attributes"] = {};
            for (var j = 0; j < xml.attributes.length; j++) {
                var attribute = xml.attributes.item(j);
                obj["attributes"][attribute.nodeName] = attribute.nodeValue;
            }
        }
    } else if (xml.nodeType == 3) { // text
        obj = xml.nodeValue;
    }
    // do children
    if (xml.hasChildNodes()) {
        for(var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i);
            var nodeName = item.nodeName.replace('ows:','');
            nodeName = nodeName.replace('#','');
            if (typeof(obj[nodeName]) == "undefined") {
                obj[nodeName] = this.xmlToJson(item);
            } else {
                if (typeof(obj[nodeName].push) == "undefined") {
                    var old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }
                obj[nodeName].push(this.xmlToJson(item));
            }
        }
    }
    return obj;
},

    GetTile:function(options, successFn, failFn){
        var params = {
            REQUEST: "GetTile",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.tileMatrixSet) {
            params.TILEMATRIXSET = options.tileMatrixSet;
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.TILEMATRIX ) {
            params.TILEMATRIX = options.TILEMATRIX;
        }
        if(options.TILEROW ) {
            params.TILEROW = options.TILEROW;
        }
        if( options.TILECOL) {
            params.TILECOL = options.TILECOL;
        }
        var config = {};
        config.url = this.url;
        config.param = params;
        //GeoGlobe.Request.issue(config);
        var url = this.urlAppend(config.url,
            this.getParameterString(config.param || {}));
        return url;
    },
    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Service.VTS.prototype
     * @param {Object} params-参数对象
     * @returns {String} 参数字符串
     * @private
     */    
    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof GeoGlobe.Service.VTS.prototype
     * @param {String}  url  - The url to append to
     * @param {String} paramStr -  The param string to append
     *
     * @returns {String}  - The new url
     * @private
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    /**
     * 获取基于MapboxGL样式名称。
     * @memberof GeoGlobe.Service.VTS.prototype
     * @param {Function} successFn  -  请求成功的回调函数。
     * @param {Function} failFn  -  请求失败的回调函数。
     */
    GetStyleName: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0"
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }

        GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
                var obj = result.responseText;
				if(!obj){
	        		failFn();
	        		return false;
	        	}
                var jformat = new GeoGlobe.Format.JSON();
                var geojson = jformat.read(obj);
                var styleName =[];
                if(geojson.style){
                    for(var n =0;n <geojson.style.length;n++){
                        styleName.push(geojson.style[n].styleName);
                    }
                }else if(geojson.styleName){
                    for(var s = 0; s < geojson.styleName.length;s++){
                        styleName.push(geojson.styleName[s]);
                    }
                }

                //var style = geojson.style[0];
                successFn(styleName);
            },
            failure: failFn
        });
    },

    /**
     *  获取基于MapboxGL样式数据（用json描述）。
     * @memberof GeoGlobe.Service.VTS.prototype
     * @param {Function} successFn  -  请求成功的回调函数。
     * @param {Function} failFn  -  请求失败的回调函数。
     */
    GetStyle: function(styleName,successFn, failFn){
        var url = this.url;
        if(styleName =="" || styleName == undefined){
            alert("请查看样式名称是否存在");
            return ;
        }
        var params = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS",
            VERSION: "1.0.0",
            STYLENAME:styleName
        };
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        
        GeoGlobe.Request.GET({
        	url: url, 
	       	params: params,
	       	scope: this,
	       	async: this.async,
        	success: function(result){
	        	var obj = result.responseText;
				if(!obj){
					failFn();
					return false;
				}
	            var jformat = new GeoGlobe.Format.JSON();
                var style = jformat.read(obj);
                //var style = geojson.style[0];
                successFn(style);
        	}, 
      		failure: failFn
        });
    },

    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.VTS.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "WFS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    CLASS_NAME: "GeoGlobe.Service.VTS"
});﻿/**
 * @class GeoGlobe.Service.WMS
 * @classdesc OGC-WMS服务类。继承GeoGlobe.Service类。
 *
 */
GeoGlobe.Service.WMS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * GeoGlobe.Service.WMS类的构造函数。
     * @memberof GeoGlobe.Service.WMS.prototype
     * @param {String} name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     *
     */
    initialize: function(name, url,  options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     * 获取服务能力描述信息。
     * @memberof GeoGlobe.Service.WMS.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn,failFn){
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMS"
        };
        if(!failFn){
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            var capabilities ={};
            var jsonOnj = json.WMT_MS_Capabilities;
            var Layer = jsonOnj.Capability.Layer.Layer;
            var request_service =jsonOnj.Capability.Request;
            var layers;
            if(Layer.length){
                layers = Layer[0];
            }else{
                layers = Layer;
            }
            capabilities.version = jsonOnj.attributes.version;
            capabilities.format = request_service.GetMap.Format[1].text;
            capabilities.layer = layers.Title.text;
            capabilities.bbox = layers.BoundingBox.attributes.SRS;
            capabilities.maxExtent = jsonOnj.Capability.Layer.LatLonBoundingBox.attributes;
            successFn(capabilities,json);
        },failFn);
    },

    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.WMS.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    xmlToJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmlToJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmlToJson(item));
                }
            }
        }
        return obj;
    },
    /**
     *  获取地图内容操作。
     * @memberof GeoGlobe.Service.WMS.prototype
     *  @param {Object} params  - 请求参数，具体内容参考OGC-WMS标准。
     * 	@param {String} version  - 版本，默认值是1.1.1。
     *  @param {String} layers  - 图层名称。
     *  @param {String} styles  -  样式，默认是空串。
     *  @param {String} srs  -  默认值是"EPSG:4326"。
     *  @param {Integer} width  - 必选 宽。
     *  @param {Integer} height  - 必选 长。
     *  @param {String} format  - 默认值是"image/jpeg"。
     *  @param {String}  bbox   - 必选 范围。
     * @returns  {String}  - 地图内容图片地址。
     *
     * @example
     * (code)
     * var url = wmsService.getMap({
     *     layers: "basic",
     *     bbox: "-180,-90,180,270",
     *     width: 256,
     *     height: 256
     * });
     * (end)
     */
    getMap: function(options){
        var url = this.url;
        var DEFAULT_PARAMS = {
            service: "WMS",
            request: "GetMap",
            TRANSPARENT: true
        };
        var params = {};
        if( options.layers ) {
            params.LAYERS = options.layers;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.bbox) {
            params.BBOX = '{bbox-epsg-3857}';
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.version ) {
            params.VERSION = options.version;
        }
        if( options.SRS ) {
            params.SRS = options.SRS;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
       // var paramsString = GeoGlobe.Util.getParameterString(params);
       //var wms_url = GeoGlobe.Util.urlAppend(url, paramsString);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        return url;
    },

    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof GeoGlobe.Service.WMS.prototype
     * @param {String} url  - The url to append to
     * @param {String}  paramStr  - The param string to append
     *
     * @returns {String}  -  The new url
     * @private
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    CLASS_NAME: "GeoGlobe.Service.WMS"
});﻿/**
 * @class GeoGlobe.Service.WMTS
 * @classdesc OGC-WMTS服务类。继承GeoGlobe.Service类。
 *
 */
GeoGlobe.Service.WMTS = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * GeoGlobe.Service.WMTS类的构造函数。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {String}  name  - 服务名称。
     * @param {String} url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     */
    initialize: function(name, url,  options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     *  获取服务能力描述信息。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn,failFn){
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMTS"
        };
        if(!failFn){
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            var jsonOnj = json.Capabilities;
            var capabilities = {};
            var layers = jsonOnj.Contents.Layer;
            if(layers.length){
                layers = layers[0];
            }else{
                layers = layers;
            }
            
            capabilities.version = jsonOnj.attributes.version;
            var contents = jsonOnj.Contents;
            capabilities.layer = layers.Title.text;
            capabilities.LayerIdentifier = layers.Identifier.text;
            capabilities.StyleIdentifier =  layers.Style.Identifier.text;
            capabilities.MatrixSet = layers.TileMatrixSetLink[0].TileMatrixSet.text;
            capabilities.Format = layers.Format[1].text;
            capabilities.Bounding = layers.BoundingBox;
            var Scales = "";
            var matrixs = contents.TileMatrixSet[0].TileMatrix;
            if(matrixs.length > 0) {
//							for(var i = 0; i < matrixs.length; i++) {
                for(var i=0, len=matrixs.length; i<len; i++) {
                    if(i == len){
                        break;
                    }
                    Scales += (matrixs[i].ScaleDenominator.text + ",");
                }
            }
            capabilities.Scales =  Scales.substr(0,Scales.length - 1);
            capabilities.zoomOffset = matrixs[0].Identifier.text;
            successFn(capabilities,json);

        },failFn);
    },
    xmlToJson:function(xml){
        // Create the return object
        var obj = {};
        if (xml.nodeType == 1) { // element
            // do attributes
            if (xml.attributes.length > 0) {
                obj["attributes"] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    obj["attributes"][attribute.nodeName] = attribute.nodeValue;
                }
            }
        } else if (xml.nodeType == 3) { // text
            obj = xml.nodeValue;
        }
        // do children
        if (xml.hasChildNodes()) {
            for(var i = 0; i < xml.childNodes.length; i++) {
                var item = xml.childNodes.item(i);
                var nodeName = item.nodeName.replace('ows:','');
                nodeName = nodeName.replace('#','');
                if (typeof(obj[nodeName]) == "undefined") {
                    obj[nodeName] = this.xmlToJson(item);
                } else {
                    if (typeof(obj[nodeName].push) == "undefined") {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(this.xmlToJson(item));
                }
            }
        }
        return obj;
    },
    /**
     * 将向服务发送“GetCapabilities”同步请求，以检测服务是否存在。
     * 注意，本方法只能验证服务是否存在，并不能保证实际功能完全正常。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @returns {Boolean}  - 服务是否存在。
     */
    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMTS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },

    /**
     * 获取瓦片内容操作。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Object} params - 请求参数，具体内容参考OGC-WMTS标准。
     * @param {String} service - 默认值是"WMTS"。
     * @param {String} version - 默认值是"1.0.0"。
     * @param {String} layer - 必选 图层标示。
     * @param {String} style - 必选 图层样式标示。
     * @param {String} format - 默认值是"image/png"。
     * @param {String} TileMatrixSet - 必选 矩阵集。
     * @param {String} TileMatrix - 必选 矩阵。
     * @param {Integer} TileRow - 必选 瓦片行号。
     * @param {Integer} TileCol - 必选 瓦片列号。
     *
     * @returns {String}  - 瓦片内容图片地址。
     *
     * @example
     * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
     * (end)
     */
    getTile:function(options){
        var DEFAULT_PARAMS = {
            service: "WMTS",
            request: "GetTile"
        };
        var params = {};
        if( options.layer ) {
            params.LAYER = options.layer;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.tileMatrixSet) {
            params.TILEMATRIXSET = options.tileMatrixSet;
        }
        if( options.TILEMATRIX ) {
            params.TILEMATRIX = options.TILEMATRIX;
        }
        if(options.TILEROW ) {
            params.TILEROW = options.TILEROW;
        }
        if( options.TILECOL) {
            params.TILECOL = options.TILECOL;
        }
        if( options.version ) {
            params.VERSION = options.version;
        }
        if( options.style ) {
            params.STYLE = options.style;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        return url;
    },
    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Object} params-参数对象
     * @returns {String} 参数字符串
     * @private
     */ 
    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {String} url -  The url to append to
     * @param {String} paramStr - The param string to append
     *
     * @returns {String}  - The new url
     * @private
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },

    /**
     * WMTS-RESTful的获取服务能力描述信息。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Function}  successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilitiesForRest: function(successFn, failFn){
        var version = "1.0.0";
        var docName = "WMTSCapabilities.xml";
        var path = version + "/" + docName;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
        url = url + path;

        if (!failFn) {
            failFn = function(){
                this.failFn("GetCapabilities");
            };
        }

        GeoGlobe.loadURL(url, null, this, function(result){
            successFn(result);
        }, failFn);
    },

    /**
     * WMTS-RESTful的获取瓦片内容操作。
     * @memberof GeoGlobe.Service.WMTS.prototype
     * @param {Object}  params  - 请求参数，具体内容参考OGC-WMTS标准。
     *
     * @returns {String}  - 瓦片内容图片地址。
     * 	layer {String} -  必选 图层标示。
     * 	style {String} - 必选 图层样式标示。
     * 	format {String} - 必选 瓦片图片格式。默认值是"image/png"。
     * 	TileMatrixSet {String} - 必选 矩阵集。
     * 	TileMatrix {String} - 必选 矩阵。
     * 	TileRow {Integer} - 必选 瓦片行号。
     * 	TileCol Integer} - {必选 瓦片列号。
     *
     * @example
     * (code)
     * var url = wmtsService.getTile({
     *     layer: "dgdom0624",
     *     style: "dgdom0624",
     *     TileMatrixSet: "Matrix_0",
     *     TileMatrix: "12",
     *     TileRow: 761,
     *     TileCol: 3342
     * });
     * (end)
     */
    getTileForRest: function(params){
        var layer = params.layer;
        var style = params.style;
        var tileMatrixSet = params.tileMatrixSet;
        var tileMatrix = params.tileMatrix;
        var tileRow = params.tileRow;
        var tileCol = params.tileCol;

        var formatSuffix = null;
        var format = params.format ? params.format : "image/png";
        var formatSuffixMap = {
            "image/png": "png",
            "image/png8": "png",
            "image/png24": "png",
            "image/png32": "png",
            "png": "png",
            "image/jpeg": "jpg",
            "image/jpg": "jpg",
            "jpeg": "jpg",
            "jpg": "jpg"
        };
        if (!formatSuffix) {
            formatSuffix = formatSuffixMap[format] || format.split("/").pop();
        }

        var path = layer + "/" + style + "/" + tileMatrixSet +
            "/" + tileMatrix + "/" + tileRow + "/" + tileCol + "." + formatSuffix;
        var url = this.url;
        if (!url.match(/\/$/)) {
            url = url + "/";
        }
        url = url + path;
        return url;
    },

    CLASS_NAME: "GeoGlobe.Service.WMTS"
});/**
 * @class GeoGlobe.Service.DTJ
 * @classdesc 地统计分析类。
 *
 */
GeoGlobe.Service.DTJ = GeoGlobe.Class4OL(GeoGlobe.Service, {

    /**
     * GeoGlobe.Service.DTJ类构造函数。
     * @memberof GeoGlobe.Service.DTJ.prototype
     * @param {String} name  - 服务名称。
     * @param {String}  url  - 服务地址。
     * @param {Object} options  - 实例的选项设置，此参数可选。
     */
    initialize: function(name,url,options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    /**
     *  获取服务能力描述信息。
     * @memberof GeoGlobe.Service.DTJ.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     */
    getCapabilities: function(successFn,failFn){
        var url = this.url;
        var params = {
            REQUEST:"GetCapabilities",
            SERVICE:"WMS"
        };
        if(!failFn){
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            successFn(json);

        },failFn);
    },

    getMap:function(options, successFn, failFn){
        var DEFAULT_PARAMS = {
            request: "GetMap",
            service:"WMS",
            version:"1.1.1"
        };
        var params = {};
        if( options.layers ) {
            params.LAYERS = options.layers;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.bbox) {
            params.BBOX = '{bbox-epsg-3857}';
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.interval ) {
            params.INTERVAL = options.interval;
        }
        if(options.GRADSIZE ) {
            params.GRADSIZE = options.GRADSIZE;
        }
        if( options.simplitymethod) {
            params.SIMPLIFYMETHOD = options.simplitymethod;
        }
        if( options.intervalcolor) {
            params.INTERVALCOLOR = options.intervalcolor;
        }
        if( options.SIMPLIFYSIZE ) {
            params.SIMPLIFYSIZE = options.SIMPLIFYSIZE;
        }
        if(options.INTERPOLAION ) {
            params.INTERPOLATIONMETHOD = options.INTERPOLAION;
        }
        if( options.RADIUS) {
            params.RADIUS = options.RADIUS;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        return url;
    },

    getStatisticInfo: function(options, successFn, failFn) {
        var DEFAULT_PARAMS = {
            request: "GetStatisticalValue",
            service:"WMS",
            version:"1.1.1"
        };
        var params = {};
        if( options.layers ) {
            params.LAYERNAME = options.layers;
        }
        if( options.lnglat ) {
            params.X = options.lnglat.lng;
            params.Y = options.lnglat.lat;
        }
        if( options.simplitymethod) {
            params.SIMPLIFYMETHOD = options.simplitymethod;
        }
        if( options.INTERPOLATIONMETHOD) {
            params.INTERPOLATIONMETHOD = options.INTERPOLATIONMETHOD;
        }
        if( options.SIMPLIFYSIZE ) {
            params.SIMPLIFYSIZE = options.SIMPLIFYSIZE;
        }
        if(options.INTERPOLAION ) {
            params.INTERPOLAION = options.INTERPOLAION;
        }
        if( options.RADIUS) {
            params.RADIUS = options.RADIUS;
        }
        GeoGlobe.Util.applyDefaults(params,DEFAULT_PARAMS);
        var url = this.urlAppend(this.url,
            this.getParameterString(params || {}));
        //var feature = this.getStatisticValue(url);
        GeoGlobe.loadURL(url,params,this,function(result){
            var doc = result.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var json = this.xmlToJson(doc);
            if(json.FeatureCollection.featureMember) {
                var jsonMemebr = json.FeatureCollection.featureMember;
                successFn(jsonMemebr);
            }

        },failFn);
    },

    /**
     * 获取公共的参数
     * @memberof GeoGlobe.Service.DTJ.prototype
     * @param options
     * @private
     */
    getParams: function(options) {
        var params = {
            request: "GetMap",
            service:"WMS",
            version:"1.1.1"
        };
        GeoGlobe.Util.extend(params,options);
        return params;
    },
    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Service.DTJ.prototype
     * @param {Object} params-参数对象
     * @returns {String} 参数字符串
     * @private
     */    
    getParameterString : function(params) {
        var paramsArray = [];
        for (var key in params) {
            var value = params[key];
            if ((value != null) && (typeof value != 'function')) {
                var encodedValue;
                if (typeof value == 'object' && value.constructor == Array) {
                    /* value is an array; encode items and separate with "," */
                    var encodedItemArray = [];
                    var item;
                    for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                        item = value[itemIndex];
                        encodedItemArray.push(encodeURIComponent(
                                (item === null || item === undefined) ? "" : item)
                        );
                    }
                    encodedValue = encodedItemArray.join(",");
                }
                else {
                    /* value is a string; simply encode */
                    encodedValue = value;
                }
                paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
            }
        }

        return paramsArray.join("&");
    },

    /**
     * Appends a parameter string to a url. This function includes the logic for
     * using the appropriate character (none, & or ?) to append to the url before
     * appending the param string.
     * @memberof GeoGlobe.Service.DTJ.prototype
     * @param {String} url  - 追加的URL
     * @param {String} paramStr  - 追加的参数
     *
     * @returns {String}   - The new url
     */
    urlAppend: function(url, paramStr) {
        var newUrl = url;
        if(paramStr) {
            var parts = (url + " ").split(/[?&]/);
            newUrl += (parts.pop() === " " ?
                paramStr :
                parts.length ? "&" + paramStr : "?" + paramStr);
        }
        return newUrl;
    },
    xmlToJson: function(xml) {
    // Create the return object
    var obj = {};
    if (xml.nodeType == 1) { // element
        // do attributes
        if (xml.attributes.length > 0) {
            obj["attributes"] = {};
            for (var j = 0; j < xml.attributes.length; j++) {
                var attribute = xml.attributes.item(j);
                obj["attributes"][attribute.nodeName] = attribute.nodeValue;
            }
        }
    } else if (xml.nodeType == 3) { // text
        obj = xml.nodeValue;
    }
    // do children
    if (xml.hasChildNodes()) {
        for(var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i);
            var nodeName = item.nodeName.replace('ows:','');
            nodeName = nodeName.replace('#','');
            if (typeof(obj[nodeName]) == "undefined") {
                obj[nodeName] = this.xmlToJson(item);
            } else {
                if (typeof(obj[nodeName].push) == "undefined") {
                    var old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }
                obj[nodeName].push(this.xmlToJson(item));
            }
        }
    }
    return obj;
},

    CLASS_NAME:"GeoGlobe.Service.DTJ"

});

/**
 * Class: GeoGlobe.Service.Fonts
 * OGC-Fonts服务类。
 * 字体服务的getcapabilities
 */

GeoGlobe.Service.Fonts = GeoGlobe.Class4OL(GeoGlobe.Service, {

    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
    },

    getCapabilities: function(successFn, failFn){
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "FLS",
            VERSION: "1.0"
        };
        //创建失败回调函数
        if (!failFn) {
            failFn = function(){
                this.failFn(params.REQUEST);
            };
        }
        GeoGlobe.loadURL(url, params, this, function(result){
            var obj = result.responseText;
            var jformat = new GeoGlobe.Format.JSON();
            var geojson;
            geojson = (obj) ? jformat.read(obj): {};
            successFn(geojson);
        }, failFn);
        //GeoGlobe.loadURL(url, params, this, function(result){
        //    var doc = result.responseXML;
        //    GeoGlobe.Function.bind(this.xmlToJson, this);
        //    var json = this.xmlToJson(doc);
        //    var info =[];
        //    var capabilities;
        //    json = json.Capabilities;
        //    capabilities = {};
        //    capabilities.version = json.font.version;
        //
        //    info[s] = capabilities;
        //    successFn(info,json);
        //}, failFn);
    },


    isExist: function(){
        var isExist = false;
        var url = this.url;
        var params = {
            REQUEST: "GetCapabilities",
            SERVICE: "FLS"
        };
        var xhr = GeoGlobe.Request.GET({
            url: url,
            params: params,
            scope: this,
            async: false,
            success: function(){
                isExist = true;
            }
        });
        return isExist;
    },
    GetFont: function(successFn, failFn) {
        var url = this.url;
        var params = {
            REQUEST: "GetFont",
            SERVICE: "FLS",
            VERSION: "1.0"
        };
        if (!failFn) {
            failFn = function () {
                this.failFn(params.REQUEST);
            };
        }
    },
        getParameterString : function(params) {
            var paramsArray = [];
            for (var key in params) {
                var value = params[key];
                if ((value != null) && (typeof value != 'function')) {
                    var encodedValue;
                    if (typeof value == 'object' && value.constructor == Array) {
                        /* value is an array; encode items and separate with "," */
                        var encodedItemArray = [];
                        var item;
                        for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                            item = value[itemIndex];
                            encodedItemArray.push(encodeURIComponent(
                                    (item === null || item === undefined) ? "" : item)
                            );
                        }
                        encodedValue = encodedItemArray.join(",");
                    }
                    else {
                        /* value is a string; simply encode */
                        encodedValue = value;
                    }
                    paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
                }
            }

            return paramsArray.join("&");
        },

        /**
         * Function: urlAppend
         * Appends a parameter string to a url. This function includes the logic for
         * using the appropriate character (none, & or ?) to append to the url before
         * appending the param string.
         *
         * Parameters:
         * url - {String} The url to append to
         * paramStr - {String} The param string to append
         *
         * Returns:
         * {String} The new url
         * @private
         */
        urlAppend: function(url, paramStr) {
            var newUrl = url;
            if(paramStr) {
                var parts = (url + " ").split(/[?&]/);
                newUrl += (parts.pop() === " " ?
                    paramStr :
                    parts.length ? "&" + paramStr : "?" + paramStr);
            }
            return newUrl;
        },
        CLASS_NAME: "GeoGlobe.Service.Fonts"
    });/**
 * @author liuck
 * @class GeoGlobe.Service.RTDS
 * @classdesc 实时数据服务类，继承GeoGlobe.Service类。实时数据应用服务（RTDS）提供了查询和分析统计实时或历史数据的接口。GetCapabilities获取服务的能力及数据集信息；DescribeFeatureDataSet获取观测对象集合的描述信息；QueryFeature获取观测对象基本属性的元信息、基本属性值和具有此观测对象观测信息的数据集；GetObservation查询实时的观测值；GetObservationHistory按时间段查询观测对象的历史观测值；FeatureAggs支持先通过属性条件过滤某时间段的观测信息，然后聚合统计一个矩形（网格）范围内的观测信息；DescribeObservationDataSet获取数据集的描述信息。
 * @example 
GeoGlobe.ProxyHost = './proxy?url=';
var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:8080/RTDS/rtds',{
	version: '1.0.0',
	format: 'json'
});
rtds.getCapabilities(function(e){
	//TODO success
},function(e){
	//TODO faile
});
rtds.get...
 */
GeoGlobe.Service.RTDS = GeoGlobe.Class4OL(GeoGlobe.Service, {

	/**
	 * 服务类型，值为RTDS
	 * @memberof GeoGlobe.Service.RTDS.prototype
	 * @type {String}
	 * @default RTDS
	 */
	service: 'RTDS',
	
	/**
     * 服务版本号。
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @type {String}
     * @default 1.0.0
     */		
	version: '1.0.0',
	
	/**
	 * 输出格式，默认值为JSON
	 * @memberof GeoGlobe.Service.RTDS.prototype
	 * @type {String}
	 * @default json
	 */
	format: 'json',
	
	/**
	 * 使用JSONP方式的跨域通讯的flightHandler名
	 * @memberof GeoGlobe.Service.RTDS.prototype
	 * @type {String}
	 * @default ''
	 */
	callback: '',

	
    /**
     * GeoGlobe.Service.RTDS类的构造函数。
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {String} name  - 服务名称。
     * @param {String} url - 服务地址。
     * @param {Object} options - 实例的选项设置，此参数可选。
     * @param {String} options.service - 服务类型，值为RTDS
     * @param {String} options.version - 服务版本号，值为1.0.0
     * @param {String} options.format - 输出格式，值为JSON
     * @param {String} options.callback - 使用JSONP方式的跨域通讯的flightHandler名，值为空
     */
    initialize: function(name, url, options){
        GeoGlobe.Service.prototype.initialize.apply(this, arguments);
        GeoGlobe.Util.extend(this, options);
    },

    /**
     * 获取服务能力描述信息
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * @example     
	    GeoGlobe.ProxyHost = './proxy?url=';
	    var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:8080/RTDS/rtds',{
	    	version: '1.0.0',
	    	format: 'json'
	    });
		rtds.getCapabilities(function(e){
			//TODO success
		},function(e){
			//TODO faile
		})
     */
    getCapabilities: function(successFn, failFn){
        var params = {
        	SERVICE: this.service,
        	VERSION: this.version,
            REQUEST: 'GetCapabilities',
            FORMAT: this.format,
            CALLBACK: this.callback
        };

        var _this = this;
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
            	var json = {};
            	try{
            		json = JSON.parse(result.responseText);
            	}catch(e){
            		console.error('RTDS GetCapabilities Error : '+ result.responseText);
            		failFn(result.responseText);
            		return;
            	}
            	successFn(json,_this);
            },
            failure: failFn
        });
        return this;
    },

    /**
     * 获取指定观测对象集合的描述信息
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {String} obsobjsetname - 要查询的观测对象集合标识，多个之间以逗号分隔
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * @example     
	    GeoGlobe.ProxyHost = './proxy?url=';
	    var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:8080/RTDS/rtds',{
	    	version: '1.0.0',
	    	format: 'json'
	    });
		rtds.describeFeatureDataSet('taxidata_obj', function(e){
			//TODO success
		},function(e){
			//TODO faile
		})
     */
    describeFeatureDataSet: function(obsobjsetname, successFn, failFn){
        var params = {
        	SERVICE: this.service,
        	VERSION: this.version,
            REQUEST: 'DescribeFeatureDataSet',
            FORMAT: this.format,
            CALLBACK: this.callback,
            OBSOBJSETNAME: obsobjsetname
        };
        
        var _this = this;
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
            	var json = {};
            	try{
            		json = JSON.parse(result.responseText);
            	}catch(e){
            		console.error('RTDS DescribeFeatureDataSet Error : '+ result.responseText);
            		failFn(result.responseText);
            		return;
            	}
            	successFn(json,_this);
            },
            failure: failFn
        });
        return this;
    },
    
    /**
     * 获取指定数据集的描述信息
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {String} datasetname - 要查询的数据集标识，多个之间以逗号分隔
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * @example     
	    GeoGlobe.ProxyHost = './proxy?url=';
	    var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:8080/RTDS/rtds',{
	    	version: '1.0.0',
	    	format: 'json'
	    });
		rtds.describeObservationDataSet('taxidata', function(e){
			//TODO success
		},function(e){
			//TODO faile
		})
     */
    describeObservationDataSet: function(datasetname, successFn, failFn){
    	var params = {
        	SERVICE: this.service,
        	VERSION: this.version,
            REQUEST: 'DescribeObservationDataSet',
            FORMAT: this.format,
            CALLBACK: this.callback,
            DATASETNAME: datasetname
        };
        
    	var _this = this;
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
            	var json = {};
            	try{
            		json = JSON.parse(result.responseText);
            	}catch(e){
            		console.error('RTDS DescribeObservationDataSet Error : '+ result.responseText);
            		failFn(result.responseText);
            		return;
            	}
            	successFn(json,_this);
            },
            failure: failFn
        });
        return this;
    },
    
    /**
     * 查询观测对象
     * @description 根据观测对象集合标识、观测对象标识和范围等条件查询观测对象的属性元信息、属性值和含有该观测对象观测信息的数据集名称和描述。
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {Object} options - 观测对象集合标识、观测对象标识和范围等条件
     * @param {String} options.obsobjsetname - [必填]观察对象集合标识
     * @param {String} options.externalid - [可选]观测对象标识，参数值为观测对象外部ID，多个之间以逗号分隔
     * @param {Array} options.bbox - [可选]按矩形范围查询，指定该参数时geometry参数无效，只针对观测对象本身具有位置信息时有效。格式为[-180,-90,180,90]
     * @param {Array} options.geometry - [可选]按几何范围查询，只针对观测对象本身具有位置信息时有效
     * @param {Int} options.startposition - [可选]从指定位置开始返回结果，用于查询结果的分页
     * @param {Int} options.maxcount - [可选]返回结果个数
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * @example     
	    GeoGlobe.ProxyHost = './proxy?url=';
	    var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:8080/RTDS/rtds',{
	    	version: '1.0.0',
	    	format: 'json'
	    });
		rtds.queryFeature({
			obsobjsetname: 'taxidata_obj',
			startposition: 0,
			maxcount: 100
		}, function(e){
			//TODO success
		},function(e){
			//TODO faile
		})
     */
    queryFeature: function(options, successFn, failFn){
    	var params = {
        	SERVICE: this.service,
        	VERSION: this.version,
            REQUEST: 'QueryFeature',
            FORMAT: this.format,
            CALLBACK: this.callback,
            OBSOBJSETNAME: options.obsobjsetname
        };
    	options.externalid && (params.EXTERNALID = options.externalid);
    	options.bbox && (params.BBOX = options.bbox);
    	options.geometry && (params.GEOMETRY = options.geometry);
    	typeof(options.startposition) != "undefined" && (params.STARTPOSITION = options.startposition);
    	typeof(options.maxcount) != "undefined" && (params.MAXCOUNT = options.maxcount);
        
    	var _this = this;
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
            	var json = {};
            	try{
            		json = JSON.parse(result.responseText);
            	}catch(e){
            		console.error('RTDS QueryFeature Error : '+ result.responseText);
            		failFn(result.responseText);
            		return;
            	}
            	successFn(json,_this);
            },
            failure: failFn
        });
        return this;    	
    },
    
    /**
     * 获取实时观测信息
     * @description 获取实时观测信息。根据观测对象及观测属性标识和范围等得到实时观测信息。
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {Object} options - 观测对象集合标识、观测对象标识和范围等条件
     * @param {String} options.datasetname - [必填]数据集标识,填写数据集名称
     * @param {String} options.externalid - [可选]观测对象标识，参数值为观测对象外部ID，多个之间以逗号分隔
     * @param {String} options.observationproperty - [可选]观测属性，参数值为观测属性名称，多个之间以逗号分隔
     * @param {Array} options.bbox - [可选]按矩形范围查询，指定该参数时geometry参数无效，只针对观测对象本身具有位置信息时有效。格式为[-180,-90,180,90]
     * @param {Array} options.geometry - [可选]按几何范围查询，只针对观测对象本身具有位置信息时有效
     * @param {Int} options.startposition - [可选]从指定位置开始返回结果，用于查询结果的分页
     * @param {Int} options.maxcount - [可选]返回结果个数
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * @example     
	    GeoGlobe.ProxyHost = './proxy?url=';
	    var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:8080/RTDS/rtds',{
	    	version: '1.0.0',
	    	format: 'json'
	    });
		rtds.getObservation({
			datasetname: 'taxidata',
			startposition: 0,
			maxcount: 100
		}, function(e){
			//TODO success
		},function(e){
			//TODO faile
		})
     */
    getObservation: function(options, successFn, failFn){
    	var params = {
        	SERVICE: this.service,
        	VERSION: this.version,
            REQUEST: 'GetObservation',
            FORMAT: this.format,
            CALLBACK: this.callback,
            DATASETNAME: options.datasetname
        };
    	options.externalid && (params.EXTERNALID = options.externalid);
    	options.observationproperty && (params.OBSERVATIONPROPERTY = options.observationproperty);
    	options.bbox && (params.BBOX = options.bbox);
    	options.geometry && (params.GEOMETRY = options.geometry);
    	typeof(options.startposition) != "undefined" && (params.STARTPOSITION = options.startposition);
    	typeof(options.maxcount) != "undefined" && (params.MAXCOUNT = options.maxcount);
        
    	var _this = this;
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
            	var json = {};
            	try{
            		json = JSON.parse(result.responseText);
            	}catch(e){
            		console.error('RTDS GetObservation Error : '+ result.responseText);
            		failFn(result.responseText);
            		return;
            	}
            	successFn(json,_this);
            },
            failure: failFn
        });
        return this;       	
    },
    
    /**
     * 获取实时观测信息,通过游标方式查询
     * @description 获取实时观测信息,通过游标方式查询。根据观测对象及观测属性标识和范围等得到实时观测信息。
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {Object} options - 观测对象集合标识、观测对象标识和范围等条件
     * @param {String} options.datasetname - [必填]数据集标识,填写数据集名称
     * @param {Int} options.maxcount - [必填]返回结果个数
     * @param {String} options.externalid - [可选]观测对象标识，参数值为观测对象外部ID，多个之间以逗号分隔
     * @param {String} options.observationproperty - [可选]观测属性，参数值为观测属性名称，多个之间以逗号分隔
     * @param {Array} options.bbox - [可选]按矩形范围查询，指定该参数时geometry参数无效，只针对观测对象本身具有位置信息时有效。格式为[-180,-90,180,90]
     * @param {Array} options.geometry - [可选]按几何范围查询，只针对观测对象本身具有位置信息时有效
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * @returns {Object} cursor - 游标对象
     * @returns {Function} cursor.next - 通过游标获取下一份数据，数据获取得到后触发successFn回调函数。next函数返回true|false，true表示可以继续获取下一份数据，false表示游标已取完数据
     * @example     
		GeoGlobe.ProxyHost = Cfg.proxyHostUrl;			
		var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:9010/RTDS/rtds',{
			version: '1.0.0',
			format: 'json'
		});
		var cursor = rtds.getObservationByCursor({
			datasetname: "test0810",
			maxcount: 5000
		},function(e){
			//TODO success
			convertAndPushData(e);//解析数据、展示等其他逻辑
			cursor.next();//通过游标，获取下一份数据
		},function(e){
			//TODO faile
		});
     */
    getObservationByCursor: function(options, successFn, failFn){
    	var params = {
        	SERVICE: this.service,
        	VERSION: this.version,
            REQUEST: 'GetObservation',
            FORMAT: this.format,
            CALLBACK: this.callback,
            DATASETNAME: options.datasetname
        };
    	options.externalid && (params.EXTERNALID = options.externalid);
    	options.observationproperty && (params.OBSERVATIONPROPERTY = options.observationproperty);
    	options.bbox && (params.BBOX = options.bbox);
    	options.geometry && (params.GEOMETRY = options.geometry);
    	if(typeof(options.maxcount) == "undefined"){
    		console.error("RTDS GetObservationByCursor中maxcount为必须参数！");
    		return;
    	}
    	params.MAXCOUNT = options.maxcount;
    	var initialCursorID = params.SCROLLID = "GETSCROLL";
    	var endOfCursor = false;
    	var _this = this;
        var query = function(){
        	GeoGlobe.Request.GET({
        		url: _this.url,
        		params: params,
        		scope: _this,
        		async: _this.async,
        		success: function(result){
        			var json = {};
        			try{
        				json = JSON.parse(result.responseText);
        			}catch(e){
        				console.error('RTDS GetObservation Error : '+ result.responseText);
        				endOfCursor = true;
        				failFn(result.responseText);
        				return;
        			}
        			if(params.SCROLLID == initialCursorID && !json.scrollId){
        				console.error('RTDS GetObservationByCursor 获取游标失败！');
        				endOfCursor = true;
        				return;
        			}
        			if(json.features.length == 0){
        				endOfCursor = true;
        			}
        			params.SCROLLID = json.scrollId;
        			successFn(json,_this);
        		},
        		failure: failFn
        	});
        }
        var cursor = {
    		next: function (){
    			var _this = this;
    			if(!endOfCursor){
    				if(params.SCROLLID == initialCursorID){
    					setTimeout(function(){
    						_this.next();
    					}, 300);
    				}else{
    					query();
    				}
    			}
    			return !endOfCursor;
        	}
        };
        query();
        return cursor;       	
    },
    
    /**
     * 获取历史观测信息
     * @description 根据数据集、观测对象标识和时间范围等获取观测对象的历史观测信息。
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {Object} options - 观测对象集合标识、观测对象标识和范围等条件
     * @param {String} options.datasetname - [必填]数据集标识,填写数据集名称
     * @param {String} options.externalid - [必填]观测对象标识，参数值为观测对象外部ID，多个之间以逗号分隔
     * @param {DateTime} options.starttime - [必填]时间段开始时间，格式为2016-04-13 12:00:00
     * @param {DateTime} options.endtime - [必填]时间段结束时间，格式为2016-04-13 12:05:00
     * @param {String} options.observationproperty - [可选]观测属性，参数值为观测属性名称，多个之间以逗号分隔
     * @param {Int} options.samplemethod - [可选]不填默认不采样， 1为时间均分采样
     * @param {Int} options.samplecount - [可选]采样时间点个数，不填默认不采样，取该段时间所有观测值
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * @example     
	    GeoGlobe.ProxyHost = './proxy?url=';
	    var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:8080/RTDS/rtds',{
	    	version: '1.0.0',
	    	format: 'json'
	    });
		rtds.getObservationHistory({
			datasetname: 'taxidata',
			externalid: 'taxi1',
			starttime: '2016-04-13 12:00:00',
			endtime: '2016-04-13 12:05:00'
		}, function(e){
			//TODO success
		},function(e){
			//TODO faile
		})
     */
    getObservationHistory: function(options, successFn, failFn){
    	var params = {
        	SERVICE: this.service,
        	VERSION: this.version,
            REQUEST: 'GetObservationHistory',
            FORMAT: this.format,
            CALLBACK: this.callback,
            DATASETNAME: options.datasetname,
            EXTERNALID: options.externalid,
            STARTTIME: options.starttime,
            ENDTIME: options.endtime
        };
    	options.observationproperty && (params.OBSERVATIONPROPERTY = options.observationproperty);
    	typeof(options.samplemethod) != "undefined" && (params.SAMPLEMETHOD = options.samplemethod);
    	typeof(options.samplecount) != "undefined" && (params.SAMPLECOUNT = options.samplecount);
        
    	var _this = this;
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
            	var json = {};
            	try{
            		json = JSON.parse(result.responseText);
            	}catch(e){
            		console.error('RTDS GetObservationHistory Error : '+ result.responseText);
            		failFn(result.responseText);
            		return;
            	}
            	successFn(json,_this);
            },
            failure: failFn
        });
        return this;    	
    },
    
    /**
     * 聚合统计观测信息
     * @description 支持先通过属性条件过滤某时间段的观测信息，然后聚合统计一个矩形（网格）范围内的观测信息。
     * @memberof GeoGlobe.Service.RTDS.prototype
     * @param {Object} options - 观测对象集合标识、观测对象标识和范围等条件
     * @param {String} options.datasetname - [必填]数据集标识,填写数据集名称
     * @param {DateTime} options.starttime - [必填]时间段开始时间，格式为2016-04-13 12:00:00
     * @param {DateTime} options.endtime - [必填]时间段结束时间，格式为2016-04-13 12:05:00
     * @param {Int} options.precision - [可选]精度,填写数值0,1,2,3,4,5,6,7,8等整数值，0代表bbox类别，1及以上代表网格，数值越大查询的格网越小
     * @param {String} options.aggtype - [可选]聚合方式，可为COUNT,SUM,AVG、MIN、MAX，格式为SUM,AVG（多个用逗号分隔），参数个数与STATISTICSPROPERTY的参数个数相等。当AGGTYPE为COUNT时，STATISTICSPRO可为空。不填默认为COUNT
     * @param {String} options.groupbypro - [可选]观测属性分组字段，多个用“,”分隔，不填默认不分组
     * @param {String} options.statisticspro - [可选]统计字段，格式为age,grade（多个用逗号分隔），参数个数与AGGTYPE的参数个数相等。不填默认求过滤和分组条件下文档COUNT
     * @param {Object[]} options.profilter - [可选]属性过滤条件，不填默认为查询所有，如:[{ "property": "name", "type": "string", "operator": "=", "value": "zs" }, { "property": "age", "type": "number", "operator": ">", "value": "18" }]
     * @param {Array} options.bbox - [可选]按矩形范围查询，指定该参数时geometry参数无效，只针对观测对象本身具有位置信息时有效。格式为[-180,-90,180,90]
     * @param {Function} successFn  - 请求成功的回调函数。
     * @param {Function} failFn  - 请求失败的回调函数。
     * @example     
	    GeoGlobe.ProxyHost = './proxy?url=';
	    var rtds = new GeoGlobe.Service.RTDS('实时数据服务', 'http://192.168.30.91:8080/RTDS/rtds',{
	    	version: '1.0.0',
	    	format: 'json'
	    });
		rtds.featureAggs({
			datasetname: 'taxidata',
			starttime: '2016-04-13 12:00:00',
			endtime: '2016-04-13 12:05:00',
			precision: 8,
			bbox: [-180,-90,180,90]
		}, function(e){
			//TODO success
		},function(e){
			//TODO faile
		})
     */
    featureAggs: function(options, successFn, failFn){
    	var params = {
        	SERVICE: this.service,
        	VERSION: this.version,
            REQUEST: 'FeatureAggs',
            FORMAT: this.format,
            CALLBACK: this.callback,
            DATASETNAME: options.datasetname,
            STARTTIME: options.starttime,
            ENDTIME: options.endtime
        };
    	typeof(options.precision) != "undefined" && (params.PRECISION = options.precision);
    	options.aggtype && (params.AGGTYPE = options.aggtype);
    	options.groupbypro && (params.GROUPBYPRO = options.groupbypro);
    	options.statisticspro && (params.STATISTICSPRO = options.statisticspro);
    	options.profilter && (params.PROFILTER = options.profilter);
    	options.bbox && (params.BBOX = options.bbox);
        
    	var _this = this;
        GeoGlobe.Request.GET({
            url: this.url,
            params: params,
            scope: this,
            async: this.async,
            success: function(result){
            	var json = {};
            	try{
            		json = JSON.parse(result.responseText);
            	}catch(e){
            		console.error('RTDS FeatureAggs Error : '+ result.responseText);
            		failFn(result.responseText);
            		return;
            	}
            	successFn(json,_this);
            },
            failure: failFn
        });
        return this;  
    },

    CLASS_NAME: "GeoGlobe.Service.RTDS"
});/**
 * @class GeoGlobe.Statistic
 * @classdesc 地统计分析类。
 *
 */
GeoGlobe.Statistic = GeoGlobe.Class({

    /**
     * 叠置分析操作所需要的WPS服务地址。
     * @memberof GeoGlobe.Statistic.prototype
     * @type {String}
     */
    url: null,

    /**
     * 叠置分析操作类型。
     * @memberof GeoGlobe.Statistic.prototype
     * @type {String}
     */
    type:"intersection",


    /**
     * GeoGlobe.Statistic类构造函数。
     * @memberof GeoGlobe.Statistic.prototype
     * @param {String} url  - 服务地址
     * @param {Object} options  - 相关属性的设置项，可选
     */
    initialize: function(url,options){
        this.url = url;
        GeoGlobe.Util.extend(this, options);
    },
    paramUrl:function(options, successFn, failFn){
        var params = this.getParams({
            request: "GetMap"
        });
        if( options.layers ) {
            params.LAYERS = options.layers;
        }
        if(options.format) {
            params.FORMAT = options.format;
        }
        if(options.bbox) {
            params.BBOX = '{bbox-epsg-3857}';
        }
        if(options.width ) {
            params.WIDTH = options.width;
        }

        if(options.height ) {
            params.HEIGHT = options.height;
        }
        if( options.interval ) {
            params.INTERVAL = options.interval;
        }
        if(options.GRADSIZE ) {
            params.GRADSIZE = options.GRADSIZE;
        }
        if( options.simplitymethod) {
            params.SIMPLIFYMETHOD = options.simplitymethod;
        }
        if( options.intervalcolor) {
            params.INTERVALCOLOR = options.intervalcolor;
        }
        if( options.SIMPLIFYSIZE ) {
            params.SIMPLIFYSIZE = options.SIMPLIFYSIZE;
        }
        if(options.INTERPOLAION ) {
            params.INTERPOLATIONMETHOD = options.INTERPOLAION;
        }
        if( options.RADIUS) {
            params.RADIUS = options.RADIUS;
        }
        var config = {};
        config.url = this.url;
        config.param = params;
        //GeoGlobe.Request.issue(config);
        var url = this.urlAppend(config.url,
           this.getParameterString(config.param || {}));
        return url;
    },

    getStatisticInfo: function(options, successFn, failFn) {
        var params = this.getParams({
            request: "GetStatisticalValue"
        });
        if( options.layers ) {
            params.LAYERNAME = options.layers;
        }
        if( options.lnglat ) {
            params.X = options.lnglat.lng;
            params.Y = options.lnglat.lat;
        }
        if( options.simplitymethod) {
            params.SIMPLIFYMETHOD = options.simplitymethod;
        }
        if( options.INTERPOLATIONMETHOD) {
            params.INTERPOLATIONMETHOD = options.INTERPOLATIONMETHOD;
        }
        if( options.SIMPLIFYSIZE ) {
            params.SIMPLIFYSIZE = options.SIMPLIFYSIZE;
        }
        if(options.INTERPOLAION ) {
            params.INTERPOLAION = options.INTERPOLAION;
        }
        if( options.RADIUS) {
            params.RADIUS = options.RADIUS;
        }
        var config = {};
        config.url = this.url;
        config.param = params;
        //GeoGlobe.Request.issue(config);
        var url = this.urlAppend(config.url,
            this.getParameterString(config.param || {}));
        var feature = this.getStatisticValue(url);
       return feature;
    },

    /**
     * 获取公共的参数
     * @memberof GeoGlobe.Statistic.prototype
     * @param {Object} options -参数选项。
     */
    getParams: function(options) {
        var params = {
            request: "GetMap",
            service:"WMS",
            version:"1.1.1"
        };
        GeoGlobe.Util.extend(params,options);
        return params;
    },
    /**
     * 获取参数字符串
     * @memberof GeoGlobe.Statistic.prototype
     * @param {Object} params-参数对象
     * @returns {String} 参数字符串
     * @private
     */ 
   getParameterString : function(params) {
    var paramsArray = [];
    for (var key in params) {
        var value = params[key];
        if ((value != null) && (typeof value != 'function')) {
            var encodedValue;
            if (typeof value == 'object' && value.constructor == Array) {
                /* value is an array; encode items and separate with "," */
                var encodedItemArray = [];
                var item;
                for (var itemIndex=0, len=value.length; itemIndex<len; itemIndex++) {
                    item = value[itemIndex];
                    encodedItemArray.push(encodeURIComponent(
                            (item === null || item === undefined) ? "" : item)
                    );
                }
                encodedValue = encodedItemArray.join(",");
            }
            else {
                /* value is a string; simply encode */
                encodedValue = value;
            }
            paramsArray.push(encodeURIComponent(key) + "=" + encodedValue);
        }
    }

    return paramsArray.join("&");
},

/**
 * Appends a parameter string to a url. This function includes the logic for
 * using the appropriate character (none, & or ?) to append to the url before
 * appending the param string.
 * @memberof GeoGlobe.Statistic.prototype
 * @param {String} url  - The url to append to
 * @param {String} paramStr  - The param string to append
 *
 * @returns {String}  - The new url
 * @private
 */
urlAppend: function(url, paramStr) {
    var newUrl = url;
    if(paramStr) {
        var parts = (url + " ").split(/[?&]/);
        newUrl += (parts.pop() === " " ?
            paramStr :
            parts.length ? "&" + paramStr : "?" + paramStr);
    }
    return newUrl;
},
    getStatisticValue: function(url ){
        var wmsUrl = url;
        var newTUrl = Cfg.proxyHostUrl+wmsUrl;
        //获取服务请求值
        Cfg.url = url;
        var request = sendAjaxRequest(newTUrl,dataChange);
        var doc = request.responseXML;
        var json = xmlToJson(doc);
        if (!doc || !doc.documentElement) {
            doc = request.responseText;
        }
        if(!doc){
            alert("服务不可用!");
            return;
        }
        if(json.FeatureCollection.featureMember){
            var jsonMemebr = json.FeatureCollection.featureMember;
            return jsonMemebr;
        }else{
            alert("服务不可用!");
        }

    },

    CLASS_NAME:"GeoGlobe.Statistic"

});

/**
 * Class: GeoGlobe.ElementContainer
 * gl地图的前置容器。
 */
GeoGlobe.ElementContainer = GeoGlobe.Class4OL({

	id: null,
	
    /**
	 * gl地图对象
	 * @memberof GeoGlobe.ElementContainer.prototype
	 * @type {String}
     */
    map: null,

    /**
     * GeoGlobe.ElementContainer构造函数。
     * @memberof GeoGlobe.ElementContainer.prototype
     * @param {Object}options -  参数对象
     */
    initialize: function(options){
		this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME+ "_");
		GeoGlobe.Util.extend(this, options);
    },
	
    /**
     * 与地图对象关联
     * @memberof GeoGlobe.ElementContainer.prototype
     * @param {Object}map - map对象
     */
    addTo: function (map){
		this.map = map;
        var mapContainer = map.getCanvasContainer();
		if(!map.eleContainer){
			//创建eleContainer
			var eleContainer = GeoGlobe.DOM.create("div", "geoglobe-element-container", mapContainer);
			eleContainer.style.width = map.getCanvas().style.width;
			eleContainer.style.height = map.getCanvas().style.height;
			eleContainer.style.position = "absolute";
			map.eleContainer = eleContainer;
		}
		
		//创建container
		this.container = GeoGlobe.DOM.create("div", null, map.eleContainer);
		this.container.style.width = map.getCanvas().style.width;
		this.container.style.height = map.getCanvas().style.height;
		this.container.style.position = "absolute";
		
//		map.isIntScrollZoom = true;//缩放级别是否为整数处理模式
		this._resize = GeoGlobe.Function.bind(this._resize, this);
		map.on('resize', this._resize);
    },
	
	/**
	 * map大小改变时
     * @memberof GeoGlobe.ElementContainer.prototype
     */
	_resize: function(){
		var map = this.map;
		map.eleContainer.style.width = map.getCanvas().style.width;
		map.eleContainer.style.height = map.getCanvas().style.height;
		this.container.style.width = map.getCanvas().style.width;
		this.container.style.height = map.getCanvas().style.height;
	},
	
    /**
     * 获取elmap。
     * @memberof GeoGlobe.ElementContainer.prototype
     */
	getElMap: function(){
		return this.elmap;
	},
	
    /**
     * 移除并销毁。
     * @memberof GeoGlobe.ElementContainer.prototype
     *
     */
    remove: function(){
		var map = this.map;
		map.off('resize', this._resize);
    },
	
    CLASS_NAME: "GeoGlobe.ElementContainer"
});/**
 * @class GeoGlobe.MaptalksEle
 * @classdesc gl地图的前置maptalks容器。
 */
GeoGlobe.MaptalksEle = GeoGlobe.Class4OL(GeoGlobe.ElementContainer, {

    /**
     * gl地图对象。
 	 * @memberof GeoGlobe.MaptalksEle.prototype
 	 * @type {String}
 	 * @default null
     */
    map: null,
	
    /**
     * maptalks map的容器。
     * @memberof GeoGlobe.MaptalksEle.prototype
     * @type {Object}

     */
    container: null,
	
    /**
     *  maptalks map对象。
     *  @memberof GeoGlobe.MaptalksEle.prototype
     *  @type {Object}
     *
     */
    elmap: null,
	
    /**
     *  maptalks map的构造选项。
     *  @memberof GeoGlobe.MaptalksEle.prototype
     *  @type {Object}
     *
     */
	elmapOptions: null,

    /**
     * GeoGlobe.MaptalksEle构造函数。
     * @memberof GeoGlobe.MaptalksEle.prototype
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
        GeoGlobe.ElementContainer.prototype.initialize.apply(this, arguments);
    },
	
    /**
     * 与gl地图对象关联
     * @memberof GeoGlobe.MaptalksEle.prototype
     * @param {Object} map -  gl地图对象
     */
    addTo: function (map){
		GeoGlobe.ElementContainer.prototype.addTo.apply(this, arguments);
		
		this.container.id = this.id;
		this.container.className = "geoglobe-maptalks-container";
		
		if (window.maptalks && window.maptalks.Map) {
			GeoGlobe.MaptalksEle.overrideMapTalksFunc();
			var center = this.map.getCenter();
			//maptalks map的构造选项
			var _opt = GeoGlobe.Util.extend({
				zoom: this.map.getZoom() + 1,
				//spatialReference:{
		        //  projection:'EPSG:3857'
		        //},
	        	center: [center.lng, center.lat]
			}, this.elmapOptions);
			this.elmap = new maptalks.Map(this.container.id, _opt);
			this._bindEvent();
		}else{
			console.log("使用前置maptalks容器，需引入maptalks地图库。");
		}
    },
	
    /**
     * 绑定事件
     * @memberof GeoGlobe.MaptalksEle.prototype
     */
	_bindEvent: function(){
		var map = this.map;
		//移动开始时，缩放开始时，旋转开始时。
		this._movestart = GeoGlobe.Function.bind(function(e){//movestart 在zoomstart之前触发
			if(this._zooming){
				this._zooming = false;//缩放途中，突然拖动地图，会打断缩放操作且会触发movestart，所以要重置this._zooming为false。
				this._iszoomend = true;
			}
		}, this);
		//移动中
		this._move = GeoGlobe.Function.bind(function(e){
			if(this._zooming == true || this._rotating == true){
				return;
			}
			this.elmap._moving = true;
			this.syncElmapCenter();
			return;
		}, this);
		//移动结束后，缩放结束后，旋转结束后。
		this._moveend = GeoGlobe.Function.bind(function(e){
			this.elmap._moving = false;
			this.elmap._dragRotating = false;
			this._zooming = false;
			this._rotating = false;
			var zoom = this.map.getZoom();
			if(Math.ceil(zoom) !== zoom){//如果不是整数，则恢复整数级别
				this.map.setZoom(Math.ceil(zoom));
			}
			if(this._iszoomend){//1.如果一个缩放操作结束，则执行。2.如果在一个缩放操作在过程中move，move结束后也执行。
				this._iszoomend = false;
				var zoom = this.map.getZoom() + 1;
				var _pos = e.target.scrollZoom._pos ? e.target.scrollZoom._pos : e.point;
				//44版本
				if(!_pos){
					_pos = e.target.scrollZoom._aroundPoint;
				}
				//44版本 end
				var origin = new maptalks.Point(_pos.x, _pos.y);
				this.elmap._zoomTo(zoom, origin);
				this.elmap._zooming = false;
				this.elmap._getRenderer().onZoomEnd();
				this.elmap._fireEvent('zoomend', { 'from': this.elmap._startZoomVal, 'to': zoom });
				this.syncElmapCenter();
				return;
			};
			var center = this.map.getCenter();
			this.elmap.setCenter([center.lng, center.lat]);
		}, this);
		
		//旋转开始
		this._rotatestart = GeoGlobe.Function.bind(function(e){
			this._rotating = true;
			this.elmap._dragRotating = true;
		}, this);
		//旋转中
		this._rotate = GeoGlobe.Function.bind(function(e){
			this.syncElmapRotate();
		}, this);
		
		//缩放开始
		this._zoomstart = GeoGlobe.Function.bind(function(e){
			//e.target.dragPan.disable();
			//e.target.scrollZoom.disable();
			this._zooming = true;
			this.elmap._moving = false;//因为movestart 在zoomstart之前触发，所以elmap._moving复原为false
			var zoom = this.map.getZoom() + 1;
			//屏幕缩放参考点
			var _pos = e.target.scrollZoom._pos ? e.target.scrollZoom._pos : e.point;
			//44版本
			if(!_pos){
				_pos = GeoGlobe.DOM.mousePos(e.target.scrollZoom._el, e.originalEvent);
			}
			//44版本 end
			var origin = new maptalks.Point(_pos.x, _pos.y);
			this.origin_lnglat = this.map.unproject(_pos);
			this.elmap.onZoomStart(zoom, origin);//此方法内会设置this.elmap._zooming = true;
		}, this);
		//缩放中
		this._zoom = GeoGlobe.Function.bind(function(e){//move 在zoom之前触发
			var center = this.map.getCenter();
			var zoom = this.map.getZoom() + 1;
			if (this.elmap._zoomLevel !== zoom) {
				var _pos = e.target.scrollZoom._pos ? e.target.scrollZoom._pos : e.point;
				//44版本
				if(!_pos){
					_pos = e.target.scrollZoom._aroundPoint;
					_pos = _pos ? _pos : GeoGlobe.DOM.mousePos(e.target.scrollZoom._el, e.originalEvent);
				}
				//44版本 end
				//屏幕缩放参考点
				var _pos2 = this.map.project(this.origin_lnglat);
				if(_pos.x !== Math.round(_pos2.x) || _pos.y !== Math.round(_pos2.y)){
					//_pos = _pos2;
					this.elmap._zooming = false;//处理
				}
				var origin = new maptalks.Point(_pos.x, _pos.y);
				this.elmap.onZooming(zoom, origin);
	        }
			var elmapCenter = this.elmap.getCenter();
			if(center.lng - elmapCenter.x > 2 || center.lng - elmapCenter.x < -2){
				this.syncElmapCenter();
			}
		}, this);
		//缩放结束时
		this._zoomend = GeoGlobe.Function.bind(function(e){//zoomend 在moveend之前触发
			this._zooming = false;
			this._iszoomend = true;
			//e.target.dragPan.enable();
			//e.target.scrollZoom.enable();
		}, this);
		
		map.on('movestart', this._movestart);
		map.on('move', this._move);
		map.on('moveend', this._moveend);
		map.on('rotatestart', this._rotatestart);
		map.on('rotate', this._rotate);
		map.on('zoomstart', this._zoomstart);
		map.on('zoom', this._zoom);
		map.on('zoomend', this._zoomend);
	},
	
    /**
     * @memberof GeoGlobe.MaptalksEle.prototype
     * map大小改变时
     */
	_resize: function(){
		GeoGlobe.ElementContainer.prototype._resize.apply(this, arguments);
		this.elmap.checkSize();
	},
	
    /**
     * @memberof GeoGlobe.MaptalksEle.prototype
     * 同步elmap的中心点。
     */
	syncElmapCenter: function(){
		var center = this.map.getCenter();
		center = [center.lng, center.lat];
        if (!center) {
            return false;
        }
        center = new maptalks.Coordinate(center);
        var projection = this.elmap.getProjection();
        var _pcenter = projection.project(center);
        this.elmap._setPrjCenter(_pcenter);
	},
	
    /**
     * 同步elmap的bearing和pitch。
     * @memberof GeoGlobe.MaptalksEle.prototype
     */
	syncElmapRotate: function(){
		var map = this.map;
		if(this.elmap){
			//var center = map.getCenter();
	        var bearing = map.getBearing();
	        var pitch = map.getPitch();
			
			var cameraOptions = {
				//'center' : [center.lng, center.lat],
	            'bearing' : map.getBearing(),
	            'pitch' : map.getPitch()
	        };
			this.elmap.setView(cameraOptions);
		}
	},
	
	 /**
      * 同步elmap的view。
      * @memberof GeoGlobe.MaptalksEle.prototype
      */
	_syncElmap: function(){
		var map = this.map;
		if(this.elmap){
			var center = map.getCenter();
	        var zoom = map.getZoom();
	        var bearing = map.getBearing();
	        var pitch = map.getPitch();
			
			var cameraOptions = {
	            'center' : [center.lng, center.lat],
	            'zoom'   : map.getZoom() + 1,
	            'bearing' : map.getBearing(),
	            'pitch' : map.getPitch()
	        };
			this.elmap.setView(cameraOptions);
		}
	},

    /**
     * 移除并销毁。
     * @memberof GeoGlobe.MaptalksEle.prototype
     */
    remove: function(){
		GeoGlobe.ElementContainer.prototype.remove.apply(this, arguments);
		var map = this.map;
		map.off('movestart', this._movestart);
		map.off('move', this._move);
		map.off('moveend', this._moveend);
		map.off('rotatestart', this._rotatestart);
		map.off('rotate', this._rotate);
		map.off('zoomstart', this._zoomstart);
		map.off('zoom', this._zoom);
		map.off('zoomend', this._zoomend);
		
		this.container.parentNode.removeChild(this.container);
		this.container = null;
		this.elmap.remove();
		this.elmap = null;
		this.map = null;
    },
	
    CLASS_NAME: "GeoGlobe.MaptalksEle"
});

GeoGlobe.MaptalksEle.overrideMapTalksFunc = function() {
	if(window.maptalks && window.maptalks.Map){
		maptalks.Map.prototype.addHandler = function(name, handlerClass) {
			//这几个handler不添加
			if(name === "draggable" || name === "touchZoom" || name === "boxZoom" || name === "doubleClickZoom" || name === "scrollWheelZoom"){
				return this;
			}
		    if (!handlerClass) {
		        return this;
		    }
		    if (!this._handlers) {
		        this._handlers = [];
		    }
		    //handler已经存在
		    if (this[name]) {
		        this[name].enable();
		        return this;
		    }
		
		    var handler = this[name] = new handlerClass(this);
		
		    this._handlers.push(handler);
		
		    if (this.options[name]) {
		        handler.enable();
		    }
		    return this;
		}
	}
}
/* Copyright (c) 2006-2013 by OpenLayers Contributors (see authors.txt for
 * full list of contributors). Published under the 2-clause BSD license.
 * See license.txt in the OpenLayers distribution or repository for the
 * full text of the license. */
/**
 * Internationalization namespace.  Contains dictionaries in various languages
 *     and methods to set and get the current language.
 * @namespace  GeoGlobe.Lang
 * @private
 */
GeoGlobe.Lang = {
    
    /**
     *  Current language code to use in GeoGlobe.  Use the
     *     setCode method to set this value and the getCode method to
     *     retrieve it.
     * @memberof GeoGlobe.Lang
     * @type {String}
     *
     */
    code: null,

    /**
     *  Default language to use when a specific language can't be found.  Default is "zh-CN".
     * @memberof GeoGlobe.Lang
     * @type {String}
     */
    defaultCode: "zh-CN",//en
        
    /**
     * Get the current language code.getCode
     * @memberof GeoGlobe.Lang
     * @returns {String}  - The current language code.
     */
    getCode: function() {
        if(!GeoGlobe.Lang.code) {
            GeoGlobe.Lang.setCode();
        }
        return GeoGlobe.Lang.code;
    },

    /**
     * Set the language code for string translation.  This code is used by
     *     the GeoGlobe.Lang.translate method.
     * @memberof GeoGlobe.Lang
     * @param {String} code  - These codes follow the IETF recommendations at
     *     http://www.ietf.org/rfc/rfc3066.txt.  If no value is set, the
     *     browser's language setting will be tested.  If no GeoGlobe.Lang
     *     dictionary exists for the code, the GeoGlobe.String.defaultLang
     *     will be used.
     */
    setCode: function(code) {
        var lang;
        if(!code) {
            code = (GeoGlobe.BROWSER_NAME == "msie") ?
                navigator.userLanguage : navigator.language;
        }
        var parts = code.split('-');
        parts[0] = parts[0].toLowerCase();
        if(typeof GeoGlobe.Lang[parts[0]] == "object") {
            lang = parts[0];
        }

        // check for regional extensions
        if(parts[1]) {
            var testLang = parts[0] + '-' + parts[1].toUpperCase();
            if(typeof GeoGlobe.Lang[testLang] == "object") {
                lang = testLang;
            }
        }
        if(!lang) {
            GeoGlobe.Console.warn(
                'Failed to find GeoGlobe.Lang.' + parts.join("-") +
                ' dictionary, falling back to default language'
            );
            lang = GeoGlobe.Lang.defaultCode;
        }
        
        GeoGlobe.Lang.code = lang;
    },

    /**
     * Looks up a key from a dictionary based on the current language string.
     *     The value of getCode will be used to determine the appropriate
     *     dictionary.  Dictionaries are stored in GeoGlobe.Lang.
     * @memberof GeoGlobe.Lang
     * @param {String} key  - The key for an i18n string value in the dictionary.
     * @param {Object} context  - Optional context to be used with
     *     GeoGlobe.String.format.
     * 
     * @returns {String}  -  A internationalized string.
     */
    translate: function(key, context) {
        var dictionary = GeoGlobe.Lang[GeoGlobe.Lang.getCode()];
        var message = dictionary && dictionary[key];
        if(!message) {
            // Message not found, fall back to message key
            message = key;
        }
        if(context) {
            message = GeoGlobe.String.format(message, context);
        }
        return message;
    }
    
};


/**
 * Alias for GeoGlobe.Lang.translate.  Looks up a key from a dictionary
 *     based on the current language string. The value of
 *     GeoGlobe.Lang.getCode>will be used to determine the appropriate
 *     dictionary.  Dictionaries are stored in GeoGlobe.Lang.
 * @memberof GeoGlobe.Lang
 * @param {String} key - The key for an i18n string value in the dictionary.
 * @param {Object} ontext - Optional context to be used with GeoGlobe.String.format.
 * 
 * @returns  {String}  - A internationalized string.
 */
GeoGlobe.i18n = GeoGlobe.Lang.translate;
/**
 *
 * Dictionary for English.  Keys for entries are used in calls to
 *     GeoGlobe.Lang.translate.  Entry bodies are normal strings or
 *     strings formatted for use with GeoGlobe.String.format calls.
 * @namespace  GeoGlobe.Lang["en"]
 * @private
 */
GeoGlobe.Lang.en = {

    'unhandledRequest': "Unhandled request return ${statusText}",

    'end': ''
    
};
/**
 *
 * Dictionary for Simplified Chinese.  Keys for entries are used in calls to
 *     GeoGlobe.Lang.translate.  Entry bodies are normal strings or
 *     strings formatted for use with GeoGlobe.String.format calls.
 *  @namespace   GeoGlobe.Lang["zh-CN"]
 *  @private
 */
GeoGlobe.Lang["zh-CN"] = {

    'unhandledRequest': "未处理的请求，返回值为 ${statusText}",

    'end': ''
};
/**
 * @module Visual
 * @author liuck
 * @class GeoGlobe.Visuals
 * @classdesc gl地图的可视化图层容器。

 */

GeoGlobe.Visuals = GeoGlobe.Class4OL(GeoGlobe.ElementContainer, {
	
    /**
     
     * @function initialize
     * @description  GeoGlobe.Visuals构造函数。
     * @memberof GeoGlobe.Visuals.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
        GeoGlobe.ElementContainer.prototype.initialize.apply(this, arguments);
    },
    
	/**
	 * 将侦听器添加到指定的事件类型。
	 *
	 * @function on
	 * @param {String} type 事件类型。
	 * @param {Function} listener 侦听器事件触发时要调用的函数。
	 * @returns {Object} `this`
	 * @memberof GeoGlobe.Visuals.prototype
	 */

	/**
	 * 删除以前注册的事件侦听器。
	 *
	 * @function off
	 * @param {string} type 事件类型。
	 * @param {Function} listener 侦听器要删除的侦听器函数。
	 * @returns {Object} `this`
	 * @memberof GeoGlobe.Visuals.prototype
	 */

	/**
	 * 将只会调用一次的侦听器添加到指定的事件类型。
	 *
	 * 监听器在注册后第一次触发该事件。
	 *
	 * @function once
	 * @param {string} type 事件类型。
	 * @param {Function} listener 侦听器要删除的侦听器函数。
	 * @returns {Object} `this`
	 * @memberof GeoGlobe.Visuals.prototype
	 */
    
    /**
     * 可视化图层（覆盖图层）WebGL画布初始事件
     * @event overlayerinit
     * @memberof GeoGlobe.Visuals.prototype
     * @property {Object} gl - 回调参数
     */ 
    
    /**
     * 可视化图层（覆盖图层）鼠标点击事件
     * @event overlayerclick
     * @memberof GeoGlobe.Visuals.prototype
     * @property {Object} data - 回调参数
     */ 
    
    /**
     * 可视化图层（覆盖图层）鼠标悬浮事件
     * @event overlayerhover
     * @memberof GeoGlobe.Visuals.prototype
     * @property {Object} data - 回调参数
     */
    
    /**

     * @function addTo
     * @description  与gl地图对象关联
     * @memberof GeoGlobe.Visuals.prototype
     * @param {Object} map -  gl地图对象
     */
    addTo: function (map){
		GeoGlobe.ElementContainer.prototype.addTo.apply(this, arguments);
    }
});

GeoGlobe.Visuals = GeoGlobe.Class4OL(GeoGlobe.Visuals, mapboxgl.Evented);/**
 * @author liuck
 * @class GeoGlobe.Visuals.Three
 * @classdesc 基于ThreeJS的可视化图层。
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -138.23,
	pitch: 57.50,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
});
 //构造THREE可视化图层
 var threebox = new GeoGlobe.Visuals.Three();
 //添加到地图中
 threebox.addTo(map);
 //绑定鼠标点击事件
 threebox.on('overlayerclick', function(e){
	alert(e.param.info.userData.attributes.OriginalData.aliasName);
});
 //绑定鼠标移动事件
 threebox.on('overlayerhover', function(e){
	console.info(e);
})
 //绘制
 threebox.render();
 */

GeoGlobe.Visuals.Three = GeoGlobe.Class4OL(GeoGlobe.Visuals, {

    /**
     * 地图对象
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @type {GeoGlobe.Map}
     * @default null

     */
    map: null,

    /**
     * map的容器
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @type {Object}

     */
    container: null,

    /**
     * 图层容器
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @type {Array}
     */
    layers: [],

    /**
     * @member Three在GL地图上的适配器
     * @type {Object}
     * @private
     */
    _threebox: null,

    /**
     * @member 拾取器
     * @type {Object}
     * @private
     */
    _raycaster: null,

    /**
     * @member 屏幕点击点二维坐标
     * @type {Vector2}
     * @private
     */
    _raycAsix: null,

    /**
     * @function initialize
     * @description  GeoGlobe.Visuals.Three构造函数。
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        GeoGlobe.Visuals.prototype.initialize.apply(this, arguments);
        this.layers = [];
        if (!window.THREE || !window.Threebox) {
            console.error("使用three可视化图层前，需引入threejs库！");
            return;
        }
        this._raycaster = new THREE.Raycaster();//拾取器
        this._raycAsix = new THREE.Vector2();//屏幕点击点二维坐标
    },

    /**
     * @function addTo
     * @description 与gl地图对象关联
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @public
     * @param {Object} map -  gl地图对象
     */
    addTo: function (map) {
        GeoGlobe.Visuals.prototype.addTo.apply(this, arguments);

        this.container.className = "geoglobe-three-container";

        this._threebox = new Threebox(this.map, this.container);
        this._threebox.setupDefaultLights();
        this._bindEvent();

    },

    /**
     * @function render
     * @description 绘制图层，包含子图层
     * @memberof GeoGlobe.Visuals.Three.prototype
     */
    render: function () {
        if (this._order) {
            for (var p = 0; p < this._order.length; p++) {
                for (var i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].id == this._order[p]) {
                        this.layers[i].render();
                    }
                }
            }
        } else {
            for (var i = 0; i < this.layers.length; i++) {
                this.layers[i].render();
            }
        }
        this._render();
    },

    /**
     * threejs内部重绘
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @private
     */
    _render: function () {
        this._threebox.render();
    },

    /**
     * @function addLayer
     * @description 向threejs可视化图层中添加子图层
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @param {Object} layer - Three命名空间下的子图层对象
     */
    addLayer: function (layer) {
        if (!layer.id) {
            console.error("图层id属性不能为空！");
            return;
        }
        var oldLayer = this.getLayer(layer.id);
        if (oldLayer) {
            oldLayer = layer;
        } else {
            this.layers.push(layer);
        }
    },

    /**
     * @function removeLayer
     * @description 移除图层
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @param {string} id - 图层id
     */
    removeLayer: function (id) {
        var array = [];
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                this._removeInnerLayer(this.layers[i]);
                continue;
            }
            array.push(this.layers[i]);
        }
        this.layers = array;
    },

    /**
     * 移动图层
     * @function moveLayer
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @param {String} id 图层id
     */
    moveLayer: function moveLayer(id, before) {
        var layer = this.getLayer(id);
        if (!layer) {
            this.fire('error', {
                error: new Error(
                    "The layer '" + id + "' does not exist in " +
                    "the map's style and cannot be moved."
                )
            });
            return;
        }

        this._order = this.layers.map(function (Layer) {
            return Layer.id;
        });
        var index = this._order.indexOf(id);
        this._order.splice(index, 1);

        var newIndex = before ? this._order.indexOf(before) : this._order.length;
        if (before && newIndex === -1) {
            this.fire('error', {error: new Error(("Layer with id \"" + before + "\" does not exist on this map."))});
            return;
        }
        this._order.splice(newIndex, 0, id);
    },

    /**
     * 移除内部图层元素，mesh
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @param {GeoGlobe.Visuals.Three.XXXLayer} - 子图层实例
     * @private
     */
    _removeInnerLayer: function (layer) {
        if (layer._meshes && layer._meshes instanceof Array && layer._meshes.length > 0) {
            for (var j = 0; j < layer._meshes.length; j++) {
                for (var i = 0; i < this._threebox.world.children.length; i++) {
                    if (this._threebox.world.children[i].children.length === 0) {
                        continue;
                    }
                    if (this._threebox.world.children[i].children[0].uuid === layer._meshes[j].uuid) {
                        this._threebox.world.remove(layer._meshes[j].parent);
                        break;
                    }
                }
                for (var i = 0; i < this._threebox.world2.children.length; i++) {
                    if (this._threebox.world2.children[i].children.length === 0) {
                        continue;
                    }
                    if (this._threebox.world2.children[i].children[0].uuid === layer._meshes[j].uuid) {
                        this._threebox.world2.remove(layer._meshes[j].parent);
                        break;
                    }
                }
            }
        }
    },

    /**
     * @function getLayer
     * @description 获取指定id图层
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @param {string} id - 图层id.
     * @returns {Object} Layer
     */
    getLayer: function (id) {
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                return this.layers[i];
            }
        }
    },

    /**
     * 通过webgl世界坐标系坐标反算地理坐标，例如点击建筑物获取高度及其经纬度
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @param {Point} point - {x:15.145329754799604, y:-73.6837176498957, z:240.09772653562322}
     * @returns {Array} xyz
     * @example
     //绑定鼠标点击事件
     threebox.on('overlayerclick', function(event){
			if(event && event.param && event.param.pickedInfos){
		    	var xyz = threebox.unprojectFromWorld(event.param.pickedInfos[0].point);	    	
			}
		});
     */
    unprojectFromWorld: function (point) {
        var matrix = new THREE.Matrix4();
        matrix.getInverse(this._threebox.world.matrixWorld);
        var vector = point.applyMatrix4(matrix);
        var xyz = this._threebox.unprojectFromWorld(vector);
        return xyz;
    },

    /**
     * @method
     * @desc 绑定事件
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @private
     */
    _bindEvent: function () {
        var _this = this;
        this.map.on('click', function THREE_CLICK_EVENT(e) {
            _this._onClick(e);
        });
        this.map.on('mousemove', function THREE_MOUSEMOVE_EVENT(e) {
            _this._onMouseMove(e);
        });
    },

    /**
     * @method
     * @desc 解绑事件
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @private
     */
    _unbindEvent: function () {
        var _this = this;
        for (var i = 0; i < this.map._listeners['click'].length; i++) {
            if (this.map._listeners['click'][i].name && this.map._listeners['click'][i].name === 'THREE_CLICK_EVENT') {
                this.map._listeners['click'].splice(i, 1);
            }
        }
        for (var i = 0; i < this.map._listeners['mousemove'].length; i++) {
            if (this.map._listeners['mousemove'][i].name && this.map._listeners['mousemove'][i].name === 'THREE_MOUSEMOVE_EVENT') {
                this.map._listeners['mousemove'].splice(i, 1);
            }
        }
    },

    /**
     * @method
     * @desc 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @private
     */
    _onMouseMove: function (event) {
        var intersects = this._computerIntersect(event);
        if (intersects.length > 0) {
            this.fire("overlayerhover", {
                param: {
                    info: this._getSymbolObject(intersects[0].object),
                    pickedInfos: intersects,
                    event: event
                }
            });
        }
    },

    /**
     * @method
     * @desc 鼠标指针单击事件
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @private
     */
    _onClick: function (event) {
        var intersects = this._computerIntersect(event);
        if (intersects.length > 0) {
            this.fire("overlayerclick", {
                param: {
                    info: this._getSymbolObject(intersects[0].object),
                    pickedInfos: intersects,
                    event: event
                }
            });
        }
    },

    /**
     * @method _computerIntersect
     * @desc 求点击射线相交
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @private
     */
    _computerIntersect: function (event) {
        this._raycAsix.x = ( (event.originalEvent.pageX - this.container.offsetLeft) / this.container.offsetWidth ) * 2 - 1;
        this._raycAsix.y = -( (event.originalEvent.pageY - this.container.offsetTop) / this.container.offsetHeight ) * 2 + 1;
        this._raycaster.setFromCamera(this._raycAsix, this._threebox.camera);
        return this._raycaster.intersectObjects(this._threebox.scene.children, true);//获取投射线上与用户预设的可被点击物体的集合的交集
    },

    /**
     * @method _getSymbolObject
     * @desc 递归查找父级为Symbol的obj
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @param {Object3D} - Object3D及其派生类实例
     * @private
     */
    _getSymbolObject: function (obj) {
        if (obj.userData.attributes) {
            return obj;
        } else {
            return this._getSymbolObject(obj.parent);
        }
    }

})﻿/**
 * @class GeoGlobe.Visuals.Three.PointLayer
 * @desc 点图层
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -47,
	pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});
 //构造THREE可视化图层
 var threebox = new GeoGlobe.Visuals.Three();
 //添加到地图中
 threebox.addTo(map);
 //构造点图层
 var pointLayer = new GeoGlobe.Visuals.Three.PointLayer({
	id: '3D point',
    data: [{"type":"Feature","properties":{"name": "一号点","size": 600, color: "skyblue"},"geometry":{"type":"Point","coordinates":[114.27467721499235,30.61823619840472,19.61132758430084]}},
            {"type":"Feature","properties":{"name": "二号点","size": 300, color: "rgb(255, 120, 0)"},"geometry":{"type":"Point","coordinates":[114.29877951124801,30.64353276353745,504.0792309408988]}},
            {"type":"Feature","properties":{"name": "三号点","size": 400, color: "0xf000f0"},"geometry":{"type":"Point","coordinates":[114.30891430616117,30.627087672503677,574.7427843331463]}},
            {"type":"Feature","properties":{"name": "四号点","size": 500, color: "hsl(0, 100%, 50%)"},"geometry":{"type":"Point","coordinates":[114.30712328993215,30.63381498764412,873.3612366333414]}},
            {"type":"Feature","properties":{"name": "五号点","size": 1200, texture: "../../images/snowflake2.png"},"geometry":{"type":"Point","coordinates":[114.24294237237757,30.6023344482078,614.1713466047934]}}],
    visible: true,
    pickable: true,
    opacity: 1
});
 //添加到THREE图层
 pointLayer.addTo(threebox);
 //绘制
 threebox.render();
 */
GeoGlobe.Visuals.Three.PointLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 可见性
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * 是否可拾取
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {Boolean}
     * @default true
     */
    pickable: true,

    /**
     * 透明度 0-1
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {Number}
     * @default 1.0
     */
    opacity: 1.0,

    /**
     * 数据
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {Array}
     * @example
     * [{
	 * 	"type":"Feature",
	 * 	"properties":{
	 * 		"id": 100001,
	 * 		"name":"",
	 * 		"size":100,
	 * 		"color":"#ddd", //颜色纹理。如果没有纹理图片时，则有效。 图片纹理优先于颜色纹理。
	 * 		"texture":'assets/textures/building.png' //图片纹理，顶部纹理
	 * 	},
	 * 	"geometry":{
	 * 		"type":"Point",
	 * 		"coordinates":[114.27731517981033,30.597299735680195,0]
	 * 	}
	 * }]
     */
    data: [],

    /**
     * 颜色GET属性
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} color - 颜色值
     */
    getColor: function (data) {
        if (data.properties.color) {
            return data.properties.color;
        } else {
            return 'rgb(255, 0, 0)';
        }
    },

    /**
     * 纹理图片资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} texture - 图片纹理资源路径
     */
    getTexture: function (data) {
        return data.properties.texture ? data.properties.texture : '';
    },

    /**
     * 点几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} coordinates - 返回点的坐标数组
     */
    getPoint: function (data) {
        if (data.geometry.type === 'Point') {
            return data.geometry.coordinates;
        } else {
            return null;
        }
    },

    /**
     * 点尺寸的GET属性
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Number} size - 尺寸值
     */
    getSize: function (data) {
        return data.properties.size ? data.properties.size : 1;
    },

    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,

    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @private
     * @type {Array}
     */
    _meshes: [],

    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {Array}
     * @private
     * @default ''
     */
    _textureCache: [],

    /**
     * @name GeoGlobe.Visuals.Three.PointLayer构造函数。
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
        this.visible = options.visible ? options.visible : this.visible;
        this.opacity = options.opacity ? options.opacity : this.opacity;
        this.pickable = options.pickable ? options.pickable : this.pickable;
        this.data = options.data ? options.data : this.data;
        this.getColor = options.getColor ? options.getColor : this.getColor;
        this.getTexture = options.getTexture ? options.getTexture : this.getTexture;
        this.getPoint = options.getPoint ? options.getPoint : this.getPoint;
        this.getSize = options.getSize ? options.getSize : this.getSize;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three
     */
    addTo: function (three) {
        this._three = three;
        this._three.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     */
    remove: function () {
        this._three.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     */
    render: function () {
        var _this = this;
        _this._three._removeInnerLayer(_this);
        _this._meshes = [];

        for (var k = 0; k < _this.data.length; k++) {
            var data = _this.data[k];
            var material = null;
            var textureURL = _this.getTexture(data);
            if (textureURL) {
                var texture = _this._getTextureCacheByURL(textureURL);
                if (texture) {
                    texture = texture.clone();
                } else {
                    texture = new THREE.TextureLoader().load(textureURL, function (t) {
                        _this._three._render();
                    });
                    _this._addTextureInToCache({
                        key: textureURL,
                        value: texture
                    })
                }
                material = new THREE.MeshPhongMaterial({map: texture});
            } else {
                material = new THREE.MeshPhongMaterial({color: new THREE.Color(_this.getColor(data))});
            }

            var size = _this.getSize(data);
            var scaleSize = Threebox.ThreeboxConstants.PROJECTION_WORLD_SIZE * size;

            var geometry = new THREE.CircleBufferGeometry(scaleSize / 2, 20);
            var point = new THREE.Mesh(geometry, material);
            var coords = _this.data[k].geometry.coordinates;
            var position = _this._three._threebox.projectToWorld(coords);
            point.position.set(position.x, position.y, position.z);
            point.visible = _this.visible;
            point.name = (_this.id ? _this.id : "threelayer") + "-" + k;
            point.userData.attributes = {
                OriginalData: data,
                Layer: _this
            };
            _this._three._threebox.addGeoreferencedMesh(point);
            _this._meshes.push(point);
            _this._three._render();
        }
    },

    /**
     * 从缓存中获取纹理
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @private
     * @param {String} url - 图片纹理资源路径
     * @returns {Object} texture - 图片纹理
     */
    _getTextureCacheByURL: function (url) {
        if (url) {
            for (var i = 0; i < this._textureCache.length; i++) {
                if (this._textureCache[i].key === url && this._textureCache[i].value.image) {
                    return this._textureCache[i].value;
                }
            }
            return null;
        } else {
            return null;
        }
    },
    /**
     * 向缓存中添加纹理
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @private
     * @param {Object} map {key: sideTextureURL,value: textureSide}
     */
    _addTextureInToCache: function (map) {
        var isExist = false;
        for (var i = 0; i < this._textureCache.length; i++) {
            if (this._textureCache[i].key === map.key) {
                isExist = true;
                break;
            }
        }
        if (!isExist) {
            this._textureCache.push(map);
        }
    }
});/**
 * @class GeoGlobe.Visuals.Three.LineLayer
 * @desc 三维线图层
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -47,
	pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});
 //构造THREE可视化图层
 var threebox = new GeoGlobe.Visuals.Three();
 //添加到地图中
 threebox.addTo(map);
 //构造线图层
 var lineLayer = new GeoGlobe.Visuals.Three.LineLayer({
	id: '3D line',
    data: [],
    visible: true,
    pickable: true,
    opacity: 1
});
 //添加到THREE图层
 lineLayer.addTo(threebox);
 //绘制
 threebox.render();
 */
GeoGlobe.Visuals.Three.LineLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 可见性
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * 是否可拾取
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @type {Boolean}
     * @default true
     */
    pickable: true,

    /**
     * 透明度 0-1
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @type {Number}
     * @default 1.0
     */
    opacity: 1.0,

    /**
     * 数据
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @type {Array}
     * @example
     * [{
	 * 	"type":"Feature",
	 * 	"properties":{
	 * 		"id": 100001,
	 * 		"name":"",
	 * 		"width":1,
	 * 		"color":"#ddd", //颜色纹理。如果没有纹理图片时，则有效。 图片纹理优先于颜色纹理。
	 * 		"texture":'' //图片纹理，顶部纹理
	 * 	},
	 * 	"geometry":{
	 * 		"type":"LineString",
	 * 		"coordinates":[[114.27467721499235,30.61823619840472,19.61132758430084],[114.29877951124801,30.64353276353745,504.0792309408988]]
	 * 	}
	 * }]
     */
    data: [],

    /**
     * 颜色GET属性
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} color - 颜色值
     */
    getColor: function (data) {
        if (data.properties.color) {
            return data.properties.color;
        } else {
            return 'rgb(255, 0, 0)';
        }
    },

    /**
     * 纹理图片资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} texture - 图片纹理资源路径
     */
    getTexture: function (data) {
        return data.properties.texture ? data.properties.texture : '';
    },

    /**
     * 线几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} coordinates - 返回线的坐标数组
     */
    getLineString: function (data) {
        if (data.geometry.type === 'LineString') {
            return data.geometry.coordinates;
        } else {
            return null;
        }
    },

    /**
     * 线宽度的GET属性
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Number} size - 线宽值
     */
    getWidth: function (data) {
        return data.properties.width ? data.properties.width : 1;
    },

    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,

    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @private
     * @type {Array}
     */
    _meshes: [],

    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @type {Array}
     * @private
     * @default ''
     */
    _textureCache: [],

    /**
     * @name GeoGlobe.Visuals.Three.PointLayer构造函数。
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
        this.visible = options.visible ? options.visible : this.visible;
        this.opacity = options.opacity ? options.opacity : this.opacity;
        this.pickable = options.pickable ? options.pickable : this.pickable;
        this.data = options.data ? options.data : this.data;
        this.getColor = options.getColor ? options.getColor : this.getColor;
        this.getTexture = options.getTexture ? options.getTexture : this.getTexture;
        this.getLineString = options.getLineString ? options.getLineString : this.getLineString;
        this.getWidth = options.getWidth ? options.getWidth : this.getWidth;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three
     */
    addTo: function (three) {
        this._three = three;
        this._three.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     */
    remove: function () {
        this._three.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.LineLayer.prototype
     */
    render: function () {
        var _this = this;
        _this._three._removeInnerLayer(_this);
        _this._meshes = [];

        for (var k = 0; k < _this.data.length; k++) {
            var data = _this.data[k];
            var material = new THREE.LineMaterial({color: new THREE.Color(_this.getColor(data)), linewidth: 0.0005 * _this.getWidth(data)});
            var positions = [];
            var coords = _this.data[k].geometry.coordinates;
            for (var i = 0; i < coords.length; i++) {
                var position = _this._three._threebox.projectToWorld(coords[i]);
                positions.push(position.x, position.y, position.z);
            }
            var geometry = new THREE.LineGeometry();
            geometry.setPositions(positions);
            var line = new THREE.Line2(geometry, material);
            line.computeLineDistances();
            line.visible = _this.visible;
            line.name = (_this.id ? _this.id : "threelayer") + "-" + k;
            line.userData.attributes = {
                OriginalData: data,
                Layer: _this
            };
            _this._three._threebox.addGeoreferencedMesh(line);
            _this._meshes.push(line);
            _this._three._render();
        }
    }
});/**
 * @class GeoGlobe.Visuals.Three.PolygonLayer
 * @desc 多边形图层
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -47,
	pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});
 //构造THREE可视化图层
 var threebox = new GeoGlobe.Visuals.Three();
 //添加到地图中
 threebox.addTo(map);
 //构造点图层
 var polygonLayer = new GeoGlobe.Visuals.Three.PolygonLayer({
	id: '3D point',
    data: [{"type":"Feature","properties":{"name": "一号多边形", color: "skyblue"},"geometry":{"type":"Polygon","coordinates":[]}},
            {"type":"Feature","properties":{"name": "二号多边形", color: "rgb(255, 120, 0)"},"geometry":{"type":"Polygon","coordinates":[]}}],
    visible: true,
    pickable: true,
    opacity: 1
});
 //添加到THREE图层
 polygonLayer.addTo(threebox);
 //绘制
 threebox.render();
 */
GeoGlobe.Visuals.Three.PolygonLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 可见性
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * 是否可拾取
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @type {Boolean}
     * @default true
     */
    pickable: true,

    /**
     * 透明度 0-1
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @type {Number}
     * @default 1.0
     */
    opacity: 1.0,

    /**
     * 数据
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @type {Array}
     * @example
     * [{
	 * 	"type":"Feature",
	 * 	"properties":{
	 * 		"id": 100001,
	 * 		"name":"",
	 * 		"color":"#ddd", //颜色纹理。如果没有纹理图片时，则有效。 图片纹理优先于颜色纹理。
	 * 		"texture":'assets/textures/building.png' //图片纹理，顶部纹理
	 * 	},
	 * 	"geometry":{
	 * 		"type":"Polygon",
	 * 		"coordinates":[]
	 * 	}
	 * }]
     */
    data: [],

    /**
     * 颜色GET属性
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} color - 颜色值
     */
    getColor: function (data) {
        if (data.properties.color) {
            return data.properties.color;
        } else {
            return 'rgb(255, 0, 0)';
        }
    },

    /**
     * 纹理图片资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} texture - 图片纹理资源路径
     */
    getTexture: function (data) {
        return data.properties.texture ? data.properties.texture : '';
    },

    /**
     * 多边形几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} coordinates - 返回面的坐标数组
     */
    getPolygon: function (data) {
        if (data.geometry.type === 'Polygon') {
            return data.geometry.coordinates;
        } else {
            return null;
        }
    },

    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,

    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @private
     * @type {Array}
     */
    _meshes: [],

    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @type {Array}
     * @private
     * @default ''
     */
    _textureCache: [],

    /**
     * @name GeoGlobe.Visuals.Three.PointLayer构造函数。
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
        this.visible = options.visible ? options.visible : this.visible;
        this.opacity = options.opacity ? options.opacity : this.opacity;
        this.pickable = options.pickable ? options.pickable : this.pickable;
        this.data = options.data ? options.data : this.data;
        this.getColor = options.getColor ? options.getColor : this.getColor;
        this.getTexture = options.getTexture ? options.getTexture : this.getTexture;
        this.getPolygon = options.getPolygon ? options.getPolygon : this.getPolygon;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three
     */
    addTo: function (three) {
        this._three = three;
        this._three.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     */
    remove: function () {
        this._three.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     */
    render: function () {
        var _this = this;
        _this._three._removeInnerLayer(_this);
        _this._meshes = [];

        for (var k = 0; k < _this.data.length; k++) {
            var data = _this.data[k];
            var material = null;
            var textureURL = _this.getTexture(data);
            if (textureURL) {
                var texture = _this._getTextureCacheByURL(textureURL);
                if (texture) {
                    texture = texture.clone();
                } else {
                    texture = new THREE.TextureLoader().load(textureURL, function (t) {
                        _this._three._render();
                    });
                    _this._addTextureInToCache({
                        key: textureURL,
                        value: texture
                    })
                }
                material = new THREE.MeshPhongMaterial({map: texture});
            } else {
                material = new THREE.MeshPhongMaterial({color: new THREE.Color(_this.getColor(data))});
            }
            var shape = new THREE.Shape();
            var coords = _this.data[k].geometry.coordinates;
            for (var i = 0; i < coords.length; i++) {
                var start = _this._three._threebox.projectToWorld(coords[i][0]);
                shape.moveTo(start.x, start.y);
                for (var j = 1; j < coords[i].length; j++) {
                    var position = _this._three._threebox.projectToWorld(coords[i][j]);
                    shape.lineTo(position.x, position.y);
                }
            }
            var geometry = new THREE.ShapeBufferGeometry(shape);
            var polygon = new THREE.Mesh(geometry, material);
            polygon.visible = _this.visible;
            polygon.name = (_this.id ? _this.id : "threelayer") + "-" + k;
            polygon.userData.attributes = {
                OriginalData: data,
                Layer: _this
            };
            _this._three._threebox.addGeoreferencedMesh(polygon);
            _this._meshes.push(polygon);
            _this._three._render();
        }
    },

    /**
     * 从缓存中获取纹理
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @private
     * @param {String} url - 图片纹理资源路径
     * @returns {Object} texture - 图片纹理
     */
    _getTextureCacheByURL: function (url) {
        if (url) {
            for (var i = 0; i < this._textureCache.length; i++) {
                if (this._textureCache[i].key === url && this._textureCache[i].value.image) {
                    return this._textureCache[i].value;
                }
            }
            return null;
        } else {
            return null;
        }
    },
    /**
     * 向缓存中添加纹理
     * @memberof GeoGlobe.Visuals.Three.PolygonLayer.prototype
     * @private
     * @param {Object} map {key: sideTextureURL,value: textureSide}
     */
    _addTextureInToCache: function (map) {
        var isExist = false;
        for (var i = 0; i < this._textureCache.length; i++) {
            if (this._textureCache[i].key === map.key) {
                isExist = true;
                break;
            }
        }
        if (!isExist) {
            this._textureCache.push(map);
        }
    }
});/**
 * @author liuck
 * @class GeoGlobe.Visuals.Three.SymbolLayer
 * @classdesc 3D模型符号图层
 * @example 
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -138.23,
	pitch: 57.50,
	units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
});
//构造THREE可视化图层
var threebox = new GeoGlobe.Visuals.Three();
//添加到地图中
threebox.addTo(map);
//构造符号图层，汽车模型 ，glTF格式
var symbolLayer2 = new GeoGlobe.Visuals.Three.SymbolLayer({
	id: '3D marker 2',
	data: [
		{"type": "Feature","properties": {"id": 10001, "name": "五号汽车","height": 0 }, "geometry": {"type": "Point","coordinates": [114.20257245367856, 30.773372078561778]}}
	],
	visible: true,
	pickable: true,
	opacity: 1,
	scale: 20,
	modelURL: "../../data/CesiumMilkTruck/CesiumMilkTruck.gltf",
	getGeometry: function(geometry, data){
	    geometry.rotateX((90/360)*2*Math.PI);
	    geometry.rotateY((-90/360)*2*Math.PI);
	    return geometry
	},
	getLoader: function(){
		return new THREE.GLTFLoader() //glTF versions >= 2.0
	}
})
//添加到THREE图层
symbolLayer2.addTo(threebox);
//绘制
threebox.render();
 */

GeoGlobe.Visuals.Three.SymbolLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否可拾取
	 * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 透明度 0-1
	 * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
	 * @type {Float}
	 * @default 1.0
	 */
	opacity: 1.0,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
	 * @type {Array}
	 * @example 
	 * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "五号汽车",
	 * 		"height": 0
	 * 	},
	 * "geometry": {
	 * 		"type": "Point",
	 * 		"coordinates": [114.20257245367856, 30.773372078561778]
	 * 	}
	 * }]
	 */
	data: [],
	
	/**
	 * 缩放比例 1-~
	 * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
	 * @type {Int}
	 * @default 1
	 */
    scale: 1,
    
    /**
     * 3D符号模型文件路径
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @type {String}
     * @default ''
     */
    modelURL: '',
    
    /**
     * 是否自动播放模型动画
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @type {Boolean}
     * @default false
     */
    autoplay: false,
    
    /**
     * 颜色GET属性
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} color - 颜色值
     */
    getColor: function (data) {
    	if(data.properties.color){
    		return data.properties.color;
    	}else{
    		return 'rgb(255, 0, 0)';    		
    	}
    },
    
    /**
     * 地理位置GET属性
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} point - [x,y,z]
     */
    getPosition: function(data){
 	    if(data.geometry.type === 'Point'){
    		var point = data.geometry.coordinates;
    		if(data.properties.height){
    			point.push(data.properties.height);
    		}else{
    			point.push(0);
    		}
    		return point;
    	}else{
    		return null;
    	}
    },

    /**
     * 几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @param {Geometry} geometry - THREE.Geometry
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Geometry} geometry - 可对geometry平移旋转缩放后的
     */
    getGeometry: function(geometry, data){
        return geometry;
    },
    
    /**
     * 模型加载器GET属性
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @returns {Loader} loader
     * @example 
     * return THREE.JSONLoader() //或
     * return THREE.GLTFLoader()
     */
    getLoader: function(){
        return new THREE.JSONLoader();
    },
    
    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,
    
    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @private 
     * @type {Array}
     */
    _meshes: [],
    
    /**
     * 动画计时器
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @private 
     * @type {THREE.Clock}
     */
    _clock: null,
    
    /**
     * 动画播放器
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @private 
     * @property {THREE.AnimationMixer} - THREE.AnimationMixer的实例
     */
    _mixer: null,
    
    /**
     * 模型缓存
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @private 
     * @property {Object} - 模型
     */
    _modelCache: null,
    
    /**
     * @name GeoGlobe.Visuals.Three.SymbolLayer构造函数。
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.id = options.id? options.id: this.id;
    	this.visible = options.visible? options.visible: this.visible;
    	this.opacity = options.opacity? options.opacity: this.opacity;
    	this.pickable = options.pickable? options.pickable: this.pickable;
    	this.data = options.data? options.data: this.data;
    	this.scale = options.scale? options.scale: this.scale;
    	this.modelURL = options.modelURL? options.modelURL: this.modelURL;
    	this.autoplay = options.autoplay? options.autoplay: this.autoplay;
    	this.getColor = options.getColor? options.getColor: this.getColor;
    	this.getPosition = options.getPosition? options.getPosition: this.getPosition;
    	this.getGeometry = options.getGeometry? options.getGeometry: this.getGeometry;
    	this.getLoader = options.getLoader? options.getLoader: this.getLoader;
    	this._clock = new THREE.Clock();
    },
    
    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three 
     */
    addTo: function(three){
    	this._three = three;
    	this._three.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     */
    remove: function(){
    	this._three.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     */
    render: function(){
    	var _this = this;
    	_this._modelCache = null;
        _this.getLoader().load(_this.modelURL, function(data) {
            _this._modelCache = data;
            _this._draw();
		}, function(xhr){
            console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
        }, function(err){
            console.error(err);
        });
    },
    
    /**
     * 重绘
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @description 重绘但不重新加载模型
     */
    redraw: function(){
    	if(this._modelCache){
    		this._draw();
    	}else{
    		this.render();
    	}
    },
    
    /**
     * 渲染
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @private 
     */
    _draw: function(){
    	this._three._removeInnerLayer(this);
    	this._meshes = [];
    	var data = this._modelCache;
    	for(var i=0; i<this.data.length; i++){
        	if(data.scene){
        		//因带骨骼动画的gltf在克隆后不显示，故暂时对带骨骼动画的不进行拷贝
        		if(this.autoplay){
        			symbol = data.scene;
        			symbol = this.getGeometry(symbol, this.data[i]);
        			var animations = data.animations;
        			if (animations && animations.length) {
        				var mixer = new THREE.AnimationMixer(symbol);
        				for (var j = 0; j < animations.length; j++ ) {
        					var animation = animations[j];
        					mixer.clipAction(animation).play();
        				}
        				this._mixer = mixer;
        			}
        		}else{
        			symbol = data.scene.clone();
            		symbol = this.getGeometry(symbol, this.data[i]);
        		}
        	}else if(data instanceof THREE.Group){
        		symbol = data.clone();
        		symbol = this.getGeometry(symbol, this.data[i]);
        	}else{
        		var geometry = this.getGeometry(data.clone(), this.data[i]);
        		var material = new THREE.MeshLambertMaterial( {color: new THREE.Color(this.getColor(this.data[i])), side: THREE.DoubleSide}); 
        		var mesh = new THREE.Mesh( geometry, material );
        		
        		symbol = mesh.clone();
        	}
            symbol.visible = this.visible;
            symbol.name = (this.id?this.id:"threelayer") + "-" + i;
            symbol.userData.attributes = {
                OriginalData: this.data[i],
                Layer: this
            };
            var scale = this.scale? this.scale: 1.0;
            var position = this.getPosition(this.data[i]);
            if(Array.isArray(position)){
                if(position.length<3){
                    position.push(0);
                }
                this._three._threebox.addAtCoordinate(symbol, position, {scaleToLatitude: true, preScale: scale});               
            }
            this._meshes.push(symbol);
        }
        this._three._render();
        this._animate();
    },
    
    /**
     * 动画
     * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
     * @private 
     */
    _animate: function() {
    	var _this = this;
    	if(!_this.autoplay){
    		return;
    	}
    	_this._mixer.update(_this._clock.getDelta());
    	_this._three._render();
		requestAnimationFrame(function(){
			_this._animate();
		});
	}
    
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.Three.BuildingLayer
 * @classdesc 建筑物图层，通过矢量面拉伸而来。
 * @example 
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -47,
	pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});
//构造THREE可视化图层
var threebox = new GeoGlobe.Visuals.Three();
//绑定鼠标点击事件
threebox.on('overlayerclick', function(e){
	var xyz = threebox.unprojectFromWorld(e.param.pickedInfos[0].point);
	alert(e.param.info.userData.attributes.OriginalData.properties.name + '\n经纬度及高程:' + xyz);
});
//绑定鼠标移动事件
threebox.on('overlayerhover', function(e){
	console.info(e);
})
//添加到地图中
threebox.addTo(map);
//构造建筑图层
var buildingLayer = new GeoGlobe.Visuals.Three.BuildingLayer({
	id: '3D building',
    data: [
		{"type":"Feature","properties":{"level":1,"name":"中国邮政储蓄银行（湖北省分行营业部）","height":280,"base_height":0,"color":"#ddd"},"geometry":{"type":"Polygon","coordinates":[[[114.26730001377071,30.595149654035424],[114.26737510423808,30.594983416111138],[114.26728930608508,30.594946561374197],[114.26731076201405,30.59488191979089],[114.26717133751096,30.594845110133267],[114.26709624642238,30.59501134779343],[114.26717132160428,30.595029748326304],[114.26713914030533,30.595094398742066],[114.26707478473918,30.59514061236826],[114.26699970846724,30.59513144350006],[114.26698898951582,30.59505759734068],[114.26678520845394,30.595048535449614],[114.26677447111632,30.595187022721653],[114.26687099882221,30.59519617428873],[114.26687099245959,30.595270029320062],[114.26707477280914,30.595279090587976],[114.26730001377071,30.595149654035424]]]}},
		{"type":"Feature","properties":{"level":1,"name":"凯盟大厦","height":30,"base_height":0,"color":"#ddd"},"geometry":{"type":"Polygon","coordinates":[[[114.26804014434877,30.59393963131797],[114.268050873183,30.59389346186711],[114.2680723228841,30.593893443111675],[114.26807232367943,30.593884211092995],[114.26800798326931,30.593782715043524],[114.26798653351257,30.59378273375209],[114.26798653351257,30.59378273375209],[114.26777203890069,30.59373675981695],[114.26775058416766,30.59379217054334],[114.26792217935898,30.593838181945106],[114.26793290347216,30.59384740463971],[114.26795435247995,30.593856617992756],[114.26797579908315,30.593893527388122],[114.26797579669712,30.593921223438407],[114.26798652078709,30.593930446104824],[114.26793288358859,30.594078204914656],[114.26779346180174,30.594050629883768],[114.26773982498072,30.594189156154734],[114.26793287006767,30.594235148758642],[114.26799723453291,30.59405968485938],[114.26804014434877,30.59393963131797]]]}},
		{"type":"Feature","properties":{"level":1,"name":"天下·国际公馆","height":80,"base_height":0,"color":"#b0c4de","side_texture":'../../images/building3.png'},"geometry":{"type":"Polygon","coordinates":[[[114.26934845937154,30.59490781536552],[114.26933774779835,30.5947601144835],[114.26881224988759,30.594779055829616],[114.26881223716111,30.594926766522196],[114.26934845937154,30.59490781536552]]]}}
	],
    visible: true,
    pickable: true,
    opacity: 1,
    drawMode:{
    	high:{
    		minZoom: 14,
    		maxZoom: 15
    	},
    	middle:{
    		minZoom: 16,
    		maxZoom: 17
    	},
    	low:{
    		minZoom: 18,
    		maxZoom: 20
    	}
    }
});
//添加到THREE图层
buildingLayer.addTo(threebox);
//绘制
threebox.render();

 */
GeoGlobe.Visuals.Three.BuildingLayer = GeoGlobe.Class4OL({
	/**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否可拾取
	 * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 透明度 0-1
	 * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
	 * @type {Float}
	 * @default 1.0
	 */
	opacity: 1.0,
	
	/**
	 * 高中低绘制机制，在zoom区间采用不同的绘制机制：'high'作为整体绘制，'middle'单个建筑绘制，'low'精细模型绘制
	 * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
	 * @type {Object}
	 * @default
	 * {
	    	high:{
	    		minZoom: 14,
	    		maxZoom: 15
	    	},
	    	middle:{
	    		minZoom: 16,
	    		maxZoom: 17
	    	},
	    	low:{
	    		minZoom: 18,
	    		maxZoom: 20
	    	}
	    }
	 */
    drawMode: {
    	high:{
    		minZoom: 14,
    		maxZoom: 15
    	},
    	middle:{
    		minZoom: 16,
    		maxZoom: 17
    	},
    	low:{
    		minZoom: 18,
    		maxZoom: 20
    	}
    },
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
	 * @type {Array}
	 * @example 
	 * [{
	 * 	"type":"Feature",
	 * 	"properties":{
	 * 		"id": 100001,
	 * 		"level":1,
	 * 		"name":"中国银行（武汉新台北支行）",
	 * 		"height":50,
	 * 		"base_height":0,
	 * 		"color":"#ddd", //颜色纹理。如果没有纹理图片时，则有效。 图片纹理优先于颜色纹理。
	 * 		"face_texture":'assets/textures/building.png', //图片纹理，顶部纹理
	 * 		"side_texture":'assets/textures/building2.png' //图片纹理，侧面纹理
	 * 	},
	 * 	"geometry":{
	 * 		"type":"Polygon",
	 * 		"coordinates":[[[114.27731517981033,30.597299735680195],[114.2771650822979,30.59732760632838],[114.27706858577743,30.597401572142914],[114.2771114663513,30.597447680396996],[114.27731517981033,30.597299735680195]]]
	 * 	}
	 * }]
	 */
	data: [],
    
    /**
     * 颜色GET属性
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} color - 颜色值
     * @default data.properties.color
     */
    getColor: function (data) {
    	if(data.properties.color){
    		return data.properties.color;
    	}else{
    		return 'rgb(255, 0, 0)';    		
    	}
    },
    
    /**
     * 建筑顶部纹理图片资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} uri - 图片路径
     * @default data.properties.face_texture
     */
    getFaceTexture: function(data){
        return data.properties.face_texture? data.properties.face_texture: '';
    },
    
    /**
     * 建筑顶部纹理平铺参数GET属性
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} repeat - 平铺参数 '10,10'
     * @default data.properties.face_texture_repeat
     */
    getFaceTextureRepeat: function(data){
        return data.properties.face_texture_repeat? data.properties.face_texture_repeat: '10,10';
    },
    
    /**
     * 建筑侧部纹理图片资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} uri - 图片路径
     * @default data.properties.side_texture
     */
    getSideTexture: function(data){
        return data.properties.side_texture? data.properties.side_texture: '';
    },
    
    /**
     * 建筑侧部纹理平铺参数GET属性
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} repeat - 平铺参数 '30,30'
     * @default data.properties.side_texture_repeat
     */
    getSideTextureRepeat: function(data){
        return data.properties.side_texture_repeat? data.properties.side_texture_repeat: '30,30';
    },

    /**
     * 多边形几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} coordinates - 返回组成多边形的坐标数组
     * @default data.geometry.coordinates
     * @example 
     * [[[114.27731517981033,30.597299735680195],[114.2771650822979,30.59732760632838],[114.27706858577743,30.597401572142914],[114.2771114663513,30.597447680396996],[114.27731517981033,30.597299735680195]]]
     */
    getPolygon: function(data){
    	if(data.geometry.type === 'Polygon'){    		
    		return data.geometry.coordinates;
    	}else{
    		return null;
    	}
    },
    
    /**
     * 建筑高程的GET属性
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Int} elevation - 返回高程值
     * @default data.properties.height
     */
    getElevation: function(data){
    	return data.properties.height? data.properties.height: 0;
    },
    
    /**
     * 建筑起始高程的GET属性
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Int} elevation - 返回起始高程值
     * @default data.properties.base_height
     */
    getBaseElevation: function(data){
    	return data.properties.base_height? data.properties.base_height: 0;
    },
    
    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,
    
    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     * @type {Array}
     */
    _meshes: [],
    
    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @type {Array}
     * @private 
     * @default ''
     */
    _textureCache: [],
    
    /**
     * @name 构造函数
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.id = options.id? options.id: this.id;
    	this.visible = options.visible? options.visible: this.visible;
    	this.opacity = options.opacity? options.opacity: this.opacity;
    	this.pickable = options.pickable? options.pickable: this.pickable;
    	this.drawMode = options.drawMode? options.drawMode: this.drawMode;
    	this.data = options.data? options.data: this.data;
    	this.scale = options.scale? options.scale: this.scale;
    	this.getColor = options.getColor? options.getColor: this.getColor;
    	this.getFaceTexture = options.getFaceTexture? options.getFaceTexture: this.getFaceTexture;
    	this.getFaceTextureRepeat = options.getFaceTextureRepeat? options.getFaceTextureRepeat: this.getFaceTextureRepeat;
    	this.getSideTexture = options.getSideTexture? options.getSideTexture: this.getSideTexture;
    	this.getSideTextureRepeat = options.getSideTextureRepeat? options.getSideTextureRepeat: this.getSideTextureRepeat;
    	this.getPolygon = options.getPolygon? options.getPolygon: this.getPolygon;
    	this.getElevation = options.getElevation? options.getElevation: this.getElevation;
    	this.getBaseElevation = options.getBaseElevation? options.getBaseElevation: this.getBaseElevation;
    	if(!this.drawMode || !this.drawMode.high || !this.drawMode.middle || !this.drawMode.low || this.drawMode.high.maxZoom == undefined || this.drawMode.high.minZoom == undefined || this.drawMode.high.maxZoom<this.drawMode.high.minZoom){
    		console.error('option中的drawMode格式不正确！');
    	}
    },
    
    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three 
     */
    addTo: function(three){
    	this._three = three;
    	this._three.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     */
    remove: function(){
    	this._three.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     */
    render: function(){
    	this._three._removeInnerLayer(this);
    	this._meshes = [];
    	var mode = this._getDrawMode();
    	switch(mode){
	    	case 'high':
	    		this._highDraw()
	    		break;
	    	case 'middle':
	    		this._middleDraw();
	    		break;
	    	case 'low':
	    		this._lowDraw()
	    		break;
	    	default:
	    		this._highDraw()
	    		break;
    	}
		this._three._render();
    },
    
    /**
     * 得到当前绘制模式
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     */
    _getDrawMode: function(){
		var zoom = this._three.map.getZoom();
    	if(this.drawMode.high.minZoom < zoom && this.drawMode.high.maxZoom >= zoom){
    		return 'high';
    	}
    	if(this.drawMode.middle.minZoom < zoom && this.drawMode.middle.maxZoom >= zoom){
    		return 'middle';
    	}
    	if(this.drawMode.low.minZoom < zoom && this.drawMode.low.maxZoom >= zoom){
    		return 'low';
    	}
    	return null;
    },
    
    /**
     * high 绘制模式
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     */
    _highDraw: function(){
    	var mergedGeometry = new THREE.Geometry();
    	var color = this.data.length>0? this.getColor(this.data[0]): 'rgb(255, 0, 0)';
    	var materialColor = new THREE.MeshPhongMaterial({color: new THREE.Color(color)});
    	for(var k=0; k<this.data.length; k++){
    		var data = this.data[k];
    		var geometry = this._createGeometry(data);
    		mergedGeometry.merge(geometry);
    	}
    	var mergedBuilding = new THREE.Mesh(mergedGeometry, materialColor);
    	mergedBuilding.visible = this.visible;
    	mergedBuilding.name = (this.id?this.id:"threelayer") + "-merge";
    	mergedBuilding.userData.attributes = {
			OriginalData: this.data,
			Layer: this
		};
		this._three._threebox.addGeoreferencedMesh(mergedBuilding);
		this._meshes.push(mergedBuilding);
    },
    
    /**
     * middle 绘制模式
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     */
    _middleDraw: function(){
    	var _this = this;
    	for(var k=0; k<_this.data.length; k++){
    		var data = _this.data[k];
    		var faceTextureURL = _this.getFaceTexture(data);
    		var sideTextureURL = _this.getSideTexture(data);
    		var materialFace, materialSide, materialColor = new THREE.MeshPhongMaterial({color: new THREE.Color(_this.getColor(data))});
			if(faceTextureURL){
				var textureFace = _this._createTexture(faceTextureURL);
				textureFace.wrapS = textureFace.wrapT = THREE.RepeatWrapping;
				var repeat = _this.getFaceTextureRepeat(data).split(',');
				textureFace.repeat.set(repeat[0], repeat[1]);
				materialFace = new THREE.MeshPhongMaterial({map: textureFace});
			}else{
				materialFace = materialColor.clone();
			}
			if(sideTextureURL){
	    		var textureSide = _this._createTexture(sideTextureURL);
				textureSide.wrapS = textureSide.wrapT = THREE.RepeatWrapping;
				var repeat = _this.getSideTextureRepeat(data).split(',');
	    		textureSide.repeat.set(repeat[0], repeat[1]);
	    		materialSide = new THREE.MeshPhongMaterial({map: textureSide});
			}else{
				materialSide = materialColor.clone();	
			}

			var geometry = _this._createGeometry(data)
			geometry = _this._createUvs(geometry);

			var building = new THREE.Mesh(geometry, [materialFace, materialSide]);
			building.visible = _this.visible;
			building.name = (_this.id?_this.id:"threelayer") + "-" + k;
			building.userData.attributes = {
				OriginalData: data,
				Layer: _this
			};
			_this._three._threebox.addGeoreferencedMesh(building);
			_this._meshes.push(building);
    	}
    },
    
    /**
     * low 绘制模式
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     */
    _lowDraw: function(){
    	var _this = this;
    	for(var k=0; k<_this.data.length; k++){
    		var data = _this.data[k];
    		var faceTextureURL = _this.getFaceTexture(data);
    		var sideTextureURL = _this.getSideTexture(data);
    		var materialFace, materialSide, materialColor = new THREE.MeshPhongMaterial({color: new THREE.Color(_this.getColor(data))});
			if(faceTextureURL){
				var textureFace = _this._createTexture(faceTextureURL);
				textureFace.wrapS = textureFace.wrapT = THREE.RepeatWrapping;
				var repeat = _this.getFaceTextureRepeat(data).split(',');
				textureFace.repeat.set(repeat[0], repeat[1]);
				materialFace = new THREE.MeshPhongMaterial({map: textureFace});
			}else{
				materialFace = materialColor.clone();
			}
			if(sideTextureURL){
	    		var textureSide = _this._createTexture(sideTextureURL);
				textureSide.wrapS = textureSide.wrapT = THREE.RepeatWrapping;
				var repeat = _this.getSideTextureRepeat(data).split(',');
	    		textureSide.repeat.set(repeat[0], repeat[1]);
	    		materialSide = new THREE.MeshPhongMaterial({map: textureSide});
			}else{
				materialSide = materialColor.clone();	
			}

			var geometry = _this._createGeometry(data)
			geometry = _this._createUvs(geometry);

			var building = new THREE.Mesh(geometry, [materialFace, materialSide]);
			building.visible = _this.visible;
			building.name = (_this.id?_this.id:"threelayer") + "-" + k;
			building.userData.attributes = {
				OriginalData: data,
				Layer: _this
			};
			_this._three._threebox.addGeoreferencedMeshToWorld2(building);
			_this._meshes.push(building);
    	}
    },
    
    /**
     * 构建几何对象
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     */
    _createGeometry: function(data){
    	var coords = data.geometry.coordinates[0];
		var shape = new THREE.Shape();
		var start = this._three._threebox.projectToWorld(coords[0]);  
		shape.moveTo(start.x, start.y);  
		for(var i = 1; i < coords.length; i ++) {
			var position = this._three._threebox.projectToWorld(coords[i]);
			shape.lineTo(position.x, position.y);
		}
		var height = this.getElevation(data);
		//var scaleHeight = this._three._threebox.projectedUnitsPerMeter(coords[0][1]) * height;
		//var scaleHeight = Threebox.ThreeboxConstants.PROJECTION_WORLD_SIZE * height;
		var scaleHeight = this._three._threebox.distaneToWorld(height);
			
		var optionsTarget = {
			amount: scaleHeight,
			bevelEnabled: false,
			material:0,
			extrudeMaterial : 1
			//uvGenerator: THREE.ExtrudeGeometry.WorldUVGenerator
		};
		var geometry = new THREE.ExtrudeGeometry(shape, optionsTarget);
		var baseHeight = this.getBaseElevation(data);
		if(baseHeight && baseHeight>0){
			var scaleBaseHeight = this._three._threebox.distaneToWorld(baseHeight);
			geometry.translate(0, 0, scaleBaseHeight);
		}
		return geometry;
    },
    
    /**
     * 创建纹理映射
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     */
    _createUvs: function(geometry){
		geometry.faceVertexUvs = [[]];
		var textureCoord = [new THREE.Vector2(1, 0),new THREE.Vector2(0, 0),new THREE.Vector2(0, 1),new THREE.Vector2(1, 1)];
		var length = geometry.faces.length;
		for (var f = 0; f < length; f+=2) {
			if(geometry.faces[f].normal.z == 0) {
//				geometry.faceVertexUvs[0][f] = [textureCoord[2],textureCoord[1],textureCoord[3]];
//				geometry.faceVertexUvs[0][f+1] = [textureCoord[1],textureCoord[0],textureCoord[3]];
				geometry.faceVertexUvs[0][f] = [textureCoord[1],textureCoord[0],textureCoord[2]];
				geometry.faceVertexUvs[0][f+1] = [textureCoord[0],textureCoord[3],textureCoord[2]];
			}else{
				var v1 = geometry.vertices[geometry.faces[f].a];
				var v2 = geometry.vertices[geometry.faces[f].b];
				var v3 = geometry.vertices[geometry.faces[f].c];
				geometry.faceVertexUvs[0][f] = [
					new THREE.Vector2(v1.x, v1.y),
					new THREE.Vector2(v2.x, v2.y),
					new THREE.Vector2(v3.x, v3.y)
				];
			
				var v4 = geometry.vertices[geometry.faces[f+1].a];
				var v5 = geometry.vertices[geometry.faces[f+1].b];
				var v6 = geometry.vertices[geometry.faces[f+1].c];
				geometry.faceVertexUvs[0][f+1] = [
					new THREE.Vector2(v4.x, v4.y),
					new THREE.Vector2(v5.x, v5.y),
					new THREE.Vector2(v6.x, v6.y)
				];
			}
		}
		return geometry;
    },
    
    /*
     * 创建材质
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     */
    _createTexture: function(textureURL){
    	var _this = this;
		var texture = _this._getTextureCacheByURL(textureURL);
		if(texture){
			texture = texture.clone();
		}else{
			texture = new THREE.TextureLoader().load(textureURL,function(texture){
				_this._three._render();
			});
			_this._addTextureInToCache({
				key: textureURL,
				value: texture
			})
		}
		return texture;
    },
    
    /**
     * 从缓存中获取纹理
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     */
    _getTextureCacheByURL: function(url){
    	if(url){
    		for (var i = 0; i < this._textureCache.length; i++) {
    			if(this._textureCache[i].key === url && this._textureCache[i].value.image){
    				return this._textureCache[i].value;
    			}else{
    				return null;
    			}
    		}
    	}else{
    		return null;
    	}
    },
    /**
     * 向缓存中添加纹理
     * @memberof GeoGlobe.Visuals.Three.BuildingLayer.prototype
     * @private 
     * @param {map} - {key: sideTextureURL,value: textureSide}
     */
    _addTextureInToCache: function(map){
    	var isExist = false;
    	for (var i = 0; i < this._textureCache.length; i++) {
			if(this._textureCache[i].key === map.key){
				isExist = true;
				break;
			}
		}
    	if(!isExist){
    		this._textureCache.push(map);
    	}
    }
    
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.Three.VideoLayer
 * @classdesc 视频图层，垂直于地面。
 * @example 
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 18,
    bearing: -47,
    pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});

//构造THREE可视化图层
var threebox = new GeoGlobe.Visuals.Three();
//绑定鼠标点击事件
threebox.on('overlayerclick', function(e){
    var xyz = threebox.unprojectFromWorld(e.param.pickedInfos[0].point);
    alert(e.param.info.userData.attributes.OriginalData.properties.name + '\n经纬度及高程:' + xyz);
});
//绑定鼠标移动事件
threebox.on('overlayerhover', function(e){
    console.info(e);
});
//添加到地图中
threebox.addTo(map);
//构造视频图层
var videoLayer = new GeoGlobe.Visuals.Three.VideoLayer({
    id: 'video in 3D',
    data: [
        {"type":"Feature","properties":{"name": "一号视频","height": 40, "base_height": 50, "video_texture": "../../data/video.mp4"},"geometry":{"type":"LineString","coordinates":[[114.267589714434,30.593727684842285],[114.26679606746787,30.59349755409514]]}},
    ],
    visible: true,
    pickable: true,
    opacity: 1,
    autoplay: true
});
//添加到THREE图层
videoLayer.addTo(threebox);
//绘制
threebox.render();
 */
GeoGlobe.Visuals.Three.VideoLayer = GeoGlobe.Class4OL({
	/**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否可拾取
	 * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 透明度 0-1
	 * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
	 * @type {Float}
	 * @default 1.0
	 */
	opacity: 1.0,
	
    /**
     * 是否自动播放
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @type {Boolean}
     * @default true
     */
    autoplay: true,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
	 * @type {Array}
	 * @example 
	 * [{
	 * 	"type":"Feature",
	 * 	"properties":{
	 * 		"id": 100001,
	 * 		"name":"1号视频",
	 * 		"height":3,
	 * 		"base_height":30,
	 * 		"video_texture":'../../data/video.mp4' //视频纹理
	 * 	},
	 * 	"geometry":{
	 * 		"type":"LineString",
	 * 		"coordinates":[[114.267589714434,30.593727684842285],[114.26679606746787,30.59349755409514]]
	 * 	}
	 * }]
	 */
	data: [],
    
    /**
     * 视频纹理资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} uri - 视频路径
     * @default data.properties.video_texture
     */
    getVideoTexture: function(data){
        return data.properties.video_texture? data.properties.video_texture: '';
    },


    /**
     * 两点线的几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} coordinates - 返回组成线的2点坐标数组
     * @default data.geometry.coordinates
     * @example 
     * [[114.267589714434,30.593727684842285],[114.26679606746787,30.59349755409514]]
     */
    getLine: function(data){
    	if(data.geometry.type === 'LineString'){    		
    		return data.geometry.coordinates;
    	}else{
    		return null;
    	}
    },
    
    /**
     * 建筑高程的GET属性
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Int} elevation - 返回高程值
     * @default data.properties.height
     */
    getElevation: function(data){
    	return data.properties.height? data.properties.height: 0;
    },
    
    /**
     * 建筑起始高程的GET属性
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Int} elevation - 返回起始高程值
     * @default data.properties.base_height
     */
    getBaseElevation: function(data){
    	return data.properties.base_height? data.properties.base_height: 0;
    },
    
    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,
    
    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @private 
     * @type {Array}
     */
    _meshes: [],
    
    /**
     * 动画ID
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @private 
     * @type {Int}
     */
    _frameId: null,
    
    /**
     * @name 构造函数
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.id = options.id? options.id: this.id;
    	this.visible = options.visible? options.visible: this.visible;
    	this.opacity = options.opacity? options.opacity: this.opacity;
    	this.pickable = options.pickable? options.pickable: this.pickable;
    	this.autoplay = options.autoplay? options.autoplay: this.autoplay;
    	this.data = options.data? options.data: this.data;
    	this.getVideoTexture = options.getVideoTexture? options.getVideoTexture: this.getVideoTexture;
    	this.getLine = options.getLine? options.getLine: this.getLine;
    	this.getElevation = options.getElevation? options.getElevation: this.getElevation;
    	this.getBaseElevation = options.getBaseElevation? options.getBaseElevation: this.getBaseElevation;
    },
    
    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three 
     */
    addTo: function(three){
    	this._three = three;
    	this._three.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     */
    remove: function(){
    	this._three.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     */
    render: function(){
    	var _this = this;
    	this._three._removeInnerLayer(this);
    	this._meshes = [];
    	var textureCoord = [new THREE.Vector2(1, 0),new THREE.Vector2(0, 0),new THREE.Vector2(0, 1),new THREE.Vector2(1, 1)];
    	for(var k=0; k<_this.data.length; k++){
    		var data = _this.data[k];
    		var videoTextureURL = _this.getVideoTexture(data);
			if(videoTextureURL){
				var videoDOM = document.createElement('video');
				videoDOM.setAttribute('class', 'geoglobe-three-video');
				videoDOM.setAttribute('src', videoTextureURL);
				videoDOM.setAttribute('autoplay', 'autoplay');
				videoDOM.setAttribute('loop', 'loop');
				videoDOM.style.display = 'none';
				document.body.appendChild(videoDOM);
				var videoTexture = new THREE.VideoTexture(videoDOM);
				videoTexture.minFilter = THREE.LinearFilter;
				videoTexture.magFilter = THREE.LinearFilter;
				videoTexture.format = THREE.RGBFormat;
				var videoMaterial = new THREE.MeshPhongMaterial({map: videoTexture, side: THREE.DoubleSide});
				
				var baseHeight = _this.getBaseElevation(data);
				var proBaseHeight = _this._three._threebox.distaneToWorld(baseHeight);
				var height = _this.getElevation(data);
				var proHeight = _this._three._threebox.distaneToWorld(baseHeight + height);
				var geoLine = _this.getLine(data);
				var vv1 = _this._three._threebox.projectToWorld(geoLine[0]); 
				var vv2 = _this._three._threebox.projectToWorld(geoLine[1]); 
				var vv3 = vv2.clone();
				var vv4 = vv1.clone();
				vv1.z = proBaseHeight;
				vv2.z = proBaseHeight;
				vv3.z = proHeight;
				vv4.z = proHeight;
				var videoVertices = [
					vv1, vv2, vv3, vv4
				];
				var videoFaces = [
					new THREE.Face3(0, 1, 2),
					new THREE.Face3(0, 2, 3)
				];
				var videoGeo = new THREE.Geometry();
				videoGeo.vertices = videoVertices;
				videoGeo.faces = videoFaces;
				videoGeo.computeFaceNormals();
				videoGeo.faceVertexUvs = [[]];
				videoGeo.faceVertexUvs[0][0] = [textureCoord[0],textureCoord[1],textureCoord[2]];
				videoGeo.faceVertexUvs[0][1] = [textureCoord[0],textureCoord[2],textureCoord[3]];
				videoGeo.translate(videoGeo.faces[0].normal.x*0.00001, videoGeo.faces[0].normal.y*0.00001 , videoGeo.faces[0].normal.z*0.00001);
				var videoMesh = new THREE.Mesh(videoGeo, videoMaterial);
				videoMesh.visible = _this.visible;
				videoMesh.name = (_this.id?_this.id:"threelayer") + "-" + k;
				videoMesh.userData.attributes = {
					OriginalData: data,
					Layer: _this
				};
				_this._three._threebox.addGeoreferencedMeshToWorld2(videoMesh);
				_this._meshes.push(videoMesh);
			}else{
				console.warn('视频纹理为必要属性！');
				continue;
			}
    	}	
		_this._three._render();
		_this._animate();
    },
    
    /**
     * 播放
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     */
    play: function(){
    	this.autoplay = true;
    	this._animate();
    },
    
    /**
     * 停止
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     */
    stop: function(){
    	this.autoplay = false;
    	window.cancelAnimationFrame(this._frameId);
    },
    
    /**
     * 动画
     * @memberof GeoGlobe.Visuals.Three.VideoLayer.prototype
     * @private 
     */
    _animate: function() {
    	var _this = this;
    	if(!_this.autoplay){
    		return;
    	}
    	_this._three._render();
		_this._frameId = window.requestAnimationFrame(function(){
			_this._animate();
		});
	}
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.Three.TextLayer
 * @classdesc 文本图层，垂直于地面。
 * @example 
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 18,
    bearing: -47,
    pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});

//构造THREE可视化图层
var threebox = new GeoGlobe.Visuals.Three();
//绑定鼠标点击事件
threebox.on('overlayerclick', function(e){
    var xyz = threebox.unprojectFromWorld(e.param.pickedInfos[0].point);
    alert(e.param.info.userData.attributes.OriginalData.properties.name + '\n经纬度及高程:' + xyz);
});
//绑定鼠标移动事件
threebox.on('overlayerhover', function(e){
    console.info(e);
});
//添加到地图中
threebox.addTo(map);
//构造文本图层
var textLayer = new GeoGlobe.Visuals.Three.TextLayer({
    id: 'text in 3D',
    data: [
        {"type":"Feature","properties":{"name": "一号文本","height": 40, "text": "我是文本Q1", color: "rgb(255, 120, 0)"},"geometry":{"type":"Point","coordinates":[114.267589714434,30.593727684842285]}},
    ],
    visible: true,
    pickable: true,
    opacity: 1,
    scale: 1,
    size: 10,
    thickness: 3,
    curveSegments: 4,
    fontURL: '../../fonts/SimHei_Regular.json',  //简体
    getGeometry: function(geometry, data){
        geometry.rotateX((90/360)*2*Math.PI);
        geometry.rotateZ((180/360)*2*Math.PI);
        return geometry;
    },
});
//添加到THREE图层
textLayer.addTo(threebox);
//绘制
threebox.render();
 */
GeoGlobe.Visuals.Three.TextLayer = GeoGlobe.Class4OL({
	/**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否可拾取
	 * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 透明度 0-1
	 * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
	 * @type {Float}
	 * @default 1.0
	 */
	opacity: 1.0,
	
	/**
	 * 缩放比例 1-~
	 * @memberof GeoGlobe.Visuals.Three.SymbolLayer.prototype
	 * @type {Int}
	 * @default 1
	 */
    scale: 1,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
	 * @type {Array}
	 * @example 
	 * [{
	 * 	"type":"Feature",
	 * 	"properties":{
	 * 		"id": 100001,
	 * 		"name":"1号视频",
	 * 		"text":"我是文本1",
	 * 		"height":30,
	 * 		"color": "rgb(255, 120, 0)"
	 * 	},
	 * 	"geometry":{
	 * 		"type":"Point",
	 * 		"coordinates": [114.20257245367856, 30.773372078561778]
	 * 	}
	 * }]
	 */
	data: [],
    
	/**
	 * 字体资源路径
	 * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
	 * @type {String}
	 * @default ''
	 */
	fontURL: '',
	
	/**
	 * 字体大小
	 * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
	 * @type {Int}
	 * @default 100
	 */
	size: 100,
	
	/**
	 * 字体厚度
	 * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
	 * @type {Int}
	 * @default 50
	 */
	thickness: 50,
	
	/**
	 * 字体曲面光滑度
	 * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
	 * @type {Int}
	 * @default 12
	 */
	curveSegments: 12,
	
    /**
     * 地理位置GET属性
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} point - [x,y,z]
     */
    getPosition: function(data){
 	    if(data.geometry.type === 'Point'){
    		var point = data.geometry.coordinates;
    		if(data.properties.height){
    			point.push(data.properties.height);
    		}else{
    			point.push(0);
    		}
    		return point;
    	}else{
    		return null;
    	}
    },
    
    /**
     * 文本GET属性
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} text - data.properties.text
     */
    getText: function(data){
    	if(data.properties.text){
    		return data.properties.text;
    	}else{
    		return '未知文本';    		
    	}
    },
    
    /**
     * 颜色GET属性
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} color - 颜色值
     */
    getColor: function (data) {
    	if(data.properties.color){
    		return data.properties.color;
    	}else{
    		return 'rgb(255, 0, 0)';    		
    	}
    },
    
    /**
     * 几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @param {Geometry} geometry - THREE.Geometry
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Geometry} geometry - 可对geometry平移旋转缩放后的
     */
    getGeometry: function(geometry, data){
        return geometry;
    },
    
    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,
    
    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @private 
     * @type {Array}
     */
    _meshes: [],
    
    /**
     * @name 构造函数
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.id = options.id? options.id: this.id;
    	this.visible = options.visible? options.visible: this.visible;
    	this.opacity = options.opacity? options.opacity: this.opacity;
    	this.pickable = options.pickable? options.pickable: this.pickable;
    	this.scale = options.scale? options.scale: this.scale;
    	this.size = options.size? options.size: this.size;
    	this.thickness = options.thickness? options.thickness: this.thickness;
    	this.curveSegments = options.curveSegments? options.curveSegments: this.curveSegments;
    	this.data = options.data? options.data: this.data;
    	this.fontURL = options.fontURL? options.fontURL: this.fontURL;
    	this.getPosition = options.getPosition? options.getPosition: this.getPosition;
    	this.getText = options.getText? options.getText: this.getText;
    	this.getColor = options.getColor? options.getColor: this.getColor;
    	this.getGeometry = options.getGeometry? options.getGeometry: this.getGeometry;
    },
    
    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three 
     */
    addTo: function(three){
    	this._three = three;
    	this._three.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     */
    remove: function(){
    	this._three.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.TextLayer.prototype
     */
    render: function(){
    	var _this = this;
    	if(!_this.fontURL){
    		console.error('字体资源是必须的属性！');
    		return;
    	}
    	this._three._removeInnerLayer(this);
    	this._meshes = [];
    	var loader = new THREE.FontLoader();
		loader.load( _this.fontURL, function ( response ) {
			var font = response;
			for(var k=0; k<_this.data.length; k++){
	    		var data = _this.data[k];
	    		var text = _this.getText(data);
	    		var textGeo = new THREE.TextGeometry( text, {
	    			font: font,
	    			size: _this.size,
	    			height: _this.thickness,
	    			curveSegments: _this.curveSegments
	    		});
	    		textGeo.computeBoundingBox();
	    		textGeo.computeVertexNormals();
	    		textGeo = _this.getGeometry(textGeo, data);
	    		materials = [
					new THREE.MeshPhongMaterial( { color: new THREE.Color(_this.getColor(data)), flatShading: true } ), // front
					new THREE.MeshPhongMaterial( { color: new THREE.Color(_this.getColor(data)) } ) // side
				];
	    		textMesh = new THREE.Mesh( textGeo, materials );

	    		var position = _this.getPosition(data);
	    		var scale = _this.scale? _this.scale: 1.0;
	    		textMesh.visible = _this.visible;
	    		textMesh.name = (_this.id?_this.id:"threelayer") + "-" + k;
	    		textMesh.userData.attributes = {
					OriginalData: data,
					Layer: _this
				};
				_this._three._threebox.addAtCoordinate(textMesh, position, {scaleToLatitude: true, preScale: scale});           
				_this._meshes.push(textMesh);
			}
			_this._three._render();
		})
    }
})/**
 * @author kz
 * @class GeoGlobe.Visuals.Three.CurveLayer
 * @classdesc 弧线图层，绘制三维空间的二次贝塞尔曲线
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -47,
	pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});
 //构造THREE可视化图层
 var threebox = new GeoGlobe.Visuals.Three();
 //添加到地图中
 threebox.addTo(map);
 //构造弧线图层
 var curveLayer = new GeoGlobe.Visuals.Three.CurveLayer({
	id: '3D curve',
    data: [{
        "type": "Feature",
        "properties": {"name": "武汉->莫斯科", "width": 1, "curveness": 0.8, "color": "red"},
        "geometry": {
            "type": "LineString",
            "coordinates": [[114.2578125, 30.600093873550072], [37.6171875, 55.751849391735284]]
        }
    },{
        "type": "Feature",
        "properties": {"name": "开普敦->莫斯科", "width": 5, "curveness": 0.2, "color": "green"},
        "geometry": {
            "type": "LineString",
            "coordinates": [[18.45703125, -33.925129700071984], [37.6171875, 55.751849391735284]]
        }
    },{
        "type": "Feature",
        "properties": {"name": "洛杉矶->纽约->巴黎->莫斯科", "width": 3, "curveness": 0.3, "color": "yellow"},
        "geometry": {
            "type": "LineString",
            "coordinates": [[-118.21289062499999, 34.05265942137599], [-74.00390625, 40.730608477796636], [2.373046875, 48.86471476180277], [37.6171875, 55.751849391735284]]
        }
    }],
    visible: true,
    pickable: true,
    opacity: 0.8
});
 //添加到THREE图层
 curveLayer.addTo(threebox);
 //绘制
 threebox.render();
 */
GeoGlobe.Visuals.Three.CurveLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 可见性
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * 是否可拾取
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @type {Boolean}
     * @default true
     */
    pickable: true,

    /**
     * 透明度 0-1
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @type {Number}
     * @default 1.0
     */
    opacity: 1.0,

    /**
     * 数据
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @type {Array}
     * @example
     * [{
	 * 	"type":"Feature",
	 * 	"properties":{
	 * 		"id": 100001,
	 * 		"name":"",
	 * 		"width":1,
	 * 		"color":"#ddd", //颜色纹理。如果没有纹理图片时，则有效。 图片纹理优先于颜色纹理。
	 * 		"texture":'' //图片纹理，顶部纹理
	 * 	},
	 * 	"geometry":{
	 * 		"type":"LineString",
	 * 		"coordinates":[[114.27467721499235,30.61823619840472,19.61132758430084],[114.29877951124801,30.64353276353745,504.0792309408988]]
	 * 	}
	 * }]
     */
    data: [],

    /**
     * 颜色GET属性
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} color - 颜色值
     */
    getColor: function (data) {
        if (data.properties.color) {
            return data.properties.color;
        } else {
            return 'rgb(255, 0, 0)';
        }
    },

    /**
     * 纹理图片资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} texture - 图片纹理资源路径
     */
    getTexture: function (data) {
        return data.properties.texture ? data.properties.texture : '';
    },

    /**
     * 线几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} coordinates - 返回线的坐标数组
     */
    getLineString: function (data) {
        if (data.geometry.type === 'LineString') {
            return data.geometry.coordinates;
        } else {
            return null;
        }
    },

    /**
     * 线宽度的GET属性
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Number} size - 线宽值
     */
    getWidth: function (data) {
        return data.properties.width ? data.properties.width : 1;
    },

    /**
     * 线曲度的GET属性（0-1）
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Number} curveness - 线曲度值
     */
    getCurveness: function (data) {
        return data.properties.curveness ? data.properties.curveness : 0.2;
    },

    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,

    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @private
     * @type {Array}
     */
    _meshes: [],

    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @type {Array}
     * @private
     * @default ''
     */
    _textureCache: [],

    /**
     * @name GeoGlobe.Visuals.Three.PointLayer构造函数。
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
        this.visible = options.visible ? options.visible : this.visible;
        this.opacity = options.opacity ? options.opacity : this.opacity;
        this.pickable = options.pickable ? options.pickable : this.pickable;
        this.data = options.data ? options.data : this.data;
        this.getColor = options.getColor ? options.getColor : this.getColor;
        this.getTexture = options.getTexture ? options.getTexture : this.getTexture;
        this.getLineString = options.getLineString ? options.getLineString : this.getLineString;
        this.getWidth = options.getWidth ? options.getWidth : this.getWidth;
        this.getCurveness = options.getCurveness ? options.getCurveness : this.getCurveness;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three
     */
    addTo: function (three) {
        this._three = three;
        this._three.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     */
    remove: function () {
        this._three.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.CurveLayer.prototype
     */
    render: function () {
        var _this = this;
        this._three._removeInnerLayer(this);
        this._meshes = [];

        var positions = [];
        var colors = [];
        var sizes = [];
        var curves = [];
        for (var k = 0; k < this.data.length; k++) {
            var data = this.data[k];
            var width = this.getWidth(data);
            var color = new THREE.Color(this.getColor(data));
            var material = new THREE.LineMaterial({
                linewidth: 0.0005 * width,
                color: color,
                opacity: this.opacity,
                transparent: true
            });
            var _points = [];
            var _positions = [];
            var _curves = [];
            var coords = this.data[k].geometry.coordinates;
            if (coords.length > 1) {
                var start = this._three._threebox.projectToWorld(coords[0]);
                var end = this._three._threebox.projectToWorld(coords[coords.length - 1]);
                var distance = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2) + Math.pow(end.z - start.z, 2));
            }

            //支持多个顶点的LineString，表现为多条二次贝塞尔曲线组成的一整条弧线
            for (var i = 0; i < coords.length - 1; i++) {
                var position1 = this._three._threebox.projectToWorld(coords[i]);
                var position2 = this._three._threebox.projectToWorld(coords[i + 1]);

                //控制点
                var control = {
                    x: (position1.x + position2.x) / 2,
                    y: (position1.y + position2.y) / 2,
                    z: Math.sqrt(Math.pow(position2.x - position1.x, 2) + Math.pow(position2.y - position1.y, 2)) / 2 * Math.tan(Math.PI / 2 * this.getCurveness(data))
                };
                var curve = new THREE.QuadraticBezierCurve3(
                    new THREE.Vector3(position1.x, position1.y, position1.z),
                    new THREE.Vector3(control.x, control.y, control.z),
                    new THREE.Vector3(position2.x, position2.y, position2.z)
                );
                if (coords.length > 1) {
                    curve.rate1 = Math.sqrt(Math.pow(position1.x - start.x, 2) + Math.pow(position1.y - start.y, 2) + Math.pow(position1.z - start.z, 2)) / distance;
                    curve.rate2 = Math.sqrt(Math.pow(position2.x - position1.x, 2) + Math.pow(position2.y - position1.y, 2) + Math.pow(position2.z - position1.z, 2)) / distance;
                }
                _curves.push(curve);
                _points = curve.getPoints(50);
                for (var j = 0; j < _points.length; j++) {
                    _positions.push(_points[j].x, _points[j].y, _points[j].z);
                }
            }
            var lineGeometry = new THREE.LineGeometry();
            lineGeometry.setPositions(_positions);
            var line = new THREE.Line2(lineGeometry, material);
            line.computeLineDistances();
            line.visible = this.visible;
            line.name = (this.id ? this.id : "threelayer") + "-" + k;
            line.userData.attributes = {
                OriginalData: data,
                Layer: this
            };
            this._three._threebox.addGeoreferencedMesh(line);
            this._meshes.push(line);

            positions.push(_positions[0]);
            positions.push(_positions[1]);
            positions.push(_positions[2]);
            colors.push(color.r, color.g, color.b);
            sizes.push(10 + width * width);
            curves.push(_curves);
        }

        //粒子
        var particlesGeometry = new THREE.BufferGeometry();
        var shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                texture: {value: new THREE.TextureLoader().load('../../images/lensflare.png')}
            },
            vertexShader: "attribute float size;varying vec3 vColor;void main() {vColor = color;vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );gl_PointSize = size;gl_Position = projectionMatrix * mvPosition;}",
            fragmentShader: "varying vec3 vColor;uniform sampler2D texture;void main() {gl_FragColor = vec4( vColor, 1.0 );gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );}",
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            vertexColors: true
        });
        particlesGeometry.addAttribute('position', new THREE.Float32BufferAttribute(positions, 3).setDynamic(true));
        particlesGeometry.addAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        particlesGeometry.addAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        var particleSystem = new THREE.Points(particlesGeometry, shaderMaterial);
        particleSystem.visible = this.visible;
        particleSystem.name = 'particles';
        particleSystem.userData.attributes = {
            OriginalData: data,
            Layer: this
        };
        this._three._threebox.addGeoreferencedMesh(particleSystem);
        this._meshes.push(particleSystem);

        this._three._render();

        //粒子动画
        var step = 0;
        var point;
        (function animate() {
            requestAnimationFrame(animate);
            step += 0.005;
            if (step > 1) step = 0;
            var positions = particlesGeometry.attributes.position.array;
            for (var i = 0; i < curves.length; i++) {
                if (curves[i].length === 1) {
                    point = curves[i][0].getPoint(step);
                } else {
                    for (var j = 0; j < curves[i].length; j++) {
                        if (step >= curves[i][j].rate1 && step <= curves[i][j].rate1 + curves[i][j].rate2) {
                            point = curves[i][j].getPoint((step - curves[i][j].rate1) / curves[i][j].rate2);
                            break;
                        }
                    }
                }
                positions[i * 3] = point.x;
                positions[i * 3 + 1] = point.y;
                positions[i * 3 + 2] = point.z;
            }
            particlesGeometry.attributes.position.needsUpdate = true;
            _this._three._render();
        })();
    }
});/**
 * @class GeoGlobe.Visuals.Three.SingleBuildingLayer
 * @classdesc 建筑物单体化图层，由单个矢量面拉伸而成。
 * @example 
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -47,
	pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});
//构造THREE可视化图层
 var threebox = new GeoGlobe.Visuals.Three();
 //添加到地图中
 threebox.addTo(map);
 //构造线图层
 var SingleBuildingLayer = new GeoGlobe.Visuals.Three.SingleBuildingLayer({
	id: 'single building',
    data: [],
    visible: true,
    pickable: true,
    opacity: 1
});
 //添加到THREE图层
 SingleBuildingLayer.addTo(threebox);
 //绘制
 threebox.render();
*/

GeoGlobe.Visuals.Three.SingleBuildingLayer = GeoGlobe.Class4OL({
	/**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	/**
	 * 建筑物底部圆环是否可见
	 * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	isCirclesVisible: true,
	/**
	 * 建筑物楼层线是否可见
	 * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	isFloorLinesVisible: true,
	
	/**
	 * 是否可拾取
	 * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 透明度 0-1
	 * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @type {Float}
	 * @default 1.0
	 */
	opacity: 1.0,
	/**
	 * 面要素数据
	 * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @type {Object}
	 * @example 
	 * {
	 * 	"type":"Feature",
	 * 	"properties":{
	 * 		"id": 100001,
	 * 		"level":7,
	 * 		"name":"中国银行（武汉新台北支行）",
	 *		"levels": [3,3,4,5,3,3,3]
	 * 	},
	 * 	"geometry":{
	 * 		"type":"Polygon",
	 * 		"coordinates":[[[114.27731517981033,30.597299735680195],[114.2771650822979,30.59732760632838],[114.27706858577743,30.597401572142914],[114.2771114663513,30.597447680396996],[114.27731517981033,30.597299735680195]]]
	 * 	}
	 * }
	 */
	data: {},
	/**
     * 颜色GET属性
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {String} color - 颜色值
     * @default data.properties.color
     */
    getColor: function (data) {
    	if(data.properties.color){
    		return data.properties.color;
    	}else{
    		return 'rgb(255, 0, 0)';    		
    	}
    },
	/**
     * 多边形几何对象GET属性
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Array} coordinates - 返回组成多边形的坐标数组
     * @default data.geometry.coordinates
     * @example 
     * [[[114.27731517981033,30.597299735680195],[114.2771650822979,30.59732760632838],[114.27706858577743,30.597401572142914],[114.2771114663513,30.597447680396996],[114.27731517981033,30.597299735680195]]]
     */
    getPolygon: function(data){
    	if(data.geometry.type === 'Polygon'){    		
    		return data.geometry.coordinates;
    	}else{
    		return null;
    	}
    },
	/**
     * 建筑高程的GET属性
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @param {Feature} data - geojson中的一个Feature
     * @returns {Int} elevation - 返回高程值
     */
    getElevation: function(data){
		if(data.properties.levels) {
			var levels = JSON.parse(data.properties.levels);
			var sum = 0;
			levels.forEach(function(floorHeight){
				sum += floorHeight;
			});
			return sum;
		}else return 0;
    },
    
    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,
    
    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @private 
     * @type {Array}
     */
    _meshes: [],
    
    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @type {Array}
     * @private 
     * @default ''
     */
    _textureCache: [],
	
	/**
     * 被选中楼层底板对象
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @type {Object}
     * @private 
     * @default ''
     */
    _INTERSECTED_FLOOR: null,
	
	/**
     * 被选中楼层底板对象
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @type {Object}
     * @private 
     * @default ''
     */
    _INTERSECTED_FLOOR_2: null,
	
	/**
     * 被选中楼层外墙对象
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @type {Object}
     * @private 
     * @default ''
     */
    _INTERSECTED_WALL: null,
    
    /**
     * @name 构造函数
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
		if(!window.turf){
			console.error("未引入turf.js库！");
			return;
		}
		
    	this.id = options.id? options.id: this.id;
		if(options.visible !== undefined) this.visible = options.visible;
		if(options.isCirclesVisible !== undefined) this.isCirclesVisible = options.isCirclesVisible;
		if(options.isFloorLinesVisible !== undefined) this.isFloorLinesVisible = options.isFloorLinesVisible;
    	this.opacity = options.opacity? options.opacity: this.opacity;
		if(options.pickable !== undefined) this.pickable = options.pickable;
    	this.data = options.data? options.data: this.data;
    	this.getColor = options.getColor? options.getColor: this.getColor;
    	this.getPolygon = options.getPolygon? options.getPolygon: this.getPolygon;
    	this.getElevation = options.getElevation? options.getElevation: this.getElevation;
    	this.getBaseElevation = options.getBaseElevation? options.getBaseElevation: this.getBaseElevation;
    },
	/**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three 
     */
    addTo: function(three){
    	this._three = three;
    	this._three.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     */
    remove: function(){
    	this._three.removeLayer(this.id);
    },
	
	/**
     * 创建感光材质，MeshPhongMaterial
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @private 
     */
    _createMaterial: function(options){
    	
    },
	
	/**
     * 基于顶点创建线几何
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @private 
     */
    _createLineGeometry: function(vertices){
    	var geometry = new THREE.Geometry();
		
		vertices.forEach(function(vertice){
			geometry.vertices.push(vertice);
		});
		
		return geometry;
    },
	
	/**
     * 创建拉伸几何
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @private 
     */
    _createGeoExtrudeGeometry: function(vertices, options){
		var shape = new THREE.Shape(vertices);
		var geometry = new THREE.GeoExtrudeGeometry(shape, options);
		
		var geometry2 =new THREE.Geometry();
		geometry2.faceVertexUvs = geometry.faceVertexUvs.concat();
		geometry2.faces = geometry.faces.concat();
		geometry2.vertices = geometry.vertices.concat();
		geometry = geometry2;
		
		return geometry;
    },
	
	/**
     * 创建拉伸几何(删除底面和顶面)
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @private 
     */
    _createSideGeometry: function(vertices, options){
		var shape = new THREE.Shape(vertices);
		var geometry = new THREE.GeoExtrudeGeometry(shape, options);
		var sum = 0;
		geometry.faces.forEach(function(face){
			if(face.normal.z != 0) sum++;
		});
		geometry.faces.splice(0, sum);
		
		var geometry2 =new THREE.Geometry();
		geometry2.faceVertexUvs = geometry.faceVertexUvs.concat();
		geometry2.faces = geometry.faces.concat();
		geometry2.vertices = geometry.vertices.concat();
		geometry = geometry2;
		
		return geometry;
    },
	
	/**
     * 创建侧棱柱几何体(融合几何体)
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @private 
     */
    _createPillarMesh: function(features, options, material){
		var _this = this;
		var geometryMege = new THREE.Geometry();
		
		features.forEach(function(circle){
			var coords = circle.geometry.coordinates[0];
			var vertices = [];
			coords.forEach(function(coord){
				vertices.push(_this._three._threebox.projectToWorld(coord));
			});
			var shape = new THREE.Shape(vertices);
			var geometry = new THREE.GeoExtrudeGeometry(shape, options);
			
			var geometry2 =new THREE.Geometry();
			geometry2.faceVertexUvs = geometry.faceVertexUvs.concat();
			geometry2.faces = geometry.faces.concat();
			geometry2.vertices = geometry.vertices.concat();
			geometry = geometry2;
			
			var mesh = new THREE.Mesh(geometry, material);
			geometryMege.merge(mesh.geometry, mesh.matrix);
		});
		var meshMerge = new THREE.Mesh(geometryMege, material);
		return meshMerge;
    },
    
	/**
     * 对选中楼层进行高亮(包括外墙和底板)
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @param [Array] intersects - 点击交互网格集合
	 * @return {Object} interscet - 返回被选中楼层对象
     */
	highlightFloor_Wall: function (intersects,evt) {
		var intersectedFloor = null;
		var intersectedWall = null;
		
		
		if ( intersects.length > 0 ) {
			for(var i = 0; i < intersects.length; i++) {
				if(intersects[i].object.userData.tag == '__wall__') {
					intersectedWall = intersects[i].object;
				}
				
				if(intersects[i].object.userData.tag == '__floor__') {
					intersectedFloor = intersects[i].object;
					break;
				}
			}
			
			if(intersectedFloor && intersectedWall) {
				
				if ( this._INTERSECTED_FLOOR != intersectedFloor && this._INTERSECTED_WALL != intersectedWall) {
					
					if ( this._INTERSECTED_FLOOR && this._INTERSECTED_WALL) {
						this._INTERSECTED_FLOOR.material.color.setHex( 0x627BC1 );
						this._INTERSECTED_FLOOR.material.opacity = 0;
						
						this._INTERSECTED_WALL.material.color.setHex( this._INTERSECTED_WALL.currentHex );
						this._INTERSECTED_WALL.material.opacity = this._INTERSECTED_WALL.currentOpacity;
					}
					this._INTERSECTED_FLOOR = intersectedFloor;
					this._INTERSECTED_FLOOR.currentHex = this._INTERSECTED_FLOOR.material.color.getHex();
					this._INTERSECTED_FLOOR.currentOpacity = this._INTERSECTED_FLOOR.material.opacity;
					this._INTERSECTED_FLOOR.material.color.setHex( 0xFFFFFF );
					this._INTERSECTED_FLOOR.material.opacity = 0.6;
					
					this._INTERSECTED_WALL = intersectedWall;
					this._INTERSECTED_WALL.currentHex = this._INTERSECTED_WALL.material.color.getHex();
					this._INTERSECTED_WALL.currentOpacity = this._INTERSECTED_WALL.material.opacity;
					this._INTERSECTED_WALL.material.color.setHex( 0xFFFF00 );
					this._INTERSECTED_WALL.material.opacity = 0.3;
					
					this._three._render();
				}
			}
			
		}else{
			this._INTERSECTED_FLOOR = null;
			this._INTERSECTED_WALL = null;
		}
		
		return intersectedFloor;
	},
	
	/**
     * 对选中楼层进行高亮(只高亮底板)
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @param [Array] intersects - 点击交互网格集合
	 * @return {Object} interscet - 返回被选中楼层对象
     */
	highlightFloor: function (intersects) {
		var intersectedFloor = null;
		
		if ( intersects.length > 0 ) {
			for(var i = 0; i < intersects.length; i++) {
				if(intersects[i].object.userData.tag == '__floor__') {
					intersectedFloor = intersects[i].object;
					break;
				}
			}
			
			if(intersectedFloor) {
				
				if ( this._INTERSECTED_FLOOR_2 != intersectedFloor) {
					if ( this._INTERSECTED_FLOOR_2 ) {
						this._INTERSECTED_FLOOR_2.material.color.setHex( this._INTERSECTED_FLOOR_2.currentHex );
						this._INTERSECTED_FLOOR_2.material.opacity = this._INTERSECTED_FLOOR_2.currentOpacity;
					}
					if(this._INTERSECTED_FLOOR){
						this._INTERSECTED_FLOOR.material.color.setHex( 0xFFFFFF );
						this._INTERSECTED_FLOOR.material.opacity = 0.6;
					}
					
					this._INTERSECTED_FLOOR_2 = intersectedFloor;
					this._INTERSECTED_FLOOR_2.currentHex = this._INTERSECTED_FLOOR_2.material.color.getHex();
					this._INTERSECTED_FLOOR_2.currentOpacity = this._INTERSECTED_FLOOR_2.material.opacity;
					this._INTERSECTED_FLOOR_2.material.color.setHex( 0x878787 );
					this._INTERSECTED_FLOOR_2.material.opacity = 0.2;
					
					this._three._render();
				}
			}
			
		}else{
			this._INTERSECTED_FLOOR_2 = null;
		}
		
		return intersectedFloor;
	},
	
	/**
	 * 返回被选中楼层对象
	 * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
	 * @param [Array] intersects - 点击交互网格集合
	 * @return {Object} interscet - 返回被选中楼层对象
	 */
	getSelectedFloor: function(intersects) {
		var intersectedFloor = null;
		if ( intersects.length > 0 ) {
			for(var i = 0; i < intersects.length; i++) {
				if(intersects[i].object.userData.tag == '__floor__') {
					intersectedFloor = intersects[i].object;
					break;
				}
			}
		}else{}
		return intersectedFloor;
	},
	
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.SingleBuildingLayer.prototype
     */
	render: function () {
		var _this = this;
        _this._three._removeInnerLayer(_this);
        _this._meshes = [];
		var group = new THREE.Group();
		group.name = 'main part';
		group.userData.attributes = {
			OriginalData: _this.data,
			Layer: _this
		};
		var group2 = new THREE.Group();
		group2.name = 'extra part';
		group2.userData.attributes = {
			OriginalData: _this.data,
			Layer: _this
		};
		
		if(!_this.data.geometry) return;
		
		var centroid = turf.centroid(_this.data);   
		var centerPoint = centroid.geometry.coordinates;
		
		//添加底部圆环
		if(_this.isCirclesVisible) {
			var materialCircle = new THREE.MeshBasicMaterial( { color: 0x708090, transparent: true, opacity: 0.3 } );
			
			var circleRadius = 0.01;  
			var circleRadiuss = [0.010,0.015,0.020,0.025,0.030,0.035,0.040,0.045,0.050,0.055];
			circleRadiuss.forEach(function(radius) {
				var options = {steps: 50, units: 'kilometers', properties: {}};
				var feature = turf.circle(centerPoint, radius, options);
				var geometry = new THREE.Geometry();
				feature.geometry.coordinates[0].forEach(function(coord) {
					geometry.vertices.push(_this._three._threebox.projectToWorld([coord[0], coord[1], -1]));
				});
				var circle = new THREE.Line(geometry, materialCircle);
				group.add(circle);
			});
		}
		
		var coords = _this.data.geometry.coordinates[0]; 
		var height = 0;
		var levels = JSON.parse(_this.data.properties.levels);
		levels.forEach(function(floorHeight){
			height += floorHeight;
		});
		//重新计算建筑物高度，并将之换算成世界坐标长度
		var buildingHeight = _this._three._threebox.distaneToWorld(height);
		
		//根据中心点和半径获得一个圆的要素
		var pillarRadius = 0.0002;  
		var pillarOptions = {steps: 10, units: 'kilometers', properties: {}};
		var pillarCircleFeatures = [];    //柱子feature集合
		
		var verticesBaseLine = [];  		//底面顶点集合
		var verticesUpLine = [];  			//顶面顶点集合
		var verticesSideLines = [];  		//侧棱顶点集合（可废弃，被侧棱柱替代）
		var verticesFloor = [];				//shape顶点集合
		var verticesSideWall = [];          //shape顶点集合
		
		for(var i = 0; i < coords.length; i ++) {
			//构建底面线、顶面线和侧楞的顶点
			var sideLineVertices = [];  //存放侧楞顶点（两个）
			var worldPos = _this._three._threebox.projectToWorld(coords[i]);
			verticesBaseLine.push(worldPos.clone());
			var clonePosSideLine = worldPos.clone();
			clonePosSideLine.z = buildingHeight;
			verticesUpLine.push(clonePosSideLine.clone());
			sideLineVertices.push(worldPos.clone());
			sideLineVertices.push(clonePosSideLine.clone());
			verticesSideLines.push(sideLineVertices);
			//构建地板和墙的顶点
			verticesFloor.push(worldPos.clone());
			verticesSideWall.push(worldPos.clone());
			//构建侧棱柱顶点
			var center = coords[i];
			var circleFeature = turf.circle(center, pillarRadius, pillarOptions);
			pillarCircleFeatures.push(circleFeature);
		}
		
		//构建材质
		//该材质用于底、顶面线和侧棱柱
		var lineMaterial = new THREE.MeshPhongMaterial({  
			color: 0xFFFFFF,
			transparent: true,
			opacity: 1
		});
		//该材质用于楼板线
		var floorLineMaterial = new THREE.MeshPhongMaterial({
			color: 0x627BC1,
			transparent: true,
			opacity: 0.5
		});
		//添加底部和顶部线
		var geometryBaseLine = _this._createLineGeometry(verticesBaseLine);
		var geometryUpLine = _this._createLineGeometry(verticesUpLine);
		var geometryBaseLineClone = geometryBaseLine.clone();
		var lineBase = new THREE.Line(geometryBaseLine, lineMaterial);
		lineBase.name = 'linebase';
		var lineUp = new THREE.Line(geometryUpLine, lineMaterial);
		lineUp.name = 'lineUp';
		group.add(lineBase);
		group.add(lineUp);
		
		var options = {
			pillar: {amount: buildingHeight, bevelEnabled: false},
			floor: {amount: 0.000000000001, bevelEnabled: false}  
		};
		var pillarMesh = _this._createPillarMesh(pillarCircleFeatures, options.pillar, lineMaterial);
		pillarMesh.name = 'pillar';
		group.add(pillarMesh);
		
		var MaterialFloorLine = new THREE.MeshPhongMaterial({
			color: 0x627BC1,
			transparent: true,
			opacity: 0.5
		});
		
		var geometryFloor = _this._createGeoExtrudeGeometry(verticesFloor, options.floor);
		var sum = 0;
		for(var j = 0;j < levels.length; j++) {
			var sum_world = _this._three._threebox.distaneToWorld(sum);
			var materialFloor = new THREE.MeshPhongMaterial({
				color: 0x627BC1, 
				transparent: true, 
				opacity: 0.1,
				specular: 0x627BC1,
				shininess: 100
			});
			
			var materialWall = new THREE.MeshPhongMaterial({
				color: 0x627BC1, 
				transparent: true, 
				opacity: 0.05,
				specular: 0xFFFF00,
				shininess: 100,
				side: THREE.DoubleSide
			});
			
			//创建地板
			var cloneGeo = geometryFloor.clone();
			cloneGeo.translate(0, 0, sum_world);
			var meshFloor = new THREE.Mesh(cloneGeo, materialFloor);
			meshFloor.userData.attributes = {
				OriginalData: _this.data,
				Layer: _this,
				level: j+1,
				tag: '__floor__'
			};
			meshFloor.userData.tag = '__floor__';
			meshFloor.name = 'this is ' + (j + 1) + ' floor';
			group.add(meshFloor);
			
			//创建楼层线
			if(_this.isFloorLinesVisible) {
				var floorLineGeo = geometryBaseLineClone.clone();
				floorLineGeo.translate(0, 0, sum_world);
				var lineFloor = new THREE.Line(floorLineGeo, MaterialFloorLine);
				//lineFloor.visible = _this.isFloorLinesVisible;
				group.add(lineFloor);
			}
			
			//创建墙 
			var floorHeight_World = _this._three._threebox.distaneToWorld(levels[j]);
			var optionsWall = {amount: floorHeight_World, bevelEnabled: false};
			var geometry = _this._createSideGeometry(verticesSideWall, optionsWall);
			geometry.translate(0, 0, sum_world);
			var meshWall = new THREE.Mesh(geometry, materialWall);
			meshWall.userData.attributes = {
				OriginalData: _this.data,
				Layer: _this,
				level: j+1,
				tag: '__wall__'
			};
			meshWall.userData.tag = '__wall__';
			meshWall.name = 'this is ' + (j + 1) + ' wall';
			group.add(meshWall);
			
			sum += levels[j];
		}
		
		//添加灯光效果
		/**
		//lightTarget
		var pos = [centerPoint[0], centerPoint[1], 300];
		var material = new THREE.MeshPhongMaterial( { color: 0xffffff, transparent: true, opacity: 0 } );
		var geometry = new THREE.BoxGeometry( 1, 1, 1 );
		var meshBox = new THREE.Mesh( geometry, material );
		meshBox.visible = false;
		meshBox.position.copy(_this._three._threebox.projectToWorld([centerPoint[0], centerPoint[1], 0]));
		meshBox.name = 'lightTarget';
		meshBox.scale.copy(new THREE.Vector3(1,1,1).multiplyScalar(_this._three._threebox.projectedUnitsPerMeter(centerPoint[1])));
		//group2.add(meshBox);
		//spotLight
		var spotLight = new THREE.SpotLight( 0x627BC1, 1 );
		spotLight.name = 'spotLight';
		spotLight.position.copy(_this._three._threebox.projectToWorld([centerPoint[0], centerPoint[1], height+50]));
		spotLight.angle = Math.PI / 4;
		spotLight.target = meshBox;
		spotLight.matrixWorldNeedsUpdate = true;
		//group2.add( spotLight );
		*/
		//球
		var sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, transparent: true, opacity: 1 } );
		var sphereGeometry = new THREE.SphereBufferGeometry( 0.001, 32, 16 );
		var meshSphere = new THREE.Mesh( sphereGeometry, sphereMaterial );
		meshSphere.position.copy(_this._three._threebox.projectToWorld([centerPoint[0], centerPoint[1], 0]));
		meshSphere.name = 'sphereTarget';
		meshSphere.scale.copy(new THREE.Vector3(1,1,1).multiplyScalar(_this._three._threebox.projectedUnitsPerMeterInScale(centerPoint[1])));
		group2.add(meshSphere);
		//pointLight
		var pointLight = new THREE.PointLight( 0xFFFF00, 200, 0 );
		pointLight.matrixWorldNeedsUpdate = true;
		meshSphere.add( pointLight );
		//添加
		_this._three._threebox.addGeoreferencedMeshToWorld2(group);
		_this._meshes.push(group);
		_this._three._threebox.addGeoreferencedMesh(group2);
		_this._meshes.push(group2);
		
		//定时循环
		var v2 = _this._three._threebox.projectToWorld([centerPoint[0], centerPoint[1], height]);
		var v1 = _this._three._threebox.projectToWorld([centerPoint[0], centerPoint[1], 0]);
		var lineCenterCurve = new THREE.LineCurve3(v1, v2);
		
		var pos = 0;
		
		function step(timestamp, elapsed) {
			if (elapsed > 1000 / 60) {   //控制帧数ms
				
				if(pos < 1){
					meshSphere.position.copy(lineCenterCurve.getPointAt(pos));
					pos += 0.01;
				}else{
					pos = 0;
				}
				_this._three._render();
				elapsed = 0;
			}
			window.requestAnimationFrame(function(_timestamp) {
				return step(_timestamp, elapsed + _timestamp - timestamp);
			});
		}
		window.requestAnimationFrame(function(timestamp) {
			return step(timestamp, 0);
		});
		
	}
});/**
 * @class GeoGlobe.Visuals.Three.RainLayer
 * @desc 点图层
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -47,
	pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});
 //构造THREE可视化图层
 var threebox = new GeoGlobe.Visuals.Three();
 //添加到地图中
 threebox.addTo(map);
 //构造点图层
 var rainLayer = new GeoGlobe.Visuals.Three.RainLayer({
	id: 'rain',
	texture: '../../images/sprites/rain.png',
	size: 10,
    visible: true,
    pickable: true,
    opacity: 1
});
 //添加到THREE图层
 rainLayer.addTo(threebox);
 //绘制
 threebox.render();
 */
GeoGlobe.Visuals.Three.RainLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 可见性
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * 是否可拾取
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @type {Boolean}
     * @default true
     */
    pickable: true,

    /**
     * 透明度 0-1
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @type {Number}
     * @default 1.0
     */
    opacity: 1.0,
	
	/**
     * 参数对象
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {Object}
     * @example
     *  {
	 *	  id: 'rain',
	 *	  texture: '../../images/sprites/rain.png',
	 *	  size: 10,
	 *	  visible: true,
	 *	  pickable: true,
	 *	  opacity: 1
	 *  }
     */
    options: {},

    /**
     * 纹理图片资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @param {Object} options
     * @returns {String} texture - 图片纹理资源路径
     */
    getTexture: function (options) {
        return options.texture ? options.texture : '';
    },

    /**
     * 粒子尺寸的GET属性
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @param {Object} options
     * @returns {Number} size - 尺寸值
     */
    getSize: function (options) {
        return options.size ? options.size : 10;
    },

    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,

    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @private
     * @type {Array}
     */
    _meshes: [],

    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @type {Array}
     * @private
     * @default ''
     */
    _textureCache: [],

    /**
     * @name GeoGlobe.Visuals.Three.RainLayer构造函数。
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
		this.visible = options.visible !== undefined ? options.visible : this.visible;
        this.opacity = options.opacity ? options.opacity : this.opacity;
		this.pickable = options.pickable !== undefined ? options.pickable : this.pickable;
        this.getTexture = options.getTexture ? options.getTexture : this.getTexture;
        this.getSize = options.getSize ? options.getSize : this.getSize;
		this.options = options ? options : this.options;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three
     */
    addTo: function (three) {
        this._three = three;
        this._three.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     */
    remove: function () {
        this._three.removeLayer(this.id);
    },
	
	/**
     * 设置粒子的显示和隐藏状态
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
	 * @param {Boolean} visible
     */
    setVisible: function (visible) {
        this.rain.visible = visible;
		this.visible = visible;
    },
	
	/**
     * 获得粒子的显示和隐藏状态
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     */
    getVisible: function () {
        return this.visible;
    },
	
	/**
     * 创建粒子对象
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
	 * @param {Object} options 参数对象
	 * @returns {Object} rain 雨粒子
     */
    createRainSprites: function (options) {
		var _this = this;
        var geometry = new THREE.Geometry();
		var positions = [];
		for ( i = 0; i < 20000; i ++ ) {
			var vertex = new THREE.Vector3();
			vertex.x = Math.random() * 8000 - 4000;
			vertex.y = Math.random() * 8000 - 4000;
			vertex.z = Math.random() * 4000;
			vertex.velocityZ = 6;
			vertex.velocityX = (Math.random() - 0.5) / 3;
			geometry.vertices.push( vertex );
		}
		geometry.verticesNeedUpdate = true;
		var size = _this.getSize(options);
		var material = null;
		var textureURL = _this.getTexture(options);
		if (textureURL) {
			var texture = _this._getTextureCacheByURL(textureURL);
			if (texture) {
				texture = texture.clone();
			} else {
				texture = new THREE.TextureLoader().load(textureURL, function (t) {
					_this._three._render();
				});
				_this._addTextureInToCache({
					key: textureURL,
					value: texture
				})
			}
			material = new THREE.PointsMaterial( { size: size, map: texture, blending: THREE.AdditiveBlending, depthTest: false, transparent : true, sizeAttenuation: true } );
		} else {
			console.error("未设置纹理图片资源路径！");
		}
		var particles = new THREE.Points( geometry, material );
		return particles;
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     */
    render: function () {
        var _this = this;
        _this._three._removeInnerLayer(_this);
        _this._meshes = [];
		
		var options = _this.options;
		_this.rain = _this.createRainSprites(options);
		_this.rain.visible = _this.visible;
		_this.rain.name = _this.id ? _this.id : "threelayer";
		_this.rain.userData.attributes = {
			OriginalData: options,
			Layer: _this
		};
		var center = _this._three.map.getCenter();
		var position = [center.lng, center.lat, 0];
		_this._three._threebox.addAtCoordinate(_this.rain, position, { scaleToLatitude: true, preScale: 1 });
		_this._meshes.push(_this.rain);
        _this._three._render();
		
		(function animate() {
			requestAnimationFrame(animate);
			var vertices = _this.rain.geometry.vertices;
			vertices.forEach(function (v) {
				v.z = v.z - (v.velocityZ);
				v.x = v.x - (v.velocityX)*.5;
				if(v.z < 0) v.z = 4000;
			});
			_this.rain.geometry.verticesNeedUpdate = true;
			_this._three._render();
		})();
		
		_this._three.map.on('zoom', function(e) {
			if(_this.getVisible()) {
				if(_this._three.map.getZoom() < 15) _this.rain.visible = false;
				else _this.rain.visible = true;
			}
		});
		
		_this._three.map.on('dragend', function(e) {
			if(_this.rain.visible) {
				var center = _this._three.map.getCenter();
				_this.rain.parent.position.copy(_this._three._threebox.projectToWorld([center.lng,center.lat,0]));
			}
		});
    },

    /**
     * 从缓存中获取纹理
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @private
     * @param {String} url - 图片纹理资源路径
     * @returns {Object} texture - 图片纹理
     */
    _getTextureCacheByURL: function (url) {
        if (url) {
            for (var i = 0; i < this._textureCache.length; i++) {
                if (this._textureCache[i].key === url && this._textureCache[i].value.image) {
                    return this._textureCache[i].value;
                }
            }
            return null;
        } else {
            return null;
        }
    },
    /**
     * 向缓存中添加纹理
     * @memberof GeoGlobe.Visuals.Three.RainLayer.prototype
     * @private
     * @param {Object} map {key: sideTextureURL,value: textureSide}
     */
    _addTextureInToCache: function (map) {
        var isExist = false;
        for (var i = 0; i < this._textureCache.length; i++) {
            if (this._textureCache[i].key === map.key) {
                isExist = true;
                break;
            }
        }
        if (!isExist) {
            this._textureCache.push(map);
        }
    }
});/**
 * @class GeoGlobe.Visuals.Three.SnowLayer
 * @desc 点图层
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: -47,
	pitch: 45,
    units: "degrees",
    center: [114.26734490525155, 30.594607628267966]
});
 //构造THREE可视化图层
 var threebox = new GeoGlobe.Visuals.Three();
 //添加到地图中
 threebox.addTo(map);
 //构造点图层
 var snowLayer = new GeoGlobe.Visuals.Three.SnowLayer({
	id: 'snow',
	texture: '../../images/sprites/snowflake.png',
	size: 10,
    visible: true,
    pickable: true,
    opacity: 1
});
 //添加到THREE图层
 snowLayer.addTo(threebox);
 //绘制
 threebox.render();
 */
GeoGlobe.Visuals.Three.SnowLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 可见性
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * 是否可拾取
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @type {Boolean}
     * @default true
     */
    pickable: true,

    /**
     * 透明度 0-1
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @type {Number}
     * @default 1.0
     */
    opacity: 1.0,
	
	/**
     * 参数对象
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {Object}
     * @example
     *  {
	 *	  id: 'snow',
	 *	  texture: '../../images/sprites/snowflake.png',
	 *	  size: 10,
	 *	  visible: true,
	 *	  pickable: true,
	 *	  opacity: 1
	 *  }
     */
    options: {},

    /**
     * 纹理图片资源路径GET属性
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @param {Object} options
     * @returns {String} texture - 图片纹理资源路径
     */
    getTexture: function (options) {
        return options.texture ? options.texture : '';
    },

    /**
     * 粒子尺寸的GET属性
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @param {Object} options
     * @returns {Number} size - 尺寸值
     */
    getSize: function (options) {
        return options.size ? options.size : 10;
    },

    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,

    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @private
     * @type {Array}
     */
    _meshes: [],

    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @type {Array}
     * @private
     * @default ''
     */
    _textureCache: [],

    /**
     * @name GeoGlobe.Visuals.Three.SnowLayer构造函数。
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
		this.visible = options.visible !== undefined ? options.visible : this.visible;
        this.opacity = options.opacity ? options.opacity : this.opacity;
		this.pickable = options.pickable !== undefined ? options.pickable : this.pickable;
        this.getTexture = options.getTexture ? options.getTexture : this.getTexture;
        this.getSize = options.getSize ? options.getSize : this.getSize;
		this.options = options ? options : this.options;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three
     */
    addTo: function (three) {
        this._three = three;
        this._three.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     */
    remove: function () {
        this._three.removeLayer(this.id);
    },
	
	/**
     * 设置雪花粒子的显示和隐藏状态
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
	 * @param {Boolean} visible
     */
    setVisible: function (visible) {
        this.snow.visible = visible;
		this.visible = visible;
    },
	
	/**
     * 获得雪花粒子的显示和隐藏状态
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     */
    getVisible: function () {
        return this.visible;
    },
	
	/**
     * 创建雪花粒子对象
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
	 * @param {Object} options 参数对象
	 * @returns {Object} snow 雪花粒子
     */
    createSnowSprites: function (options) {
		var _this = this;
        var geometry = new THREE.Geometry();
		var positions = [];
		for ( i = 0; i < 20000; i ++ ) {
			var vertex = new THREE.Vector3();
			vertex.x = Math.random() * 8000 - 4000;
			vertex.y = Math.random() * 8000 - 4000;
			vertex.z = Math.random() * 4000;
			vertex.velocityZ = 2;
			vertex.velocityX = (Math.random() - 0.5) / 3;
			geometry.vertices.push( vertex );
		}
		geometry.verticesNeedUpdate = true;
		var size = _this.getSize(options);
		var material = null;
		var textureURL = _this.getTexture(options);
		if (textureURL) {
			var texture = _this._getTextureCacheByURL(textureURL);
			if (texture) {
				texture = texture.clone();
			} else {
				texture = new THREE.TextureLoader().load(textureURL, function (t) {
					_this._three._render();
				});
				_this._addTextureInToCache({
					key: textureURL,
					value: texture
				})
			}
			material = new THREE.PointsMaterial( { size: size, map: texture, blending: THREE.AdditiveBlending, depthTest: false, transparent : true, sizeAttenuation: true } );
		} else {
			console.error("未设置纹理图片资源路径！");
		}
		var particles = new THREE.Points( geometry, material );
		return particles;
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     */
    render: function () {
        var _this = this;
        _this._three._removeInnerLayer(_this);
        _this._meshes = [];
		
		var options = _this.options;
		_this.snow = _this.createSnowSprites(options);
		_this.snow.visible = _this.visible;
		_this.snow.name = _this.id ? _this.id : "threelayer";
		_this.snow.userData.attributes = {
			OriginalData: options,
			Layer: _this
		};
		var center = _this._three.map.getCenter();
		var position = [center.lng, center.lat, 0];
		_this._three._threebox.addAtCoordinate(_this.snow, position, { scaleToLatitude: true, preScale: 1 });
		_this._meshes.push(_this.snow);
        _this._three._render();
		
		(function animate() {
			requestAnimationFrame(animate);
			var vertices = _this.snow.geometry.vertices;
			vertices.forEach(function (v) {
				v.z = v.z - (v.velocityZ);
				v.x = v.x - (v.velocityX)*.5;
				if(v.z < 0) v.z = 4000;
			});
			_this.snow.geometry.verticesNeedUpdate = true;
			_this._three._render();
		})();
		
		_this._three.map.on('zoom', function(e) {
			if(_this.getVisible()) {
				if(_this._three.map.getZoom() < 15) _this.snow.visible = false;
				else _this.snow.visible = true;
			}
		});
		
		_this._three.map.on('dragend', function(e) {
			if(_this.snow.visible) {
				var center = _this._three.map.getCenter();
				_this.snow.parent.position.copy(_this._three._threebox.projectToWorld([center.lng,center.lat,0]));
			}
		});
    },

    /**
     * 从缓存中获取纹理
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @private
     * @param {String} url - 图片纹理资源路径
     * @returns {Object} texture - 图片纹理
     */
    _getTextureCacheByURL: function (url) {
        if (url) {
            for (var i = 0; i < this._textureCache.length; i++) {
                if (this._textureCache[i].key === url && this._textureCache[i].value.image) {
                    return this._textureCache[i].value;
                }
            }
            return null;
        } else {
            return null;
        }
    },
    /**
     * 向缓存中添加纹理
     * @memberof GeoGlobe.Visuals.Three.SnowLayer.prototype
     * @private
     * @param {Object} map {key: sideTextureURL,value: textureSide}
     */
    _addTextureInToCache: function (map) {
        var isExist = false;
        for (var i = 0; i < this._textureCache.length; i++) {
            if (this._textureCache[i].key === map.key) {
                isExist = true;
                break;
            }
        }
        if (!isExist) {
            this._textureCache.push(map);
        }
    }
});/**
 * @class GeoGlobe.Visuals.Three.BrightkiteLayer
 * @desc 网格图层
 * @example
 //构造地图对象
 //构造地图对象
var map = new GeoGlobe.Map({
	style: Cfg.style,
	container: 'map',
	zoom: 10,
	bearing: 0,
	pitch: 0,
	units: "degrees",
	isIntScrollZoom: true,
	center: [114.31312918998901, 30.55318201596893]
});
 //构造THREE可视化图层
var threebox = new GeoGlobe.Visuals.Three();
//添加到地图中
threebox.addTo(map);
//构造三维线图层
var options = {
	id: 'rtds',
	visible: true,
	pickable: true,
	opacity: 1,
	tileSize: 256,  //与当前地图瓦片大小保持一致
	name: '实时数据服务',
	service: 'http://192.168.30.91:9010/RTDS/rtds',
	version: '1.0.0',
	format: 'json',
	levelPrecision: [8,8,8,8,8,8,8,2,2,6,7],
	requestArgs: {
		datasetname: 'test0810',
		starttime: '2012-01-01 00:00:00',
		endtime: '2018-12-31 23:59:59'
	},
	rendererOptions: {
		markPoint: {
			symbolMinSize: 10,
			symbolMaxSize: 10,
			effect: {
				show: true,
				scaleSize: 1,
				period: 10
			},
			color: "rgba(255, 122, 20, 1)"
		}
	}
}
var rtdsLayer = new GeoGlobe.Visuals.Three.BrightkiteLayer(options);
//添加到THREE图层
rtdsLayer.addTo(threebox);
//绘制
rtdsLayer.render();
 */
GeoGlobe.Visuals.Three.BrightkiteLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 可见性
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {Boolean}
     * @default true
     */
    visible: true,

    /**
     * 是否可拾取
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {Boolean}
     * @default true
     */
    pickable: true,

    /**
     * 透明度 0-1
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {Number}
     * @default 1.0
     */
    opacity: 1.0,
	
	/**
     * 实时数据服务名称
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {String}
     * @default '实时数据服务'
     */
    name: '实时数据服务',
	
	/**
     * 服务版本号
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {String}
     * @default '1.0.0'
     */
    version: '1.0.0',
	
	/**
     * 输出格式，默认值为JSON
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {String}
     * @default 'json'
     */
    format: 'json',
	
	/**
     * [可选]精度,填写数值0,1,2,3,4,5,6,7,8等整数值，0代表bbox类别，1及以上代表网格，数值越大查询的格网越小
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {Array}
     * @default [8,8,8]
     */
    levelPrecision: [8,8,8],
	
	/**
     * 请求服务参数
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {Object}
     * @default {}
     */
    requestArgs: {},
	
	/**
     * 渲染参数
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {Object}
     * @default {}
     */
    rendererOptions: {},
	
	/**
     * 参数对象
     * @memberof GeoGlobe.Visuals.Three.PointLayer.prototype
     * @type {Object}
     * @example
     *  {
	 *	  id: 'brightkite',
	 *	  tiles: '../../images/sprites/snowflake.png',
	 *	  tileSize: 256,
	 *	  visible: true,
	 *	  pickable: true,
	 *	  opacity: 1
	 *  }
     */
    options: {},

    /**
     * 请求服务地址
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {String}
     * @default 'RTDS'
     */
    service: 'RTDS',
	
	/**
     * 瓦片大小
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {Number}
     * @default 256
     */
    tileSize: 256,

    /**
     * Three可视化对象
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.Three}
     */
    _three: null,

    /**
     * 内部网格集合
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     * @type {Array}
     */
    _meshes: [],

    /**
     * 纹理缓存器
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @type {Array}
     * @private
     * @default ''
     */
    _textureCache: [],

    /**
     * @name GeoGlobe.Visuals.Three.BrightkiteLayer构造函数。
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
		this.options           = options ? options : this.options;
		this.textureCoord      = [new THREE.Vector2(1, 0),new THREE.Vector2(0, 0),new THREE.Vector2(0, 1),new THREE.Vector2(1, 1)];
        this.id                = options.id ? options.id : this.id;
		this.visible           = options.visible !== undefined ? options.visible : this.visible;
        this.opacity           = options.opacity ? options.opacity : this.opacity;
		this.pickable          = options.pickable !== undefined ? options.pickable : this.pickable;
        this.name              = options.name ? options.name : this.name;
		this.service           = options.service ? options.service : this.service;
		this.tileSize          = options.tileSize ? options.tileSize : this.tileSize;
		this.version           = options.version ? options.version : this.version;
		this.format            = options.format ? options.format : this.format;
		this.levelPrecision    = options.levelPrecision ? options.levelPrecision : this.levelPrecision;
		this.requestArgs       = options.requestArgs ? options.requestArgs : this.requestArgs;
		this.rendererOptions   = options.rendererOptions ? options.rendererOptions : this.rendererOptions;
		this.getService        = options.getService ? options.getService : this.getService;
		this.projMatrix        = new Float64Array(16);
		this.alignedProjMatrix = new Float64Array(16);
		this.pixelMatrix       = new Float64Array(16);
		this.pixelMatrixInverse= new Float64Array(16);
		
		this._initMat4();
		this._initCalculator();
		this.mat4              = new this.mat4();
		this.calculator        = new this.calculator();

		//使用Worker和OffscreenCanvas优化绘制
        'OffscreenCanvas' in window && this._initWorker();
    },

    _initWorker: function () {
        var _this = this;
        var texture;
        var workerCode = "\n// debugger\n'use strict';\n\nfunction transformMat4(out, a, m){\n    var x = a[0], y = a[1], z = a[2], w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return out;\n}\n\nfunction zoomTo(column, row, zoom, tileZoom){\n    var scale = Math.pow(2, tileZoom - zoom);\n    column *= scale;\n    row *= scale;\n    zoom = tileZoom;\n    \n    return {\n       column: column,\n       row: row,\n       zoom: zoom,\n    };\n}\n\nfunction locationCoordinate(lnglat, transform){\n    var column = (180 + lnglat[0]) * transform.worldSize / 360 / transform.tileSize;\n    var row = (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lnglat[1] * Math.PI / 360)))) * transform.worldSize / 360 / transform.tileSize;\n    var zoom = transform.zoom;\n    \n    return zoomTo(column, row, zoom, transform.tileZoom);\n}\n\nfunction coordinatePoint(coord, transform){\n    var zoomedCoord = zoomTo(coord.column, coord.row, coord.zoom, transform.zoom);\n    var p = [zoomedCoord.column * transform.tileSize, zoomedCoord.row * transform.tileSize, 0, 1];\n    transformMat4(p, p, transform.pixelMatrix);\n    return {\n        x: p[0] / p[3],\n        y: p[1] / p[3]\n    };\n}\n\nfunction locationPoint(lnglat, transform){\n    return coordinatePoint(locationCoordinate(lnglat, transform), transform);\n}\n\nfunction project(lnglat, transform){\n    return locationPoint(lnglat, transform);\n}\n\n/**\n * \u6839\u636E\u5355\u4E2A\u74E6\u7247URL\u8BF7\u6C42\u77E2\u91CF\u6570\u636E\uFF0C\u5E76\u53D1\u8D77\u56DE\u8C03\n * @param {Object} requestArgs \u5355\u4E2A\u74E6\u7247\u7684\u5B9E\u65F6\u6570\u636E\u7684\u8BF7\u6C42\u53C2\u6570\n * @param {Function} callback \u8BF7\u6C42\u5B8C\u6210\u540E\u56DE\u8C03\u51FD\u6570\n */\nfunction getCanvas(requestArgs, callback) {\n\tvar formData = new FormData();\n    formData.append('SERVICE', 'RTDS');\n    formData.append('VERSION', '" + _this.version + "');\n    formData.append('REQUEST', 'FeatureAggs');\n    formData.append('FORMAT', '" + _this.format + "');\n    for(var arg in requestArgs){\n        if(requestArgs.hasOwnProperty(arg)){\n            formData.append(arg.toUpperCase(), requestArgs[arg]);\n        }\n    }\n    \n    var url = proxyHost + '" + _this.service + "?'\n    formData.forEach(function(value, arg) {\n        url += arg + '=' + value + '&';\n    });\n    url = url.slice(0, -1);\n    \n\tvar xhr = new XMLHttpRequest();\n\txhr.open('GET', url, true);\n    xhr.responseType = 'json';\n    xhr.send(null);\n\txhr.onreadystatechange = function (e) {\n\t\tif (this.status === 200 && this.readyState === 4) {\n\t\t    callback(this.response);\n\t\t}\n\t};\n}\n\n/**\n * \u5C06\u8BF7\u6C42\u83B7\u5F97\u7684\u5355\u4E2A\u74E6\u7247\u77E2\u91CF\u6570\u636E\u6E32\u67D3\u6210\u6805\u683C\u56FE\u50CF\n * @param {Object} data \u8BF7\u6C42\u5355\u4E2A\u74E6\u7247\u77E2\u91CF\u6570\u636E\u8FD4\u56DE\u7684\u7ED3\u679C\n * @param {Object} coordinate \u5355\u4E2A\u74E6\u7247\u884C\u5217\u53F7\n * @param {Object} transform \u5730\u56FE\u53C2\u6570\n * @param {Function} callback \u8BF7\u6C42\u5B8C\u6210\u540E\u56DE\u8C03\u51FD\u6570\n*/\nfunction renderToCanvas(data, coordinate, transform, callback) {\n    //\u74E6\u7247\u79BB\u5C4F\u753B\u5E03\uFF08266*266\uFF09\n    var tileOffscreen = new OffscreenCanvas(" + _this.tileSize + " + 10, " + _this.tileSize + " + 10);\n    var tileOffscreenContext = tileOffscreen.getContext('2d');\n    tileOffscreenContext.globalCompositeOperation = 'lighter';\n    \n\tvar features = [];\n\tdata.forEach(function (elt, i) {\n\t\tfeatures.push({\n\t\t\t\"type\": \"Feature\",\n\t\t\t\"properties\": {name: i, value: elt.value},\n\t\t\t\"geometry\": {\n\t\t\t\t\"type\": \"Point\",\n\t\t\t\t\"coordinates\": [elt.location.X, elt.location.Y]\n\t\t\t}\n\t\t});\n\t});\n\t\n\t// \u6C42\u6781\u503C\n\tvar minValue = Number.MAX_VALUE;\n\tvar maxValue = Number.MIN_VALUE;\n\tfor (var k = 0; k < features.length; k++) {\n\t\tif (features[k].properties.value < minValue) minValue = features[k].properties.value;\n\t\tif (features[k].properties.value > maxValue) maxValue = features[k].properties.value;\n\t}\n\t//\u6807\u6CE8\u53C2\u6570\u8BA1\u7B97\n\tfor (var j = 0; j < features.length; j++) {\n\t\t//\u74E6\u7247\u4E0A\u7684\u70B9\u76F8\u5BF9\u4E8E\u753B\u5E03\u7684\u5750\u6807\n\t\tvar point = project([features[j].geometry.coordinates[0], features[j].geometry.coordinates[1]], transform);\n\t\tvar canvasCord = coordinatePoint(coordinate, transform);\n\t\tvar X = point.x - (canvasCord.x-5);\n\t\tvar Y = point.y - (canvasCord.y-5);\n\n\t\t//\u7ED8\u5236\n\t\ttileOffscreenContext.save();\n\t\ttileOffscreenContext.translate(X, Y);\n\t\ttileOffscreenContext.drawImage(spriteOffscreen, -spriteOffscreen.width / 2, -spriteOffscreen.width / 2);\n\t\ttileOffscreenContext.restore();\n\t}\n\t\n\tvar imgData = tileOffscreenContext.getImageData(5, 5, " + _this.tileSize + ", " + _this.tileSize + ");\n\ttileOffscreen.width = " + _this.tileSize + ";\n\ttileOffscreen.height = " + _this.tileSize + ";\n\ttileOffscreenContext.putImageData(imgData, 0, 0);\n\tcallback(tileOffscreen);\n}\n\nvar proxyHost;\nvar spriteOffscreen, spriteOffscreenContext;\nself.onmessage = function(e) {\n    if(!e.data.key){\n        proxyHost = e.data.proxyHost;\n\n        //\u5C0F\u7CBE\u7075\u79BB\u5C4F\u753B\u5E03\uFF0810*10\uFF09\n        spriteOffscreen = new OffscreenCanvas(e.data.size, e.data.size);\n        spriteOffscreenContext = spriteOffscreen.getContext('2d');\n        \n        //\u5C0F\u7CBE\u7075\u6807\u6CE8\u989C\u8272\u914D\u7F6E\u6682\u65F6\u53EA\u652F\u6301\u5355\u8272\n        var gradient = spriteOffscreenContext.createRadialGradient(e.data.size / 2, e.data.size / 2, 0, e.data.size / 2, e.data.size / 2, e.data.size / 2);\n        gradient.addColorStop(0.15, e.data.color);\n        gradient.addColorStop(0.5, 'rgba' + e.data.rgbColor.slice(3).split(')')[0] + ',0.15)');\n        gradient.addColorStop(1, 'rgba' + e.data.rgbColor.slice(3).split(')')[0] + ',0)');\n        spriteOffscreenContext.fillStyle = gradient;\n        spriteOffscreenContext.fillRect(0, 0, e.data.size, e.data.size);\n    } else {\n        getCanvas(e.data.requestArgs, function(response){\n            renderToCanvas(response, e.data.coordinate, e.data.transform, function(canvas){\n                var bitmap = canvas.transferToImageBitmap();\n                postMessage({\n                    key: e.data.key,\n                    bitmap: bitmap\n                }, [bitmap]);\n            });\n        });\n    }\n};";
        /*var workerCode = `
// debugger
'use strict';

function transformMat4(out, a, m){
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
}

function zoomTo(column, row, zoom, tileZoom){
    var scale = Math.pow(2, tileZoom - zoom);
    column *= scale;
    row *= scale;
    zoom = tileZoom;

    return {
       column: column,
       row: row,
       zoom: zoom,
    };
}

function locationCoordinate(lnglat, transform){
    var column = (180 + lnglat[0]) * transform.worldSize / 360 / transform.tileSize;
    var row = (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lnglat[1] * Math.PI / 360)))) * transform.worldSize / 360 / transform.tileSize;
    var zoom = transform.zoom;

    return zoomTo(column, row, zoom, transform.tileZoom);
}

function coordinatePoint(coord, transform){
    var zoomedCoord = zoomTo(coord.column, coord.row, coord.zoom, transform.zoom);
    var p = [zoomedCoord.column * transform.tileSize, zoomedCoord.row * transform.tileSize, 0, 1];
    transformMat4(p, p, transform.pixelMatrix);
    return {
        x: p[0] / p[3],
        y: p[1] / p[3]
    };
}

function locationPoint(lnglat, transform){
    return coordinatePoint(locationCoordinate(lnglat, transform), transform);
}

function project(lnglat, transform){
    return locationPoint(lnglat, transform);
}

/!**
 * 根据单个瓦片URL请求矢量数据，并发起回调
 * @param {Object} requestArgs 单个瓦片的实时数据的请求参数
 * @param {Function} callback 请求完成后回调函数
 *!/
function getCanvas(requestArgs, callback) {
	var formData = new FormData();
    formData.append('SERVICE', 'RTDS');
    formData.append('VERSION', '${_this.version}');
    formData.append('REQUEST', 'FeatureAggs');
    formData.append('FORMAT', '${_this.format}');
    for(var arg in requestArgs){
        if(requestArgs.hasOwnProperty(arg)){
            formData.append(arg.toUpperCase(), requestArgs[arg]);
        }
    }

    var url = proxyHost + '${_this.service}?'
    formData.forEach(function(value, arg) {
        url += arg + '=' + value + '&';
    });
    url = url.slice(0, -1);

	var xhr = new XMLHttpRequest();
	xhr.open('GET', url, true);
    xhr.responseType = 'json';
    xhr.send(null);
	xhr.onreadystatechange = function (e) {
		if (this.status === 200 && this.readyState === 4) {
		    callback(this.response);
		}
	};
}

/!**
 * 将请求获得的单个瓦片矢量数据渲染成栅格图像
 * @param {Object} data 请求单个瓦片矢量数据返回的结果
 * @param {Object} coordinate 单个瓦片行列号
 * @param {Object} transform 地图参数
 * @param {Function} callback 请求完成后回调函数
*!/
function renderToCanvas(data, coordinate, transform, callback) {
    //瓦片离屏画布（266*266）
    var tileOffscreen = new OffscreenCanvas(${_this.tileSize} + 10, ${_this.tileSize} + 10);
    var tileOffscreenContext = tileOffscreen.getContext('2d');
    tileOffscreenContext.globalCompositeOperation = 'lighter';

	var features = [];
	data.forEach(function (elt, i) {
		features.push({
			"type": "Feature",
			"properties": {name: i, value: elt.value},
			"geometry": {
				"type": "Point",
				"coordinates": [elt.location.X, elt.location.Y]
			}
		});
	});

	// 求极值
	var minValue = Number.MAX_VALUE;
	var maxValue = Number.MIN_VALUE;
	for (var k = 0; k < features.length; k++) {
		if (features[k].properties.value < minValue) minValue = features[k].properties.value;
		if (features[k].properties.value > maxValue) maxValue = features[k].properties.value;
	}
	//标注参数计算
	for (var j = 0; j < features.length; j++) {
		//瓦片上的点相对于画布的坐标
		var point = project([features[j].geometry.coordinates[0], features[j].geometry.coordinates[1]], transform);
		var canvasCord = coordinatePoint(coordinate, transform);
		var X = point.x - (canvasCord.x-5);
		var Y = point.y - (canvasCord.y-5);

		//绘制
		tileOffscreenContext.save();
		tileOffscreenContext.translate(X, Y);
		tileOffscreenContext.drawImage(spriteOffscreen, -spriteOffscreen.width / 2, -spriteOffscreen.width / 2);
		tileOffscreenContext.restore();
	}

	var imgData = tileOffscreenContext.getImageData(5, 5, ${_this.tileSize}, ${_this.tileSize});
	tileOffscreen.width = ${_this.tileSize};
	tileOffscreen.height = ${_this.tileSize};
	tileOffscreenContext.putImageData(imgData, 0, 0);
	callback(tileOffscreen);
}

var proxyHost;
var spriteOffscreen, spriteOffscreenContext;
self.onmessage = function(e) {
    if(!e.data.key){
        proxyHost = e.data.proxyHost;

        //小精灵离屏画布（10*10）
        spriteOffscreen = new OffscreenCanvas(e.data.size, e.data.size);
        spriteOffscreenContext = spriteOffscreen.getContext('2d');

        //小精灵标注颜色配置暂时只支持单色
        var gradient = spriteOffscreenContext.createRadialGradient(e.data.size / 2, e.data.size / 2, 0, e.data.size / 2, e.data.size / 2, e.data.size / 2);
        gradient.addColorStop(0.15, e.data.color);
        gradient.addColorStop(0.5, 'rgba' + e.data.rgbColor.slice(3).split(')')[0] + ',0.15)');
        gradient.addColorStop(1, 'rgba' + e.data.rgbColor.slice(3).split(')')[0] + ',0)');
        spriteOffscreenContext.fillStyle = gradient;
        spriteOffscreenContext.fillRect(0, 0, e.data.size, e.data.size);
    } else {
        getCanvas(e.data.requestArgs, function(response){
            renderToCanvas(response, e.data.coordinate, e.data.transform, function(canvas){
                var bitmap = canvas.transferToImageBitmap();
                postMessage({
                    key: e.data.key,
                    bitmap: bitmap
                }, [bitmap]);
            });
        });
    }
};`;*/
        var blob = new Blob([workerCode], {type: 'text/javascript'});
        this.workerObjectURL = URL.createObjectURL(blob);
        this.worker = new Worker(this.workerObjectURL);
        this.worker.onmessage = function (e) {
            var canvas = document.createElement('canvas');
            canvas.width = _this.tileSize;
            canvas.height = _this.tileSize;
            canvas.getContext('bitmaprenderer').transferFromImageBitmap(e.data.bitmap);
            texture = new THREE.CanvasTexture(canvas);
            _this._addTextureInToCache({
                key: e.data.key,
                value: texture
            });
            _this._render();
        };

        //初始化
        this.worker.postMessage({
            size: this.rendererOptions.markPoint.symbolMaxSize,
            color: this.rendererOptions.markPoint.color,
            rgbColor: GeoGlobe.Util.getRgbColor(this.rendererOptions.markPoint.color),
            proxyHost: location.origin + '/' + location.pathname.split('/')[1] + '/proxy?url='
        });
        URL.revokeObjectURL(this.workerObjectURL);
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @param {GeoGlobe.Visuals.Three} three
     */
    addTo: function (three) {
        this._three = three;
        this._three.addLayer(this);
		this._bindEvent();
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     */
    remove: function () {
        this._three.removeLayer(this.id);
    },
	
	/**
     * @method
     * @desc 绑定事件
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private 
     */
	_bindEvent: function(){
		var _this = this;
		this._three.map.on('moveend', function BRIGHTKITE_MOVEEND_EVENT(e){
			_this._reDraw();
		});
	},
	
	/**
     * @method
     * @desc 重绘图层
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private 
     */
	_reDraw: function(){
		var _this = this;
		_this.update();
	},
	
	/**
     * @method
     * @desc 重绘图层
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     */
	reDraw: function(){
		this._clearTextureFromCache();
		this.update();
	},
	
    /**
     * @method
     * @desc 解绑事件
     * @memberof GeoGlobe.Visuals.Three.prototype
     * @private 
     */
	_unbindEvent: function(){
		var _this = this;
		for(var i=0; i<this._three.map._listeners['moveend'].length; i++){
			if(this._three.map._listeners['moveend'][i].name && this._three.map._listeners['moveend'][i].name === 'BRIGHTKITE_MOVEEND_EVENT'){
				this._three.map._listeners['moveend'].splice(i,1);
			}
		}
	},
	
	/**
     * 根据坐标和纹理生成瓦片网格对象
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
	 * @private
     * @param {Array} coords 瓦片地理范围
	 * @param {Object} texture 瓦片纹理
	 * @param {Array} textureCoord 纹理坐标
	 * @returns {Object} mesh - 瓦片网格对象
     */
    getTileMesh: function (coords, texture, textureCoord) {
		var vv1 = this._three._threebox.projectToWorld(coords[0]);
		var vv2 = this._three._threebox.projectToWorld(coords[1]);
		var vv3 = this._three._threebox.projectToWorld(coords[2]);
		var vv4 = this._three._threebox.projectToWorld(coords[3]);
		var vertices = [
			vv1, vv2, vv3, vv4
		];
		var faces = [
			new THREE.Face3(0, 1, 2),
			new THREE.Face3(0, 2, 3)
		];
		var geometry = new THREE.Geometry();
		geometry.vertices = vertices;
		geometry.faces = faces;
		geometry.computeFaceNormals();
		geometry.faceVertexUvs = [[]];
		geometry.faceVertexUvs[0][0] = [textureCoord[2],textureCoord[1],textureCoord[0]];
		geometry.faceVertexUvs[0][1] = [textureCoord[2],textureCoord[0],textureCoord[3]];
		var material = new THREE.MeshBasicMaterial({
			map: texture, 
			side: THREE.DoubleSide, 
			blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true});
		var mesh = new THREE.Mesh(geometry, material);
		return mesh;
    },
	
	/**
     * 计算瓦片地理范围
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
	 * @private
     * @param {Number} x 瓦片zoom值
	 * @param {Number} y 瓦片列号
	 * @param {Number} z 瓦片行号
	 * @returns {Array} coordinates - 瓦片地理范围: [minx, miny, maxx, maxy]
     */
    getTileBBox: function (x, y, z) {
        var zoom = Math.pow(2, z);
        y = (zoom - y - 1);
		
		var minx = -20037508.3427892 + 40075016.6855784 * x / zoom;
		var miny = -20037508.3427892 + 40075016.6855784 * y / zoom;
        var maxx = -20037508.3427892 + 40075016.6855784 * (x + 1) / zoom;
        var maxy = -20037508.3427892 + 40075016.6855784 * (y + 1) / zoom;
		
		return [minx, miny, maxx, maxy];
    },
	
	/**
     * 获取比瓦片大小大10像素的瓦片地理范围
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
	 * @private
     * @param {Number} x 瓦片zoom值
	 * @param {Number} y 瓦片列号
	 * @param {Number} z 瓦片行号
	 * @param {Object} transform 坐标计算的相关参数
	 * @returns {Array} coordinates - 瓦片地理范围: [minx, miny, maxx, maxy]
     */
    getBiggerTileBBox: function (x, y, z, transform) {
        var zoom = Math.pow(2, z);
        y = (zoom - y - 1);
		
		var minx = -20037508.3427892 + 40075016.6855784 * x / zoom;
		var miny = -20037508.3427892 + 40075016.6855784 * y / zoom;
        var maxx = -20037508.3427892 + 40075016.6855784 * (x + 1) / zoom;
        var maxy = -20037508.3427892 + 40075016.6855784 * (y + 1) / zoom;
		
		var min = GeoGlobe.Util.transferToLonLat([minx, miny]);
		var max = GeoGlobe.Util.transferToLonLat([maxx, maxy]);
		
		// var min_screen = this._three.map.project(min);
		var min_screen = this.calculator.project(min, transform);
        min_screen.x = min_screen.x - 5;
        min_screen.y = min_screen.y + this.tileSize + 5;
        // var max_screen = this._three.map.project(max);
		var max_screen = this.calculator.project(max, transform);
        max_screen.x = max_screen.x + this.tileSize + 5;
        max_screen.y = max_screen.y - 5;

        // var min = this._three.map.unproject(min_screen);
		var min = this.calculator.unproject(min_screen, transform);
        // var max = this._three.map.unproject(max_screen);
		var max = this.calculator.unproject(max_screen, transform);

		return [min.lng, min.lat, max.lng, max.lat];
    },
	
	/**
     * 根据单个瓦片URL请求矢量数据，并将请求结果渲染成栅格瓦片，并发起回调
	 * @private
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @param {Object} requestArgs 单个瓦片的实时数据的请求参数
	 * @param {Object} coordinate 瓦片坐标
	 * @param {String} key 从缓冲中获取纹理的key值
	 * @param {Function} callback 请求完成后回调函数
     */
    getCanvas: function (requestArgs, coordinate, key, transform, callback) {
		var _this = this;
		var rtds = new GeoGlobe.Service.RTDS(this.name, this.service, {
			version: this.version,
			format: this.format,
			coordinate: coordinate,
			key: key,
			transform: transform
		});
		rtds.featureAggs(requestArgs, function(data,obj){
			var canvas = _this.renderToCanvas(this, data, obj.coordinate, obj.transform);
			callback(canvas, obj.key);
		},function(e){

		})
    },

	/**
     * 将请求获得的单个瓦片矢量数据渲染成栅格图像
	 * @private
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @param {Object} context Window对象
	 * @param {Object} data 请求单个瓦片矢量数据返回的结果
	 * @param {Object} coordinate 单个瓦片行列号
	 * @param {Object} transform 坐标计算相关参数
	 * @returns {Object} canvas
     */
	renderToCanvas: function(context, data, coordinate, transform) {
		console.time('renderToCanvas');

        //单个标注的缓存画布
		if(!this.markPointCacheCanvas) {
            var markPointCacheCanvasSize = this.rendererOptions.markPoint.symbolMaxSize;
            this.markPointCacheCanvas = document.createElement("canvas");
            this.markPointCacheCanvas.width = markPointCacheCanvasSize;
            this.markPointCacheCanvas.height = markPointCacheCanvasSize;
            var markPointCacheCanvasContext = this.markPointCacheCanvas.getContext('2d');

            // markPointCacheCanvasContext.globalAlpha = alpha;

            //标注颜色配置暂时只支持单色
            var rgbColor = GeoGlobe.Util.getRgbColor(this.rendererOptions.markPoint.color);
            var gradient = markPointCacheCanvasContext.createRadialGradient(markPointCacheCanvasSize / 2, markPointCacheCanvasSize / 2, 0, markPointCacheCanvasSize / 2, markPointCacheCanvasSize / 2, markPointCacheCanvasSize / 2);
            gradient.addColorStop(0.15, this.rendererOptions.markPoint.color);
            gradient.addColorStop(0.5, 'rgba' + rgbColor.slice(3).split(')')[0] + ',0.15)');
            gradient.addColorStop(1, 'rgba' + rgbColor.slice(3).split(')')[0] + ',0)');
            markPointCacheCanvasContext.fillStyle = gradient;
            markPointCacheCanvasContext.fillRect(0, 0, markPointCacheCanvasSize, markPointCacheCanvasSize);
        }

		var myCanvas = document.createElement("canvas");
		myCanvas.width = this.tileSize + 10;
		myCanvas.height = this.tileSize + 10;
		var ctx = myCanvas.getContext("2d");
		ctx.globalCompositeOperation = 'lighter';

		var features = [];
        data.forEach(function (elt, i) {
            features.push({
                "type": "Feature",
                "properties": {name: i, value: elt.value},
                "geometry": {
                    "type": "Point",
                    "coordinates": [elt.location.X, elt.location.Y]
                }
            });
        });

        // 求极值
        var minValue = Number.MAX_VALUE;
        var maxValue = Number.MIN_VALUE;
        for (var k = 0; k < features.length; k++) {
            if (features[k].properties.value < minValue) minValue = features[k].properties.value;
            if (features[k].properties.value > maxValue) maxValue = features[k].properties.value;
        }
        //标注参数计算
        for (var j = 0; j < features.length; j++) {
			/**
            var weight = (features[j].properties.value - minValue) / (maxValue - minValue);//计算权重
            if (isNaN(weight)) weight = 1;
            if (weight > 1) weight = 1;
            if (weight < 0) weight = 0;
			//根据权重和options参数计算点的大小
            var size = this.rendererOptions.markPoint.symbolMinSize + (this.rendererOptions.markPoint.symbolMaxSize - this.rendererOptions.markPoint.symbolMinSize) * weight;
            var radius = size / 2;

			var scale = size / this.rendererOptions.markPoint.symbolMaxSize;
            var factor = 1;
            var energy = this.rendererOptions.markPoint.effect.show ? Math.random() * this.rendererOptions.markPoint.effect.scaleSize : this.rendererOptions.markPoint.effect.scaleSize;
            var increment = Math.max(0.1 * this.rendererOptions.markPoint.effect.scaleSize / this.rendererOptions.markPoint.effect.period + Math.random() * (Math.random() > 0.5 ? 1 : -1) * 0.002, 0.001);
            if (energy <= 0.15) {
                factor = 1;
            } else if (energy >= this.rendererOptions.markPoint.effect.scaleSize) {
                factor = -1;
            }
            energy += factor * increment;
			var alpha = +(this.rendererOptions.markPoint.color.split(',')[3].split(')')[0]) * weight;
			*/


            //瓦片上的点相对于画布的坐标

			// var point = this._three.map.project([features[j].geometry.coordinates[0], features[j].geometry.coordinates[1]]);
			var point = this.calculator.project([features[j].geometry.coordinates[0], features[j].geometry.coordinates[1]], transform);
            // var canvasCord = this._three.map.transform.coordinatePoint(coordinate);
			var canvasCord = this.calculator.coordinatePoint(coordinate, transform);
            var X = point.x - (canvasCord.x-5);
            var Y = point.y - (canvasCord.y-5);

            //绘制
            ctx.save();
            ctx.translate(X, Y);
			// ctx.scale(scale * energy, scale * energy);
            ctx.drawImage(this.markPointCacheCanvas, -this.markPointCacheCanvas.width / 2, -this.markPointCacheCanvas.height / 2);
            // ctx.globalCompositeOperation = 'lighter';
			// ctx.globalAlpha = context.alpha;
            ctx.restore();
		}

		var myCanvas_temp = document.createElement("canvas");
        myCanvas_temp.width = this.tileSize;
        myCanvas_temp.height = this.tileSize;
        var ctx_temp = myCanvas_temp.getContext("2d");
        var imgData = ctx.getImageData(5, 5, this.tileSize, this.tileSize);
        ctx_temp.putImageData(imgData, 0, 0);

		console.timeEnd('renderToCanvas');
		return myCanvas_temp;
	},
	
	/**
     * 通过图像对象生成纹理对象
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
	 * @private
     * @param {Image} img 图像对象
	 * @returns {Object} texture - 纹理对象
     */
	createTexture: function(img) {
		//TODO 用画布作纹理
		var canvas = document.createElement('canvas');
		canvas.height = 256;
		canvas.width = 256;
		var ctx = canvas.getContext('2d');
		ctx.drawImage(img,0,0);
		var texture = new THREE.CanvasTexture(canvas);  
		return texture;
	},
	
	/**
     * 根据服务地址获得单个瓦片的URL
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
	 * @private
	 * @param {String} tiles 服务地址
     * @param {Number} z 瓦片的zoom值
	 * @param {Number} x 瓦片的列号
	 * @param {Number} y 瓦片的行号
	 * @returns {String} tiles - 单个瓦片的URL
     */
    url: function (tiles,z,x,y) {
        return tiles
		.replace('{z}', String(z))
        .replace('{x}', String(x))
        .replace('{y}', String(y));
    },
	
	/**
     * 根据相机参数计算像素矩阵
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
	 * @private
	 * @param {Object} map mapbox地图对象
	 * @returns {Float64Array} pixelMatrix - 像素矩阵
     */
    _calcMatrices: function (map) {
		var transform = map.transform;
		if(!transform.height) return;
		var cameraToCenterDistance = 0.5 / Math.tan(transform.fov / 2) * transform.height;
		var halfFov = transform.fov / 2;
		var groundAngle = Math.PI / 2;
		var topHalfSurfaceDistance = Math.sin(halfFov) * cameraToCenterDistance / Math.sin(Math.PI - groundAngle - halfFov);
		var x = transform.x, y = transform.y;
		var furthestDistance = Math.cos(Math.PI / 2) * topHalfSurfaceDistance + cameraToCenterDistance;
		var farZ = furthestDistance * 1.01;
		
		var m = new Float64Array(16);
		this.mat4.perspective(m, transform.fov, transform.width / transform.height, 1, farZ);
		
		this.mat4.scale(m, m, [1, -1, 1]);
        this.mat4.translate(m, m, [0, 0, -cameraToCenterDistance]);
        this.mat4.rotateX(m, m, 0);
        this.mat4.rotateZ(m, m, 0);
        this.mat4.translate(m, m, [-x, -y, 0]);
		
		var verticalScale = transform.worldSize / (2 * Math.PI * 6378137 * Math.abs(Math.cos(transform.center.lat * (Math.PI / 180))));
        if(transform.units === "m"){
            verticalScale = transform.worldSize / (transform.latRange[1] - transform.latRange[0]);
        }
        this.mat4.scale(m, m, [1, 1, verticalScale, 1]);
        this.projMatrix = m;
		
		var xShift = (transform.width % 2) / 2, yShift = (transform.height % 2) / 2,
            angleCos = Math.cos(transform.angle), angleSin = Math.sin(transform.angle),
            dx = x - Math.round(x) + angleCos * xShift + angleSin * yShift,
            dy = y - Math.round(y) + angleCos * yShift + angleSin * xShift;
        var alignedM = new Float64Array(m);
        this.mat4.translate(alignedM, alignedM, [ dx > 0.5 ? dx - 1 : dx, dy > 0.5 ? dy - 1 : dy, 0 ]);
        this.alignedProjMatrix = alignedM;
		
		m = this.mat4.create();
        this.mat4.scale(m, m, [transform.width / 2, -transform.height / 2, 1]);
        this.mat4.translate(m, m, [1, -1, 0]);
        this.pixelMatrix = this.mat4.multiply(new Float64Array(16), m, this.projMatrix);
		
		m = this.mat4.invert(new Float64Array(16), this.pixelMatrix);
        if (!m) throw new Error("failed to invert matrix");
        this.pixelMatrixInverse = m;
    },
	
	/**
     * 更新瓦片以及瓦片纹理
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
	 * @private
     */
    update: function () {
        var _this = this;
        
		var idealTileIDs = _this._three.map.transform.coveringTiles({
			tileSize: _this.tileSize,
			minzoom: 0,
			maxzoom: 22,
			roundZoom: true
		});
		
		this._calcMatrices(_this._three.map);
		
		var transform = {
			pixelMatrix: _this.pixelMatrix,
			pixelMatrixInverse: _this.pixelMatrixInverse,
			worldSize: _this._three.map.transform.worldSize,
			tileSize: _this._three.map.transform.tileSize,
			tileZoom: _this._three.map.transform.tileZoom,
			zoom: _this._three.map.transform.zoom
		};
		
		for (var i = 0; i < idealTileIDs.length; i++) {
			var bbox = _this.getBiggerTileBBox(idealTileIDs[i].canonical.x, idealTileIDs[i].canonical.y, idealTileIDs[i].canonical.z, transform);
			var levelPrecision = _this.levelPrecision;
			var precision = 8;
			if(_this.levelPrecision[idealTileIDs[i].canonical.z - 1]) {
				precision = _this.levelPrecision[idealTileIDs[i].canonical.z - 1];
			}
			_this.requestArgs.precision = precision;
			_this.requestArgs.bbox = JSON.stringify(bbox);
			var coordinate = idealTileIDs[i].toCoordinate();
			coordinate.column = coordinate.column-1;
			var key = idealTileIDs[i].key;
			
			var texture = _this._getTextureCacheByTileId(key);
			if(!texture) {
				if(('OffscreenCanvas' in window)) {
                    _this.worker.postMessage({
                        key: key,
                        coordinate: coordinate,
                        requestArgs: _this.requestArgs,
                        transform: transform
                    });
				} else {
                    _this.getCanvas(_this.requestArgs, coordinate, key, transform, function(canvas, key) {
                    	texture = new THREE.CanvasTexture(canvas);
                    	_this._addTextureInToCache({
                    		key: key,
                    		value: texture
                    	});
                    	_this._render();
                    });
				}
			}
		}
		_this._render();
    },
	
	/**
     * 绘制
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     */
	_render: function() {
		var _this = this;
		_this._three._removeInnerLayer(_this);
		_this._meshes = [];
		
		var idealTileIDs = _this._three.map.transform.coveringTiles({
			tileSize: _this.tileSize,
			minzoom: 0,
			maxzoom: 22,
			roundZoom: true
		});
		for (var i = 0; i < idealTileIDs.length; i++) {
			var bbox = _this.getTileBBox(idealTileIDs[i].canonical.x, idealTileIDs[i].canonical.y, idealTileIDs[i].canonical.z);
			var min = GeoGlobe.Util.transferToLonLat([bbox[0], bbox[1]]);
			var max = GeoGlobe.Util.transferToLonLat([bbox[2], bbox[3]]);
			var bbox2 = [min[0], min[1], max[0], max[1]];
			var bbox3 = [[bbox2[0],bbox2[3]], [bbox2[0],bbox2[1]], [bbox2[2],bbox2[1]], [bbox2[2],bbox2[3]]];
			
			var texture = _this._getTextureCacheByTileId(idealTileIDs[i].key);
			if(texture) {
				var tileMesh = _this.getTileMesh(bbox3, texture, _this.textureCoord);
				
				tileMesh.visible = _this.visible;
				tileMesh.name = _this.id ? _this.id : "BrightkiteLayer";
				tileMesh.userData.attributes = {
					OriginalData: _this.options,
					Layer: _this
				};
				
				_this._three._threebox.addGeoreferencedMeshToWorld2(tileMesh);
				_this._meshes.push(tileMesh);
			}
		}
		_this._three._render();
	},
	
	/**
     * 渲染
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     */
	render: function () {
		this.update();
	},

    /**
     * 从缓存中获取纹理
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     * @param {Number} tileId - 瓦片唯一key值
     * @returns {Object} texture - 图片纹理
     */
    _getTextureCacheByTileId: function (tileId) {
        if (tileId) {
            for (var i = 0; i < this._textureCache.length; i++) {
                if (this._textureCache[i].key === tileId && this._textureCache[i].value.image) {
                    return this._textureCache[i].value;
                }
            }
            return null;
        } else {
            return null;
        }
    },
    /**
     * 向缓存中添加纹理
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     * @param {Object} map {key: key,value: texture}
     */
    _addTextureInToCache: function (map) {
        var isExist = false;
        for (var i = 0; i < this._textureCache.length; i++) {
            if (this._textureCache[i].key === map.key) {
                isExist = true;
                break;
            }
        }
        if (!isExist) {
            this._textureCache.push(map);
        }
		if(this._textureCache.length > 1000) {
			this._textureCache.splice(0, this._textureCache.length - 1000);
		}
    },
	/**
     * 清除缓存
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     */
    _clearTextureFromCache: function () {
        this._textureCache = [];
    },
	
	/**
     * 增加坐标计算类
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     */
	_initCalculator: function() {
		this.calculator = function(){};
		this.calculator.prototype = {
			project: function(lnglat, transform) {
				return this.locationPoint(lnglat, transform);
			},
			unproject: function(p, transform) {
				return this.pointLocation(p, transform);
			},
			pointLocation: function(p, transform) {
				return this.coordinateLocation(this.pointCoordinate(p, transform), transform);
			},
			coordinateLocation: function(coord, transform) {
				var zoomedCoord = this.zoomTo(coord.column, coord.row, coord.zoom, transform.zoom);
				
				var lng = this.xLng(zoomedCoord.column * transform.tileSize, transform);
				var lat = this.yLat(zoomedCoord.row * transform.tileSize, transform);
				return {
					lng: lng,
					lat: lat
				}
			},
			xLng: function(x, transform) {
				return x * 360 / transform.worldSize - 180;
			},
			yLat: function(y, transform) {
				var y2 = 180 - y * 360 / transform.worldSize;
				return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;
			},
			pointCoordinate: function(p, transform) {
				var zoom = transform.tileZoom;
				var targetZ = 0;

				var coord0 = [p.x, p.y, 0, 1];
				var coord1 = [p.x, p.y, 1, 1];

				this.transformMat4(coord0, coord0, transform.pixelMatrixInverse);
				this.transformMat4(coord1, coord1, transform.pixelMatrixInverse);

				var w0 = coord0[3];
				var w1 = coord1[3];
				var x0 = coord0[0] / w0;
				var x1 = coord1[0] / w1;
				var y0 = coord0[1] / w0;
				var y1 = coord1[1] / w1;
				var z0 = coord0[2] / w0;
				var z1 = coord1[2] / w1;

				var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);

				var coord = {
				   column: this.interp(x0, x1, t) / transform.tileSize,
				   row: this.interp(y0, y1, t) / transform.tileSize,
				   zoom: transform.zoom
				};
				return this.zoomTo(coord.column, coord.row, coord.zoom, zoom);
			},
			interp: function(a,b,t) {
				return (a * (1 - t)) + (b * t);
			},
			locationPoint: function(lnglat, transform) {
				return this.coordinatePoint(this.locationCoordinate(lnglat, transform), transform);
			},
			coordinatePoint: function(coord, transform) {
				var zoomedCoord = this.zoomTo(coord.column, coord.row, coord.zoom, transform.zoom);
				var p = [zoomedCoord.column * transform.tileSize, zoomedCoord.row * transform.tileSize, 0, 1];
				this.transformMat4(p, p, transform.pixelMatrix);
				return {
					x: p[0] / p[3],
					y: p[1] / p[3]
				};
			},
			locationCoordinate: function(lnglat, transform) {
				var column = (180 + lnglat[0]) * transform.worldSize / 360 / transform.tileSize;
				var row = (180 - (180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lnglat[1] * Math.PI / 360)))) * transform.worldSize / 360 / transform.tileSize;
				var zoom = transform.zoom;

				return this.zoomTo(column, row, zoom, transform.tileZoom);
			},
			zoomTo: function(column, row, zoom, tileZoom) {
				var scale = Math.pow(2, tileZoom - zoom);
				column *= scale;
				row *= scale;
				zoom = tileZoom;

				return {
				   column: column,
				   row: row,
				   zoom: zoom
				};
			},
			transformMat4: function(out, a, m) {
				var x = a[0], y = a[1], z = a[2], w = a[3];
				out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
				out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
				out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
				out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
				return out;
			}
		};
	},
	
	/**
     * 增加矩阵类
     * @memberof GeoGlobe.Visuals.Three.BrightkiteLayer.prototype
     * @private
     */
	_initMat4: function() {
    	this.mat4 = function(){};
		
		this.mat4.prototype = {
			create: function() {
				var out = new Float32Array(16);
				out[0] = 1;
				out[1] = 0;
				out[2] = 0;
				out[3] = 0;
				out[4] = 0;
				out[5] = 1;
				out[6] = 0;
				out[7] = 0;
				out[8] = 0;
				out[9] = 0;
				out[10] = 1;
				out[11] = 0;
				out[12] = 0;
				out[13] = 0;
				out[14] = 0;
				out[15] = 1;
				return out;
			},
			identity: function(out) {
				out[0] = 1;
				out[1] = 0;
				out[2] = 0;
				out[3] = 0;
				out[4] = 0;
				out[5] = 1;
				out[6] = 0;
				out[7] = 0;
				out[8] = 0;
				out[9] = 0;
				out[10] = 1;
				out[11] = 0;
				out[12] = 0;
				out[13] = 0;
				out[14] = 0;
				out[15] = 1;
				return out;
			},
			translate: function(out, a, v) {
				var x = v[0], y = v[1], z = v[2],
				a00, a01, a02, a03,
				a10, a11, a12, a13,
				a20, a21, a22, a23;
				if (a === out) {
					out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
					out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
					out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
					out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
				} else {
					a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
					a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
					a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];
					out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
					out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
					out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;
					out[12] = a00 * x + a10 * y + a20 * z + a[12];
					out[13] = a01 * x + a11 * y + a21 * z + a[13];
					out[14] = a02 * x + a12 * y + a22 * z + a[14];
					out[15] = a03 * x + a13 * y + a23 * z + a[15];
				}
				return out;
			},
			scale: function(out, a, v) {
				var x = v[0], y = v[1], z = v[2];
				out[0] = a[0] * x;
				out[1] = a[1] * x;
				out[2] = a[2] * x;
				out[3] = a[3] * x;
				out[4] = a[4] * y;
				out[5] = a[5] * y;
				out[6] = a[6] * y;
				out[7] = a[7] * y;
				out[8] = a[8] * z;
				out[9] = a[9] * z;
				out[10] = a[10] * z;
				out[11] = a[11] * z;
				out[12] = a[12];
				out[13] = a[13];
				out[14] = a[14];
				out[15] = a[15];
				return out;
			},
			multiply: function(out, a, b) {
				var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
					a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
					a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
					a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
				var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
				out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
				out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
				out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
				out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
				return out;
			},
			perspective: function(out, fovy, aspect, near, far) {
				var f = 1.0 / Math.tan(fovy / 2),
					nf = 1 / (near - far);
				out[0] = f / aspect;
				out[1] = 0;
				out[2] = 0;
				out[3] = 0;
				out[4] = 0;
				out[5] = f;
				out[6] = 0;
				out[7] = 0;
				out[8] = 0;
				out[9] = 0;
				out[10] = (far + near) * nf;
				out[11] = -1;
				out[12] = 0;
				out[13] = 0;
				out[14] = (2 * far * near) * nf;
				out[15] = 0;
				return out;
			},
			rotateX: function(out, a, rad) {
				var s = Math.sin(rad),
					c = Math.cos(rad),
					a10 = a[4],
					a11 = a[5],
					a12 = a[6],
					a13 = a[7],
					a20 = a[8],
					a21 = a[9],
					a22 = a[10],
					a23 = a[11];
				if (a !== out) {
					out[0]  = a[0];
					out[1]  = a[1];
					out[2]  = a[2];
					out[3]  = a[3];
					out[12] = a[12];
					out[13] = a[13];
					out[14] = a[14];
					out[15] = a[15];
				}
				out[4] = a10 * c + a20 * s;
				out[5] = a11 * c + a21 * s;
				out[6] = a12 * c + a22 * s;
				out[7] = a13 * c + a23 * s;
				out[8] = a20 * c - a10 * s;
				out[9] = a21 * c - a11 * s;
				out[10] = a22 * c - a12 * s;
				out[11] = a23 * c - a13 * s;
				return out;
			},
			rotateZ: function(out, a, rad) {
				var s = Math.sin(rad),
					c = Math.cos(rad),
					a00 = a[0],
					a01 = a[1],
					a02 = a[2],
					a03 = a[3],
					a10 = a[4],
					a11 = a[5],
					a12 = a[6],
					a13 = a[7];
				if (a !== out) {
					out[8]  = a[8];
					out[9]  = a[9];
					out[10] = a[10];
					out[11] = a[11];
					out[12] = a[12];
					out[13] = a[13];
					out[14] = a[14];
					out[15] = a[15];
				}
				out[0] = a00 * c + a10 * s;
				out[1] = a01 * c + a11 * s;
				out[2] = a02 * c + a12 * s;
				out[3] = a03 * c + a13 * s;
				out[4] = a10 * c - a00 * s;
				out[5] = a11 * c - a01 * s;
				out[6] = a12 * c - a02 * s;
				out[7] = a13 * c - a03 * s;
				return out;
			},
			invert: function(out, a) {
				var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
					a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
					a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
					a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],
					b00 = a00 * a11 - a01 * a10,
					b01 = a00 * a12 - a02 * a10,
					b02 = a00 * a13 - a03 * a10,
					b03 = a01 * a12 - a02 * a11,
					b04 = a01 * a13 - a03 * a11,
					b05 = a02 * a13 - a03 * a12,
					b06 = a20 * a31 - a21 * a30,
					b07 = a20 * a32 - a22 * a30,
					b08 = a20 * a33 - a23 * a30,
					b09 = a21 * a32 - a22 * a31,
					b10 = a21 * a33 - a23 * a31,
					b11 = a22 * a33 - a23 * a32,
					det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
				if (!det) {
					return null;
				}
				det = 1.0 / det;
				out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
				out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
				out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
				out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
				out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
				out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
				out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
				out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
				out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
				out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
				out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
				out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
				out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
				out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
				out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
				out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
				return out;
			},
			ortho: function(out, left, right, bottom, top, near, far) {
				var lr = 1 / (left - right),
					bt = 1 / (bottom - top),
					nf = 1 / (near - far);
				out[0] = -2 * lr;
				out[1] = 0;
				out[2] = 0;
				out[3] = 0;
				out[4] = 0;
				out[5] = -2 * bt;
				out[6] = 0;
				out[7] = 0;
				out[8] = 0;
				out[9] = 0;
				out[10] = 2 * nf;
				out[11] = 0;
				out[12] = (left + right) * lr;
				out[13] = (top + bottom) * bt;
				out[14] = (far + near) * nf;
				out[15] = 1;
				return out;
			}
		};
    }
});/**
 * @author liuck
 * @class GeoGlobe.Visuals.EchartsGL
 * @classdesc 基于EchartsGL的可视化图层。
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 2,
    bearing: 0,
	pitch: 40,
    units: "degrees",
    center: [24.114129, 22.550339]
});
 //构造EchartsGL可视化图层
 var echartsgl = new GeoGlobe.Visuals.EchartsGL({
	visualMap: {
	    show: true,
	    max: 1000,
	    calculable: true,
	    realtime: false,
	    inRange: {
	        color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']
	    },
	    outOfRange: {
	        colorAlpha: 0
	    }
	},
	mapbox3D: {
        boxHeight: 50,
        altitudeScale: 1,
        postEffect: {
            enable: true,
            screenSpaceAmbientOcclusion: {
                enable: true,
                radius: 2
            }
        },
        light: {
            main: {
                intensity: 2,
                shadow: true,
                shadowQuality: 'high'
            },
            ambient: {
                intensity: 0.
            },
            ambientCubemap: {
                texture: '../../data/canyon.hdr',
                exposure: 2,
                diffuseIntensity: 0.5
            }
        }
    }
});
 //绑定鼠标点击事件
 echartsgl.on('overlayerclick', function(e){
	console.info(e);
});
 //绑定鼠标移动事件
 echartsgl.on('overlayerhover', function(e){
	console.info(e);
})
 //添加到地图中
 echartsgl.addTo(map);
 //绘制
 echartsgl.render();
 */

GeoGlobe.Visuals.EchartsGL = GeoGlobe.Class4OL(GeoGlobe.Visuals, {

    /**
     * 地图对象
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @type {GeoGlobe.Map}
     * @default null
     */
    map: null,

    /**
     * map的容器
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @type {Object}

     */
    container: null,

    /**
     * 图层容器
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @type {Array}
     */
    layers: [],

    /**
     * 是视觉映射组件，用于进行『视觉编码』，也就是将数据映射到视觉元素（视觉通道）。
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @property {Object} - 参见echarts配置项，http://echarts.baidu.com/option.html#visualMap
     * @example
     * {
	    	show: true,
	        max: 1000,
	        calculable: true,
	        realtime: false,
	        inRange: {
	            color: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026']
	        },
	        outOfRange: {
	            colorAlpha: 0
	        }
    	}
     */
    visualMap: null,

    /**
     * 光照和特效等渲染参数
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @property {Object} - 参见echarts配置项，http://echarts.baidu.com/option-gl.html#mapbox3D
     * @example
     {
         boxHeight: 10,
         boxWidth:100,
         altitudeScale: 2,
         shading: 'realistic'
         postEffect: {
             enable: true,
             screenSpaceAmbientOcclusion: {
                 enable: true,
                 radius: 2
             }
         },
         light: {
             main: {
                 intensity: 2,
                 shadow: true,
                 shadowQuality: 'high'
             },
             ambient: {
                 intensity: 0.
             },
             ambientCubemap: {
                 texture: 'asset/canyon.hdr',
                 exposure: 2,
                 diffuseIntensity: 0.5
             }
         }
     }
     */
    mapbox3D: {
        boxHeight: 10,
        boxWidth: 100,
        altitudeScale: 1
    },

    /**
     * @member EchartsGL在GL地图上的适配器
     * @type {Object}
     * @private
     */
    _echartsgl: null,

    /**
     * @function initialize
     * @description  GeoGlobe.Visuals.EchartsGL构造函数。
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        GeoGlobe.Visuals.prototype.initialize.apply(this, arguments);
        this.layers = [];
        if (!window.echarts) {
            console.error("使用EchartsGL可视化图层前，需引入echarts和echartsgl库！");
            return;
        }
        this.visualMap = options.visualMap ? options.visualMap : this.visualMap;
        this.mapbox3D = options.mapbox3D ? options.mapbox3D : this.mapbox3D;
        console.warn('EchartsGL 1.1 暂未支持鼠标拾取事件！');
    },

    /**
     * @function addTo
     * @description 与gl地图对象关联
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @public
     * @param {Object} map -  gl地图对象
     */
    addTo: function (map) {
        GeoGlobe.Visuals.prototype.addTo.apply(this, arguments);

        this.container.className = "geoglobe-echartsgl-container";
        this._init();
    },

    /**
     * @function _init
     * @description 初始化echartsgl实例
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @private
     */
    _init: function () {
        this._echartsgl = echarts.init(this.container);
        this._echartsgl._mapbox = this.map;
        this.mapbox3D.center = this.map.getCenter().toArray();
        this.mapbox3D.zoom = this.map.getZoom();
        this.mapbox3D.pitch = this.map.getPitch();
        this.mapbox3D.bearing = this.map.getBearing();
        this._bindEvent();
    },

    /**
     * @function render
     * @description 绘制图层，包含子图层
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     */
    render: function () {
        //修复重绘时画布内容无变化问题
        if (this._echartsgl.getOption()) {
            try {
                this.clear();
            } catch (e) {
                try {
                    this._echartsgl.dispose();
                } catch (e) {
                }
                ;
                this._unbindEvent();
                this._init();
            }
            ;
        }
        this.option = {};
        this.visualMap && (this.option.visualMap = this.visualMap);
        this.option.mapbox3D = this.mapbox3D;
        this.option.series = [];
        this.option.units = this.map.units;
        this.option.topTileExtent = this.map._tileExtent;
        if (this._order) {
            for (var p = 0; p < this._order.length; p++) {
                for (var i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].id == this._order[p]) {
                        this.option.series.push(this.layers[i].getRenderOption());
                    }
                }
            }
        } else {
            for (var i = 0; i < this.layers.length; i++) {
                this.option.series.push(this.layers[i].getRenderOption());
            }
        }
        this._echartsgl.setOption(this.option);
    },

    /**
     * @function clear
     * @description 清空画布内容，用于重绘时
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     */
    clear: function () {
        this._echartsgl.clear();
    },

    /**
     * @function addLayer
     * @description 向EchartsGLjs可视化图层中添加子图层
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @param {Object} layer - EchartsGL命名空间下的子图层对象
     */
    addLayer: function (layer) {
        if (!layer.id) {
            console.error("图层id属性不能为空！");
            return;
        }
        var oldLayer = this.getLayer(layer.id);
        if (oldLayer) {
            oldLayer = layer;
        } else {
            this.layers.push(layer);
        }
    },

    /**
     * @function removeLayer
     * @description 移除图层
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @param {string} id - 图层id
     */
    removeLayer: function (id) {
        var array = [];
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                continue;
            }
            array.push(this.layers[i]);
        }
        this.layers = array;
    },

    /**
     * 移动图层
     * @function moveLayer
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @param {String} id 图层id
     */
    moveLayer: function moveLayer(id, before) {
        var layer = this.getLayer(id);
        if (!layer) {
            this.fire('error', {
                error: new Error(
                    "The layer '" + id + "' does not exist in " +
                    "the map's style and cannot be moved."
                )
            });
            return;
        }

        this._order = this.layers.map(function (Layer) {
            return Layer.id;
        });
        var index = this._order.indexOf(id);
        this._order.splice(index, 1);

        var newIndex = before ? this._order.indexOf(before) : this._order.length;
        if (before && newIndex === -1) {
            this.fire('error', {error: new Error(("Layer with id \"" + before + "\" does not exist on this map."))});
            return;
        }
        this._order.splice(newIndex, 0, id);
    },

    /**
     * @function getLayer
     * @description 获取指定id图层
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @param {string} id - 图层id.
     * @returns Layer
     */
    getLayer: function (id) {
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                return this.layers[i];
            }
        }
    },

    /**
     * @method
     * @desc 绑定事件
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @private
     */
    _bindEvent: function () {
        var _this = this;
        this.map.on('click', function ECHARTSGL_CLICK_EVENT(e) {
            _this._onClick(e);
        });
        this.map.on('mousemove', function ECHARTSGL_MOUSEMOVE_EVENT(e) {
            _this._onMouseMove(e);
        });
        this.map.on('resize', function ECHARTSGL_RESIZE_EVENT(e) {
            _this._echartsgl.resize();
        })
    },

    /**
     * @method
     * @desc 解绑事件
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @private
     */
    _unbindEvent: function () {
        var _this = this;
        for (var i = 0; i < this.map._listeners['click'].length; i++) {
            if (this.map._listeners['click'][i].name && this.map._listeners['click'][i].name === 'ECHARTSGL_CLICK_EVENT') {
                this.map._listeners['click'].splice(i, 1);
            }
        }
        for (var i = 0; i < this.map._listeners['mousemove'].length; i++) {
            if (this.map._listeners['mousemove'][i].name && this.map._listeners['mousemove'][i].name === 'ECHARTSGL_MOUSEMOVE_EVENT') {
                this.map._listeners['mousemove'].splice(i, 1);
            }
        }
        for (var i = 0; i < this.map._listeners['resize'].length; i++) {
            if (this.map._listeners['resize'][i].name && this.map._listeners['resize'][i].name === 'ECHARTSGL_RESIZE_EVENT') {
                this.map._listeners['resize'].splice(i, 1);
            }
        }
    },

    /**
     * @method
     * @desc 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @private
     */
    _onMouseMove: function (event) {
        this.fire("overlayerhover", {
            param: {
                info: null,
                pickedInfos: [],
                event: event
            }
        });
    },

    /**
     * @method
     * @desc 鼠标指针单击事件
     * @memberof GeoGlobe.Visuals.EchartsGL.prototype
     * @private
     */
    _onClick: function (event) {
        this.fire("overlayerclick", {
            param: {
                info: null,
                pickedInfos: [],
                event: event
            }
        });
    }

})/**
 * @author liuck
 * @class GeoGlobe.Visuals.EchartsGL.BarLayer
 * @classdesc 基于EchartsGL的三维柱状图
 * @example 
//option参见：http://echarts.baidu.com/option-gl.html#series-bar3D
//构造EchartsGL可视化图层
var echartsgl = new GeoGlobe.Visuals.EchartsGL({
	visualMap: {
		...
	},
	mapbox3D: {
		...
    }
});
//构造3D柱图层
var barLayer = new GeoGlobe.Visuals.EchartsGL.BarLayer({
	id: '3D bar',
	name: '3D柱',
    data: [{
		"type": "Feature",
		"properties": {
			"id": 10001,
	 		"name": "1号柱",
			"height": 1000
		},
		"geometry": {
			"type": "Point",
			"coordinates": [114.20257245367856, 30.773372078561778]
		},
		"itemStyle": {
			...
		},
		"label": {
			...
		},
		"emphasis": {
			...
		}
	}],
    shading: 'lambert',
    minHeight: 0.1,
    barSize: 0.1,
    silent: true,
    animationEasingUpdate: 2000
});
//添加到EchartsGL图层
barLayer.addTo(echartsgl);
//绘制
echartsgl.render();
 */

GeoGlobe.Visuals.EchartsGL.BarLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 图层名称
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 用于tooltip的显示，legend 的图例筛选，在 setOption 更新数据和配置项时用于指定对应的系列。
	 * @type {String}
	 * @default ''
	 */
	name: '',
	
	/**
	 * 图层类别
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @constant
	 * @type {String}
	 * @default 'bar3D'
	 * @description 为常量值，固定为'bar3D'
	 */
	type: 'bar3D',
	
	/**
	 * 图层使用的坐标系
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @constant
	 * @type {String}
	 * @default 'mapbox3D'
	 * @description 为常量值，固定为'mapbox3D'
	 */
	coordinateSystem: 'mapbox3D',
	
	/**
	 * 柱子的倒角尺寸
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 支持设置为从 0 到 1 的值。默认为 0，即没有倒角
	 * @type {Int}
	 * @default 0
	 */
	bevelSize: 0,
	
	/**
	 * 柱子倒角的光滑/圆润度
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 柱子倒角的光滑/圆润度，数值越大越光滑/圆润。
	 * @type {Int}
	 * @default 2
	 */
	bevelSmoothness: 2,
	
	/**
	 * 柱状图堆叠
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 相同 stack 值的柱状图系列数据会有叠加。注意不同系列需要叠加的数据项在数组中的索引必须是一样的。
	 * @type {String}
	 * @default ''
	 */
	stack: '',
	
	/**
	 * 最小柱子高度
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 最小柱子高度
	 * @type {Int}
	 * @default 0
	 */
	minHeight: 0,
	
	/**
	 * 柱子的样式
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 柱子的样式，包括颜色和不透明度。
	 * @type {Object}
	 * @default null
	 * @example 
	 * {
	 * 	color: [1, 1, 1, 1],
	 * 	opacity: 1
	 * }
	 */
	itemStyle: null,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description geojson结构
	 * @type {Array}
	 * @example 
	 * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "1号柱",
	 * 		"height": 1000
	 * 	},
	 * "geometry": {
	 * 		"type": "Point",
	 * 		"coordinates": [114.20257245367856, 30.773372078561778]
	 * 	},
	 * 	"itemStyle": {
	 * 		...
	 * 	},
	 * 	"label": {
	 * 		...
	 * 	},
	 * 	"emphasis": {
	 * 		...
	 * 	}
	 * }]
	 */
	data: [],
	
	/**
	 * 柱子的标签配置
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 柱子的标签配置
	 * @type {Object}
	 * @default null
	 * @example 
	 * {
	 * 	show: false,
	 * 	distance: 2,
	 * 	formatter: ...
	 * 	textStyle: {
	 * 		color: '#fff',
	 * 		borderWidth: 1,
	 * 		borderColor: '#fff',
	 * 		fontFamily: 'sans-serif',
	 * 		fontSize: 20,
	 * 		fontWeight: normal
	 * 	}
	 * }
	 */
	label: null,
	
	/**
	 * 柱子高亮状态的标签和样式配置
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 柱子的标签配置
	 * @type {Object}
	 * @default null
	 * @example 
	 * {
	 * 	itemStyle : {
	 * 		...
	 * 	},
	 * 	label: {
	 * 		...
	 * 	}
	 * }
	 */
	emphasis: null,
	
	/**
	 * 三维柱状图中三维图形的着色效果
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 支持下面三种着色方式,'color' 只显示颜色，不受光照等其它因素的影响。'lambert' 通过经典的 lambert 着色表现光照带来的明暗。'realistic' 真实感渲染，配合 light.ambientCubemap 和 postEffect 使用可以让展示的画面效果和质感有质的提升。
	 * @type {String}
	 * @default null - 
	 */
	shading: null,
	
	/**
	 * 真实感材质相关的配置项
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 真实感材质相关的配置项，在 shading 为'realistic'时有效。
	 * @type {Object}
	 * @default null
	 * @example 
	 * {
	 * 	detailTexture: ...,
	 * 	textureTiling: 1,
	 * 	textureOffset: 0,
	 * 	roughness: 0.5,
	 * 	metalness: 0,
	 * 	roughnessAdjust: 0.5,
	 * 	metalnessAdjust: 0.5,
	 * 	normalTexture: ...,
	 * }
	 */
	realisticMaterial: null,
	
	/**
	 * lambert 材质相关的配置项
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description lambert 材质相关的配置项，在 shading 为'lambert'时有效。
	 * @type {Object}
	 * @default null
	 * @example 
	 * {
	 * 	detailTexture: ...,
	 * 	textureTiling: 1,
	 * 	textureOffset: 0,
	 * }
	 */
	lambertMaterial: null,
	
	/**
	 * color 材质相关的配置项
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description color 材质相关的配置项，在 shading 为'color'时有效。
	 * @type {Object}
	 * @default null
	 * @example 
	 * {
	 * 	detailTexture: ...,
	 * 	textureTiling: 1,
	 * 	textureOffset: 0,
	 * }
	 */
	colorMaterial: null,
	
	/**
	 * 组件所在的层
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 组件所在的层。
	 * @type {Int}
	 * @default -10
	 */
	zlevel: -10,
	
	/**
	 * 图形是否不响应和触发鼠标事件
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 图形是否不响应和触发鼠标事件，默认为 false，即响应和触发鼠标事件。
	 * @type {Boolean}
	 * @default false
	 */
	silent: false,
	
	/**
	 * 是否开启动画。
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 是否开启动画。
	 * @type {Boolean}
	 * @default true
	 */
	animation: true,
	
	/**
	 * 过渡动画的时长。
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 过渡动画的时长。
	 * @type {Int}
	 * @default 500
	 */
	animationDurationUpdate: 500,
	
	/**
	 * 过渡动画的缓动效果。
	 * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
	 * @description 过渡动画的缓动效果。
	 * @type {String}
	 * @default 'cubicOut'
	 */
	animationEasingUpdate: 'cubicOut ',
	
    /**
     * EchartsGL可视化对象
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.EchartsGL}
     */
	_parent: null,
	
    /**
     * @name 构造函数。
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.id = options.id? options.id: this.id;
    	this.name = options.name? options.name: this.name;
    	this.bevelSize = options.bevelSize? options.bevelSize: this.bevelSize;
    	this.bevelSmoothness = options.bevelSmoothness? options.bevelSmoothness: this.bevelSmoothness;
    	this.stack = options.stack? options.stack: this.stack;
    	this.minHeight = options.minHeight? options.minHeight: this.minHeight;
    	this.itemStyle = options.itemStyle? options.itemStyle: this.itemStyle;
    	this.label = options.label? options.label: this.label;
    	this.emphasis = options.emphasis? options.emphasis: this.emphasis;
    	this.data = options.data? options.data: this.data;
    	this.shading = options.shading? options.shading: this.shading;
    	this.realisticMaterial = options.realisticMaterial? options.realisticMaterial: this.realisticMaterial;
    	this.lambertMaterial = options.lambertMaterial? options.lambertMaterial: this.lambertMaterial;
    	this.colorMaterial = options.colorMaterial? options.colorMaterial: this.colorMaterial;
    	this.zlevel = options.zlevel? options.zlevel: this.zlevel;
    	this.silent = options.silent? options.silent: this.silent;
    	this.animation = options.animation? options.animation: this.animation;
    	this.animationDurationUpdate = options.animationDurationUpdate? options.animationDurationUpdate: this.animationDurationUpdate;
    	this.animationEasingUpdate = options.animationEasingUpdate? options.animationEasingUpdate: this.animationEasingUpdate;
    	
    	this.type = 'bar3D';
    	this.coordinateSystem = 'mapbox3D'
    },
	
    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @param {GeoGlobe.Visuals.EchartsGL} echartsgl 
     */
    addTo: function(echartsgl){
    	this._parent = echartsgl;
    	this._parent.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     */
    remove: function(){
    	this._parent.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     */
    render: function(){
    	this._parent.render();
    },
    
    /**
     * 获取绘制的option结构数据
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @returns {Object} options
     * @see {@link http://echarts.baidu.com/option-gl.html#series-bar3D}
     */
    getRenderOption: function(){
    	var option = {};
    	this.id && (option.id = this.id);
    	this.name && (option.name = this.name);
    	this.bevelSize && (option.bevelSize = this.bevelSize);
    	this.bevelSmoothness && (option.bevelSmoothness = this.bevelSmoothness);
    	this.stack && (option.stack = this.stack);
    	this.minHeight && (option.minHeight = this.minHeight);
    	this.itemStyle && (option.itemStyle = this.itemStyle);
    	this.label && (option.label = this.label);
    	this.emphasis && (option.emphasis = this.emphasis);
    	this.shading && (option.shading = this.shading);
    	this.realisticMaterial && (option.realisticMaterial = this.realisticMaterial);
    	this.lambertMaterial && (option.lambertMaterial = this.lambertMaterial);
    	this.colorMaterial && (option.colorMaterial = this.colorMaterial);
    	this.zlevel && (option.zlevel = this.zlevel);
    	this.silent && (option.silent = this.silent);
    	this.animation && (option.animation = this.animation);
    	this.animationDurationUpdate && (option.animationDurationUpdate = this.animationDurationUpdate);
    	this.animationEasingUpdate && (option.animationEasingUpdate = this.animationEasingUpdate);
    	
    	option.type = 'bar3D';
    	option.coordinateSystem = 'mapbox3D';
    	
    	if(this.data && this.data instanceof Array){
    		option.data = [];
    		for(var i=0; i<this.data.length; i++){
    			if(!this.data[i].properties || !this.data[i].geometry){
    				console.warn("BarLayer使用的数据格式不正确，请确认为geojson格式！");
    				continue;
    			}
    			if(this.data[i].geometry.type != 'Point'){
    				console.warn("BarLayer使用的必须是Point几何形状！");
    				continue;
    			}
    			var item = {};
    			item.name = this.data[i].properties.name;
    			item.value = [this.data[i].geometry.coordinates[0], this.data[i].geometry.coordinates[1], this.data[i].properties.height?this.data[i].properties.height:0];
    			this.data[i].itemStyle && (item.itemStyle = this.data[i].itemStyle);
    			this.data[i].label && (item.label = this.data[i].label);
    			this.data[i].emphasis && (item.emphasis = this.data[i].emphasis);
    			option.data.push(item);
    		}
    	}
    	
    	return option;
    }
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.EchartsGL.ScatterLayer
 * @classdesc 基于EchartsGL的三维散点图
 * @example
 //option参见：http://echarts.baidu.com/option-gl.html#series-scatter3D
 //构造EchartsGL可视化图层
 var echartsgl = new GeoGlobe.Visuals.EchartsGL({
	visualMap: {
		...
	},
	mapbox3D: {
		...
    }
});
 //构造3D散点图层
 var scatterLayer = new GeoGlobe.Visuals.EchartsGL.ScatterLayer({
	id: '3D scatter',
	name: '3D散点',
    data: [{
		"type": "Feature",
		"properties": {
			"id": 10001,
	 		"name": "1号点",
			"height": 1000
		},
		"geometry": {
			"type": "Point",
			"coordinates": [114.20257245367856, 30.773372078561778]
		}
	}],
    silent: true,
    animationEasingUpdate: 2000
});
 //添加到EchartsGL图层
 scatterLayer.addTo(echartsgl);
 //绘制
 echartsgl.render();
 */

GeoGlobe.Visuals.EchartsGL.ScatterLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 图层名称，用于tooltip的显示，legend 的图例筛选，在 setOption 更新数据和配置项时用于指定对应的系列。
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {String}
     * @default ''
     */
    name: '',

    /**
     * 图层类别，为常量值，固定为'scatter3D'
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @constant
     * @type {String}
     * @default 'scatter3D'
     */
    type: 'scatter3D',

    /**
     * 图层使用的坐标系，为常量值，固定为'mapbox3D'
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @constant
     * @type {String}
     * @default 'mapbox3D'
     */
    coordinateSystem: 'mapbox3D',

    /**
     * 散点的形状。默认为圆形。ECharts提供的标记类型包括 'circle', 'rect', 'roundRect', 'triangle', 'diamond', 'pin', 'arrow'，可以通过 'path://' 将图标设置为任意的矢量路径。这种方式相比于使用图片的方式，不用担心因为缩放而产生锯齿或模糊，而且可以设置为任意颜色。路径图形会自适应调整为合适（如果是 symbol 的话就是 symbolSize）的大小。路径的格式参见 SVG PathData。可以从 Adobe Illustrator 等工具编辑导出。
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {String}
     * @default 'circle'
     */
    symbol: 'circle',

    /**
     * 标记的大小，可以设置成诸如 10 这样单一的数字，也可以用数组分开表示宽和高，例如 [20, 10] 表示标记宽为20，高为10。
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Number}
     * @default 10
     */
    symbolSize: 10,

    /**
     * 混合模式，目前支持'source-over'，'lighter'，默认使用的'source-over'是通过 alpha 混合，而'lighter'是叠加模式，该模式可以让数据集中的区域因为叠加而产生高亮的效果。
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {String}
     * @default 'source-over'
     */
    blendMode: 'source-over',

    /**
     * 散点图颜色描边等样式
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	color: [1, 1, 1, 1],
	 * 	opacity: 1,
	 * 	borderWidth: 0,
	 * 	borderColor: '#fff'
	 * }
     */
    itemStyle: null,

    /**
     * 三维散点图数据数组，geojson结构
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Array}
     * @example
     * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "1号点",
	 * 		"height": 1000
	 * 	},
	 * "geometry": {
	 * 		"type": "Point",
	 * 		"coordinates": [114.20257245367856, 30.773372078561778]
	 * 	}
	 * }]
     */
    data: [],

    /**
     * 标签样式
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	show: false,
	 * 	distance: 5,
	 * 	position: 'right',
	 * 	formatter: ...
	 * 	textStyle: {
	 * 		color: '#fff',
	 * 		borderWidth: 1,
	 * 		borderColor: '#fff',
	 * 		fontFamily: 'sans-serif',
	 * 		fontSize: 20,
	 * 		fontWeight: normal
	 * 	}
	 * }
     */
    label: null,

    /**
     * 图形和标签高亮的样式
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	itemStyle : {
	 * 		...
	 * 	},
	 * 	label: {
	 * 		...
	 * 	}
	 * }
     */
    emphasis: null,

    /**
     * 组件所在的层，zlevel 大的 Canvas 会放在 zlevel 小的 Canvas 的上面。
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Number}
     * @default -10
     */
    zlevel: -10,

    /**
     * 图形是否不响应和触发鼠标事件，默认为 false，即响应和触发鼠标事件。
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Boolean}
     * @default false
     */
    silent: false,

    /**
     * 是否开启动画
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Boolean}
     * @default true
     */
    animation: true,

    /**
     * 过渡动画的时长
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {Number}
     * @default 500
     */
    animationDurationUpdate: 500,

    /**
     * 过渡动画的缓动效果
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @type {String}
     * @default 'cubicOut'
     */
    animationEasingUpdate: 'cubicOut ',

    /**
     * EchartsGL可视化对象
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.EchartsGL}
     */
    _parent: null,

    /**
     * 构造函数
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
        this.name = options.name ? options.name : this.name;
        this.symbol = options.symbol ? options.symbol : this.symbol;
        this.symbolSize = options.symbolSize ? options.symbolSize : this.symbolSize;
        this.blendMode = options.blendMode ? options.blendMode : this.blendMode;
        this.itemStyle = options.itemStyle ? options.itemStyle : this.itemStyle;
        this.label = options.label ? options.label : this.label;
        this.emphasis = options.emphasis ? options.emphasis : this.emphasis;
        this.data = options.data ? options.data : this.data;
        this.zlevel = options.zlevel ? options.zlevel : this.zlevel;
        this.silent = options.silent ? options.silent : this.silent;
        this.animation = options.animation ? options.animation : this.animation;
        this.animationDurationUpdate = options.animationDurationUpdate ? options.animationDurationUpdate : this.animationDurationUpdate;
        this.animationEasingUpdate = options.animationEasingUpdate ? options.animationEasingUpdate : this.animationEasingUpdate;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @param {GeoGlobe.Visuals.EchartsGL} echartsgl
     */
    addTo: function (echartsgl) {
        this._parent = echartsgl;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     */
    render: function () {
        this._parent.render();
    },

    /**
     * 获取绘制的option结构数据
     * @memberof GeoGlobe.Visuals.EchartsGL.ScatterLayer.prototype
     * @returns {Object} options
     * @see {@link http://echarts.baidu.com/option-gl.html#series-scatter3D}
     */
    getRenderOption: function () {
        var option = {};
        this.id && (option.id = this.id);
        this.name && (option.name = this.name);
        this.symbol && (option.symbol = this.symbol);
        this.symbolSize && (option.symbolSize = this.symbolSize);
        this.blendMode && (option.blendMode = this.blendMode);
        this.itemStyle && (option.itemStyle = this.itemStyle);
        this.label && (option.label = this.label);
        this.emphasis && (option.emphasis = this.emphasis);
        this.zlevel && (option.zlevel = this.zlevel);
        this.silent && (option.silent = this.silent);
        this.animation && (option.animation = this.animation);
        this.animationDurationUpdate && (option.animationDurationUpdate = this.animationDurationUpdate);
        this.animationEasingUpdate && (option.animationEasingUpdate = this.animationEasingUpdate);

        option.type = 'scatter3D';
        option.coordinateSystem = 'mapbox3D';

        if (this.data && this.data instanceof Array) {
            option.data = [];
            for (var i = 0; i < this.data.length; i++) {
                if (!this.data[i].properties || !this.data[i].geometry) {
                    console.warn("ScatterLayer使用的数据格式不正确，请确认为geojson格式！");
                    continue;
                }
                if (this.data[i].geometry.type !== 'Point') {
                    console.warn("ScatterLayer使用的必须是Point几何形状！");
                    continue;
                }
                var item = {};
                item.name = this.data[i].properties.name;
                item.value = [this.data[i].geometry.coordinates[0], this.data[i].geometry.coordinates[1], this.data[i].properties.height ? this.data[i].properties.height : 0];
                option.data.push(item);
            }
        }

        return option;
    }
});/**
 * @author liuck
 * @class GeoGlobe.Visuals.EchartsGL.LinesLayer
 * @classdesc 基于EchartsGL的三维飞线图
 * @example
 //option参见：http://echarts.baidu.com/option-gl.html#series-lines3D
 //构造EchartsGL可视化图层
 var echartsgl = new GeoGlobe.Visuals.EchartsGL({
	visualMap: {
		...
	},
	mapbox3D: {
		...
    }
});
 //构造3D飞线图层
 var linesLayer = new GeoGlobe.Visuals.EchartsGL.LinesLayer({
	id: '3D lines',
	name: '3D飞线',
    data: [{
		"type": "Feature",
		"properties": {
			"id": 10001,
	 		"name": "1号点",
			"height": 1000
		},
		"geometry": {
			"type": "LineString",
			"coordinates": [[116.3671875, 39.90973623453719], [-73.98193359375, 40.730608477796636]]
		}
	}],
    silent: true,
    animationEasingUpdate: 2000
});
 //添加到EchartsGL图层
 linesLayer.addTo(echartsgl);
 //绘制
 echartsgl.render();
 */

GeoGlobe.Visuals.EchartsGL.LinesLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 图层名称，用于tooltip的显示，legend 的图例筛选，在 setOption 更新数据和配置项时用于指定对应的系列。
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {String}
     * @default ''
     */
    name: '',

    /**
     * 图层类别，为常量值，固定为'lines3D'
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @constant
     * @type {String}
     * @default 'lines3D'
     */
    type: 'lines3D',

    /**
     * 图层使用的坐标系，为常量值，固定为'mapbox3D'
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @constant
     * @type {String}
     * @default 'mapbox3D'
     */
    coordinateSystem: 'mapbox3D',

    /**
     * 是否是多段线。默认为 false，只能用于绘制只有两个端点的线段（表现为被赛尔曲线）。如果该配置项为 true，则可以在 data.coords 中设置多于 2 个的顶点用来绘制多段线，在绘制路线轨迹的时候比较有用。
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {Boolean}
     * @default false
     */
    polyline: false,

    /**
     * 混合模式，目前支持'source-over'，'lighter'，默认使用的'source-over'是通过 alpha 混合，而'lighter'是叠加模式，该模式可以让数据集中的区域因为叠加而产生高亮的效果。
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {String}
     * @default 'source-over'
     */
    blendMode: 'source-over',

    /**
     * 飞线的尾迹特效。
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	show: false,
	 * 	period: 4,
	 * 	constantSpeed: null,
	 * 	trailWidth: 4,
	 * 	trailLength: 0.1,
	 * 	trailColor: null,
	 * 	trailOpacity: null
	 * }
     */
    effect: null,

    /**
     * 飞线的线条样式。
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	color: [1, 1, 1, 1],
	 * 	opacity: 1,
	 * 	width: 1
	 * }
     */
    lineStyle: null,

    /**
     * 三维飞线图数据数组。通常数据的每一项可以是一个包含起点和终点的坐标集。在 polyline 设置为 true 时支持多于两个的坐标。geojson结构
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {Array}
     * @example
     * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "1号线"
	 * 	},
	 * "geometry": {
	 * 	    "type": "LineString",
	 * 		"coordinates": [[116.3671875, 39.90973623453719], [-73.98193359375, 40.730608477796636]]
	 * 	}
	 * }]
     */
    data: [],

    /**
     * 组件所在的层，zlevel 大的 Canvas 会放在 zlevel 小的 Canvas 的上面。
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {Number}
     * @default -10
     */
    zlevel: -10,

    /**
     * 图形是否不响应和触发鼠标事件，默认为 false，即响应和触发鼠标事件。
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @type {Boolean}
     * @default false
     */
    silent: false,

    /**
     * EchartsGL可视化对象
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.EchartsGL}
     */
    _parent: null,

    /**
     * 构造函数
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
        this.name = options.name ? options.name : this.name;
        this.polyline = options.polyline ? options.polyline : this.polyline;
        this.blendMode = options.blendMode ? options.blendMode : this.blendMode;
        this.effect = options.effect ? options.effect : this.effect;
        this.lineStyle = options.lineStyle ? options.lineStyle : this.lineStyle;
        this.data = options.data ? options.data : this.data;
        this.zlevel = options.zlevel ? options.zlevel : this.zlevel;
        this.silent = options.silent ? options.silent : this.silent;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @param {GeoGlobe.Visuals.EchartsGL} echartsgl
     */
    addTo: function (echartsgl) {
        this._parent = echartsgl;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     */
    render: function () {
        this._parent.render();
    },

    /**
     * 获取绘制的option结构数据
     * @memberof GeoGlobe.Visuals.EchartsGL.LinesLayer.prototype
     * @returns {Object} options
     * @see {@link http://echarts.baidu.com/option-gl.html#series-lines3D}
     */
    getRenderOption: function () {
        var option = {};
        this.id && (option.id = this.id);
        this.name && (option.name = this.name);
        this.polyline && (option.polyline = this.polyline);
        this.blendMode && (option.blendMode = this.blendMode);
        this.effect && (option.effect = this.effect);
        this.lineStyle && (option.lineStyle = this.lineStyle);
        this.zlevel && (option.zlevel = this.zlevel);
        this.silent && (option.silent = this.silent);

        option.type = 'lines3D';
        option.coordinateSystem = 'mapbox3D';

        if (this.data && this.data instanceof Array) {
            option.data = [];
            for (var i = 0; i < this.data.length; i++) {
                if (!this.data[i].properties || !this.data[i].geometry) {
                    console.warn("LinesLayer使用的数据格式不正确，请确认为geojson格式！");
                    continue;
                }
                if (this.data[i].geometry.type !== 'LineString') {
                    console.warn("LinesLayer使用的必须是LineString几何形状！");
                    continue;
                }
                var item = {};
                item.name = this.data[i].properties.name;
                item.value = this.data[i].properties.value;
                item.lineStyle = this.data[i].properties.lineStyle;
                item.coords = this.data[i].geometry.coordinates;
                option.data.push(item);
            }
        }

        return option;
    }
});/**
 * @author liuck
 * @class GeoGlobe.Visuals.EchartsGL.MapLayer
 * @classdesc 基于EchartsGL的三维地图图层
 * @example
 //option参见：http://echarts.baidu.com/option-gl.html#series-map3D
 //构造EchartsGL可视化图层
 var echartsgl = new GeoGlobe.Visuals.EchartsGL({
	visualMap: {
		...
	},
	mapbox3D: {
		...
    }
});
 //构造3D地图图层
 var mapLayer = new GeoGlobe.Visuals.EchartsGL.MapLayer({
	id: '3D map',
	name: '3D地图',
    data: [{
		"type": "Feature",
		"properties": {
			"id": 10001,
	 		"name": "1号",
			"height": 1000
		},
		"geometry": {
			"type": "Polygon",
			"coordinates": [[[114.26730001377071,30.595149654035424],[114.26737510423808,30.594983416111138],[114.26728930608508,30.594946561374197],[114.26731076201405,30.59488191979089],[114.26717133751096,30.594845110133267],[114.26709624642238,30.59501134779343],[114.26717132160428,30.595029748326304],[114.26713914030533,30.595094398742066],[114.26707478473918,30.59514061236826],[114.26699970846724,30.59513144350006],[114.26698898951582,30.59505759734068],[114.26678520845394,30.595048535449614],[114.26677447111632,30.595187022721653],[114.26687099882221,30.59519617428873],[114.26687099245959,30.595270029320062],[114.26707477280914,30.595279090587976],[114.26730001377071,30.595149654035424]]]
		}
	}],
    silent: true,
    animationEasingUpdate: 2000
});
 //添加到EchartsGL图层
 mapLayer.addTo(echartsgl);
 //绘制
 echartsgl.render();
 */

GeoGlobe.Visuals.EchartsGL.MapLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {String}
     * @default '1'
     */
    id: '1',

    /**
     * 图层名称，用于tooltip的显示，legend 的图例筛选，在 setOption 更新数据和配置项时用于指定对应的系列。
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {String}
     * @default ''
     */
    name: '',

    /**
     * 图层类别，为常量值，固定为'map3D'
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @constant
     * @type {String}
     * @default 'map3D'
     */
    type: 'map3D',

    /**
     * 图层使用的坐标系，为常量值，固定为'mapbox3D'
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @constant
     * @type {String}
     * @default 'mapbox3D'
     */
    coordinateSystem: 'mapbox3D',

    /**
     * 地图类型。ECharts 中提供了两种格式的地图数据，一种是可以直接 script 标签引入的 js 文件，引入后会自动注册地图名字和数据。还有一种是 JSON 文件，需要通过 AJAX 异步加载后手动注册。
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {String}
     * @default ''
     */
    map: '',

    /**
     * 会将 GeoJSON 中所有的 geometry 合并成一个，在 GeoJSON 拥有特别多（上千）的 geometry 时可以有效提升绘制效率。
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {Boolean}
     * @default false
     */
    instancing: false,

    /**
     * 标签的相关设置
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
     *  show: false,
     *  distance: 10,
     *  formatter: '{b}: {c}',
     *  textStyle: {...}
     * }
     */
    label: null,

    /**
     * 鼠标 hover 高亮时图形和标签的样式
     * @memberof GeoGlobe.Visuals.EchartsGL.PolygonsLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
     *  label:{...}
     *  itemStyle:{...}
     * }
     */
    emphasis: null,

    /**
     * 三维地图 中三维图形的视觉属性，包括颜色，透明度，描边等。
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	color: [1, 1, 1, 1],
	 * 	opacity: 1,
	 * 	borderWidth: 1,
	 * 	borderColor: '#333'
	 * }
     */
    itemStyle: null,

    /**
     * 地图区域的设置。geojson结构
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {Array}
     * @example
     * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "1号多边形",
	 *	    "height": 3
	 * 	},
	 * "geometry": {
	 * 	    "type": "Polygon",
	 * 		"coordinates": [[[114.26730001377071,30.595149654035424],[114.26737510423808,30.594983416111138],[114.26728930608508,30.594946561374197],[114.26731076201405,30.59488191979089],[114.26717133751096,30.594845110133267],[114.26709624642238,30.59501134779343],[114.26717132160428,30.595029748326304],[114.26713914030533,30.595094398742066],[114.26707478473918,30.59514061236826],[114.26699970846724,30.59513144350006],[114.26698898951582,30.59505759734068],[114.26678520845394,30.595048535449614],[114.26677447111632,30.595187022721653],[114.26687099882221,30.59519617428873],[114.26687099245959,30.595270029320062],[114.26707477280914,30.595279090587976],[114.26730001377071,30.595149654035424]]]
	 * 	}
	 * }]
     */
    data: [],

    /**
     * 三维地图中三维图形的着色效果。支持下面三种着色方式,'color' 只显示颜色，不受光照等其它因素的影响。'lambert' 通过经典的 lambert 着色表现光照带来的明暗。'realistic' 真实感渲染，配合 light.ambientCubemap 和 postEffect 使用可以让展示的画面效果和质感有质的提升。
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {String}
     * @default null
     */
    shading: null,

    /**
     * 真实感材质相关的配置项，在 shading 为'realistic'时有效。
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	detailTexture: ...,
	 * 	textureTiling: 1,
	 * 	textureOffset: 0,
	 * 	roughness: 0.5,
	 * 	metalness: 0,
	 * 	roughnessAdjust: 0.5,
	 * 	metalnessAdjust: 0.5,
	 * 	normalTexture: ...,
	 * }
     */
    realisticMaterial: null,

    /**
     * lambert lambert 材质相关的配置项，在 shading 为'lambert'时有效。
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	detailTexture: ...,
	 * 	textureTiling: 1,
	 * 	textureOffset: 0,
	 * }
     */
    lambertMaterial: null,

    /**
     * color 材质相关的配置项，在 shading 为'color'时有效。
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	detailTexture: ...,
	 * 	textureTiling: 1,
	 * 	textureOffset: 0,
	 * }
     */
    colorMaterial: null,

    /**
     * 光照相关的设置。在 shading 为 'color' 的时候无效。光照的设置会影响到组件以及组件所在坐标系上的所有图表。合理的光照设置能够让整个场景的明暗变得更丰富，更有层次。
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	main: {...},
	 * 	ambient: {...},
	 * 	ambientCubemap: {...},
	 * }
     */
    light: null,

    /**
     * 后处理特效的相关配置，后处理特效可以为画面添加高光，景深，环境光遮蔽（SSAO），调色等效果。可以让整个画面更富有质感。
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	enable: false,
	 * 	bloom: {...},
	 * 	depthOfField: {...},
	 * 	screenSpaceAmbientOcclusion: {...},
	 * 	SSAO: {...},
	 * 	colorCorrection: {...},
	 * 	FXAA: {...}
	 * }
     */
    postEffect: null,

    /**
     * 分帧超采样。在开启 postEffect 后，WebGL 默认的 MSAA 会无法使用，所以我们需要自己解决锯齿的问题。分帧超采样就是用来解决锯齿的问题，它在画面静止后会持续分帧对一个像素多次抖动采样，从而达到抗锯齿的效果。而且在这个分帧采样的过程中，echarts-gl 也会对 postEffect 中一些需要采样保证效果的特效，例如 SSAO, 景深，以及阴影进行渐进增强。
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @type {Object}
     * @default null
     * @example
     * {
	 * 	enable: 'auto'
	 * }
     */
    temporalSuperSampling: null,

    /**
     * 组件所在的层
     * @memberof GeoGlobe.Visuals.EchartsGL.BarLayer.prototype
     * @type {Number}
     * @default -10
     */
    zlevel: -10,

    /**
     * EchartsGL可视化对象
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @private
     * @type {GeoGlobe.Visuals.EchartsGL}
     */
    _parent: null,

    /**
     * 构造函数
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @private
     * @param {Object}  options -  参数对象
     */
    initialize: function (options) {
        this.id = options.id ? options.id : this.id;
        this.name = options.name ? options.name : this.name;
        this.map = options.map ? options.map : this.map;
        this.instancing = options.instancing ? options.instancing : this.instancing;
        this.label = options.label ? options.label : this.label;
        this.emphasis = options.emphasis ? options.emphasis : this.emphasis;
        this.itemStyle = options.itemStyle ? options.itemStyle : this.itemStyle;
        this.data = options.data ? options.data : this.data;
        this.shading = options.shading ? options.shading : this.shading;
        this.realisticMaterial = options.realisticMaterial ? options.realisticMaterial : this.realisticMaterial;
        this.lambertMaterial = options.lambertMaterial ? options.lambertMaterial : this.lambertMaterial;
        this.colorMaterial = options.colorMaterial ? options.colorMaterial : this.colorMaterial;
        this.light = options.light ? options.light : this.light;
        this.postEffect = options.postEffect ? options.postEffect : this.postEffect;
        this.temporalSuperSampling = options.temporalSuperSampling ? options.temporalSuperSampling : this.temporalSuperSampling;
        this.zlevel = options.zlevel ? options.zlevel : this.zlevel;
    },

    /**
     * 关联Three
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @param {GeoGlobe.Visuals.EchartsGL} echartsgl
     */
    addTo: function (echartsgl) {
        this._parent = echartsgl;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     */
    render: function () {
        this._parent.render();
    },

    /**
     * 获取绘制的option结构数据
     * @memberof GeoGlobe.Visuals.EchartsGL.MapLayer.prototype
     * @returns {Object} options
     * @see {@link http://echarts.baidu.com/option-gl.html#series-map3D}
     */
    getRenderOption: function () {
        var option = {};
        this.id && (option.id = this.id);
        this.name && (option.name = this.name);
        this.map && (option.map = this.map);
        this.instancing && (option.instancing = this.instancing);
        this.label && (option.label = this.label);
        this.emphasis && (option.emphasis = this.emphasis);
        this.itemStyle && (option.itemStyle = this.itemStyle);
        this.shading && (option.shading = this.shading);
        this.realisticMaterial && (option.realisticMaterial = this.realisticMaterial);
        this.lambertMaterial && (option.lambertMaterial = this.lambertMaterial);
        this.colorMaterial && (option.colorMaterial = this.colorMaterial);
        this.light && (option.light = this.light);
        this.postEffect && (option.postEffect = this.postEffect);
        this.temporalSuperSampling && (option.temporalSuperSampling = this.temporalSuperSampling);
        this.zlevel && (option.zlevel = this.zlevel);

        option.type = 'map3D';
        option.coordinateSystem = 'mapbox3D';

        if (this.data && this.data instanceof Array) {
            option.data = [];
            for (var i = 0; i < this.data.length; i++) {
                if (!this.data[i].properties || !this.data[i].geometry) {
                    console.warn("MapLayer使用的数据格式不正确，请确认为geojson格式！");
                    continue;
                }
                if (this.data[i].geometry.type !== 'Polygon') {
                    console.warn("MapLayer使用的必须是Polygon几何形状！");
                    continue;
                }
                var item = {};
                item.name = this.data[i].properties.name;
                item.height = this.data[i].properties.height;
                item.value = this.data[i].properties.value;
                option.data.push(item);
            }
        }

        return option;
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Custom
 * @classdesc 可视化定制图层
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //绑定鼠标点击事件
 custom.on('overlayerclick', function(e){
	console.info(e);
 });
 //绑定鼠标移动事件
 custom.on('overlayerhover', function(e){
	console.info(e);
 });
 //构造气泡图层
 var bubble = new GeoGlobe.Visuals.Custom.Bubble({
    id: "bubble_1",
    visibility: true,
    dragdrawing: true,
    data: [{"type": "Feature", "properties": {name: "湖北省", value: 666}, "geometry": {"type": "Point", "coordinates": [112.26577320468478, 30.98857642486671]}}],
    rendererOptions: {
        markPoint: {
            hoverable: true,
            clickable: true,
            symbol: "bubble",
            itemStyle: {
                color: 'rgba(255,0,0,0.7)'
            }
        }
    }
 });
 //添加到可视化定制图层
 bubble.addTo(custom);
 //绘制
 custom.render();
 */
GeoGlobe.Visuals.Custom = GeoGlobe.Class4OL(GeoGlobe.Visuals, {

    /**
     * 地图对象
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @type {GeoGlobe.Map}
     * @default null
     */
    map: null,

    /**
     * map的容器
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @type {Object}
     */
    container: null,

    /**
     * 图层集合
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @type {Array}
     */
    layers: [],

    /**
     * 图层id集合
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @type {Array}
     */
    _order: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        GeoGlobe.Visuals.prototype.initialize.apply(this, arguments);
        this.layers = [];
        this._order = [];
    },

    /**
     * 与地图对象关联
     * @function addTo
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @public
     * @param {Object} map 地图对象
     */
    addTo: function (map) {
        GeoGlobe.Visuals.prototype.addTo.apply(this, arguments);

        this.container.className = "geoglobe-custom-container";
        this._bindEvent();
    },

    /**
     * 绘制图层
     * @function render
     * @memberof GeoGlobe.Visuals.Custom.prototype
     */
    render: function () {
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i].render();
        }
    },

    /**
     * 向可视化图层中添加子图层
     * @function addLayer
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @param {Object} layer 子图层对象
     */
    addLayer: function (layer) {
        if (!layer.id) {
            console.error("图层id属性不能为空！");
            return;
        }
        var oldLayer = this.getLayer(layer.id);
        if (oldLayer) {
            oldLayer = layer;
        } else {
            this.layers.push(layer);
        }
    },

    /**
     * 移动图层
     * @function moveLayer
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @param {String} id 图层id
     */
    moveLayer: function moveLayer(id, before) {
        var layer = this.getLayer(id);
        if (!layer) {
            this.fire('error', {
                error: new Error(
                    "The layer '" + id + "' does not exist in " +
                    "the map's style and cannot be moved."
                )
            });
            return;
        }

        this._order = this.layers.map(function (Layer) {
            return Layer.id;
        });
        var index = this._order.indexOf(id);
        this._order.splice(index, 1);

        var newIndex = before ? this._order.indexOf(before) : this._order.length;
        if (before && newIndex === -1) {
            this.fire('error', {error: new Error(("Layer with id \"" + before + "\" does not exist on this map."))});
            return;
        }
        this._order.splice(newIndex, 0, id);
        for (var j = 0; j < this._order.length; j++) {
            for (var i = 0; i < this.layers.length; i++) {
                if (this._order[j] === this.layers[i].id) {
                    this.layers[i].div.style.zIndex = j
                }
            }
        }
    },

    /**
     * 移除图层
     * @function removeLayer
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @param {String} id 图层id
     */
    removeLayer: function (id) {
        var array = [];
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                this.layers[i].destroy && this.layers[i].destroy();
                continue;
            }
            array.push(this.layers[i]);
        }
        this.layers = array;
    },

    /**
     * 获取指定id图层
     * @function getLayer
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @param {String} id 图层id
     * @returns {Object} layer 图层对象
     */
    getLayer: function (id) {
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                return this.layers[i];
            }
        }
    },

    /**
     * 绑定事件
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @private
     */
    _bindEvent: function () {
        var _this = this;

        // 地图平移开始，当地图未倾斜时记下此时的中心点坐标，这种情况下只是平移图层画布而不重绘
        this.map.on('dragstart', function CUSTOM_DRAGSTART_EVENT() {
            if (this.getPitch() === 0) {
                _this.lastCenter = this.getCenter();
            }
        });
        // 地图平移、缩放、旋转或倾斜时
        this.map.on('move', function CUSTOM_MOVE_EVENT() {
            _this.lastCenter && (_this.lastCenterPixel = this.project(_this.lastCenter));
            _this.layers.forEach(function (layer) {
                layer.onMove();
            });
        });
        // 地图平移、缩放、旋转或倾斜结束
        this.map.on('moveend', function CUSTOM_MOVEEND_EVENT() {
            _this.lastCenter = null;
            _this.layers.forEach(function (layer) {
                layer.onMoveEnd();
            });
        });

        this.map.on('click', function CUSTOM_CLICK_EVENT(e) {
            _this._onClick(e);
        });
        this.map.on('mousemove', function CUSTOM_MOUSEMOVE_EVENT(e) {
            _this._onMouseMove(e);
        });
        this.map.on('resize', function CUSTOM_RESIZE_EVENT(e) {
            _this._onResize();
        })
    },

    /**
     * 解绑事件
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @private
     */
    _unbindEvent: function () {
        for (var i = 0; i < this.map._listeners['dragstart'].length; i++) {
            if (this.map._listeners['dragstart'][i].name && this.map._listeners['dragstart'][i].name === 'CUSTOM_DRAGSTART_EVENT') {
                this.map._listeners['dragstart'].splice(i, 1);
            }
        }
        for (var i = 0; i < this.map._listeners['move'].length; i++) {
            if (this.map._listeners['move'][i].name && this.map._listeners['move'][i].name === 'CUSTOM_MOVE_EVENT') {
                this.map._listeners['move'].splice(i, 1);
            }
        }
        for (var i = 0; i < this.map._listeners['moveend'].length; i++) {
            if (this.map._listeners['moveend'][i].name && this.map._listeners['moveend'][i].name === 'CUSTOM_MOVEEND_EVENT') {
                this.map._listeners['moveend'].splice(i, 1);
            }
        }
        for (var i = 0; i < this.map._listeners['click'].length; i++) {
            if (this.map._listeners['click'][i].name && this.map._listeners['click'][i].name === 'CUSTOM_CLICK_EVENT') {
                this.map._listeners['click'].splice(i, 1);
            }
        }
        for (var i = 0; i < this.map._listeners['mousemove'].length; i++) {
            if (this.map._listeners['mousemove'][i].name && this.map._listeners['mousemove'][i].name === 'CUSTOM_MOUSEMOVE_EVENT') {
                this.map._listeners['mousemove'].splice(i, 1);
            }
        }
        for (var i = 0; i < this.map._listeners['resize'].length; i++) {
            if (this.map._listeners['resize'][i].name && this.map._listeners['resize'][i].name === 'CUSTOM_RESIZE_EVENT') {
                this.map._listeners['resize'].splice(i, 1);
            }
        }
    },

    /**
     * 鼠标指针单击事件
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @param {Object} event 事件参数
     * @private
     */
    _onClick: function (event) {
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i].onClick && this.layers[i].onClick(event);
        }
    },

    /**
     * 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @param {Object} event 事件参数
     * @private
     */
    _onMouseMove: function (event) {
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i].onMouseMove && this.layers[i].onMouseMove(event);
        }
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @private
     */
    _onResize: function () {
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i].onResize();
        }
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Custom.Bubble
 * @classdesc 气泡图层
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.dragdrawing 拖动图层时是否绘制
 * @param {Boolean} options.data 数据，geojson格式
 * @param {Object} options.rendererOptions 渲染配置
 * @param {Object} options.rendererOptions.markPoint 标注
 * @param {Boolean} options.rendererOptions.markPoint.hoverable 是否启用鼠标悬浮
 * @param {Boolean} options.rendererOptions.markPoint.clickable 是否启用鼠标点击
 * @param {String} options.rendererOptions.markPoint.symbol 标注图形类型，可选为：'bubble' | 'circle' | 'ring' | 'pin' | 'rmb' | 'round' | 'fire' | 'water' | 'ellipse' | 'heatmap' | 'icon' | 'sprite'
 * @param {Number} options.rendererOptions.markPoint.symbolMinSize 标注最小大小
 * @param {Number} options.rendererOptions.markPoint.symbolMaxSize 标注最大大小
 * @param {Number} options.rendererOptions.markPoint.symbolNumber 最大绘制的标注数量
 * @param {Number} options.rendererOptions.markPoint.symbolValueRangeScale 标注统计值范围的缩放倍数，默认为1
 * @param {Number} options.rendererOptions.markPoint.symbolSrc 标注图标文件路径
 * @param {Object} options.rendererOptions.markPoint.effect 动画特效
 * @param {Boolean} options.rendererOptions.markPoint.effect.show 是否启用动画
 * @param {Number} options.rendererOptions.markPoint.effect.scaleSize 缩放倍数，以标注大小为基准
 * @param {Number} options.rendererOptions.markPoint.effect.period 运动周期，无单位，值越大越慢
 * @param {Object} options.rendererOptions.markPoint.itemStyle 图形样式属性
 * @param {String} options.rendererOptions.markPoint.itemStyle.color 颜色
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowColor 阴影颜色
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowBlur 阴影模糊度
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowOffsetX 阴影偏移量X
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowOffsetY 阴影偏移量Y
 * @param {Object} options.rendererOptions.markPoint.label 标签
 * @param {Boolean} options.rendererOptions.markPoint.label.show 标签是否显示
 * @param {String} options.rendererOptions.markPoint.label.color 颜色
 * @param {String} options.rendererOptions.markPoint.label.align 水平对齐方式，可选为：'start' | 'end' | 'left' | 'right' | 'center'
 * @param {String} options.rendererOptions.markPoint.label.baseline 垂直对齐方式，可选为：'top' | 'hanging' | 'middle' | 'alphabetic' | 'ideographic' | 'bottom'
 * @param {String} options.rendererOptions.markPoint.label.fontFamily 字体系列
 * @param {Number} options.rendererOptions.markPoint.label.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.markPoint.label.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.markPoint.label.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 * @param {Object} options.rendererOptions.tooltip 悬浮提示
 * @param {Boolean} options.rendererOptions.tooltip.show 是否显示悬浮提示框
 * @param {String} options.rendererOptions.tooltip.backgroundColor 背景颜色
 * @param {String} options.rendererOptions.tooltip.borderColor 边框颜色
 * @param {Number} options.rendererOptions.tooltip.borderRadius 边框圆角
 * @param {Number} options.rendererOptions.tooltip.borderWidth 边框宽度
 * @param {Number} options.rendererOptions.tooltip.padding 内边距
 * @param {Object} options.rendererOptions.tooltip.textStyle 文字样式
 * @param {String} options.rendererOptions.tooltip.textStyle.color 颜色
 * @param {String} options.rendererOptions.tooltip.textStyle.fontFamily 字体系列
 * @param {Number} options.rendererOptions.tooltip.textStyle.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.tooltip.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.tooltip.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 *
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //构造气泡图层
 var bubble = new GeoGlobe.Visuals.Custom.Bubble({
    id: "bubble_1",
    visibility: true,
    dragdrawing: true,
    data: [{"type": "Feature", "properties": {name: "湖北省", value: 666}, "geometry": {"type": "Point", "coordinates": [112.26577320468478, 30.98857642486671]}}],
    rendererOptions: {
        markPoint: {
            symbol: 'bubble',
            symbolMinSize: 20,
            symbolMaxSize: 40,
            effect: {
                show: true,
                scaleSize: 2,
                period: 10
            },
            itemStyle: {
                color: 'rgba(255,0,0,0.7)'
            },
            label: {
                show: false
            }
        }
    }
 });
 //添加到可视化定制图层
 bubble.addTo(custom);
 //绘制
 custom.render();
 */
GeoGlobe.Visuals.Custom.Bubble = GeoGlobe.Class4OL({

    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @type {Array}
     */
    canvas: [],

    /**
     * 离屏画布集合
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @type {Array}
     */
    cacheCanvas: [],

    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @type {Array}
     */
    canvasContext: [],

    /**
     * 离屏画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @type {Array}
     */
    cacheCanvasContext: [],

    /**
     * 标注类
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @type {Function}
     */
    MarkPoint: null,

    /**
     * 标注对象集
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @type {Array}
     */
    markPoints: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     */
    _initContainer: function () {
        this.div = document.createElement("div");
        this.div.setAttribute("id", this.id);
        this.div.setAttribute("style", "position:absolute");
    },

    /**
     * 初始化渲染配置
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     */
    _init_RendererOptions: function () {
        this._rendererOptions = GeoGlobe.Util.deepExtend({}, {
            markPoint: {
                hoverable: true,
                clickable: true,
                symbol: 'bubble',
                symbolMinSize: 20,
                symbolMaxSize: 40,
                symbolNumber: Number.MAX_VALUE,
                symbolValueRangeScale: 1,
                symbolSrc: "",
                effect: {
                    show: true,
                    scaleSize: 2,
                    period: 10
                },
                itemStyle: {
                    color: 'rgba(255,0,0,0.7)',
                    shadowColor: '#000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                },
                label: {
                    show: true,
                    color: '#fff',
                    align: 'center',
                    baseline: 'middle',
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            },
            tooltip: {
                show: true,
                backgroundColor: '#fff',
                borderColor: '#333',
                borderRadius: 0,
                borderWidth: 0,
                padding: 10,
                textStyle: {
                    color: "#000",
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            }
        }, this.rendererOptions);
    },

    /**
     * 定义标注类
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     */
    _initMarkPoint: function () {
        var _this = this;

        var markPoint = this._rendererOptions.markPoint;

        var effect = markPoint.effect;
        var itemStyle = markPoint.itemStyle;
        var label = markPoint.label;

        /**
         * 构造一个标注实例
         * @param {Number} index 索引号
         * @param {String} name 字段名
         * @param {Number} value 数据值，决定了标注的大小
         * @param {Number} lon 经度
         * @param {Number} lat 纬度
         * @param {String} time 时间
         * @param {Object} attributes 属性
         */
        this.MarkPoint = function (index, name, value, lon, lat, time, attributes) {
            this.index = index;
            this.name = name;
            this.value = value;
            this.lon = lon;
            this.lat = lat;
            this.time = time;
            this.attributes = attributes;
            this.init();

            this.weight = (this.value - _this.minValue) / (_this.maxValue - _this.minValue);
            if (isNaN(this.weight)) this.weight = 1;
            if (this.weight > 1) this.weight = 1;
            if (this.weight < 0) this.weight = 0;
            this.size = markPoint.symbolMinSize + (markPoint.symbolMaxSize - markPoint.symbolMinSize) * this.weight;
            this.radius = this.size / 2;

            this.color = GeoGlobe.Util.getType(itemStyle.color) === "object" ? 'rgba(' + _this.gradientImageData[~~(this.weight * 255 + 0.5) * 4] + ',' + _this.gradientImageData[~~(this.weight * 255 + 0.5) * 4 + 1] + ',' + _this.gradientImageData[~~(this.weight * 255 + 0.5) * 4 + 2] + ',' + _this.gradientImageData[3] / 255 + ')' : itemStyle.color;
            this.rgbColor = GeoGlobe.Util.getRgbColor(this.color);
            this.tmpColor = this.color;
            this.alpha = this.color.indexOf("a(") !== -1 ? +this.color.split(',')[3].split(')')[0] : 1;

            switch (markPoint.symbol) {
                case 'fire':
                    this.fires = [];
                    for (var i = 0; i < 150; i++) {
                        this.fires.push(new _this.Fire(this.size));
                    }
                    break;
                case 'water':
                    this.waveLength = 0.1;
                    this.waveSize = this.size * 0.8;
                    this.attenuations = [3, 2];
                    this.noises = [0.6 * ((this.waveSize / 2) - 4), 0.3 * ((this.waveSize / 2) - 4)];
                    this.Fs = [10, 10];//todo
                    break;
                case 'heatmap':
                    this.scale = this.size / markPoint.symbolMaxSize;
                    break;
                case 'sprite':
                    this.scale = this.size / markPoint.symbolMaxSize;
                    this.factor = 1;
                    break;
            }
        };

        /**
         * 初始化
         * @memberof GeoGlobe.Visuals.Custom.Bubble.MarkPoint.prototype
         */
        this.MarkPoint.prototype.init = function () {
            switch (markPoint.symbol) {
                case "bubble":
                case "ellipse":
                    this.energy = effect.show ? Math.random() * effect.scaleSize : effect.scaleSize;
                    this.increment = Math.max(0.1 * effect.scaleSize / effect.period + Math.random() * (Math.random() > 0.5 ? 1 : -1) * 0.002, 0.001);
                    break;
                case "circle":
                    this.energy = [0, 1 / 3, 2 / 3];
                    this.increment = Math.max(0.1 * effect.scaleSize / effect.period + Math.random() * (Math.random() > 0.5 ? 1 : -1) * 0.002, 0.001);
                    break;
                case "ring":
                    this.energy = [0, 1 / 4 * effect.scaleSize, 2 / 4 * effect.scaleSize, 3 / 4 * effect.scaleSize];
                    this.increment = Math.max(0.1 * effect.scaleSize / effect.period + Math.random() * (Math.random() > 0.5 ? 1 : -1) * 0.002, 0.001);
                    break;
                case "pin":
                case "rmb":
                case "round":
                case "fire":
                case "heatmap":
                    break;
                case "water":
                    this.energy = 0;
                    this.increment = 0.1 + Math.random() * (Math.random() > 0.5 ? 1 : -1) * 0.02;
                    break;
                case "sprite":
                    this.energy = effect.show ? Math.random() * effect.scaleSize : effect.scaleSize;
                    this.increment = Math.max(0.1 * effect.scaleSize / effect.period + Math.random() * (Math.random() > 0.5 ? 1 : -1) * 0.002, 0.001);
                    break;
            }
        };

        /**
         * 更新标注的位置
         * @memberof GeoGlobe.Visuals.Custom.Bubble.MarkPoint.prototype
         */
        this.MarkPoint.prototype.updateXY = function () {
            //todo 判断标注是否在屏幕可视范围之内，倾斜、旋转会存在问题
            // if (this.lon >= _this._parent.bounds[0] && this.lon <= _this._parent.bounds[2] && this.lat >= _this._parent.bounds[1] && this.lat <= _this._parent.bounds[3]) {
            var point = _this._parent.map.project([this.lon, this.lat]);
            this.x = point.x;
            this.y = point.y;

            if (markPoint.symbol === 'fire') {
                for (var i = 0; i < this.fires.length; i++) {
                    this.fires[i].x = this.x;
                    this.fires[i].y = this.y;
                }
            }
            this.visible = true;
            //} else {
            //    this.visible = false;
            //}
        };

        /**
         * 更新标注的大小
         * @memberof GeoGlobe.Visuals.Custom.Bubble.MarkPoint.prototype
         */
        this.MarkPoint.prototype.update = function () {
            var i;
            switch (markPoint.symbol) {
                case "bubble":
                case "ellipse":
                    this.energy += this.increment;
                    if (this.energy > effect.scaleSize) {
                        this.energy = 0;
                    }
                    break;
                case "circle":
                    for (i = 0; i < 3; i++) {
                        this.energy[i] += this.increment;
                        if (this.energy[i] > 1) {
                            this.energy[i] = 0;
                        }
                    }
                    break;
                case "ring":
                    for (i = 0; i < 4; i++) {
                        this.energy[i] += this.increment;
                        if (this.energy[i] > effect.scaleSize) {
                            this.energy[i] = 0;
                        }
                    }
                    break;
                case "pin":
                case "rmb":
                case "round":
                case "heatmap":
                    break;
                case "fire":
                    var fire;
                    for (i = 0; i < this.fires.length; i++) {
                        fire = this.fires[i];
                        fire.x += fire.speedX;
                        fire.y += fire.speedY;
                        fire.opacity -= fire.increment;
                        fire.radius++;

                        if (fire.opacity < 0) {
                            this.fires[i] = new _this.Fire(this.size, this.x, this.y);
                        }
                    }
                    break;
                case "water":
                    //todo
                    this.energy = (this.energy + this.increment) % (Math.PI * 64);
                    break;
                case "sprite":
                    // this.energy = this.energy * this.energy * (( 1.70158 + 1 ) * this.energy - 1.70158 );
                    // if (this.energy === 0) this.energy = effect.scaleSize;
                    if (this.energy <= 0.15) {
                        this.factor = 1;
                    } else if (this.energy >= effect.scaleSize) {
                        this.factor = -1;
                    }
                    this.energy += this.factor * this.increment;
                    break;
            }
        };

        /**
         * 判断鼠标是否悬浮在路径上
         * @memberof GeoGlobe.Visuals.Custom.Bubble.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkPoint.prototype.isPointInPath = function (context, x, y) {
            context.beginPath();
            switch (markPoint.symbol) {
                case "bubble":
                case "circle":
                case "ring":
                case "round":
                case "water":
                case "ellipse":
                case "heatmap":
                case "sprite":
                    context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
                    break;
                case "pin":
                    context.moveTo(this.x - 0.5, this.y);
                    context.quadraticCurveTo(this.x, this.y - this.radius / 2, this.x - this.radius * Math.sin(Math.PI / 3), this.y - this.radius - this.radius * Math.sin(Math.PI / 6));
                    context.arc(this.x, this.y - this.radius * 2, this.radius, 0, Math.PI * 5 / 6, true);
                    context.arc(this.x, this.y - this.radius * 2, this.radius, 0, Math.PI / 6, false);
                    context.quadraticCurveTo(this.x, this.y - this.radius / 2, this.x + 0.5, this.y);
                    break;
                case "rmb":
                    context.font = label.fontStyle + ' ' + label.fontWeight + ' ' + this.size + 'px ' + label.fontFamily; //todo 保留字体样式可配置性
                    if (GeoGlobe.String.isNumeric(this.value)) {
                        var width = 0;
                        var height = this.size;
                        if (markPoint.formatter) {
                            var str = GeoGlobe.Util.getFormattedString({
                                a: this.name,
                                b: '统计数',
                                c: this.value
                            }, markPoint.formatter);
                            var strs = str.split('<br/>');
                            var rows = strs.length;
                            for (var i = 0; i < rows; i++) {
                                var w = context.measureText(strs[i]).width;
                                w > width && (width = w);
                                context.fillText(strs[i], this.x, this.y - ((rows - 1) / 2 - i) * (this.radius * 2 + 5));
                            }
                        } else {
                            width = context.measureText('￥' + this.value).width;
                        }
                        context.rect(this.x - width / 2, this.y - height / 2, width, height);
                    }
                    break;
                case "fire":
                    //todo 火焰路径范围
                    context.rect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                    break;
            }
            if (context.isPointInPath(x, y)) {
                _this.hoveredMarkPoint = this;
            }
        };

        /**
         * 将标注静态部分绘制到离屏画布1
         * @memberof GeoGlobe.Visuals.Custom.Bubble.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkPoint.prototype.draw1 = function (context) {
            if (_this.hoveredMarkPoint === this) {
                this.radius = this.size / 2 * 1.1;
                this.color = GeoGlobe.Util.getShadeColor(this.tmpColor, 20);
                this.rgbColor = GeoGlobe.Util.getRgbColor(this.color);
            } else {
                this.radius = this.size / 2;
                this.color = this.tmpColor;
                this.rgbColor = GeoGlobe.Util.getRgbColor(this.color);
            }

            context.shadowColor = itemStyle.shadowColor;
            context.shadowBlur = itemStyle.shadowBlur;
            context.shadowOffsetX = itemStyle.shadowOffsetX;
            context.shadowOffsetY = itemStyle.shadowOffsetY;
            switch (markPoint.symbol) {
                case "bubble":
                    if (_this.hoveredMarkPoint === this) {
                        context.beginPath();
                        context.arc(this.x, this.y, this.radius * effect.scaleSize / 2, 0, Math.PI * 2, true);
                        context.lineWidth = ~~(this.radius / 5 + .5) < 2 ? 2 : ~~(this.radius / 5 + .5);
                        context.strokeStyle = this.color;
                        context.stroke();
                    }
                    break;
                case "circle":
                case "round":
                    context.beginPath();
                    context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
                    context.fillStyle = this.color;
                    context.fill();
                    break;
                case "pin":
                    context.beginPath();
                    context.moveTo(this.x + this.radius / 3, this.y);
                    context.quadraticCurveTo(this.x + this.radius / 3, this.y + this.radius / 10, this.x, this.y + this.radius / 10);
                    context.quadraticCurveTo(this.x - this.radius / 3, this.y + this.radius / 10, this.x - this.radius / 3, this.y);
                    context.quadraticCurveTo(this.x - this.radius / 3, this.y - this.radius / 10, this.x, this.y - this.radius / 10);
                    context.quadraticCurveTo(this.x + this.radius / 3, this.y - this.radius / 10, this.x + this.radius / 3, this.y);
                    context.fillStyle = 'rgba(0,0,0,0.3)';
                    context.fill();
                    context.beginPath();
                    context.moveTo(this.x + this.radius * 2 / 3, this.y);
                    context.quadraticCurveTo(this.x + this.radius * 2 / 3, this.y + this.radius / 6, this.x, this.y + this.radius / 6);
                    context.quadraticCurveTo(this.x - this.radius * 2 / 3, this.y + this.radius / 6, this.x - this.radius * 2 / 3, this.y);
                    context.quadraticCurveTo(this.x - this.radius * 2 / 3, this.y - this.radius / 6, this.x, this.y - this.radius / 6);
                    context.quadraticCurveTo(this.x + this.radius * 2 / 3, this.y - this.radius / 6, this.x + this.radius * 2 / 3, this.y);
                    context.fillStyle = 'rgba(0,0,0,0.2)';
                    context.fill();
                    context.beginPath();
                    context.moveTo(this.x - 0.5, this.y);
                    context.quadraticCurveTo(this.x, this.y - this.radius / 2, this.x - this.radius * Math.sin(Math.PI / 3), this.y - this.radius - this.radius * Math.sin(Math.PI / 6));
                    context.arc(this.x, this.y - this.radius * 2, this.radius, 0, Math.PI * 5 / 6, true);
                    context.arc(this.x, this.y - this.radius * 2, this.radius, 0, Math.PI / 6, false);
                    context.quadraticCurveTo(this.x, this.y - this.radius / 2, this.x + 0.5, this.y);
                    context.fillStyle = this.color;
                    context.fill();
                    break;
                case "rmb":
                    context.font = label.fontStyle + ' ' + label.fontWeight + ' ' + (this.radius * 2) + 'px ' + label.fontFamily; //todo 保留字体样式可配置性
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillStyle = this.color;
                    if (GeoGlobe.String.isNumeric(this.value)) {
                        if (markPoint.formatter) {
                            var str = GeoGlobe.Util.getFormattedString({
                                a: this.name,
                                b: '统计数',
                                c: this.value
                            }, markPoint.formatter);
                            var strs = str.split('<br/>');
                            var rows = strs.length;
                            for (var i = 0; i < rows; i++) {
                                context.fillText(strs[i], this.x, this.y - ((rows - 1) / 2 - i) * (this.radius * 2 + 5));
                            }
                        } else {
                            context.fillText('￥' + this.value, this.x, this.y);
                        }
                    }
                    break;
                case "ring":
                case 'fire':
                case "ellipse":
                case "sprite":
                    break;
                case "water":
                    var gradient = context.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius);
                    gradient.addColorStop(0.8, 'rgba(255,255,255,0)');
                    gradient.addColorStop(1, 'rgba(255,255,255,1)');

                    context.beginPath();
                    context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                    context.fillStyle = gradient;
                    context.fill();
                    break;
                case "heatmap":
                    context.save();
                    context.translate(this.x, this.y);
                    context.scale(this.scale, this.scale);
                    context.drawImage(_this.markPointCacheCanvas, -_this.markPointCacheCanvasSize / 2, -_this.markPointCacheCanvasSize / 2);
                    context.restore();
                    break;
                case "icon":
                    context.save();
                    context.translate(this.x, this.y);
                    context.rotate(Math.PI / 180 * (this.attributes.azimuth - _this._parent.map.getBearing()));
                    context.drawImage(_this.markPointCacheImage, -this.size / 2, -this.size / 2, this.size, this.size);
                    context.restore();
                    break;
            }

            //绘制圆内文字
            switch (markPoint.symbol) {
                case "bubble":
                case "circle":
                case "round":
                case "water":
                case "ellipse":
                    if (label.show) {
                        context.font = label.fontStyle + ' ' + label.fontWeight + ' ' + label.fontSize + 'px ' + label.fontFamily;
                        context.textAlign = label.align;
                        context.textBaseline = label.baseline;
                        context.fillStyle = label.color;
                        context.fillText(this.value, this.x, this.y);
                    }
                    break;
                case "pin":
                    if (label.show) {
                        context.beginPath();
                        context.arc(this.x, this.y - this.radius * 2, this.radius / 3, 0, Math.PI * 2, true);
                        context.shadowBlur = 0;
                        context.shadowOffsetX = 0;
                        context.shadowOffsetY = 0;
                        context.fillStyle = label.color;
                        context.fill();
                    }
                    break;
            }
        };

        /**
         * 将标注动画部分绘制到离屏画布2
         * @memberof GeoGlobe.Visuals.Custom.Bubble.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkPoint.prototype.draw2 = function (context) {
            var i;
            switch (markPoint.symbol) {
                case "bubble":
                    context.beginPath();
                    context.arc(this.x, this.y, this.radius * this.energy, 0, Math.PI * 2, true);
                    context.strokeStyle = this.color;
                    context.stroke();
                    break;
                case "circle":
                    i = 0;
                    while (i < 3) {
                        context.beginPath();
                        context.arc(this.x, this.y, this.radius + this.radius * (effect.scaleSize - 1) * this.energy[i], 0, Math.PI * 2, true);
                        context.strokeStyle = 'rgba' + this.rgbColor.slice(3).split(')')[0] + ',' + (1 - this.energy[i]) * this.alpha + ')';
                        context.stroke();
                        i++;
                    }
                    break;
                case "ring":
                    i = 0;
                    while (i < 4) {
                        context.beginPath();
                        context.arc(this.x, this.y, this.radius * this.energy[i], 0, Math.PI * 2, true);
                        context.fillStyle = 'rgba' + this.rgbColor.slice(3).split(')')[0] + ',' + Math.max(1 - this.energy[i] / effect.scaleSize, 0) * this.alpha + ')';
                        context.fill();
                        i++;
                    }

                    //绘制到离屏画布2以防被遮挡
                    if (label.show) {
                        context.font = label.fontStyle + ' ' + label.fontWeight + ' ' + label.fontSize + 'px ' + label.fontFamily;
                        context.textAlign = label.align;
                        context.textBaseline = label.baseline;
                        context.fillStyle = label.color ? label.color : this.color;
                        context.fillText(this.value, this.x, this.y);
                    }
                    break;
                case "pin":
                case "rmb":
                case "round":
                case "heatmap":
                    break;
                case "fire":
                    var fire, gradient;
                    for (i = 0; i < this.fires.length; i++) {
                        fire = this.fires[i];

                        gradient = context.createRadialGradient(fire.x, fire.y, 0, fire.x, fire.y, fire.radius);
                        gradient.addColorStop(0, 'rgba' + this.rgbColor.slice(3).split(')')[0] + ',' + fire.opacity + ')');
                        gradient.addColorStop(0.5, 'rgba' + this.rgbColor.slice(3).split(')')[0] + ',' + fire.opacity + ')');
                        gradient.addColorStop(1, "rgba" + this.rgbColor.slice(3).split(')')[0] + ", 0)");

                        context.beginPath();
                        context.arc(fire.x, fire.y, fire.radius, 0, Math.PI * 2, false);
                        context.fillStyle = gradient;
                        context.globalAlpha = this.alpha;
                        context.fill();
                    }
                    break;
                case "water":
                    var x0 = this.x - this.radius * 0.8;
                    var y0 = this.y;
                    var x, y;

                    context.beginPath();
                    context.moveTo(x0, y0);
                    for (i = -this.waveLength; i <= this.waveLength; i += 0.01) {
                        i = parseFloat(parseFloat(i).toFixed(2));
                        x = x0 + this.waveSize * ((i + this.waveLength) / (this.waveLength * 2));
                        y = y0 + this.noises[0] * Math.pow(Math.sin(i * 10 * this.attenuations[0]), 1) * Math.sin(this.Fs[0] * i - this.energy);
                        context.lineTo(x, y)
                    }
                    context.arc(this.x, this.y, this.radius * 0.8, 0, Math.PI, false);
                    context.fillStyle = GeoGlobe.Util.getShadeColor(this.color, -10);
                    context.globalAlpha = this.alpha;
                    context.fill();

                    context.beginPath();
                    context.moveTo(x0, y0);
                    for (i = -this.waveLength; i <= this.waveLength; i += 0.01) {
                        i = parseFloat(parseFloat(i).toFixed(2));
                        x = x0 + this.waveSize * ((i + this.waveLength) / (this.waveLength * 2));
                        y = y0 + this.noises[1] * Math.pow(Math.sin(i * 10 * this.attenuations[1]), 1) * Math.sin(this.Fs[1] * i - this.energy);
                        context.lineTo(x, y)
                    }
                    context.arc(this.x, this.y, this.radius * 0.8, 0, Math.PI, false);
                    context.fillStyle = this.color;
                    context.globalAlpha = 1;
                    context.fill();
                    break;
                case "ellipse":
                    var gradient;
                    gradient = context.createRadialGradient(this.x, this.y, this.radius * this.energy, this.x, this.y, 0);
                    gradient.addColorStop(0.70, "rgba" + this.rgbColor.slice(3).split(')')[0] + ", 0.5)");
                    gradient.addColorStop(0.30, "rgba" + this.rgbColor.slice(3).split(')')[0] + ", 1)");
                    gradient.addColorStop(0.20, "rgba" + this.rgbColor.slice(3).split(')')[0] + ", 1)");
                    gradient.addColorStop(0.00, "rgba" + this.rgbColor.slice(3).split(')')[0] + ", 0)");
                    context.beginPath();
                    context.arc(this.x, this.y, this.radius * this.energy, 0, Math.PI * 2, false);
                    context.fillStyle = gradient;
                    context.globalAlpha = (1 - this.energy / effect.scaleSize) * this.alpha;
                    context.fill();
                    break;
                case "sprite":
                    context.save();
                    context.translate(this.x, this.y);
                    context.scale(this.scale * this.energy, this.scale * this.energy);
                    context.drawImage(_this.markPointCacheCanvas, -_this.markPointCacheCanvasSize / 2, -_this.markPointCacheCanvasSize / 2);
                    context.restore();
                    break;
            }

            if (effect.show) {
                this.update();
            }
        };
    },

    /**
     * 处理特殊标注符号其他杂项
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     */
    _initMarkPointExtra: function () {
        var _this = this;
        if (GeoGlobe.Util.getType(this._rendererOptions.markPoint.itemStyle.color) === "object") {
            this.gradientImageData = GeoGlobe.Util.getGradientImageData(this._rendererOptions.markPoint.itemStyle.color);
        }

        switch (this._rendererOptions.markPoint.symbol) {
            case 'fire':
                if (!this.Fire) {
                    this.Fire = function (size, x, y) {
                        this.x = x;
                        this.y = y;
                        this.speedX = -1 + Math.random() * 2;
                        this.speedY = -5 + Math.random() * 5;
                        this.radius = .5 + Math.random();
                        this.increment = (1 + Math.random()) / size;
                        this.opacity = 1;
                    };
                }
                break;
            case "ellipse":
                //todo
                break;
            case 'heatmap':
                /**
                 * 方式一：geoshow方式
                 * 创建一个symbolMaxSize大小的缓存画布，绘制一个黑色渐变色填充的圆
                 */
                this.markPointCacheCanvasSize = this._rendererOptions.markPoint.symbolMaxSize;
                this.markPointCacheCanvas = document.createElement("canvas");
                this.markPointCacheCanvas.width = this.markPointCacheCanvasSize;
                this.markPointCacheCanvas.height = this.markPointCacheCanvasSize;
                this.markPointCacheCanvasContext = this.markPointCacheCanvas.getContext('2d');

                var radius = this._rendererOptions.markPoint.symbolMaxSize / 2;
                var gradient = this.markPointCacheCanvasContext.createRadialGradient(radius, radius, 0, radius, radius, radius);
                gradient.addColorStop(0.25, "rgba(0,0,0,0.25)");
                gradient.addColorStop(1, "rgba(0,0,0,0)");

                this.markPointCacheCanvasContext.beginPath();
                this.markPointCacheCanvasContext.arc(radius, radius, radius, 0, 2 * Math.PI, false);
                this.markPointCacheCanvasContext.fillStyle = gradient;
                this.markPointCacheCanvasContext.fill();

                /**
                 * 方式二：mapv方式
                 * 创建一个symbolMaxSize大小的缓存画布，绘制一个圆的阴影（将圆的阴影偏移至画布中心）
                 */
                // this.markPointCacheCanvasSize = this._rendererOptions.markPoint.symbolMaxSize;
                // this.markPointCacheCanvas = document.createElement("canvas");
                // this.markPointCacheCanvas.width = this.markPointCacheCanvasSize;
                // this.markPointCacheCanvas.height = this.markPointCacheCanvasSize;
                // this.markPointCacheCanvasContext = this.markPointCacheCanvas.getContext('2d');
                //
                // var radius = this._rendererOptions.markPoint.symbolMaxSize / 3;
                // var shadowBlur = radius / 2;
                // var offsetDistance = 10000;
                // this.markPointCacheCanvasContext.shadowBlur = shadowBlur;
                // this.markPointCacheCanvasContext.shadowColor = 'black';
                // this.markPointCacheCanvasContext.shadowOffsetX = offsetDistance;
                // this.markPointCacheCanvasContext.shadowOffsetY = offsetDistance;
                // this.markPointCacheCanvasContext.beginPath();
                // this.markPointCacheCanvasContext.arc(this.markPointCacheCanvasSize / 2 - offsetDistance, this.markPointCacheCanvasSize / 2 - offsetDistance, radius, 0, Math.PI * 2, true);
                // this.markPointCacheCanvasContext.closePath();
                // this.markPointCacheCanvasContext.fill();

                //定义着色方法
                if (!this.makeItHot) {
                    this.makeItHot = function (context, x, y, width, height) {
                        // var now = new Date();
                        var imgData = context.getImageData(x, y, width, height), pixData = imgData.data;
                        var gradient = this.gradientImageData;
                        var len = pixData.length / 4;
                        var index, alpha, offset;
                        while (len--) {
                            index = len * 4 + 3;
                            alpha = pixData[index];
                            offset = alpha * 4;
                            if (alpha) {
                                pixData[index - 3] = gradient[offset];
                                pixData[index - 2] = gradient[offset + 1];
                                pixData[index - 1] = gradient[offset + 2];
                            }
                        }
                        context.putImageData(imgData, x, y);
                        // console.log(new Date() - now);
                    };
                }
                break;
            case "icon":
                this.markPointCacheImage = new Image();
                this.markPointCacheImage.src = this._rendererOptions.markPoint.symbolSrc;
                this.markPointCacheImage.onload = function () {
                    _this.drawCanvas1();
                };
                break;
            case "sprite":
                this.markPointCacheCanvasSize = this._rendererOptions.markPoint.symbolMaxSize;
                this.markPointCacheCanvas = document.createElement("canvas");
                this.markPointCacheCanvas.width = this.markPointCacheCanvasSize;
                this.markPointCacheCanvas.height = this.markPointCacheCanvasSize;
                this.markPointCacheCanvasContext = this.markPointCacheCanvas.getContext('2d');

                //小精灵标注颜色配置暂时只支持单色
                var rgbColor = GeoGlobe.Util.getRgbColor(this._rendererOptions.markPoint.itemStyle.color);
                var gradient = this.markPointCacheCanvasContext.createRadialGradient(this.markPointCacheCanvasSize / 2, this.markPointCacheCanvasSize / 2, 0, this.markPointCacheCanvasSize / 2, this.markPointCacheCanvasSize / 2, this.markPointCacheCanvasSize / 2);
                gradient.addColorStop(0.15, this._rendererOptions.markPoint.itemStyle.color);
                gradient.addColorStop(0.5, 'rgba' + rgbColor.slice(3).split(')')[0] + ',0.15)');
                gradient.addColorStop(1, 'rgba' + rgbColor.slice(3).split(')')[0] + ',0)');
                this.markPointCacheCanvasContext.fillStyle = gradient;
                this.markPointCacheCanvasContext.fillRect(0, 0, this.markPointCacheCanvasSize, this.markPointCacheCanvasSize);
                break;
        }
    },

    /**
     * 画布初始化
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));
        this.canvasContext.push(this.canvas[1].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));
        this.cacheCanvasContext.push(this.cacheCanvas[1].getContext("2d"));

        this.canvas[0].style.position = "absolute";
        this.canvas[1].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);
        this.div.appendChild(this.canvas[1]);

        this.setVisible(this.visibility);
    },

    /**
     * 悬浮提示框初始化
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     */
    _initTooltip: function () {
        if ((this._rendererOptions.markPoint.hoverable || this._rendererOptions.markPoint.clickable) && this._rendererOptions.tooltip.show) {
            this.tooltipDiv = this.tooltipDiv || this.div.appendChild(document.createElement('div'));
            this.tooltipDiv.style.position = "relative";
            this.tooltipDiv.style.display = "none";
            this.tooltipDiv.style.zIndex = 999;
            this.tooltipDiv.style.color = this._rendererOptions.tooltip.textStyle.color;
            this.tooltipDiv.style.padding = this._rendererOptions.tooltip.padding + "px";
            this.tooltipDiv.style.font = this._rendererOptions.tooltip.textStyle.fontStyle + ' ' + this._rendererOptions.tooltip.textStyle.fontWeight + ' ' + this._rendererOptions.tooltip.textStyle.fontSize + 'px ' + this._rendererOptions.tooltip.textStyle.fontFamily;

            //(IE8-)不兼容rgba问题处理
            if (document.createElement('canvas').getContext) {
                this.tooltipDiv.style["background-color"] = this._rendererOptions.tooltip.backgroundColor;
            } else {
                this.tooltipDiv.style["background-color"] = GeoGlobe.Util.getRgbColor(this._rendererOptions.tooltip.backgroundColor);
            }

            this.tooltipDiv.style["border-width"] = this._rendererOptions.tooltip.borderWidth + "px";
            this.tooltipDiv.style["border-color"] = this._rendererOptions.tooltip.borderColor;
            this.tooltipDiv.style["border-radius"] = this._rendererOptions.tooltip.borderRadius + "px";
            this.tooltipDiv.style["border-style"] = "solid";
            this.tooltipDiv.style['white-space'] = "pre-wrap";
            this.tooltipDiv.style["box-shadow"] = "rgba(0, 0, 0, 0.2) 0px 10px 10px";
            this.tooltipDiv.style["transition"] = "left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)";
        }
    },

    /**
     * 渲染图层
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    render: function () {
        this._init_RendererOptions();
        this._initTooltip();
        this._initMarkPoint();
        this._initMarkPointExtra();
        this.setData(this.data);
        this.draw();
    },

    /**
     * 图层绘制
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    draw: function () {
        this.updateXY();
        this.drawCanvas1();

        //动画
        this.animation = true;
        this.frame && cancelAnimationFrame(this.frame);
        if (this._rendererOptions.markPoint.symbol === "bubble" ||
            this._rendererOptions.markPoint.symbol === "circle" ||
            this._rendererOptions.markPoint.symbol === "ring" ||
            this._rendererOptions.markPoint.symbol === "fire" ||
            this._rendererOptions.markPoint.symbol === "water" ||
            this._rendererOptions.markPoint.symbol === "ellipse" ||
            this._rendererOptions.markPoint.symbol === "sprite") {
            var _this = this;
            (function animate() {
                if (_this._rendererOptions.markPoint.effect.show) {
                    _this.frame = requestAnimationFrame(animate);
                }

                (!_this.moving || (_this.dragdrawing && _this.animation)) && _this.drawCanvas2();
                _this.animation = true;
            })();
        }
    },

    /**
     * 图层（地图）移动时触发：
     * 1、若拖拽时绘制，暂停动画，更新屏幕坐标并重绘画布
     * 2、若拖拽时不绘制，地图未倾斜时的平移，移动画布而不重绘
     * 3、若拖拽时不绘制，其他情况下的地图移动，清空画布
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    onMove: function () {
        this.moving = true;
        if (this.dragdrawing) {
            this.animation = false;
            this.updateXY();
            this.drawCanvas1();
            this.drawCanvas2();
        } else {
            this._parent.lastCenter ? this.moveCanvas() : this.clearCanvas();
        }
    },

    /**
     * 图层（地图）移动结束触发
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    onMoveEnd: function () {
        this.moving = false;
        this.redraw();
    },

    /**
     * 鼠标指针单击事件
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @param {Object} event 事件参数
     */
    onClick: function (event) {
        this._rendererOptions.markPoint.clickable && this.hoveredMarkPoint && this._parent.fire("overlayerclick", {
            layer: this,
            feature: this.hoveredMarkPoint,
            event: event
        });
    },

    /**
     * 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @param {Object} event 事件参数
     */
    onMouseMove: function (event) {
        if (this._rendererOptions.markPoint.hoverable && this.visibility && this.markPoints.length > 0 && !this._parent.map.moving) {
            this.hover(event.point.x, event.point.y);

            this.hoveredMarkPoint && this._parent.fire("overlayerhover", {
                layer: this,
                feature: this.hoveredMarkPoint,
                event: event
            });
        }
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    onResize: function () {
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.canvas[1].height = this.cacheCanvas[0].height = this.cacheCanvas[1].height = this.height = this._parent.map.transform.height;
        this.redraw();
    },

    /**
     * 图层重绘
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    redraw: function () {
        this.clearCanvas();
        this.resetCanvas();

        this.updateXY();
        this.drawCanvas1();
        this.drawCanvas2();
    },

    /**
     * 重新计算标注的屏幕坐标
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    updateXY: function () {
        var i = this.markPoints.length < this._rendererOptions.markPoint.symbolNumber ? this.markPoints.length : this._rendererOptions.markPoint.symbolNumber;
        while (i--) {
            this.markPoints[i].updateXY();
        }
    },

    /**
     * 将标注静态部分绘制到画布1
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    drawCanvas1: function () {
        this.cacheCanvas[0].width = this.width;

        if (this._rendererOptions.markPoint.symbol === "round") {
            this.cacheCanvasContext[0].globalCompositeOperation = 'lighter';
        }
        var i = this.markPoints.length < this._rendererOptions.markPoint.symbolNumber ? this.markPoints.length : this._rendererOptions.markPoint.symbolNumber;
        while (i--) {
            this.markPoints[i].visible && this.markPoints[i].draw1(this.cacheCanvasContext[0]);
        }

        // 热力图样式
        if (this._rendererOptions.markPoint.symbol === "heatmap") {
            this.makeItHot(this.cacheCanvasContext[0], 0, 0, this.width, this.height);
        }

        this.canvas[0].width = this.width;
        this.canvasContext[0].drawImage(this.cacheCanvas[0], 0, 0);
    },

    /**
     * 将标注动画部分绘制到画布2
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    drawCanvas2: function () {
        if (this._rendererOptions.markPoint.symbol === "bubble") {
            if (document.createElement('canvas').getContext) {
                this.cacheCanvasContext[1].globalCompositeOperation = 'destination-out';
                this.cacheCanvasContext[1].fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.cacheCanvasContext[1].fillRect(0, 0, this.width, this.height);
                this.cacheCanvasContext[1].globalCompositeOperation = 'source-over';//lighter
            } else {
                this.cacheCanvas[1].width = this.width;
            }
        } else if (this._rendererOptions.markPoint.symbol === "ring" || this._rendererOptions.markPoint.symbol === "fire" || this._rendererOptions.markPoint.symbol === "sprite") {
            this.cacheCanvas[1].width = this.width;
            this.cacheCanvasContext[1].globalCompositeOperation = 'lighter';
        } else {
            this.cacheCanvas[1].width = this.width;
        }

        this.cacheCanvasContext[1].save();

        var i = this.markPoints.length < this._rendererOptions.markPoint.symbolNumber ? this.markPoints.length : this._rendererOptions.markPoint.symbolNumber;
        while (i--) {
            this.markPoints[i].visible && this.markPoints[i].draw2(this.cacheCanvasContext[1]);
        }
        this.canvas[1].width = this.width;
        this.canvasContext[1].drawImage(this.cacheCanvas[1], 0, 0);
    },

    /**
     * 画布复位
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    resetCanvas: function () {
        this.canvas[0].style.left = this.canvas[1].style.left = this.canvas[0].style.top = this.canvas[1].style.top = '';
    },

    /**
     * 画布清空
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    clearCanvas: function () {
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width;
    },

    /**
     * 画布平移
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    moveCanvas: function () {
        this.canvas[0].style.left = this.canvas[1].style.left = (this._parent.lastCenterPixel.x - this.width / 2) + 'px';
        this.canvas[0].style.top = this.canvas[1].style.top = (this._parent.lastCenterPixel.y - this.height / 2) + 'px';
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    destroy: function () {
        //先停动画，再移Dom，再重置属性
        cancelAnimationFrame(this.frame);

        this._parent.container.removeChild(this.div);

        this.MarkPoint = null;
        this.markPoints = [];
        this.canvas = [];
        this.data = [];
        this.cacheCanvas = [];
        this.canvasContext = [];
        this.cacheCanvasContext = [];
        this._rendererOptions = {};
    },

    /**
     * 鼠标悬浮时触发
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @param {Number} x 鼠标在主画布上的位置（x轴方向）
     * @param {Number} y 鼠标在主画布上的位置（y轴方向）
     */
    hover: function (x, y) {
        this.hoveredMarkPoint = null;

        for (var i = 0, len = this.markPoints.length < this._rendererOptions.markPoint.symbolNumber ? this.markPoints.length : this._rendererOptions.markPoint.symbolNumber; i < len; i++) {
            !this.hoveredMarkPoint && this.markPoints[i].isPointInPath(this.cacheCanvasContext[0], x, y);
        }

        this.drawCanvas1();
        !this._rendererOptions.markPoint.effect.show && this.drawCanvas2();

        //显示悬浮提示框
        if (this.hoveredMarkPoint) {
            this.canvas[1].style.cursor = "pointer";
            this.showTooltip(this.hoveredMarkPoint.name, x, y);
        } else {
            this.canvas[1].style.cursor = "default";
            this.hideTooltip();
        }
    },

    /**
     * 显示悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @param {String} text 要提示的文本
     * @param {Number} x 鼠标在画布上的位置（x轴方向）
     * @param {Number} y 鼠标在画布上的位置（y轴方向）
     * @ignore
     */
    showTooltip: function (text, x, y) {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.textContent = text;
            this.tooltipDiv.style.top = (y - 15) + "px";
            this.tooltipDiv.style.left = (x + 15) + "px";
            this.tooltipDiv.style.display = "block";
        }
    },

    /**
     * 关闭悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     */
    hideTooltip: function () {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.style.display = "none";
        }
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.canvas[1].height = this.cacheCanvas[0].height = this.cacheCanvas[1].height = this.height = this._parent.map.transform.height;
    },

    /**
     * 图层的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = this.canvas[1].style.display = visibility ? "block" : "none";
    },

    /**
     * 数据的处理，构造标注对象
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @param {Array} data 数据
     */
    setData: function (data) {
        this.data = data;

        // 求极值
        this.minValue = Number.MAX_VALUE;
        this.maxValue = Number.MIN_VALUE;
        for (var i = 0; i < data.length; i++) {
            if (data[i].properties.value < this.minValue) this.minValue = data[i].properties.value;
            if (data[i].properties.value > this.maxValue) this.maxValue = data[i].properties.value;
        }
        // this.minValue *= this._rendererOptions.markPoint.symbolValueRangeScale;
        this.maxValue /= this._rendererOptions.markPoint.symbolValueRangeScale;

        var markPoints = [];
        for (var i = 0; i < data.length; i++) {
            markPoints.push(new this.MarkPoint(i, data[i].properties.name, data[i].properties.value, data[i].geometry.coordinates[0], data[i].geometry.coordinates[1], data[i].properties.time, data[i].properties));
        }
        this.hoveredMarkPoint = null;
        this.markPoints = markPoints;
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Custom.Migration
 * @classdesc 迁徙图层
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.data 数据，geojson格式
 * @param {String} options.direction 迁徙方向，可选为：in | out
 * @param {Object} options.location 起始位置or终点位置
 * @param {Object} options.rendererOptions 渲染配置
 * @param {Object} options.rendererOptions.markLine 标线
 * @param {Boolean} options.rendererOptions.markLine.hoverable 是否启用鼠标悬浮
 * @param {Number} options.rendererOptions.markLine.curveness 曲线弯曲弧度，smooth为true时有效
 * @param {Object} options.rendererOptions.markLine.effect 炫光特效
 * @param {String} options.rendererOptions.markLine.effect.color 炫光颜色
 * @param {Number} options.rendererOptions.markLine.effect.scaleSize 放大倍数，以标线宽度为基准
 * @param {Number} options.rendererOptions.markLine.effect.period 运动周期，无单位，值越大越慢
 * @param {Object} options.rendererOptions.markLine.itemStyle 图形样式属性
 * @param {Number} options.rendererOptions.markLine.itemStyle.width 线宽
 * @param {Object} options.rendererOptions.markPoint 标注
 * @param {Boolean} options.rendererOptions.markPoint.hoverable 是否启用鼠标悬浮
 * @param {String} options.rendererOptions.markPoint.symbol 标注图形类型，可选为：'circle' | 'ring' | 'emptyCircle'
 * @param {Number} options.rendererOptions.markPoint.symbolMinSize 标注最小大小
 * @param {Number} options.rendererOptions.markPoint.symbolMaxSize 标注最大大小
 * @param {Object} options.rendererOptions.markPoint.effect 炫光特效
 * @param {Number} options.rendererOptions.markPoint.effect.scaleSize 放大倍数，以标注大小为基准
 * @param {Number} options.rendererOptions.markPoint.effect.period 运动周期，无单位，值越大越慢
 * @param {Object} options.rendererOptions.markPoint.gradientColor 标注颜色取值范围，并指定全局不透明度
 * @param {Object} options.rendererOptions.markPoint.itemStyle 图形样式属性
 * @param {String} options.rendererOptions.markPoint.itemStyle.color 颜色
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowColor 阴影颜色
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowBlur 阴影模糊度
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowOffsetX 阴影偏移量X
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowOffsetY 阴影偏移量Y
 * @param {Object} options.rendererOptions.markPoint.label 标签
 * @param {Boolean} options.rendererOptions.markPoint.label.show 标签是否显示
 * @param {String} options.rendererOptions.markPoint.label.color 颜色
 * @param {String} options.rendererOptions.markPoint.label.align 水平对齐方式，可选为：'start' | 'end' | 'left' | 'right' | 'center'
 * @param {String} options.rendererOptions.markPoint.label.baseline 垂直对齐方式，可选为：'top' | 'hanging' | 'middle' | 'alphabetic' | 'ideographic' | 'bottom'
 * @param {String} options.rendererOptions.markPoint.label.fontFamily 字体系列
 * @param {Number} options.rendererOptions.markPoint.label.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.markPoint.label.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.markPoint.label.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 * @param {Object} options.rendererOptions.tooltip 悬浮提示
 * @param {Boolean} options.rendererOptions.tooltip.show 是否显示悬浮提示框
 * @param {String} options.rendererOptions.tooltip.backgroundColor 背景颜色
 * @param {String} options.rendererOptions.tooltip.borderColor 边框颜色
 * @param {Number} options.rendererOptions.tooltip.borderRadius 边框圆角
 * @param {Number} options.rendererOptions.tooltip.borderWidth 边框宽度
 * @param {Number} options.rendererOptions.tooltip.padding 内边距
 * @param {Object} options.rendererOptions.tooltip.textStyle 文字样式
 * @param {String} options.rendererOptions.tooltip.textStyle.color 颜色
 * @param {String} options.rendererOptions.tooltip.textStyle.fontFamily 字体系列
 * @param {Number} options.rendererOptions.tooltip.textStyle.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.tooltip.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.tooltip.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 *
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //构造迁徙图层
 var migration = new GeoGlobe.Visuals.Custom.Migration({
    id: "migration_1",
    visibility: true,
    direction: "out",
    location: {
        name: "香港特别行政区",
        lonLat: [114.12694391453464, 22.380716926328258]
    },
    data: [{
        "type": "Feature",
        "properties": {name: "湖北省", value: 666},
        "geometry": {
            "type": "Point",
            "coordinates": [112.26577320468478, 30.98857642486671]
        }
    },{
        "type": "Feature",
        "properties": {name: "山东省", value: 299},
        "geometry": {
            "type": "Point",
            "coordinates": [118.15725615843111,36.354896713378366]
        }
    }],
    rendererOptions: {
        markLine: {
            hoverable: true,
            curveness: 0.6,
            effect: {
                color: '#fff',
                scaleSize: 3,
                period: 25
            },
            itemStyle: {
                width: 1
            }
        },
        markPoint: {
            symbol: "ring",
            symbolMinSize: 20,
            symbolMaxSize: 40,
            effect: {
                scaleSize: 3,
                period: 20
            },
            itemStyle: {
                color: {
                    "0": "rgba(58, 200, 0, 0.5)",
                    "0.5": "rgba(243, 255, 0, 0.5)",
                    "1": "rgba(255, 20, 0, 0.5)"
                }//"rgba(255,0,0,0.5)"
            },
            label: {
                show: false
            }
        }
    }
 });
 //添加到可视化定制图层
 migration.addTo(custom);
 //绘制
 custom.render();
 */
GeoGlobe.Visuals.Custom.Migration = GeoGlobe.Class4OL({

    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @type {Array}
     */
    canvas: [],

    /**
     * 离屏画布集合
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @type {Array}
     */
    cacheCanvas: [],

    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @type {Array}
     */
    canvasContext: [],

    /**
     * 离屏画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @type {Array}
     */
    cacheCanvasContext: [],

    /**
     * 标注类
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @type {Function}
     */
    MarkPoint: null,

    /**
     * 标线类
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @type {Function}
     */
    MarkLine: null,

    /**
     * 标注对象集
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @type {Array}
     */
    markPoints: [],

    /**
     * 标线对象集
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @type {Array}
     */
    markLines: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @private
     */
    _initContainer: function () {
        this.div = document.createElement("div");
        this.div.setAttribute("id", this.id);
        this.div.setAttribute("style", "position:absolute");
    },

    /**
     * 初始化渲染配置
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @private
     */
    _init_RendererOptions: function () {
        this._rendererOptions = GeoGlobe.Util.deepExtend({}, {
            markLine: {
                hoverable: true,
                curveness: 0.6,
                effect: {
                    color: '#fff',
                    scaleSize: 3,
                    period: 30
                },
                itemStyle: {
                    color: null,
                    width: 1
                }
            },
            markPoint: {
                hoverable: true,
                symbol: "emptyCircle",
                symbolMinSize: 20,
                symbolMaxSize: 40,
                effect: {
                    scaleSize: 2,
                    period: 30
                },
                itemStyle: {
                    color: "rgba(255,0,0,0.5)",
                    shadowColor: '#000000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                },
                label: {
                    show: true,
                    color: "#fff",
                    align: 'center',
                    baseline: 'middle',
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            },
            tooltip: {
                show: true,
                backgroundColor: '#fff',
                borderColor: '#333',
                borderRadius: 0,
                borderWidth: 0,
                padding: 10,
                textStyle: {
                    color: "#000",
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            }
        }, this.rendererOptions);
    },

    /**
     * 定义标注类
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @private
     */
    _initMarkPoint: function () {
        var _this = this;

        var symbol = this._rendererOptions.markPoint.symbol;
        var symbolMinSize = this._rendererOptions.markPoint.symbolMinSize;
        var symbolMaxSize = this._rendererOptions.markPoint.symbolMaxSize;
        var effect = this._rendererOptions.markPoint.effect;

        var itemStyle = this._rendererOptions.markPoint.itemStyle;
        if (typeof itemStyle.color === "object") {
            var gradientImageData = GeoGlobe.Util.getGradientImageData(itemStyle.color);
        }
        var label = this._rendererOptions.markPoint.label;

        /**
         * 构造一个标注实例
         * @param {Number} index 索引号
         * @param {String} name 字段名
         * @param {Number} value 统计值
         * @param {Number} lon 经度
         * @param {Number} lat 纬度
         */
        this.MarkPoint = function (index, name, value, lon, lat) {
            this.index = index;
            this.name = name;
            this.value = value;
            this.lon = lon;
            this.lat = lat;
            this.init();

            this.weight = (this.value - _this.minValue) / (_this.maxValue - _this.minValue);
            if (isNaN(this.weight)) this.weight = 1;
            if (this.weight > 1) this.weight = 1;
            if (this.weight < 0) this.weight = 0;
            this.size = symbolMinSize + (symbolMaxSize - symbolMinSize) * this.weight;
            this.radius = this.size / 2;

            this.color = typeof itemStyle.color === "object" ? 'rgba(' + gradientImageData[parseInt(this.weight * 255, 10) * 4] + ',' + gradientImageData[parseInt(this.weight * 255, 10) * 4 + 1] + ',' + gradientImageData[parseInt(this.weight * 255, 10) * 4 + 2] + ',' + gradientImageData[3] / 255 + ')' : itemStyle.color;
            this.rgbColor = GeoGlobe.Util.getRgbColor(this.color);
            this.tmpColor = this.color;
        };

        /**
         * 初始化
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         */
        this.MarkPoint.prototype.init = function () {
            switch (symbol) {
                case "circle":
                    this.energy = [0, 1 / 3, 2 / 3];
                    break;
                case "ring":
                    this.energy = [0, 1 / 4 * effect.scaleSize, 2 / 4 * effect.scaleSize, 3 / 4 * effect.scaleSize];
                    break;
                case "emptyCircle":
                    this.energy = 0;
                    break;
            }
            this.increment = Math.max(0.1 * effect.scaleSize / effect.period + Math.random() * (Math.random() > 0.5 ? 1 : -1) * 0.002, 0.001);
        };

        /**
         * 重新计算标注的位置
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         */
        this.MarkPoint.prototype.updateXY = function () {
            var point = _this._parent.map.project([this.lon, this.lat]);
            this.x = point.x;
            this.y = point.y;
        };

        /**
         * 更新标注的大小
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         */
        this.MarkPoint.prototype.update = function () {
            var i;
            switch (symbol) {
                case "circle":
                    for (i = 0; i < 3; i++) {
                        if (this.energy[i] < 1) {
                            this.energy[i] += this.increment;
                        } else {
                            this.energy[i] = 0;
                        }
                    }
                    break;
                case "ring":
                    for (i = 0; i < 4; i++) {
                        if (this.energy[i] < effect.scaleSize) {
                            this.energy[i] += this.increment;
                        } else {
                            this.energy[i] = 0;
                        }
                    }
                    break;
                case "emptyCircle":
                    if (this.energy < effect.scaleSize) {
                        this.energy += this.increment;
                    } else {
                        this.energy = 0;
                    }
                    break;
            }
        };

        /**
         * 判断鼠标是否悬浮在路径上
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkPoint.prototype.isPointInPath = function (context, x, y) {
            context.beginPath();
            context.arc(this.x, this.y, this.size / 2, 0, Math.PI * 2, true);
            if (context.isPointInPath(x, y)) {
                _this.hoveredMarkPoint = this;
            }
        };

        /**
         * 将标注静态部分绘制到离屏画布1
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkPoint.prototype.draw1 = function (context) {
            if (_this.hoveredMarkPoint === this) {
                this.radius = this.size / 2 * 1.1;
                this.color = GeoGlobe.Util.getShadeColor(this.tmpColor, 20);
                this.rgbColor = GeoGlobe.Util.getRgbColor(this.color);
            } else {
                this.radius = this.size / 2;
                this.color = this.tmpColor;
                this.rgbColor = GeoGlobe.Util.getRgbColor(this.color);
            }

            context.shadowColor = itemStyle.shadowColor;
            context.shadowBlur = itemStyle.shadowBlur;
            context.shadowOffsetX = itemStyle.shadowOffsetX;
            context.shadowOffsetY = itemStyle.shadowOffsetY;
            switch (symbol) {
                case "circle":
                    context.beginPath();
                    context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
                    context.fillStyle = this.color;
                    context.fill();
                    break;
                case "ring":
                    break;
                case "emptyCircle":
                    if (_this.hoveredMarkPoint === this) {
                        context.beginPath();
                        context.arc(this.x, this.y, this.radius * effect.scaleSize / 2, 0, Math.PI * 2, true);
                        context.lineWidth = Math.round(this.radius / 5) < 2 ? 2 : Math.round(this.radius / 5);
                        context.strokeStyle = this.color;
                        context.stroke();
                    }
                    break;
            }
        };

        /**
         * 将标注动画部分、中心数字绘制到离屏画布3
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkPoint.prototype.draw2 = function (context) {
            this.update();

            var i;
            switch (symbol) {
                case "circle":
                    i = 0;
                    while (i < 3) {
                        context.beginPath();
                        context.arc(this.x, this.y, this.radius + this.radius * (effect.scaleSize - 1) * this.energy[i], 0, Math.PI * 2, true);
                        context.strokeStyle = 'rgba' + this.rgbColor.slice(3).split(')')[0] + ',' + (1 - this.energy[i]) + ')';
                        context.stroke();
                        i++;
                    }
                    break;
                case "ring":
                    i = 0;
                    while (i < 4) {
                        context.beginPath();
                        context.arc(this.x, this.y, this.radius * this.energy[i], 0, Math.PI * 2, true);
                        context.fillStyle = 'rgba' + this.rgbColor.slice(3).split(')')[0] + ',' + Math.max(1 - this.energy[i] / effect.scaleSize, 0) + ')';
                        context.fill();
                        i++;
                    }
                    break;
                case "emptyCircle":
                    context.beginPath();
                    context.arc(this.x, this.y, this.radius * this.energy, 0, Math.PI * 2, true);
                    context.strokeStyle = this.color;
                    context.stroke();
                    break;
            }

            //绘制到离屏画布3以防被遮挡
            if (label.show) {
                context.font = label.fontStyle + ' ' + label.fontWeight + ' ' + label.fontSize + 'px ' + label.fontFamily;
                context.textAlign = label.align;
                context.textBaseline = label.baseline;
                context.fillStyle = label.color ? label.color : this.color;
                context.fillText(this.value, this.x, this.y);
            }
        };
    },

    /**
     * 定义标线类
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @private
     */
    _initMarkLine: function () {
        var _this = this;

        var effect = this._rendererOptions.markLine.effect;
        var itemStyle = this._rendererOptions.markLine.itemStyle;

        /**
         * 构造一个标线实例
         * @param {Number} index 索引号
         * @param {Object} start 起点
         * @param {Object} end 终点
         */
        this.MarkLine = function (index, start, end) {
            var self = this;

            this.index = index;
            this.start = start;
            this.end = end;
            this.color = itemStyle.color ? itemStyle.color : _this.direction === 'out' ? end.color : start.color;
            this.width = itemStyle.width;

            //炫光特效对象
            this.effect = {
                radius: itemStyle.width * effect.scaleSize / 2,
                color: effect.color,
                increment: 0.1 / effect.period,//每帧移动的距离百分比
                init: function () {
                    this.energy = 0;
                },
                update: function () {
                    if (this.energy < 1) {
                        this.energy += this.increment;

                        if (_this._rendererOptions.markLine.curveness !== 0) {
                            //二次贝塞尔曲线公式：B(t)=(1 - t)^2 * P1 + 2t * (1 - t) * CP + t^2 * P2,t∈[0,1]
                            this.x = Math.pow(1 - this.energy, 2) * self.p1.x + 2 * this.energy * (1 - this.energy) * self.cp.x + Math.pow(this.energy, 2) * self.p2.x;
                            this.y = Math.pow(1 - this.energy, 2) * self.p1.y + 2 * this.energy * (1 - this.energy) * self.cp.y + Math.pow(this.energy, 2) * self.p2.y;
                        } else {
                            this.x = self.p1.x + this.energy * (self.p2.x - self.p1.x);
                            this.y = self.p1.y + this.energy * (self.p2.y - self.p1.y);
                        }
                    } else {
                        this.init();
                    }
                },
                draw: function (context) {
                    this.update();
                    context.beginPath();
                    context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
                    context.fillStyle = this.color;
                    context.fill();
                    context.closePath();
                }
            };
        };

        /**
         * 更新起点、终点和控制点的位置
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         */
        this.MarkLine.prototype.updateXY = function () {
            this.p1 = _this._parent.map.project([this.start.lon, this.start.lat]);
            this.p2 = _this._parent.map.project([this.end.lon, this.end.lat]);

            if (_this._rendererOptions.markLine.curveness !== 0) {
                this.getControlPoint();
            }
        };

        /**
         * 求控制点，设定：两条切线（与起点终点连线的夹角都为angle）的交点，弧向顺时针
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         */
        this.MarkLine.prototype.getControlPoint = function () {
            var angle = _this._rendererOptions.markLine.curveness / 2;

            //起点到终点的距离
            var DISTANCE_TO_P2 = Math.sqrt(Math.pow(this.p1.x - this.p2.x, 2) + Math.pow(this.p1.y - this.p2.y, 2));
            //起点到控制点的距离
            var DISTANCE_TO_CP = DISTANCE_TO_P2 / 2 / Math.cos(angle);

            //起点到终点顺时针方向的角度
            var rotate;
            if (this.p1.x === this.p2.x) {
                if (this.p1.y > this.p2.y) {
                    rotate = 0;
                    this.cp = {
                        x: this.p1.x - Math.round(DISTANCE_TO_CP * Math.sin(angle)),
                        y: this.p1.y - Math.round(DISTANCE_TO_CP * Math.cos(angle))
                    };
                } else if (this.p1.y === this.p2.y) {
                    //todo 起点和终点相同
                    this.cp = {
                        x: this.p1.x,
                        y: this.p1.y
                    };
                } else {
                    rotate = Math.PI;
                    this.cp = {
                        x: this.p1.x + Math.round(DISTANCE_TO_CP * Math.sin(angle)),
                        y: this.p1.y + Math.round(DISTANCE_TO_CP * Math.cos(angle))
                    };
                }
            } else if (this.p1.x < this.p2.x) {
                if (this.p1.y > this.p2.y) {
                    rotate = Math.asin((this.p2.x - this.p1.x) / DISTANCE_TO_P2);
                    if (rotate < angle) {
                        this.cp = {
                            x: this.p1.x - Math.round(DISTANCE_TO_CP * Math.sin(angle - rotate)),
                            y: this.p1.y - Math.round(DISTANCE_TO_CP * Math.cos(angle - rotate))
                        };
                    } else if (rotate === angle) {
                        this.cp = {
                            x: this.p1.x,//this.p1.x + Math.round(DISTANCE_TO_CP * Math.sin(0))
                            y: this.p1.y - DISTANCE_TO_CP//this.p1.x - Math.round(DISTANCE_TO_CP * Math.cos(0))
                        };
                    } else {
                        this.cp = {
                            x: this.p1.x + Math.round(DISTANCE_TO_CP * Math.sin(rotate - angle)),
                            y: this.p1.y - Math.round(DISTANCE_TO_CP * Math.cos(rotate - angle))
                        };
                    }
                } else if (this.p1.y === this.p2.y) {
                    rotate = Math.PI / 2;
                    this.cp = {
                        x: this.p1.x + Math.round(DISTANCE_TO_CP * Math.cos(angle)),
                        y: this.p1.y - Math.round(DISTANCE_TO_CP * Math.sin(angle))
                    };
                } else {
                    rotate = Math.PI - Math.asin((this.p2.x - this.p1.x) / DISTANCE_TO_P2);
                    if (rotate < Math.PI / 2 + angle) {
                        this.cp = {
                            x: this.p1.x + Math.round(DISTANCE_TO_CP * Math.cos(angle - (rotate - Math.PI / 2))),
                            y: this.p1.y - Math.round(DISTANCE_TO_CP * Math.sin(angle - (rotate - Math.PI / 2)))
                        };
                    } else if (rotate === Math.PI / 2 + angle) {
                        this.cp = {
                            x: this.p1.x + DISTANCE_TO_CP,
                            y: this.p1.y
                        };
                    } else {
                        this.cp = {
                            x: this.p1.x + Math.round(DISTANCE_TO_CP * Math.cos((rotate - Math.PI / 2) - angle)),
                            y: this.p1.y + Math.round(DISTANCE_TO_CP * Math.sin((rotate - Math.PI / 2) - angle))
                        };
                    }
                }
            } else {
                if (this.p1.y < this.p2.y) {
                    rotate = Math.PI + Math.asin((this.p1.x - this.p2.x) / DISTANCE_TO_P2);
                    if (rotate < Math.PI + angle) {
                        this.cp = {
                            x: this.p1.x + Math.round(DISTANCE_TO_CP * Math.sin(angle - (rotate - Math.PI))),
                            y: this.p1.y + Math.round(DISTANCE_TO_CP * Math.cos(angle - (rotate - Math.PI)))
                        };
                    } else if (rotate === Math.PI + angle) {
                        this.cp = {
                            x: this.p1.x,
                            y: this.p1.y + DISTANCE_TO_CP
                        };
                    } else {
                        this.cp = {
                            x: this.p1.x - Math.round(DISTANCE_TO_CP * Math.sin((rotate - Math.PI) - angle)),
                            y: this.p1.y + Math.round(DISTANCE_TO_CP * Math.cos((rotate - Math.PI) - angle))
                        };
                    }
                } else if (this.p1.y === this.p2.y) {
                    rotate = Math.PI * 3 / 2;
                    this.cp = {
                        x: this.p1.x - Math.round(DISTANCE_TO_CP * Math.cos(angle)),
                        y: this.p1.y + Math.round(DISTANCE_TO_CP * Math.sin(angle))
                    };
                } else {
                    rotate = Math.PI * 3 / 2 + Math.acos((this.p1.x - this.p2.x) / DISTANCE_TO_P2);
                    if (rotate < Math.PI * 3 / 2 + angle) {
                        this.cp = {
                            x: this.p1.x - Math.round(DISTANCE_TO_CP * Math.cos(angle - (rotate - Math.PI * 3 / 2))),
                            y: this.p1.y + Math.round(DISTANCE_TO_CP * Math.sin(angle - (rotate - Math.PI * 3 / 2)))
                        };
                    } else if (rotate === Math.PI * 3 / 2 + angle) {
                        this.cp = {
                            x: this.p1.x - DISTANCE_TO_CP,
                            y: this.p1.y
                        };
                    } else {
                        this.cp = {
                            x: this.p1.x - Math.round(DISTANCE_TO_CP * Math.cos((rotate - Math.PI * 3 / 2) - angle)),
                            y: this.p1.y - Math.round(DISTANCE_TO_CP * Math.sin((rotate - Math.PI * 3 / 2) - angle))
                        };
                    }
                }
            }
        };

        /**
         * 判断鼠标是否悬浮在路线上
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkLine.prototype.isPointInStroke = function (context, x, y) {
            context.beginPath();
            context.moveTo(this.p1.x, this.p1.y);
            if (_this._rendererOptions.markLine.curveness !== 0) {
                context.quadraticCurveTo(this.cp.x, this.cp.y, this.p2.x, this.p2.y);
            } else {
                context.lineTo(this.p2.x, this.p2.y);
            }
            if (context.isPointInStroke(x, y)) {
                _this.hoveredMarkLine = this;
            }
        };

        /**
         * 绘制标线
         * @memberof GeoGlobe.Visuals.Custom.Migration.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkLine.prototype.draw = function (context) {
            if (_this.hoveredMarkLine === this) {
                this.color = GeoGlobe.Util.getShadeColor(itemStyle.color ? itemStyle.color : _this.direction === 'out' ? this.end.color : this.start.color, 20);
                this.width = itemStyle.width * 1.1;
            } else {
                this.color = itemStyle.color ? itemStyle.color : _this.direction === 'out' ? this.end.color : this.start.color;
                this.width = itemStyle.width;
            }

            context.beginPath();
            context.moveTo(this.p1.x, this.p1.y);
            if (_this._rendererOptions.markLine.curveness !== 0) {
                context.quadraticCurveTo(this.cp.x, this.cp.y, this.p2.x, this.p2.y);
            } else {
                context.lineTo(this.p2.x, this.p2.y);
            }
            context.lineWidth = this.width;
            context.strokeStyle = this.color;
            context.stroke();
        }
    },

    /**
     * 画布初始化
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @private
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvas.push(document.createElement('canvas'));
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));
        this.canvasContext.push(this.canvas[1].getContext("2d"));
        this.canvasContext.push(this.canvas[2].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));
        this.cacheCanvasContext.push(this.cacheCanvas[1].getContext("2d"));
        this.cacheCanvasContext.push(this.cacheCanvas[2].getContext("2d"));

        this.canvas[0].style.position = "absolute";
        this.canvas[1].style.position = "absolute";
        this.canvas[2].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);
        this.div.appendChild(this.canvas[1]);
        this.div.appendChild(this.canvas[2]);
        this.setVisible(this.visibility);
    },

    /**
     * 悬浮提示框初始化
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @private
     */
    _initTooltip: function () {
        if ((this._rendererOptions.markLine.hoverable || this._rendererOptions.markPoint.hoverable) && this._rendererOptions.tooltip.show) {
            this.tooltipDiv = this.tooltipDiv || this.div.appendChild(document.createElement('div'));
            this.tooltipDiv.style.position = "relative";
            this.tooltipDiv.style.display = "none";
            this.tooltipDiv.style.zIndex = 999;
            this.tooltipDiv.style.color = this._rendererOptions.tooltip.textStyle.color;
            this.tooltipDiv.style.padding = this._rendererOptions.tooltip.padding + "px";
            this.tooltipDiv.style.font = this._rendererOptions.tooltip.textStyle.fontStyle + ' ' + this._rendererOptions.tooltip.textStyle.fontWeight + ' ' + this._rendererOptions.tooltip.textStyle.fontSize + 'px ' + this._rendererOptions.tooltip.textStyle.fontFamily;

            //(IE8-)不兼容rgba问题处理
            if (document.createElement('canvas').getContext) {
                this.tooltipDiv.style["background-color"] = this._rendererOptions.tooltip.backgroundColor;
            } else {
                this.tooltipDiv.style["background-color"] = GeoGlobe.Util.getRgbColor(this._rendererOptions.tooltip.backgroundColor);
            }

            this.tooltipDiv.style["border-width"] = this._rendererOptions.tooltip.borderWidth + "px";
            this.tooltipDiv.style["border-color"] = this._rendererOptions.tooltip.borderColor;
            this.tooltipDiv.style["border-radius"] = this._rendererOptions.tooltip.borderRadius + "px";
            this.tooltipDiv.style["border-style"] = "solid";
            this.tooltipDiv.style['white-space'] = "nowrap";
            this.tooltipDiv.style["box-shadow"] = "rgba(0, 0, 0, 0.2) 0px 10px 10px";
            this.tooltipDiv.style["transition"] = "left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)";
        }
    },

    /**
     * 渲染图层
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    render: function () {
        this._init_RendererOptions();
        this._initMarkPoint();
        this._initMarkLine();
        this._initTooltip();
        this.setData(this.data);
        this.draw();
    },

    /**
     * 图层绘制
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    draw: function () {
        this.updateXY();
        this.drawCanvas1();

        //动画
        this.animation = true;
        this.frame && cancelAnimationFrame(this.frame);
        var _this = this;
        (function animate() {
            _this.frame = requestAnimationFrame(animate);
            _this.animation && _this.drawCanvas2();
            _this.animation && _this.drawCanvas3();
            _this.animation = true;
        })();
    },

    /**
     * 图层（地图）移动时触发
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    onMove: function () {
        this.cacheCanvas[1].width = this.cacheCanvas[2].width = this.width;//清除残影
        this.animation = false;
        this.updateXY();
        this.drawCanvas1();
        this.drawCanvas2();
        this.drawCanvas3();
    },

    /**
     * 图层（地图）移动结束触发
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    onMoveEnd: function () {
        this.redraw();
    },

    /**
     * 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @param {Object} event 事件参数
     */
    onMouseMove: function (event) {
        if ((this._rendererOptions.markLine.hoverable || this._rendererOptions.markPoint.hoverable) && this.visibility && this.markPoints.length > 0 && !this._parent.map.moving) {
            this.hover(event.point.x, event.point.y);

            this.hoveredMarkPoint && this._parent.fire("overlayerhover", {
                layer: this,
                feature: this.hoveredMarkPoint,
                event: event
            });
        }
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    onResize: function () {
        this.canvas[0].width = this.canvas[1].width = this.canvas[2].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.cacheCanvas[2].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.canvas[1].height = this.canvas[2].height = this.cacheCanvas[0].height = this.cacheCanvas[1].height = this.cacheCanvas[2].height = this.height = this._parent.map.transform.height;
        this.redraw();
    },

    /**
     * 图层重绘
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    redraw: function () {
        this.clearCanvas();

        this.updateXY();
        this.drawCanvas1();
        this.drawCanvas2();
        this.drawCanvas3();
    },

    /**
     * 重新计算标线、标注的屏幕坐标
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    updateXY: function () {
        var i = this.markPoints.length;
        while (i--) {
            this.markPoints[i].updateXY();
            this.markLines[i].updateXY();
        }
    },

    /**
     * 将标线、标注静态部分绘制到画布1
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    drawCanvas1: function () {
        this.cacheCanvas[0].width = this.width;

        var i = this.markLines.length;
        while (i--) {
            this.markLines[i].draw(this.cacheCanvasContext[0]);
        }

        i = this.markPoints.length;
        while (i--) {
            this.markPoints[i].draw1(this.cacheCanvasContext[0]);
        }

        this.canvas[0].width = this.width;
        this.canvasContext[0].drawImage(this.cacheCanvas[0], 0, 0);
    },

    /**
     * 将标线动画部分绘制到画布2
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    drawCanvas2: function () {
        if (document.createElement('canvas').getContext) {
            this.cacheCanvasContext[1].globalCompositeOperation = 'destination-out';
            this.cacheCanvasContext[1].fillStyle = 'rgba(0, 0, 0, 0.05)';
            this.cacheCanvasContext[1].fillRect(0, 0, this.width, this.height);
            this.cacheCanvasContext[1].globalCompositeOperation = 'source-over';//lighter
        } else {
            this.cacheCanvas[1].width = this.width;
        }
        this.cacheCanvasContext[1].save();

        var i = this.markLines.length;
        while (i--) {
            this.markLines[i].effect.draw(this.cacheCanvasContext[1]);
        }

        this.cacheCanvasContext[1].restore();

        this.canvas[1].width = this.width;
        this.canvasContext[1].drawImage(this.cacheCanvas[1], 0, 0);
    },

    /**
     * 将标注动画部分绘制到画布3
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    drawCanvas3: function () {
        if (this._rendererOptions.markPoint.symbol === "emptyCircle") {
            if (document.createElement('canvas').getContext) {
                this.cacheCanvasContext[2].globalCompositeOperation = 'destination-out';
                this.cacheCanvasContext[2].fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.cacheCanvasContext[2].fillRect(0, 0, this.width, this.height);
                this.cacheCanvasContext[2].globalCompositeOperation = 'source-over';//lighter
            } else {
                this.cacheCanvas[2].width = this.width;
            }
        } else if (this._rendererOptions.markPoint.symbol === "ring") {
            this.cacheCanvas[2].width = this.width;
            this.cacheCanvasContext[2].globalCompositeOperation = 'lighter';
        } else {
            this.cacheCanvas[2].width = this.width;
        }
        this.cacheCanvasContext[2].save();

        var i = this.markPoints.length;
        while (i--) {
            this.markPoints[i].draw2(this.cacheCanvasContext[2]);
        }

        this.cacheCanvasContext[2].restore();

        this.canvas[2].width = this.width;
        this.canvasContext[2].drawImage(this.cacheCanvas[2], 0, 0);
    },

    /**
     * 画布清空
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    clearCanvas: function () {
        this.canvas[0].width = this.canvas[1].width = this.canvas[2].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.cacheCanvas[2].width = this.width;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    destroy: function () {
        //先停动画，再移Dom，再重置属性
        cancelAnimationFrame(this.frame);

        this._parent.container.removeChild(this.div);

        this.MarkPoint = null;
        this.markPoints = [];
        this.canvas = [];
        this.data = [];
        this.cacheCanvas = [];
        this.canvasContext = [];
        this.cacheCanvasContext = [];
        this._rendererOptions = {};
    },

    /**
     * 鼠标悬浮时触发
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @param {Number} x 鼠标在主画布上的位置（x轴方向）
     * @param {Number} y 鼠标在主画布上的位置（y轴方向）
     */
    hover: function (x, y) {
        this.hoveredMarkLine = null;
        this.lastHoveredMarkPoint = this.hoveredMarkPoint ? GeoGlobe.Util.clone(this.hoveredMarkPoint) : null;
        this.hoveredMarkPoint = null;

        var i, len;
        for (i = 0, len = this.markLines.length; i < len; i++) {
            !this.hoveredMarkLine && this.markLines[i].isPointInStroke(this.cacheCanvasContext[0], x, y);
        }
        for (i = 0, len = this.markPoints.length; i < len; i++) {
            !this.hoveredMarkPoint && this.markPoints[i].isPointInPath(this.cacheCanvasContext[0], x, y);
        }

        this.drawCanvas1();

        //显示悬浮提示框
        if (this.hoveredMarkLine || this.hoveredMarkPoint) {
            this.showTooltip(this.hoveredMarkLine ? this.hoveredMarkLine.start.name + ' > ' + this.hoveredMarkLine.end.name : this.hoveredMarkPoint.name, x, y);
            this.canvas[2].style.cursor = "pointer";
        } else {
            this.hideTooltip();
            this.canvas[2].style.cursor = "default";
        }
    },

    /**
     * 显示悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @param {String} text 要提示的文本
     * @param {Number} x 鼠标在画布上的位置（x轴方向）
     * @param {Number} y 鼠标在画布上的位置（y轴方向）
     * @ignore
     */
    showTooltip: function (text, x, y) {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.textContent = text;
            this.tooltipDiv.style.top = (y - 15) + "px";
            this.tooltipDiv.style.left = (x + 15) + "px";
            this.tooltipDiv.style.display = "block";
        }
    },

    /**
     * 关闭悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     */
    hideTooltip: function () {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.style.display = "none";
        }
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.canvas[1].width = this.canvas[2].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.cacheCanvas[2].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.canvas[1].height = this.canvas[2].height = this.cacheCanvas[0].height = this.cacheCanvas[1].height = this.cacheCanvas[2].height = this.height = this._parent.map.transform.height;
    },

    /**
     * 图层的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = this.canvas[1].style.display = this.canvas[2].style.display = visibility ? "block" : "none";
    },

    /**
     * 数据的处理，构造标注、标线对象
     * @memberof GeoGlobe.Visuals.Custom.Migration.prototype
     * @param {Array} data 数据
     */
    setData: function (data) {
        this.data = data;

        // 求极值
        this.minValue = Number.MAX_VALUE;
        this.maxValue = Number.MIN_VALUE;
        for (var i = 0; i < data.length; i++) {
            if (data[i].properties.value < this.minValue) this.minValue = data[i].properties.value;
            if (data[i].properties.value > this.maxValue) this.maxValue = data[i].properties.value;
        }

        var locationMarkPoint = new this.MarkPoint(undefined, this.location.name, 0, this.location.lonLat[0], this.location.lonLat[1]);

        var markPoints = [];
        var markLines = [];
        for (var i = 0; i < data.length; i++) {
            markPoints.push(new this.MarkPoint(i, data[i].properties.name, data[i].properties.value, data[i].geometry.coordinates[0], data[i].geometry.coordinates[1]));
            markLines.push(this.direction === 'out' ? new this.MarkLine(i, locationMarkPoint, markPoints[i]) : new this.MarkLine(i, markPoints[i], locationMarkPoint));
        }
        this.hoveredMarkPoint = null;
        this.hoveredMarkLine = null;
        this.markPoints = markPoints;
        this.markLines = markLines;
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Custom.Commute
 * @classdesc 通勤图层
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.data 数据，geojson格式
 * @param {Object} options.rendererOptions 渲染配置
 * @param {Object} options.rendererOptions.markLine 标线
 * @param {Object} options.rendererOptions.markLine.effect 散点特效
 * @param {String} options.rendererOptions.markLine.effect.color 散点颜色
 * @param {Number} options.rendererOptions.markLine.effect.scaleSize 缩放倍数，以标线宽度为基准
 * @param {Number} options.rendererOptions.markLine.effect.period 运动周期，无单位，值越大越慢
 * @param {Object} options.rendererOptions.markLine.itemStyle 图形样式属性
 * @param {String} options.rendererOptions.markLine.itemStyle.color 颜色
 * @param {Number} options.rendererOptions.markLine.itemStyle.width 线宽
 * @param {Object} options.rendererOptions.markPoint 标注
 * @param {Boolean} options.rendererOptions.markPoint.hoverable 是否启用鼠标悬浮
 * @param {Number} options.rendererOptions.markPoint.symbolSize 标注大小
 * @param {Object} options.rendererOptions.markPoint.effect 炫光特效
 * @param {Number} options.rendererOptions.markPoint.effect.scaleSize 缩放倍数，以标注大小为基准
 * @param {Number} options.rendererOptions.markPoint.effect.period 运动周期，无单位，值越大越慢
 * @param {Object} options.rendererOptions.markPoint.itemStyle 图形样式属性
 * @param {String} options.rendererOptions.markPoint.itemStyle.color 颜色
 * @param {Object} options.rendererOptions.tooltip 悬浮提示
 * @param {Boolean} options.rendererOptions.tooltip.show 是否显示悬浮提示框
 * @param {String} options.rendererOptions.tooltip.backgroundColor 背景颜色
 * @param {String} options.rendererOptions.tooltip.borderColor 边框颜色
 * @param {Number} options.rendererOptions.tooltip.borderRadius 边框圆角
 * @param {Number} options.rendererOptions.tooltip.borderWidth 边框宽度
 * @param {Number} options.rendererOptions.tooltip.padding 内边距
 * @param {Object} options.rendererOptions.tooltip.textStyle 文字样式
 * @param {String} options.rendererOptions.tooltip.textStyle.color 颜色
 * @param {String} options.rendererOptions.tooltip.textStyle.fontFamily 字体系列
 * @param {Number} options.rendererOptions.tooltip.textStyle.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.tooltip.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.tooltip.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 *
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //通过jquery加载json数据
 $.getJSON('../../data/jinling.json', function (result) {
    //构造通勤图层
    var commute = new GeoGlobe.Visuals.Custom.Commute({
        id: "commute_1",
        visibility: true,
        data: result,
        rendererOptions: {
            markLine: {
                effect: {
                    color: 'rgba(255,255,255,0.7)',
                    scaleSize: 60,
                    period: 15
                },
                itemStyle: {
                    color: 'rgba(255,58,53,0.9)',
                    width: 0.1
                }
            },
            markPoint: {
                symbolSize: 30,
                effect: {
                    scaleSize: 2,
                    period: 15
                },
                itemStyle: {
                    color: 'rgba(255,255,255,0.7)'
                }
            }
        }
    });
    //添加到可视化定制图层
    commute.addTo(custom);
    //绘制
    custom.render();
 });
 */
GeoGlobe.Visuals.Custom.Commute = GeoGlobe.Class4OL({

    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @type {Array}
     */
    canvas: [],

    /**
     * 离屏画布集合
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @type {Array}
     */
    cacheCanvas: [],

    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @type {Array}
     */
    canvasContext: [],

    /**
     * 离屏画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @type {Array}
     */
    cacheCanvasContext: [],

    /**
     * 标注类
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @type {Function}
     */
    MarkPoint: null,

    /**
     * 标线类
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @type {Function}
     */
    MarkLine: null,

    /**
     * 标注对象集
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @type {Array}
     */
    markPoints: [],

    /**
     * 标线对象集
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @type {Object}
     */
    markLines: {items: [], option: {}},

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @private
     */
    _initContainer: function () {
        this.div = document.createElement("div");
        this.div.setAttribute("id", this.id);
        this.div.setAttribute("style", "position:absolute");
    },

    /**
     * 初始化渲染配置
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @private
     */
    _init_RendererOptions: function () {
        this._rendererOptions = GeoGlobe.Util.deepExtend({}, {
            markLine: {
                effect: {
                    color: 'rgba(255,255,255,0.7)',
                    scaleSize: 60,
                    period: 15
                },
                itemStyle: {
                    color: 'rgba(255,58,53,0.9)',
                    width: 0.1
                }
            },
            markPoint: {
                hoverable: true,
                symbolSize: 30,
                effect: {
                    scaleSize: 2,
                    period: 15
                },
                itemStyle: {
                    color: 'rgba(255,255,255,0.7)'
                }
            },
            tooltip: {
                show: true,
                backgroundColor: '#fff',
                borderColor: '#333',
                borderRadius: 0,
                borderWidth: 0,
                padding: 10,
                textStyle: {
                    color: "#000",
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            }
        }, this.rendererOptions);
    },

    /**
     * 定义标注类
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @private
     */
    _initMarkPoint: function () {
        var _this = this;

        var symbolSize = this._rendererOptions.markPoint.symbolSize;
        var effect = this._rendererOptions.markPoint.effect;
        var itemStyle = this._rendererOptions.markPoint.itemStyle;

        /**
         * 构造一个标注实例
         * @param {Number} index 索引号
         * @param {String} name 字段名
         * @param {Number} lon 经度
         * @param {Number} lat 纬度
         */
        this.MarkPoint = function (index, name, lon, lat) {
            this.index = index;
            this.name = name;
            this.lon = lon;
            this.lat = lat;
            this.init();
            this.radius = symbolSize / 2;
            this.color = itemStyle.color;
            this.rgbColor = GeoGlobe.Util.getRgbColor(itemStyle.color);
        };

        /**
         * 初始化
         * @memberof GeoGlobe.Visuals.Custom.Commute.MarkPoint.prototype
         */
        this.MarkPoint.prototype.init = function () {
            this.energy = 0;
            this.increment = 0.1 * effect.scaleSize / effect.period + Math.random() * (Math.random() > 0.5 ? 1 : -1) * 0.002;
        };

        /**
         * 重新计算标注的位置
         * @memberof GeoGlobe.Visuals.Custom.Commute.MarkPoint.prototype
         */
        this.MarkPoint.prototype.updateXY = function () {
            var point = _this._parent.map.project([this.lon, this.lat]);
            this.x = point.x;
            this.y = point.y;
        };

        /**
         * 更新标注的大小
         * @memberof GeoGlobe.Visuals.Custom.Commute.MarkPoint.prototype
         */
        this.MarkPoint.prototype.update = function () {
            if (this.energy < effect.scaleSize) {
                this.energy += this.increment;
            } else {
                this.energy = 0;
            }
        };

        /**
         * 判断鼠标是否悬浮在路径上
         * @memberof GeoGlobe.Visuals.Custom.Commute.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkPoint.prototype.isPointInPath = function (context, x, y) {
            context.beginPath();
            context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
            if (context.isPointInPath(x, y)) {
                _this.hoveredMarkPoint = this;
            }
        };

        /**
         * 绘制
         * @memberof GeoGlobe.Visuals.Custom.Commute.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkPoint.prototype.draw = function (context) {
            this.update();

            context.beginPath();
            context.arc(this.x, this.y, this.radius * this.energy, 0, Math.PI * 2, true);
            context.globalAlpha = 1;
            context.strokeStyle = this.color;
            context.stroke();

            if (_this.hoveredMarkPoint === this) {
                context.beginPath();
                context.arc(this.x, this.y, this.radius * effect.scaleSize / 2, 0, Math.PI * 2, true);
                context.lineWidth = Math.round(this.radius / 5) < 2 ? 2 : Math.round(this.radius / 5);
                context.strokeStyle = this.color;
                context.globalAlpha = 0.1;
                context.stroke();
            }
        }
    },

    /**
     * 定义标线类
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    _initMarkLine: function () {
        var _this = this;

        var effect = this._rendererOptions.markLine.effect;
        var itemStyle = this._rendererOptions.markLine.itemStyle;

        /**
         * 构造一个标线实例
         * @param {Number} index 索引号
         * @param {Array} points 构成线条的点集合
         */
        this.MarkLine = function (index, points) {
            this.index = index;
            this.points = points;

            //部分线条才有点动画特效
            if (index < ~~(_this.markLines.option.linesNumber / 10)) {
                var markLine = this;
                this.effect = {
                    radius: itemStyle.width * effect.scaleSize / 2,
                    color: effect.color,
                    pointIndex: ~~(Math.random() * this.points.length),//随机选择线条上的一个点绘制动画特效
                    update: function () {
                        if (_this.markLines.option.factor === 1) {
                            this.pointIndex += _this.markLines.option.lineIncrement + 0.1;
                            this.pointIndex > markLine.points.length - 1 && (this.pointIndex = 0);
                        } else {
                            this.pointIndex -= _this.markLines.option.lineIncrement - 0.1;
                            this.pointIndex < 0 && (this.pointIndex = markLine.points.length - 1);
                        }

                        this.pointIndex = Math.round(this.pointIndex);
                    },
                    draw: function (context) {
                        this.update();

                        context.beginPath();
                        if (index < ~~(_this.markLines.option.linesNumber / 200)) {
                            context.arc(markLine.points[this.pointIndex].x, markLine.points[this.pointIndex].y, this.radius, 0, Math.PI * 2, true);
                        } else {
                            context.rect(markLine.points[this.pointIndex].x - 1, markLine.points[this.pointIndex].y - 1, 2, 2);
                        }
                        context.fillStyle = this.color;
                        context.fill();
                    }
                };
            }
        };

        /**
         * 更新点的位置
         * @memberof GeoGlobe.Visuals.Custom.Commute.MarkLine.prototype
         */
        this.MarkLine.prototype.updateXY = function () {
            for (var i = 0; i < this.points.length; i++) {
                var point = _this._parent.map.project([this.points[i].lon, this.points[i].lat]);
                this.points[i].x = point.x;
                this.points[i].y = point.y;
            }
        };

        /**
         * 连接标线路径
         * @todo 神奇bug：定义此方法时参数顺序不能调换
         * @memberof GeoGlobe.Visuals.Custom.Commute.MarkLine.prototype
         * @param {Number} length 此刻标线的长度（要连接的点的数量）
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkLine.prototype.path = function (length, context) {
            length > this.points.length && (length = this.points.length);

            for (var i = 0; i < length; i++) {
                if (i === 0) {
                    context.moveTo(this.points[0].x, this.points[0].y);
                } else {
                    context.lineTo(this.points[i].x, this.points[i].y);
                }
            }
        };
    },

    /**
     * 画布初始化
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @private
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));
        this.canvasContext.push(this.canvas[1].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));
        this.cacheCanvasContext.push(this.cacheCanvas[1].getContext("2d"));

        this.canvas[0].style.position = "absolute";
        this.canvas[1].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);
        this.div.appendChild(this.canvas[1]);
        this.setVisible(this.visibility);
    },

    /**
     * 悬浮提示框初始化
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @private
     */
    _initTooltip: function () {
        if (this._rendererOptions.markPoint.hoverable && this._rendererOptions.tooltip.show) {
            this.tooltipDiv = this.tooltipDiv || this.div.appendChild(document.createElement('div'));
            this.tooltipDiv.style.position = "relative";
            this.tooltipDiv.style.display = "none";
            this.tooltipDiv.style.zIndex = 999;
            this.tooltipDiv.style.color = this._rendererOptions.tooltip.textStyle.color;
            this.tooltipDiv.style.padding = this._rendererOptions.tooltip.padding + "px";
            this.tooltipDiv.style.font = this._rendererOptions.tooltip.textStyle.fontStyle + ' ' + this._rendererOptions.tooltip.textStyle.fontWeight + ' ' + this._rendererOptions.tooltip.textStyle.fontSize + 'px ' + this._rendererOptions.tooltip.textStyle.fontFamily;

            //(IE8-)不兼容rgba问题处理
            if (document.createElement('canvas').getContext) {
                this.tooltipDiv.style["background-color"] = this._rendererOptions.tooltip.backgroundColor;
            } else {
                this.tooltipDiv.style["background-color"] = GeoGlobe.Util.getRgbColor(this._rendererOptions.tooltip.backgroundColor);
            }

            this.tooltipDiv.style["border-width"] = this._rendererOptions.tooltip.borderWidth + "px";
            this.tooltipDiv.style["border-color"] = this._rendererOptions.tooltip.borderColor;
            this.tooltipDiv.style["border-radius"] = this._rendererOptions.tooltip.borderRadius + "px";
            this.tooltipDiv.style["border-style"] = "solid";
            this.tooltipDiv.style['white-space'] = "nowrap";
            this.tooltipDiv.style["box-shadow"] = "rgba(0, 0, 0, 0.2) 0px 10px 10px";
            this.tooltipDiv.style["transition"] = "left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)";
        }
    },

    /**
     * 渲染图层
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    render: function () {
        this._init_RendererOptions();
        this._initTooltip();
        this._initMarkPoint();
        this._initMarkLine();
        this.setData(this.data);
        this.draw();
    },

    /**
     * 图层绘制
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    draw: function () {
        this.updateXY();

        //动画
        this.animation = true;
        this.frame && cancelAnimationFrame(this.frame);
        var _this = this;
        (function animate() {
            _this.frame = requestAnimationFrame(animate);
            _this.animation && _this.drawCanvas1();
            _this.animation && _this.drawCanvas2();
            _this.animation = true;
        })();
    },

    /**
     * 图层（地图）移动时触发
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    onMove: function () {
        this.animation = false;
        this.updateXY();
        this.drawCanvas1();
        this.drawCanvas2();
    },

    /**
     * 图层（地图）移动结束触发
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    onMoveEnd: function () {
        this.redraw();
    },

    /**
     * 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @param {Object} event 事件参数
     */
    onMouseMove: function (event) {
        if (this._rendererOptions.markPoint.hoverable && this.visibility && this.markPoints.length > 0 && !this._parent.map.moving) {
            this.hover(event.point.x, event.point.y);

            this.hoveredMarkPoint && this._parent.fire("overlayerhover", {
                layer: this,
                feature: this.hoveredMarkPoint,
                event: event
            });
        }
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    onResize: function () {
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.canvas[1].height = this.cacheCanvas[0].height = this.cacheCanvas[1].height = this.height = this._parent.map.transform.height;
        this.redraw();
    },

    /**
     * 图层重绘
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    redraw: function () {
        this.clearCanvas();

        this.updateXY();
        this.drawCanvas1();
        this.drawCanvas2();
    },

    /**
     * 重新计算标线点、标注的屏幕坐标
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    updateXY: function () {
        var i = this.markLines.items.length;
        while (i--) {
            this.markLines.items[i].updateXY();
        }

        i = this.markPoints.length;
        while (i--) {
            this.markPoints[i].updateXY();
        }
    },

    /**
     * 绘制标线、标线的点到最底层画布
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    drawCanvas1: function () {
        this.cacheCanvas[0].width = this.width;
        this.cacheCanvasContext[0].globalCompositeOperation = 'lighter';

        var i, len;
        var lines = this.markLines.items;
        var ops = this.markLines.option;
        if (lines.length > 0) {

            //绘制线条（四部曲）
            this.cacheCanvasContext[0].beginPath();
            switch (ops.step) {
                case 1:
                    ops.lineLength += ops.lineIncrement + 0.1;
                    for (i = 0, len = ~~(ops.linesNumber * 2 / 3); i < len; i++) {
                        lines[i].path(Math.round(ops.lineLength), this.cacheCanvasContext[0]);
                    }
                    ops.lineLength > ops.linePointsNumber - 1 && (ops.factor = 1, ops.lineLength = 0, ops.step = 2);
                    break;
                case 2:
                    for (i = 0, len = ~~(ops.linesNumber * 2 / 3); i < len; i++) {
                        lines[i].path(ops.linePointsNumber, this.cacheCanvasContext[0]);
                    }

                    ops.lineLength += ops.lineIncrement + 0.1;
                    for (i = ~~(ops.linesNumber * 2 / 3), len = ops.linesNumber; i < len; i++) {
                        lines[i].path(Math.round(ops.lineLength), this.cacheCanvasContext[0]);
                    }
                    ops.lineLength > ops.linePointsNumber - 1 && (ops.factor = -1, ops.lineLength = ops.linePointsNumber - 1, ops.step = 3);
                    break;
                case 3:
                    for (i = 0, len = ~~(ops.linesNumber * 2 / 3); i < len; i++) {
                        lines[i].path(ops.linePointsNumber, this.cacheCanvasContext[0]);
                    }

                    ops.lineLength -= ops.lineIncrement - 0.1;
                    for (i = ~~(ops.linesNumber * 2 / 3), len = ops.linesNumber; i < len; i++) {
                        lines[i].path(Math.round(ops.lineLength), this.cacheCanvasContext[0]);
                    }
                    ops.lineLength < 0 && (ops.factor = -1, ops.lineLength = ops.linePointsNumber - 1, ops.step = 4);
                    break;
                case 4:
                    ops.lineLength -= ops.lineIncrement - 0.1;
                    for (i = 0, len = ~~(ops.linesNumber * 2 / 3); i < len; i++) {
                        lines[i].path(Math.round(ops.lineLength), this.cacheCanvasContext[0]);
                    }
                    ops.lineLength < 0 && (ops.factor = 1, ops.lineLength = 0, ops.step = 1);
                    break;
            }
            this.cacheCanvasContext[0].lineWidth = this._rendererOptions.markLine.itemStyle.width;
            this.cacheCanvasContext[0].strokeStyle = this._rendererOptions.markLine.itemStyle.color;
            this.cacheCanvasContext[0].stroke();

            //绘制线条的点（小）
            for (i = ~~(this.markLines.option.linesNumber / 200), len = ~~(this.markLines.option.linesNumber / 10); i < len; i++) {
                this.markLines.items[i].effect.draw(this.cacheCanvasContext[0]);
            }
        }

        this.canvas[0].width = this.width;
        this.canvasContext[0].drawImage(this.cacheCanvas[0], 0, 0);
    },

    /**
     * 绘制标注、标线的点（大）
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    drawCanvas2: function () {
        //IE8以下无残影效果
        if (document.createElement('canvas').getContext) {
            this.cacheCanvasContext[1].globalCompositeOperation = 'destination-out';
            this.cacheCanvasContext[1].fillStyle = 'rgba(0, 0, 0, 0.05)';
            this.cacheCanvasContext[1].fillRect(0, 0, this.width, this.height);
            this.cacheCanvasContext[1].globalCompositeOperation = 'source-over';//lighter
        } else {
            this.cacheCanvas[1].width = this.width;
        }
        this.cacheCanvasContext[1].save();

        //绘制线条的点（大）
        if (this.markLines.items.length > 0) {
            for (var i = 0; i < ~~(this.markLines.option.linesNumber / 200); i++) {
                this.markLines.items[i].effect.draw(this.cacheCanvasContext[1]);
            }
        }

        //绘制标注
        i = this.markPoints.length;
        while (i--) {
            this.markPoints[i].draw(this.cacheCanvasContext[1]);
        }

        this.cacheCanvasContext[1].restore();

        this.canvas[1].width = this.width;
        this.canvasContext[1].drawImage(this.cacheCanvas[1], 0, 0);
    },

    /**
     * 画布清空
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    clearCanvas: function () {
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    destroy: function () {
        //先停动画，再移Dom，再重置属性
        cancelAnimationFrame(this.frame);

        this._parent.container.removeChild(this.div);

        this.MarkPoint = null;
        this.markPoints = [];
        this.canvas = [];
        this.data = [];
        this.cacheCanvas = [];
        this.canvasContext = [];
        this.cacheCanvasContext = [];
        this._rendererOptions = {};
    },

    /**
     * 鼠标悬浮时触发
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @param {Number} x 鼠标在主画布上的位置（x轴方向）
     * @param {Number} y 鼠标在主画布上的位置（y轴方向）
     */
    hover: function (x, y) {
        this.hoveredMarkPoint = null;

        this.cacheCanvasContext[1].save();

        for (var i = 0, len = this.markPoints.length; i < len; i++) {
            !this.hoveredMarkPoint && this.markPoints[i].isPointInPath(this.cacheCanvasContext[1], x, y);
        }
        this.cacheCanvasContext[1].restore();

        //显示悬浮提示框
        if (this.hoveredMarkPoint) {
            this.canvas[1].style.cursor = "pointer";
            this.showTooltip(this.hoveredMarkPoint.name, x, y);
        } else {
            this.canvas[1].style.cursor = "default";
            this.hideTooltip();
        }
    },

    /**
     * 显示悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @param {String} text 要提示的文本
     * @param {Number} x 鼠标在画布上的位置（x轴方向）
     * @param {Number} y 鼠标在画布上的位置（y轴方向）
     * @ignore
     */
    showTooltip: function (text, x, y) {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.textContent = text;
            this.tooltipDiv.style.top = (y - 15) + "px";
            this.tooltipDiv.style.left = (x + 15) + "px";
            this.tooltipDiv.style.display = "block";
        }
    },

    /**
     * 关闭悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     */
    hideTooltip: function () {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.style.display = "none";
        }
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.canvas[1].height = this.cacheCanvas[0].height = this.cacheCanvas[1].height = this.height = this._parent.map.transform.height;
    },

    /**
     * 图层的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = this.canvas[1].style.display = visibility ? "block" : "none";
    },

    /**
     * 数据的处理，构造标线对象
     * @memberof GeoGlobe.Visuals.Custom.Commute.prototype
     * @param {Array} data 数据
     */
    setData: function (data) {
        this.data = data;

        //初始化一些配置参数
        this.markLines.option = {
            step: 1,
            factor: 1,
            linesNumber: data.length,
            linePointsNumber: data[0].geometry.coordinates.length,
            lineLength: 0,
            lineIncrement: 10 / this._rendererOptions.markLine.effect.period
        };
        for (var i = 0; i < data.length; i++) {
            var points = [];
            for (var j = 0; j < data[i].geometry.coordinates.length; j++) {
                points.push({lon: data[i].geometry.coordinates[j][0], lat: data[i].geometry.coordinates[j][1]});
            }
            this.markLines.items.push(new this.MarkLine(i, points));
        }

        //todo 取标线最后一个点，构造标注实例
        var destination = data[data.length - 1].geometry.coordinates[data[data.length - 1].geometry.coordinates.length - 1];
        this.markPoints.push(new this.MarkPoint(0, data[data.length - 1].properties.name || '终点', destination[0], destination[1]));
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Custom.Scatter
 * @classdesc 地域分布（散点）图层
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.data 数据，geojson格式
 * @param {Object} options.legend 图例配置
 * @param {Boolean} options.legend.show 是否显示图例
 * @param {String} options.legend.title 图例标题
 * @param {Number} options.legend.left 距左边界的距离
 * @param {Number} options.legend.right 距右边界的距离
 * @param {Number} options.legend.top 距上边界的距离
 * @param {Number} options.legend.bottom 距下边界的距离
 * @param {Number} options.legend.col 图例项的列数
 * @param {Number} options.legend.itemSize 图例项图形大小
 * @param {Array} options.legend.itemColors 图例项图形颜色集
 * @param {Array} options.legend.itemStatuses 图例项启用状态，0表示未启用、1表示启用
 * @param {String} options.legend.backgroundColor 背景颜色
 * @param {String} options.legend.borderColor 边框颜色
 * @param {Number} options.legend.borderWidth 边框线宽
 * @param {Number} options.legend.borderRadius 边框圆角
 * @param {String} options.legend.shadowColor 阴影颜色
 * @param {Number} options.legend.shadowBlur 阴影模糊度
 * @param {Number} options.legend.shadowOffsetX 阴影水平偏移量
 * @param {Number} options.legend.shadowOffsetY 阴影垂直偏移量
 * @param {Number} options.legend.padding 内边距
 * @param {String} options.legend.textStyle 文字样式
 * @param {String} options.legend.textStyle.color 颜色
 * @param {String} options.legend.textStyle.fontFamily 字体系列
 * @param {Number} options.legend.textStyle.fontSize 字号 ，单位px
 * @param {String} options.legend.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String|Number} options.legend.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 * @param {Object} options.rendererOptions 渲染配置
 * @param {Object} options.rendererOptions.markPoint 标注
 * @param {Boolean} options.rendererOptions.markPoint.unactivatedDrawable 是否绘制未激活状态的标注，为true时以灰色调进行绘制
 * @param {String} options.rendererOptions.markPoint.symbol 标注图形类型，可选为：'square' | 'round' | 'square2'
 * @param {Number} options.rendererOptions.markPoint.symbolSize 标注大小
 * @param {Object} options.rendererOptions.markPoint.itemStyle 图形样式属性
 * @param {String} options.rendererOptions.markPoint.itemStyle.color 颜色
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowColor 阴影颜色
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowBlur 阴影模糊度
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowOffsetX 阴影偏移量X
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowOffsetY 阴影偏移量Y
 *
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //通过jquery加载json数据
 $.getJSON('../../data/xuzhou.json', function (result) {
    //构造地域分布（散点）图层
    var scatter = new GeoGlobe.Visuals.Custom.Scatter({
        id: "scatter_1",
        visibility: true,
        data: result.features,
        legend:{
            show: true,
            left: 10,
            top: 10,
            col: 1,
            itemSize: 10,
            itemColors: ["#4f19c7","#c71969","#1984c7","#8419c7","#c76919","#c78419","#199fc7","#9f19c7",
                "#69c719","#b9c719","#3419c7","#19b9c7","#19c74f","#c79f19","#19c7b9","#34c719",
                "#FFD7AA","#8DD7FF","#FFD766"],
            itemStatuses: [1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0],
            padding: 5
        },
        rendererOptions: {
            markPoint: {
                unactivatedDrawable: false,
                symbol: 'square',
                symbolSize: 1
            }
        }
    });
    //添加到可视化定制图层
    scatter.addTo(custom);
    //绘制
    custom.render();
 });
 */
GeoGlobe.Visuals.Custom.Scatter = GeoGlobe.Class4OL({

    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @type {Array}
     */
    canvas: [],

    /**
     * 离屏画布集合
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @type {Array}
     */
    cacheCanvas: [],

    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @type {Array}
     */
    canvasContext: [],

    /**
     * 离屏画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @type {Array}
     */
    cacheCanvasContext: [],

    /**
     * 标注对象集类
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @type {Function}
     */
    MarkPointsSet: null,

    /**
     * 标注对象集
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @type {Array}
     */
    markPointsSets: [],

    /**
     * 图例标签名数组
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @type {Array}
     */
    legendLabels: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @private
     */
    _initContainer: function () {
        this.div = document.createElement("div");
        this.div.setAttribute("id", this.id);
        this.div.setAttribute("style", "position:absolute");
    },

    /**
     * 初始化图例配置
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @private */
    _init_Legend: function () {
        this._legend = GeoGlobe.Util.deepExtend({}, {
            show: true,
            left: null,
            right: null,
            top: null,
            bottom: null,
            col: 1,
            itemSize: 10,
            itemColors: [],
            itemStatuses: [],
            backgroundColor: "rgba(0,0,0,0.5)",
            borderColor: "#000",
            borderWidth: 1,
            borderRadius: 0,
            shadowColor: "#fff",
            shadowBlur: 5,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            padding: 10,
            textStyle: {
                color: "#fff",
                fontFamily: "serif",
                fontSize: 12,
                fontStyle: "normal",
                fontWeight: "normal"
            }
        }, this.legend);
    },

    /**
     * 初始化渲染配置
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @private
     */
    _init_RendererOptions: function () {
        this._rendererOptions = GeoGlobe.Util.deepExtend({}, {
            markPoint: {
                unactivatedDrawable: true,
                symbol: 'square',
                symbolSize: 2,
                itemStyle: {
                    color: 'rgba(255,0,0,0.7)',
                    shadowColor: '#000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                }
            }
        }, this.rendererOptions);
    },

    /**
     * 定义标注集类
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @private
     */
    _initMarkPointsSet: function () {
        var _this = this;

        var itemColors = this._legend.itemColors;
        var itemStatuses = this._legend.itemStatuses;

        var unactivatedDrawable = this._rendererOptions.markPoint.unactivatedDrawable;
        var symbol = this._rendererOptions.markPoint.symbol;
        var symbolSize = this._rendererOptions.markPoint.symbolSize;
        var itemStyle = this._rendererOptions.markPoint.itemStyle;


        /**
         * 构造一个标注集
         * @param {Number} legendLabel 类型名
         * @param {Array} markPoints 同类型的标注
         */
        this.MarkPointsSet = function (legendLabel, markPoints, index) {
            this.legendLabel = legendLabel;
            this.markPoints = markPoints;
            var i;
            i = markPoints.length;
            while (i--) {
                markPoints[i].weight = (markPoints[i].value - _this.minValue) / (_this.maxValue - _this.minValue);
                if (isNaN(markPoints[i].weight)) markPoints[i].weight = 1;
                if (markPoints[i].weight > 1) markPoints[i].weight = 1;
                if (markPoints[i].weight < 0) markPoints[i].weight = 0;
                if (GeoGlobe.Util.getType(_this._rendererOptions.markPoint.itemStyle.color[index]) === "object") {
                    _this.gradientImageData = GeoGlobe.Util.getGradientImageData(_this._rendererOptions.markPoint.itemStyle.color[index]);
                }
                markPoints[i].color = GeoGlobe.Util.getType(itemStyle.color[index]) === "object" ? 'rgba(' + _this.gradientImageData[~~(markPoints[i].weight * 255 + 0.5) * 4] + ',' + _this.gradientImageData[~~(markPoints[i].weight * 255 + 0.5) * 4 + 1] + ',' + _this.gradientImageData[~~(markPoints[i].weight * 255 + 0.5) * 4 + 2] + ',' + _this.gradientImageData[3] / 255 + ')' : itemColors[index];

            }
        };

        /**
         * 更新标注的位置
         * @memberof GeoGlobe.Visuals.Custom.Scatter.MarkPointsSet.prototype
         */
        this.MarkPointsSet.prototype.updateXY = function () {
            var i = this.markPoints.length;
            while (i--) {
                var point = _this._parent.map.project([this.markPoints[i].lon, this.markPoints[i].lat]);
                this.markPoints[i].x = point.x;
                this.markPoints[i].y = point.y;
            }
        };

        /**
         * 绘制标注
         * @memberof GeoGlobe.Visuals.Custom.Scatter.MarkPointsSet.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的图层上下文
         * @param {Number} index 当前绘制的类型索引
         */
        this.MarkPointsSet.prototype.draw = function (context, index) {
            if (!unactivatedDrawable && itemStatuses[index] === 0) {
                return;
            }
            var renderedArray = [];
            var getRenderedItem = function (item) {
                for (var i = 0; i < renderedArray.length; i++) {
                    if (parseInt(renderedArray[i].x) === parseInt(item.x) && parseInt(renderedArray[i].y) === parseInt(item.y)) {
                        return renderedArray[i];
                    }
                }
                return null;
            };

            var drawMarkPoint = function () {
                context.fillStyle = markPoint.color;
                context.beginPath();
                switch (symbol) {
                    case 'square':
                        context.globalCompositeOperation = 'lighter';
                        context.rect(markPoint.x - symbolSize / 2, markPoint.y - symbolSize / 2, symbolSize, symbolSize);
                        break;
                    case 'square2':
                        context.rect(markPoint.x - symbolSize / 2, markPoint.y - symbolSize / 2, symbolSize, symbolSize);
                        break;
                    case 'round':
                        context.globalCompositeOperation = 'lighter';
                        context.arc(markPoint.x, markPoint.y, symbolSize / 2, 0, Math.PI * 2, false);
                        break;
                }
                context.fill();
            };
            var i = this.markPoints.length;
            this.markPoints = this.markPoints.sort(function (a, b) {
                var val1 = a.value;
                var val2 = b.value;
                if (val1 > val2) {
                    return -1;
                } else if (val1 < val2) {
                    return 1;
                } else {
                    return 0;
                }
            })

            while (i--) {
                var markPoint;
                markPoint = this.markPoints[i];
                if (symbol === 'square2') {
                    var suitItem = getRenderedItem(markPoint);
                    if (suitItem) {
                        if (markPoint.value > suitItem.value) {
                            drawMarkPoint();
                            suitItem.value = markPoint.value;
                        }
                    } else {
                        drawMarkPoint();
                        renderedArray.push({
                            x: markPoint.x,
                            y: markPoint.y,
                            value: markPoint.value
                        });
                    }
                } else {
                    drawMarkPoint();
                }
            }
        }
    },

    /**
     * 画布初始化
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @private
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));

        this.canvas[0].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);
        this.setVisible(this.visibility);
    },

    /**
     * 渲染图层
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    render: function () {
        this._init_Legend();
        this._init_RendererOptions();
        this._initMarkPointsSet();
        this.setData(this.data);
        this.draw();
    },

    /**
     * 图层绘制
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    draw: function () {
        this.updateXY();
        this.drawCanvas();

        //动画
        this.frame && cancelAnimationFrame(this.frame);
        var _this = this;
        (function animate() {
            //todo
        })();
    },

    /**
     * 图层懒绘制
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    lazydraw: function () {
        var _this = this;
        (function loop() {
            if (_this.DRAWINDEX < _this.legendLabels.length) {
                requestAnimationFrame(loop);

                _this.drawLegend(_this.DRAWINDEX);
                _this.markPointsSets[_this.DRAWINDEX].draw(_this.cacheCanvasContext[0], _this.DRAWINDEX);
                _this.canvas[0].width = _this.width;
                _this.canvasContext[0].drawImage(_this.cacheCanvas[0], 0, 0);

                _this.DRAWINDEX++;
            }
        })();
    },

    /**
     * 图层（地图）移动时触发
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    onMove: function () {
        this.updateXY();
        this.drawCanvas();
    },

    /**
     * 图层（地图）移动结束触发
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    onMoveEnd: function () {
        this.redraw();
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    onResize: function () {
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this._parent.map.transform.height;
        this.redraw();
    },

    /**
     * 图层重绘
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    redraw: function () {
        this.clearCanvas();

        this.updateXY();
        this.drawCanvas();
    },

    /**
     * 重新计算标注集的屏幕坐标
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    updateXY: function () {
        var i = this.markPointsSets.length;
        while (i--) {
            this.markPointsSets[i].updateXY();
        }
    },

    /**
     * 绘制标注集到画布
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    drawCanvas: function () {
        this.cacheCanvas[0].width = this.width;

        for (var i = 0, len = this.markPointsSets.length; i < len; i++) {
            this.markPointsSets[i].draw(this.cacheCanvasContext[0], i);
        }

        this.canvas[0].width = this.width;
        this.canvasContext[0].drawImage(this.cacheCanvas[0], 0, 0);
    },

    /**
     * 绘制图例
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @param {Number} index 当前绘制的类型索引
     */
    drawLegend: function (index) {
        if (this._legend && this._legend.show) {
            //创建图例div
            if (!this.legendDiv) {

                //外层div
                this.legendDiv = document.createElement('div');
                this.legendDiv.style.display = this.visibility ? "block" : "none";//跟随图层默认显示隐藏
                this.legendDiv.style.zIndex = 9999;
                this.legendDiv.style.position = "absolute";
                this.legendDiv.style["background-color"] = this._legend.backgroundColor;
                this.legendDiv.style["border-color"] = this._legend.borderColor;
                this.legendDiv.style["border-width"] = this._legend.borderWidth + 'px';
                this.legendDiv.style["border-radius"] = this._legend.borderRadius + 'px';
                this.legendDiv.style["border-style"] = 'solid';
                this.legendDiv.style["box-shadow"] = this._legend.shadowOffsetX + 'px ' + this._legend.shadowOffsetY + 'px ' + this._legend.shadowBlur + 'px ' + this._legend.shadowColor;
                this.legendDiv.style.padding = this._legend.padding + 'px';

                //设置方位
                this.legendDiv.style.left = this._legend.left !== null ? this._legend.left + 'px' : null;
                this.legendDiv.style.right = this._legend.right !== null ? this._legend.right + 'px' : null;
                this.legendDiv.style.top = this._legend.top !== null ? this._legend.top + 'px' : null;
                this.legendDiv.style.bottom = this._legend.bottom !== null ? this._legend.bottom + 'px' : null;

                //内层canvas
                this.legendCanvas = document.createElement('canvas');
                this.legendCanvasContext = this.legendCanvas.getContext("2d");

                //解决底部有3px间距的问题
                this.legendCanvas.style.display = 'block';

                //设置好字体，以便测量canvas所需宽高
                this.legendCanvasContext.font = this._legend.textStyle.fontStyle + ' ' + this._legend.textStyle.fontWeight + ' ' + this._legend.textStyle.fontSize + 'px ' + this._legend.textStyle.fontFamily;

                this.legendDiv.appendChild(this.legendCanvas);
                this._parent.container.parentNode.parentNode.parentNode.appendChild(this.legendDiv);
            }

            //计算图例每列的最大宽度
            var legendColumnWidths = [];
            var legendColumnWidth = null;
            for (var i = 0, len1 = this.legendLabels.length; i < len1; i++) {
                legendColumnWidth = this._legend.itemSize + 10 + this.legendCanvasContext.measureText(this.legendLabels[i].toString()).width;

                var len2 = this._legend.col;
                for (var j = 0; j < len2; j++) {
                    if (i % this._legend.col === j) {
                        (!legendColumnWidths[j] || legendColumnWidths[j] < legendColumnWidth) && (legendColumnWidths[j] = legendColumnWidth);
                    }
                }
            }

            //计算canvas大小
            var width = 10, height = 10;
            for (var i = 0, len = legendColumnWidths.length; i < len; i++) {
                width += legendColumnWidths[i] + 10;
            }
            height += ((this._legend.itemSize < this._legend.textStyle.fontSize ? this._legend.textStyle.fontSize : this._legend.itemSize) + 10) * (~~(this.legendLabels.length / this._legend.col) + (this.legendLabels.length % this._legend.col === 0 ? 0 : 1));

            //设置canvas的大小
            this.legendCanvas.width = width;
            this.legendCanvas.height = height;

            /**
             * 绘制图例
             * @param {Number} legendItemIndex 当前绘制的图例项索引
             * @param {String} mouseType 鼠标事件类型
             * @param {Number} mouseX 鼠标x位置
             * @param {Number} mouseY 鼠标y位置
             */
            var draw = function (legendItemIndex, mouseType, mouseX, mouseY) {
                this.legendCanvas.width = width;

                var hasHover = false;
                var hasClick = false;
                var x, y;
                for (var i = 0,
                         len1 = legendItemIndex !== void 0 ? legendItemIndex + 1 : this.legendLabels.length; i < len1; i++) {
                    for (var j = 0, len2 = this._legend.col; j < len2; j++) {
                        if (i % this._legend.col === j) {
                            x = 10 + this._legend.itemSize / 2;
                            for (var m = 0; m < j; m++) {
                                x += legendColumnWidths[m] + 10;
                            }
                        }
                    }

                    y = 10 + this._legend.itemSize / 2 + ((this._legend.itemSize < this._legend.textStyle.fontSize ? this._legend.textStyle.fontSize : this._legend.itemSize) + 10) * ~~(i / this._legend.col);

                    //判断鼠标是否悬浮/是否点击在图例项/图例项标签上
                    var hover = false;
                    var click = false;
                    this.legendCanvasContext.beginPath();
                    switch (this._rendererOptions.markPoint.symbol) {
                        case 'square':
                            this.legendCanvasContext.rect(x - this._legend.itemSize / 2, y - this._legend.itemSize / 2, this._legend.itemSize, this._legend.itemSize);
                            break;
                        case 'square2':
                            this.legendCanvasContext.rect(x - this._legend.itemSize / 2, y - this._legend.itemSize / 2, this._legend.itemSize, this._legend.itemSize);
                            break;
                        case 'round':
                            this.legendCanvasContext.arc(x, y, this._legend.itemSize / 2, 0, Math.PI * 2, false);
                            break;
                    }
                    if (mouseType === "mousemove" && mouseX !== void 0 && mouseY !== void 0 && this.legendCanvasContext.isPointInPath(mouseX, mouseY)) hover = true, hasHover = true;
                    if (mouseType === "mousedown" && mouseX !== void 0 && mouseY !== void 0 && this.legendCanvasContext.isPointInPath(mouseX, mouseY)) click = true, hasClick = true;
                    this.legendCanvasContext.beginPath();
                    this.legendCanvasContext.font = this._legend.textStyle.fontStyle + ' ' + this._legend.textStyle.fontWeight + ' ' + this._legend.textStyle.fontSize + 'px ' + this._legend.textStyle.fontFamily;
                    this.legendCanvasContext.rect(x + this._legend.itemSize / 2 + 10, y - this._legend.textStyle.fontSize / 2, this.legendCanvasContext.measureText(this.legendLabels[i].toString()).width, this._legend.textStyle.fontSize);
                    if (mouseType === "mousemove" && mouseX !== void 0 && mouseY !== void 0 && this.legendCanvasContext.isPointInPath(mouseX, mouseY)) hover = true, hasHover = true;
                    if (mouseType === "mousedown" && mouseX !== void 0 && mouseY !== void 0 && this.legendCanvasContext.isPointInPath(mouseX, mouseY)) click = true, hasClick = true;

                    //切换图例项的开启与关闭，并与图层联动
                    if (click) {
                        this._legend.itemStatuses[i] = this._legend.itemStatuses[i] === 0 ? 1 : 0;
                        this.drawCanvas();
                    }

                    //更新图例项的颜色
                    var itemColor = this._legend.itemStatuses[i] === 0 ? '#808080' : this._legend.itemColors[i] ? this._legend.itemColors[i] : this._rendererOptions.markPoint.itemStyle.color;
                    var fontColor = this._legend.itemStatuses[i] === 0 ? '#808080' : this._legend.textStyle.color;
                    itemColor = hover || click ? GeoGlobe.Util.getShadeColor(itemColor, 20) : itemColor;
                    fontColor = hover || click ? GeoGlobe.Util.getShadeColor(fontColor, 20) : fontColor;

                    //绘制图例项
                    this.legendCanvasContext.beginPath();
                    switch (this._rendererOptions.markPoint.symbol) {
                        case 'square':
                            this.legendCanvasContext.rect(x - this._legend.itemSize / 2, y - this._legend.itemSize / 2, this._legend.itemSize, this._legend.itemSize);
                            break;
                        case 'square2':
                            this.legendCanvasContext.rect(x - this._legend.itemSize / 2, y - this._legend.itemSize / 2, this._legend.itemSize, this._legend.itemSize);
                            break;
                        case 'round':
                            this.legendCanvasContext.arc(x, y, this._legend.itemSize / 2, 0, Math.PI * 2, false);
                            break;
                    }
                    this.legendCanvasContext.fillStyle = itemColor;
                    this.legendCanvasContext.fill();

                    this.legendCanvasContext.font = this._legend.textStyle.fontStyle + ' ' + this._legend.textStyle.fontWeight + ' ' + this._legend.textStyle.fontSize + 'px ' + this._legend.textStyle.fontFamily;
                    this.legendCanvasContext.textAlign = 'left';
                    this.legendCanvasContext.textBaseline = 'middle';
                    this.legendCanvasContext.fillStyle = fontColor;
                    this.legendCanvasContext.fillText(this.legendLabels[i], x + this._legend.itemSize / 2 + 10, y);
                }

                //更新鼠标形状
                if (hasHover) {
                    this.legendCanvas.style.cursor = "pointer";
                } else {
                    this.legendCanvas.style.cursor = "default";
                }

                //todo 触发图例选中状态改变事件
                // hasClick && this._parent.fire('legendselectchanged', {
                //     layer: this,
                //     legend: {
                //         'legendLabels': this.legendLabels,
                //         'statuses': this._legend.itemStatuses
                //     }
                // });
            }.bind(this);

            //鼠标按下
            this.legendCanvas.onmousedown = function (evt) {
                var mouseX = evt.offsetX || (evt.clientX - (evt.target || evt.srcElement).getBoundingClientRect().left);
                var mouseY = evt.offsetY || (evt.clientY - (evt.target || evt.srcElement).getBoundingClientRect().top);
                draw(void 0, evt.type, mouseX, mouseY);
            };

            //鼠标移动
            this.legendCanvas.onmousemove = function (evt) {
                var mouseX = evt.offsetX || (evt.clientX - (evt.target || evt.srcElement).getBoundingClientRect().left);
                var mouseY = evt.offsetY || (evt.clientY - (evt.target || evt.srcElement).getBoundingClientRect().top);
                draw(void 0, evt.type, mouseX, mouseY);
            };

            //绘制图例
            draw(index);
        }
    },

    /**
     * 画布清空
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    clearCanvas: function () {
        this.canvas[0].width = this.cacheCanvas[0].width = this.width;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     */
    destroy: function () {
        //先停动画，再移Dom，再重置属性
        cancelAnimationFrame(this.frame);

        this._parent.container.removeChild(this.div);

        this.MarkPoint = null;
        this.markPoints = [];
        this.canvas = [];
        this.data = [];
        this.cacheCanvas = [];
        this.canvasContext = [];
        this.cacheCanvasContext = [];
        this._rendererOptions = {};
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this._parent.map.transform.height;
    },

    /**
     * 图层、图例的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = visibility ? "block" : "none";
        this.legendDiv && (this.legendDiv.style.display = visibility ? "block" : "none");
    },

    /**
     * 数据的处理，构造标注对象集对象
     * @memberof GeoGlobe.Visuals.Custom.Scatter.prototype
     * @param {Array} data 数据
     */
    setData: function (data) {
        this.data = data;
        // 求极值
        this.minValue = Number.MAX_VALUE;
        this.maxValue = Number.MIN_VALUE;
        for (var i = 0; i < data.length; i++) {
            if (data[i].properties.value < this.minValue) this.minValue = data[i].properties.value;
            if (data[i].properties.value > this.maxValue) this.maxValue = data[i].properties.value;
        }

        var blob = new Blob(['function MarkPoint(lon, lat, value) {' +
        'this.lon = lon;' +
        'this.lat = lat;' +
        'this.value = value;' +
        '}' +


        'function MarkPointsSet(legendLabel) {' +
        'this.legendLabel = legendLabel;' +
        'this.markPoints = [];' +
        '}' +

        'var legendLabels = [];' +
        'var markPointsSets = [];' +
        'onmessage = function (evt) {' +

        'var features = evt.data.data;' +
        'var feature = null;' +
        'var legendLabel = null;' +
        'for (var i = 0, len = features.length; i < len; i++) {' +
        'feature = features[i];' +
        'legendLabel = feature.properties.type;' +
        'if (legendLabels.indexOf(legendLabel) === -1) {' +
        'legendLabels.push(legendLabel);' +
        'markPointsSets.push(new MarkPointsSet(legendLabel));' +
        '}' +
        'markPointsSets[legendLabels.indexOf(legendLabel)].markPoints.push(new MarkPoint(feature.geometry.coordinates[0], feature.geometry.coordinates[1],feature.properties.value));' +
        '}' +
        'postMessage({' +
        'legendLabels: legendLabels,' +
        'markPointsSets: markPointsSets' +
        '})' + '}'
        ]);
        var blobURL = window.URL.createObjectURL(blob);
        var worker = new Worker(blobURL);
        worker.postMessage({data: this.data});
        worker.onmessage = function (evt) {
            this.legendLabels = evt.data.legendLabels;

            var markPointsSets;
            for (var i = 0, len = evt.data.markPointsSets.length; i < len; i++) {
                markPointsSets = new this.MarkPointsSet(evt.data.markPointsSets[i].legendLabel, evt.data.markPointsSets[i].markPoints, i);
                markPointsSets.updateXY();
                this.markPointsSets.push(markPointsSets);
            }
            this.DRAWINDEX = 0;
            this.lazydraw();
        }.bind(this);
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Custom.Proportion
 * @classdesc 占比图层
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.dragdrawing 拖动图层时是否绘制
 * @param {Boolean} options.data 数据，geojson格式
 * @param {Object} options.legend 图例配置
 * @param {Boolean} options.legend.show 是否显示图例
 * @param {String} options.legend.title 图例标题
 * @param {Number} options.legend.left 距左边界的距离
 * @param {Number} options.legend.right 距右边界的距离
 * @param {Number} options.legend.top 距上边界的距离
 * @param {Number} options.legend.bottom 距下边界的距离
 * @param {Number} options.legend.col 图例项的列数
 * @param {Number} options.legend.itemWidth 图例项图形宽度
 * @param {Number} options.legend.itemHeight 图例项图形高度
 * @param {Array} options.legend.itemColors 图例项图形颜色集
 * @param {Array} options.legend.itemStatuses 图例项启用状态，0表示未启用、1表示启用
 * @param {Array} options.legend.hLegendLabels 横向图例标签名数组
 * @param {Array} options.legend.vLegendLabels 纵向图例标签名数组
 * @param {String} options.legend.backgroundColor 背景颜色
 * @param {String} options.legend.borderColor 边框颜色
 * @param {Number} options.legend.borderWidth 边框线宽
 * @param {Number} options.legend.borderRadius 边框圆角
 * @param {String} options.legend.shadowColor 阴影颜色
 * @param {Number} options.legend.shadowBlur 阴影模糊度
 * @param {Number} options.legend.shadowOffsetX 阴影水平偏移量
 * @param {Number} options.legend.shadowOffsetY 阴影垂直偏移量
 * @param {Number} options.legend.padding 内边距
 * @param {String} options.legend.textStyle 文字样式
 * @param {String} options.legend.textStyle.color 颜色
 * @param {String} options.legend.textStyle.fontFamily 字体系列
 * @param {Number} options.legend.textStyle.fontSize 字号 ，单位px
 * @param {String} options.legend.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String|Number} options.legend.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 * @param {Object} options.rendererOptions 渲染配置
 * @param {Object} options.rendererOptions.markPoint 标注
 * @param {Boolean} options.rendererOptions.markPoint.hoverable 是否启用鼠标悬浮
 * @param {Boolean} options.rendererOptions.markPoint.clickable 是否启用鼠标点击
 * @param {Number} options.rendererOptions.markPoint.slope 标注图形3d模式的角度
 * @param {String} options.rendererOptions.markPoint.symbol 标注图形类型，可选为：'column' | 'pie'
 * @param {Number} options.rendererOptions.markPoint.symbolMinSize 标注最小高度/半径
 * @param {Number} options.rendererOptions.markPoint.symbolMinSize 标注最大高度/半径
 * @param {Number} options.rendererOptions.markPoint.symbolWidth 标注宽度，标注类型=pie时为圆环宽度
 * @param {Number} options.rendererOptions.markPoint.symbolThickness 标注厚度，>0时显示为3d模式
 * @param {Number} options.rendererOptions.markPoint.symbolGap 标注间隙
 * @param {Number} options.rendererOptions.markPoint.opacity 标注不透明度（全局）
 * @param {Object} options.rendererOptions.markPoint.itemStyle 图形样式属性
 * @param {String} options.rendererOptions.markPoint.itemStyle.color 颜色
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowColor 阴影颜色，column标注类型时才有效
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowBlur 阴影模糊度
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowOffsetX 阴影偏移量X
 * @param {Number} options.rendererOptions.markPoint.itemStyle.shadowOffsetY 阴影偏移量Y
 * @param {Object} options.rendererOptions.tooltip 悬浮提示
 * @param {Boolean} options.rendererOptions.tooltip.show 是否显示悬浮提示框
 * @param {Number} options.rendererOptions.tooltip.width 悬浮提示框宽度
 * @param {String} options.rendererOptions.tooltip.backgroundColor 背景颜色
 * @param {String} options.rendererOptions.tooltip.borderColor 边框颜色
 * @param {Number} options.rendererOptions.tooltip.borderRadius 边框圆角
 * @param {Number} options.rendererOptions.tooltip.borderWidth 边框宽度
 * @param {Number/String} options.rendererOptions.tooltip.padding 内边距
 * @param {Object} options.rendererOptions.tooltip.textStyle 文字样式
 * @param {String} options.rendererOptions.tooltip.textStyle.color 颜色
 * @param {String} options.rendererOptions.tooltip.textStyle.fontFamily 字体系列
 * @param {Number} options.rendererOptions.tooltip.textStyle.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.tooltip.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.tooltip.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 *
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //通过jquery加载json数据
 $.getJSON('../../data/geostar.json', function (result) {
    //构造占比图层
    var proportion = new GeoGlobe.Visuals.Custom.Proportion({
        id: "proportion_1",
        visibility: true,
        data: result.features,
        legend: {
            show: true,
            left: 10,
            top: 10,
            col: 3,
            itemWidth: 20,
            itemHeight: 12,
            itemColors: ["#3EEAFE","#8187FF","#ED5E2A"],
            itemStatuses: [1,1,1],
            hLegendLabels: ["武大吉奥"],
            vLegendLabels: ["智慧城市", "国土", "测绘"],
            backgroundColor: "transparent",
            borderWidth: 0,
            shadowBlur: 0,
            padding: 0,
            textStyle: {
                color: "#fff"
            }
        },
        rendererOptions: {
            markPoint: {
                slope: 0,
                symbol: 'pie',
                symbolMinSize: 20,
                symbolMaxSize: 100,
                symbolWidth: 20,
                symbolThickness: 10,
                symbolGap: 5,
                opacity: 0.8,
                itemStyle: {
                    color: 'rgba(0,0,0,0.5)'
                }
            },
            tooltip: {
                show: true,
                textStyle: {
                    fontFamily: 'Microsoft YaHei'
                }
            }
        }
    });
    //添加到可视化定制图层
    proportion.addTo(custom);
    //绘制
    custom.render();
 });
 */
GeoGlobe.Visuals.Custom.Proportion = GeoGlobe.Class4OL({

    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @type {Array}
     */
    canvas: [],

    /**
     * 离屏画布集合
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @type {Array}
     */
    cacheCanvas: [],

    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @type {Array}
     */
    canvasContext: [],

    /**
     * 离屏画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @type {Array}
     */
    cacheCanvasContext: [],

    /**
     * 标注类
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @type {Function}
     */
    MarkPoint: null,

    /**
     * 标注对象集
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @type {Array}
     */
    markPoints: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @private
     */
    _initContainer: function () {
        this.div = document.createElement("div");
        this.div.setAttribute("id", this.id);
        this.div.setAttribute("style", "position:absolute");
    },

    /**
     * 初始化图例配置
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @private
     */
    _init_Legend: function () {
        this._legend = GeoGlobe.Util.deepExtend({}, {
            show: true,
            left: null,
            right: null,
            top: null,
            bottom: null,
            col: 1,
            itemWidth: 20,
            itemHeight: 12,
            itemColors: [],
            itemStatuses: [],
            hLegendLabels: [],
            vLegendLabels: [],
            backgroundColor: "rgba(0,0,0,0.5)",
            borderColor: "#000",
            borderWidth: 1,
            borderRadius: 0,
            shadowColor: "#fff",
            shadowBlur: 5,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            padding: 10,
            textStyle: {
                color: "#fff",
                fontFamily: "serif",
                fontSize: 12,
                fontStyle: "normal",
                fontWeight: "normal"
            }
        }, this.legend);
    },

    /**
     * 初始化渲染配置
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @private
     */
    _init_RendererOptions: function () {
        this._rendererOptions = GeoGlobe.Util.deepExtend({}, {
            markPoint: {
                hoverable: true,
                clickable: true,
                slope: 0.8,
                symbol: 'column',
                symbolMinSize: 0,
                symbolMaxSize: 100,
                symbolWidth: 10,
                symbolThickness: 5,
                symbolGap: 5,
                opacity: 1,
                itemStyle: {
                    color: 'rgba(255,0,0,0.7)',
                    shadowColor: '#000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                }
            },
            tooltip: {
                show: true,
                backgroundColor: '#fff',
                borderColor: '#333',
                borderRadius: 0,
                borderWidth: 0,
                padding: 10,
                textStyle: {
                    color: "#000",
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            }
        }, this.rendererOptions);
    },

    /**
     * 定义标注类
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @private
     */
    _initMarkPoint: function () {
        var _this = this;

        var itemColors = this._legend.itemColors;//引用类型
        var itemStatuses = this._legend.itemStatuses;//引用类型
        var symbol = this._rendererOptions.markPoint.symbol;
        var symbolMinSize = this._rendererOptions.markPoint.symbolMinSize;
        var symbolMaxSize = this._rendererOptions.markPoint.symbolMaxSize;
        var symbolWidth = this._rendererOptions.markPoint.symbolWidth;
        var symbolThickness = this._rendererOptions.markPoint.symbolThickness;
        var symbolGap = this._rendererOptions.markPoint.symbolGap;
        var opacity = this._rendererOptions.markPoint.opacity;
        var itemStyle = this._rendererOptions.markPoint.itemStyle;

        /**
         * 构造一个标注实例
         * @param {Number} id 索引号
         * @param {String} name 字段名
         * @param {Array} measureValues 度量值集合，[[100,99,1000],[...],[...]]
         * @param {Number} lon 经度
         * @param {Number} lat 纬度
         */
        this.MarkPoint = function (id, name, measureValues, lon, lat) {
            this.id = id;
            this.name = name;
            this.measureValues = measureValues;
            this.lon = lon;
            this.lat = lat;
            this.init();

            if (symbol === 'pie') {
                var self = this;
                this.Point = function (x, y, z) {
                    this.x = x;
                    this.y = y;
                    this.z = z;
                    this.get2d = function () {
                        var scale = 50000 / (50000 + this.z);//焦距50000
                        var x = self.x + this.x * scale;
                        var y = self.y + this.y * scale;
                        return {x: x, y: y};
                    }
                };
            }
        };

        /**
         * 初始化
         * @memberof GeoGlobe.Visuals.Custom.Proportion.MarkPoint.prototype
         */
        this.MarkPoint.prototype.init = function () {
            this.energy = 0;
            switch (symbol) {
                case "column":
                    this.velocity = 0.1;
                    break;
                case "pie":
                    this.velocity = 0.05;
                    break;
            }
        };

        /**
         * 更新标注的位置
         * @memberof GeoGlobe.Visuals.Custom.Proportion.MarkPoint.prototype
         */
        this.MarkPoint.prototype.updateXY = function () {
            var point = _this._parent.map.project([this.lon, this.lat]);
            this.x = point.x;
            this.y = point.y;
        };

        /**
         * 更新标注各柱体size及高度/扇体弧度
         * @memberof GeoGlobe.Visuals.Custom.Proportion.MarkPoint.prototype
         */
        this.MarkPoint.prototype.updateSize = function () {
            var i, j;
            this.parts = [];
            for (i = 0; i < this.measureValues.length; i++) {
                this.parts.push({size: (symbolMaxSize - symbolMinSize) * (_this.measureValueMaxSum === _this.measureValueMinSum ? 1 : (this.measureValueSums[i] - _this.measureValueMinSum) / (_this.measureValueMaxSum - _this.measureValueMinSum)) + symbolMinSize});
                switch (symbol) {
                    case "column":
                        this.parts[i]['cubes'] = [];
                        break;
                    case "pie":
                        this.parts[i]['sectors'] = [];
                        break;
                }
                for (j = 0; j < this.measureValues[i].length; j++) {
                    switch (symbol) {
                        case "column":
                            this.parts[i]['cubes'].push({height: itemStatuses[j] === 0 || this.measureValueSums[i] === 0 ? 0 : this.measureValues[i][j] / this.measureValueSums[i] * this.parts[i].size});
                            break;
                        case "pie":
                            this.parts[i]['sectors'].push({angle: itemStatuses[j] === 0 || this.measureValueSums[i] === 0 ? 0 : this.measureValues[i][j] / this.measureValueSums[i] * Math.PI * 2});
                            break;
                    }
                }
            }
        };

        /**
         * 更新各柱体/扇体的位置
         * @memberof GeoGlobe.Visuals.Custom.Proportion.MarkPoint.prototype
         */
        this.MarkPoint.prototype.updatePartXY = function () {
            var slope = _this._rendererOptions.markPoint.slope;
            var i, j, m;
            switch (symbol) {
                case "column":

                    //最左边柱体底面右下角顶点的位置
                    var x, y;
                    if (this.parts.length % 2 === 0) {
                        x = this.x - symbolThickness * Math.cos(slope) / 2 - (this.parts.length / 2 - 1) * symbolWidth - (this.parts.length / 2 - 0.5) * symbolGap;
                        y = this.y + symbolThickness * Math.sin(slope) / 2;
                    } else {
                        x = this.x + (symbolWidth - symbolThickness * Math.cos(slope)) / 2 - (this.parts.length - 1) / 2 * symbolWidth - (this.parts.length - 1) / 2 * symbolGap;
                        y = this.y + symbolThickness * Math.sin(slope) / 2;
                    }

                    for (i = 0; i < this.parts.length; i++) {
                        for (j = 0; j < this.parts[i].cubes.length; j++) {

                            //各堆积柱体起始位置的高度
                            var h = 0;
                            for (m = j; m > 0; m--) {
                                h += this.parts[i].cubes[m - 1].height;
                            }

                            //各堆积柱体底面4个顶点的坐标（右下角起逆时针顺序）
                            this.parts[i].cubes[j].vertexs = [
                                [x + i * (symbolWidth + symbolGap), y - h],
                                [x + i * (symbolWidth + symbolGap) + symbolThickness * Math.cos(slope), y - symbolThickness * Math.sin(slope) - h],
                                [x + i * (symbolWidth + symbolGap) + symbolThickness * Math.cos(slope) - symbolWidth, y - symbolThickness * Math.sin(slope) - h],
                                [x + i * (symbolWidth + symbolGap) - symbolWidth, y - h]
                            ];
                        }
                    }
                    break;
                case "pie":
                    var oRadius;
                    var iRadius;
                    var uCentrePoint, tCentrePoint;
                    var oUnderPoints, oTopPoints;
                    var iUnderPoints, iTopPoints;
                    var length = 50;//length个点连接成圆
                    var increment = Math.PI * 2 / length;

                    //todo 暂时只处理第一个饼图
                    for (i = 0; i < 1; i++) {
                        oRadius = this.parts[i].size / 2;
                        iRadius = oRadius > symbolWidth ? oRadius - symbolWidth : 0;

                        //圆心
                        uCentrePoint = new this.Point(0, 0, -symbolThickness / 2);
                        tCentrePoint = new this.Point(0, 0, symbolThickness / 2);

                        //内外圆上的length+1个点，首尾相同
                        oUnderPoints = [];
                        oTopPoints = [];
                        iUnderPoints = [];
                        iTopPoints = [];
                        var angle = 0;
                        while (angle <= Math.PI * 2) {
                            oUnderPoints.push(new this.Point(oRadius * Math.cos(angle), oRadius * Math.sin(angle), -symbolThickness / 2));
                            oTopPoints.push(new this.Point(oRadius * Math.cos(angle), oRadius * Math.sin(angle), symbolThickness / 2));
                            if (iRadius > 0) {
                                iUnderPoints.push(new this.Point(iRadius * Math.cos(angle), iRadius * Math.sin(angle), -symbolThickness / 2));
                                iTopPoints.push(new this.Point(iRadius * Math.cos(angle), iRadius * Math.sin(angle), symbolThickness / 2));
                            }
                            angle += increment;
                        }
                        oUnderPoints.push(new this.Point(oRadius, 0, -symbolThickness / 2));
                        oTopPoints.push(new this.Point(oRadius, 0, symbolThickness / 2));
                        if (iRadius > 0) {
                            iUnderPoints.push(new this.Point(iRadius, 0, -symbolThickness / 2));
                            iTopPoints.push(new this.Point(iRadius, 0, symbolThickness / 2));
                        }

                        //按X轴旋转slope弧度
                        var cos = Math.cos(slope);
                        var sin = Math.sin(slope);
                        var y, z;

                        y = uCentrePoint.y * cos - uCentrePoint.z * sin;
                        z = uCentrePoint.z * cos + uCentrePoint.y * sin;
                        uCentrePoint.y = y;
                        uCentrePoint.z = z;

                        y = tCentrePoint.y * cos - tCentrePoint.z * sin;
                        z = tCentrePoint.z * cos + tCentrePoint.y * sin;
                        tCentrePoint.y = y;
                        tCentrePoint.z = z;

                        for (m = 0; m < length; m++) {
                            y = oUnderPoints[m].y * cos - oUnderPoints[m].z * sin;
                            z = oUnderPoints[m].z * cos + oUnderPoints[m].y * sin;
                            oUnderPoints[m].y = y;
                            oUnderPoints[m].z = z;

                            y = oTopPoints[m].y * cos - oTopPoints[m].z * sin;
                            z = oTopPoints[m].z * cos + oTopPoints[m].y * sin;
                            oTopPoints[m].y = y;
                            oTopPoints[m].z = z;

                            if (iRadius > 0) {
                                y = iUnderPoints[m].y * cos - iUnderPoints[m].z * sin;
                                z = iUnderPoints[m].z * cos + iUnderPoints[m].y * sin;
                                iUnderPoints[m].y = y;
                                iUnderPoints[m].z = z;

                                y = iTopPoints[m].y * cos - iTopPoints[m].z * sin;
                                z = iTopPoints[m].z * cos + iTopPoints[m].y * sin;
                                iTopPoints[m].y = y;
                                iTopPoints[m].z = z;
                            }
                        }

                        //遍历扇形
                        var angle, startAngle, endAngle;
                        for (j = 0; j < this.parts[i].sectors.length; j++) {
                            angle = this.parts[i].sectors[j].angle;

                            //扇体起始、结束弧度
                            startAngle = 0;
                            for (m = j; m > 0; m--) {
                                startAngle += this.parts[i].sectors[m - 1].angle;
                            }
                            endAngle = startAngle + angle;

                            //扇体起始、结束点索引
                            this.parts[i].sectors[j].startIndex = j === 0 ? Math.round(startAngle / increment) : this.parts[i].sectors[j - 1].endIndex;
                            this.parts[i].sectors[j].endIndex = Math.round(endAngle / increment);
                        }

                        this.parts[i].uCentrePoint = uCentrePoint;
                        this.parts[i].tCentrePoint = tCentrePoint;
                        this.parts[i].oUnderPoints = oUnderPoints;
                        this.parts[i].oTopPoints = oTopPoints;
                        if (iRadius > 0) {
                            this.parts[i].iUnderPoints = iUnderPoints;
                            this.parts[i].iTopPoints = iTopPoints;
                        }
                    }
                    break;
            }
        };

        /**
         * 更新标注的大小
         * @memberof GeoGlobe.Visuals.Custom.Proportion.MarkPoint.prototype
         */
        this.MarkPoint.prototype.update = function () {
            this.energy += this.velocity;
            this.energy > 1 && (this.energy = 1);

            //动画完成时更改状态
            _this.DRAWDONE = this.energy === 1;
        };

        /**
         * 判断鼠标是否悬浮在路径上
         * @memberof GeoGlobe.Visuals.Custom.Proportion.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkPoint.prototype.isPointInPath = function (context, x, y) {
            var i, j, m;
            switch (symbol) {
                case "column":
                    for (i = 0; i < this.parts.length; i++) {
                        for (j = 0; j < this.parts[i].cubes.length; j++) {
                            if (this.parts[i].cubes[j].height > 0) {
                                context.beginPath();
                                context.moveTo(this.parts[i].cubes[j].vertexs[0][0], this.parts[i].cubes[j].vertexs[0][1]);
                                context.lineTo(this.parts[i].cubes[j].vertexs[1][0], this.parts[i].cubes[j].vertexs[1][1]);
                                context.lineTo(this.parts[i].cubes[j].vertexs[1][0], this.parts[i].cubes[j].vertexs[1][1] - this.parts[i].cubes[j].height);
                                context.lineTo(this.parts[i].cubes[j].vertexs[3][0], this.parts[i].cubes[j].vertexs[3][1] - this.parts[i].cubes[j].height);
                                context.lineTo(this.parts[i].cubes[j].vertexs[3][0], this.parts[i].cubes[j].vertexs[3][1]);

                                if (context.isPointInPath(x, y)) {
                                    _this.hoveredMarkPoint = this;

                                    //高亮的柱体横向、纵向索引
                                    this.hActive = i;
                                    this.vActive = j;

                                    return;
                                }
                            }
                        }
                    }
                    break;
                case "pie":
                    //todo 暂时只绘制第一个饼状体
                    for (i = 0; i < 1; i++) {
                        var uCentrePoint = this.parts[i].uCentrePoint;
                        var tCentrePoint = this.parts[i].tCentrePoint;
                        var oUnderPoints = this.parts[i].oUnderPoints;
                        var oTopPoints = this.parts[i].oTopPoints;
                        var iUnderPoints = this.parts[i].iUnderPoints;
                        var iTopPoints = this.parts[i].iTopPoints;

                        //环状饼图
                        var ring = false;
                        if (this.parts[i].size / 2 > symbolWidth) {
                            ring = true;
                        }

                        //遍历扇形
                        var length = 50;//length个点连接成圆
                        var middleIndex = Math.round(length / 2);
                        var angles = [], startIndexes = [], endIndexes = [], colors = [];
                        for (j = 0; j < this.parts[i].sectors.length; j++) {
                            angles.push(this.parts[i].sectors[j].angle);
                            startIndexes.push(this.parts[i].sectors[j].startIndex);
                            endIndexes.push(Math.round(this.parts[i].sectors[j].endIndex * this.energy));
                            colors.push(itemColors[j] ? itemColors[j] : itemStyle.color);
                        }
                        for (j = angles.length - 1; j >= 0; j--) {
                            if (angles[j] > 0) {
                                context.beginPath();
                                if (startIndexes[j] > middleIndex) {
                                    context.moveTo(oTopPoints[endIndexes[j]].get2d().x, oTopPoints[endIndexes[j]].get2d().y);
                                    for (m = endIndexes[j] - 1; m >= startIndexes[j]; m--) {
                                        context.lineTo(oTopPoints[m].get2d().x, oTopPoints[m].get2d().y);
                                    }
                                    if (ring) {
                                        context.lineTo(iTopPoints[startIndexes[j]].get2d().x, iTopPoints[startIndexes[j]].get2d().y);
                                        for (m = startIndexes[j]; m <= endIndexes[j]; m++) {
                                            context.lineTo(iUnderPoints[m].get2d().x, iUnderPoints[m].get2d().y);
                                        }
                                        context.lineTo(iTopPoints[endIndexes[j]].get2d().x, iTopPoints[endIndexes[j]].get2d().y);
                                    } else {
                                        context.lineTo(tCentrePoint.get2d().x, tCentrePoint.get2d().y);
                                    }
                                } else if (endIndexes[j] < middleIndex) {
                                    context.moveTo(oUnderPoints[endIndexes[j]].get2d().x, oUnderPoints[endIndexes[j]].get2d().y);
                                    for (m = endIndexes[j] - 1; m >= startIndexes[j]; m--) {
                                        context.lineTo(oUnderPoints[m].get2d().x, oUnderPoints[m].get2d().y);
                                    }
                                    context.lineTo(oTopPoints[startIndexes[j]].get2d().x, oTopPoints[startIndexes[j]].get2d().y);
                                    if (ring) {
                                        for (m = startIndexes[j]; m <= endIndexes[j]; m++) {
                                            context.lineTo(iTopPoints[m].get2d().x, iTopPoints[m].get2d().y);
                                        }
                                    } else {
                                        context.lineTo(tCentrePoint.get2d().x, tCentrePoint.get2d().y);
                                    }
                                    context.lineTo(oTopPoints[endIndexes[j]].get2d().x, oTopPoints[endIndexes[j]].get2d().y);
                                } else {
                                    context.moveTo(oTopPoints[endIndexes[j]].get2d().x, oTopPoints[endIndexes[j]].get2d().y);
                                    for (m = endIndexes[j] - 1; m >= middleIndex; m--) {
                                        context.lineTo(oTopPoints[m].get2d().x, oTopPoints[m].get2d().y);
                                    }
                                    for (m = middleIndex; m >= startIndexes[j]; m--) {
                                        context.lineTo(oUnderPoints[m].get2d().x, oUnderPoints[m].get2d().y);
                                    }
                                    context.lineTo(oTopPoints[startIndexes[j]].get2d().x, oTopPoints[startIndexes[j]].get2d().y);
                                    if (ring) {
                                        for (m = startIndexes[j]; m <= middleIndex; m++) {
                                            context.lineTo(iTopPoints[m].get2d().x, iTopPoints[m].get2d().y);
                                        }
                                        for (m = middleIndex; m <= endIndexes[j]; m++) {
                                            context.lineTo(iUnderPoints[m].get2d().x, iUnderPoints[m].get2d().y);
                                        }
                                    } else {
                                        context.lineTo(tCentrePoint.get2d().x, tCentrePoint.get2d().y);
                                    }
                                }

                                if (context.isPointInPath(x, y)) {
                                    _this.hoveredMarkPoint = this;

                                    //高亮的饼图横向、纵向索引
                                    this.hActive = i;
                                    this.vActive = j;

                                    return;
                                }
                            }
                        }
                    }
                    break;
            }
        };

        /**
         * 将标注绘制到离屏canvas
         * @memberof GeoGlobe.Visuals.Custom.Proportion.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkPoint.prototype.draw = function (context) {
            var slope = _this._rendererOptions.markPoint.slope;
            this.update();

            var i, j, m;
            var drew = false;
            var color;
            switch (symbol) {
                case "column":
                    for (i = 0; i < this.parts.length; i++) {
                        for (j = 0; j < this.parts[i].cubes.length; j++) {
                            if (this.parts[i].cubes[j].height > 0) {
                                drew = true;
                                color = itemColors[j] ? itemColors[j] : itemStyle.color;

                                //鼠标悬浮时高亮
                                if (_this.hoveredMarkPoint === this && i === this.hActive && j === this.vActive) {
                                    color = GeoGlobe.Util.getShadeColor(color, 20);
                                }

                                //前
                                context.globalAlpha = opacity;
                                context.globalCompositeOperation = "source-over";
                                context.shadowBlur = 0;
                                context.shadowOffsetX = 0;
                                context.shadowOffsetY = 0;
                                context.beginPath();
                                context.moveTo(this.parts[i].cubes[j].vertexs[0][0], this.parts[i].cubes[j].vertexs[0][1]);
                                context.lineTo(this.parts[i].cubes[j].vertexs[0][0], this.parts[i].cubes[j].vertexs[0][1] - this.parts[i].cubes[j].height * this.energy);
                                context.lineTo(this.parts[i].cubes[j].vertexs[3][0], this.parts[i].cubes[j].vertexs[3][1] - this.parts[i].cubes[j].height * this.energy);
                                context.lineTo(this.parts[i].cubes[j].vertexs[3][0], this.parts[i].cubes[j].vertexs[3][1]);
                                context.closePath();
                                context.fillStyle = color;
                                context.fill();

                                if (symbolThickness !== 0) {

                                    //右
                                    context.beginPath();
                                    context.moveTo(this.parts[i].cubes[j].vertexs[0][0], this.parts[i].cubes[j].vertexs[0][1]);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[1][0], this.parts[i].cubes[j].vertexs[1][1]);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[1][0], this.parts[i].cubes[j].vertexs[1][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[0][0], this.parts[i].cubes[j].vertexs[0][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.closePath();
                                    context.fillStyle = GeoGlobe.Util.getShadeColor(color, -40);
                                    context.fill();

                                    //上
                                    context.beginPath();
                                    context.moveTo(this.parts[i].cubes[j].vertexs[0][0], this.parts[i].cubes[j].vertexs[0][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[1][0], this.parts[i].cubes[j].vertexs[1][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[2][0], this.parts[i].cubes[j].vertexs[2][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[3][0], this.parts[i].cubes[j].vertexs[3][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.closePath();
                                    context.fillStyle = GeoGlobe.Util.getShadeColor(color, -20);
                                    context.fill();

                                    //被遮住的三个面才可以绘制阴影
                                    context.shadowColor = itemStyle.shadowColor;
                                    context.shadowBlur = itemStyle.shadowBlur;
                                    context.shadowOffsetX = itemStyle.shadowOffsetX;
                                    context.shadowOffsetY = itemStyle.shadowOffsetY;

                                    //后
                                    context.globalCompositeOperation = "destination-over";
                                    context.beginPath();
                                    context.moveTo(this.parts[i].cubes[j].vertexs[1][0], this.parts[i].cubes[j].vertexs[1][1]);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[1][0], this.parts[i].cubes[j].vertexs[1][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[2][0], this.parts[i].cubes[j].vertexs[2][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[2][0], this.parts[i].cubes[j].vertexs[2][1]);
                                    context.closePath();
                                    context.fillStyle = color;
                                    context.fill();

                                    //左
                                    context.beginPath();
                                    context.moveTo(this.parts[i].cubes[j].vertexs[2][0], this.parts[i].cubes[j].vertexs[2][1]);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[2][0], this.parts[i].cubes[j].vertexs[2][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[3][0], this.parts[i].cubes[j].vertexs[3][1] - this.parts[i].cubes[j].height * this.energy);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[3][0], this.parts[i].cubes[j].vertexs[3][1]);
                                    context.closePath();
                                    context.fillStyle = GeoGlobe.Util.getShadeColor(color, -40);
                                    context.fill();

                                    //下
                                    context.beginPath();
                                    context.moveTo(this.parts[i].cubes[j].vertexs[0][0], this.parts[i].cubes[j].vertexs[0][1]);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[1][0], this.parts[i].cubes[j].vertexs[1][1]);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[2][0], this.parts[i].cubes[j].vertexs[2][1]);
                                    context.lineTo(this.parts[i].cubes[j].vertexs[3][0], this.parts[i].cubes[j].vertexs[3][1]);
                                    context.closePath();
                                    context.fillStyle = GeoGlobe.Util.getShadeColor(color, -20);
                                    context.fill();
                                }
                            }
                        }
                    }

                    //绘制基准线
                    if (drew) {

                        //x轴
                        context.lineWidth = 0.3;
                        context.globalAlpha = 1;
                        context.globalCompositeOperation = "destination-over";
                        context.shadowBlur = 0;
                        context.shadowOffsetX = 0;
                        context.shadowOffsetY = 0;
                        context.strokeStyle = '#fff';
                        context.beginPath();
                        context.moveTo(this.x - this.parts.length / 2 * symbolWidth - (this.parts.length / 2 - 0.5) * symbolGap - 5, this.y);
                        context.lineTo(this.x + this.parts.length / 2 * symbolWidth + (this.parts.length / 2 - 0.5) * symbolGap + 5, this.y);
                        context.closePath();
                        context.stroke();

                        //z轴
                        if (symbolThickness !== 0) {
                            context.beginPath();
                            context.moveTo(this.x - (symbolThickness / 2 + 5) * Math.cos(slope), this.y + (symbolThickness / 2 + 5) * Math.sin(slope));
                            context.lineTo(this.x + (symbolThickness / 2 + 5) * Math.cos(slope), this.y - (symbolThickness / 2 + 5) * Math.sin(slope));
                            context.closePath();
                            context.stroke();
                        }
                    }
                    break;
                case "pie":
                    context.globalAlpha = opacity;

                    //todo 暂时只绘制第一个饼状体
                    for (i = 0; i < 1; i++) {
                        var uCentrePoint = this.parts[i].uCentrePoint;
                        var tCentrePoint = this.parts[i].tCentrePoint;
                        var oUnderPoints = this.parts[i].oUnderPoints;
                        var oTopPoints = this.parts[i].oTopPoints;
                        var iUnderPoints = this.parts[i].iUnderPoints;
                        var iTopPoints = this.parts[i].iTopPoints;

                        //环状饼图
                        var ring = false;
                        if (this.parts[i].size / 2 > symbolWidth) {
                            ring = true;
                        }

                        //遍历扇形
                        var length = 50;//length个点连接成圆
                        var middleIndex = Math.round(length / 2);
                        var angles = [], startIndexes = [], endIndexes = [], colors = [];
                        for (j = 0; j < this.parts[i].sectors.length; j++) {
                            angles.push(this.parts[i].sectors[j].angle);
                            startIndexes.push(this.parts[i].sectors[j].startIndex);
                            endIndexes.push(Math.round(this.parts[i].sectors[j].endIndex * this.energy));
                            colors.push(itemColors[j] ? itemColors[j] : itemStyle.color);
                        }

                        //鼠标悬浮时高亮
                        for (j = angles.length - 1; j >= 0; j--) {
                            if (angles[j] > 0) {
                                if (_this.hoveredMarkPoint === this && i === this.hActive && j === this.vActive) {
                                    colors[j] = GeoGlobe.Util.getShadeColor(colors[j], 10);
                                }
                            }
                        }

                        //1 绘制扇形底面
                        for (j = angles.length - 1; j >= 0; j--) {
                            if (angles[j] > 0) {
                                context.globalCompositeOperation = "destination-over";
                                context.beginPath();
                                context.moveTo(oUnderPoints[endIndexes[j]].get2d().x, oUnderPoints[endIndexes[j]].get2d().y);
                                for (m = endIndexes[j] - 1; m >= startIndexes[j]; m--) {
                                    context.lineTo(oUnderPoints[m].get2d().x, oUnderPoints[m].get2d().y);
                                }

                                //环状
                                if (ring) {
                                    for (m = startIndexes[j]; m <= endIndexes[j]; m++) {
                                        context.lineTo(iUnderPoints[m].get2d().x, iUnderPoints[m].get2d().y);
                                    }
                                } else {
                                    context.lineTo(uCentrePoint.get2d().x, uCentrePoint.get2d().y);
                                }
                                context.fillStyle = colors[j];
                                context.fill();
                            }
                        }

                        //绘制3d饼图
                        if (slope !== 0) {

                            //2 绘制扇形连接面
                            for (j = angles.length - 1; j >= 0; j--) {
                                if (angles[j] > 0) {
                                    context.globalCompositeOperation = "source-over";
                                    context.beginPath();
                                    context.moveTo(oUnderPoints[endIndexes[j]].get2d().x, oUnderPoints[endIndexes[j]].get2d().y);
                                    if (ring) {
                                        context.lineTo(iUnderPoints[endIndexes[j]].get2d().x, iUnderPoints[endIndexes[j]].get2d().y);
                                        context.lineTo(iTopPoints[endIndexes[j]].get2d().x, iTopPoints[endIndexes[j]].get2d().y);
                                    } else {
                                        context.lineTo(uCentrePoint.get2d().x, uCentrePoint.get2d().y);
                                        context.lineTo(tCentrePoint.get2d().x, tCentrePoint.get2d().y);
                                    }
                                    context.lineTo(oTopPoints[endIndexes[j]].get2d().x, oTopPoints[endIndexes[j]].get2d().y);
                                    context.moveTo(oUnderPoints[startIndexes[j]].get2d().x, oUnderPoints[startIndexes[j]].get2d().y);
                                    if (ring) {
                                        context.lineTo(iUnderPoints[startIndexes[j]].get2d().x, iUnderPoints[startIndexes[j]].get2d().y);
                                        context.lineTo(iTopPoints[startIndexes[j]].get2d().x, iTopPoints[startIndexes[j]].get2d().y);
                                    } else {
                                        context.lineTo(uCentrePoint.get2d().x, uCentrePoint.get2d().y);
                                        context.lineTo(tCentrePoint.get2d().x, tCentrePoint.get2d().y);
                                    }
                                    context.lineTo(oTopPoints[startIndexes[j]].get2d().x, oTopPoints[startIndexes[j]].get2d().y);
                                    context.fillStyle = GeoGlobe.Util.getShadeColor(colors[j], -20);
                                    context.fill();
                                }
                            }

                            //3 绘制扇形内壁
                            if (ring) {
                                for (j = angles.length - 1; j >= 0; j--) {
                                    if (angles[j] > 0) {
                                        context.globalCompositeOperation = "source-over";
                                        context.beginPath();
                                        context.moveTo(iUnderPoints[endIndexes[j]].get2d().x, iUnderPoints[endIndexes[j]].get2d().y);
                                        if (startIndexes[j] < middleIndex && endIndexes[j] > middleIndex) {
                                            for (m = endIndexes[j] - 1; m >= middleIndex; m--) {
                                                context.lineTo(iUnderPoints[m].get2d().x, iUnderPoints[m].get2d().y);
                                            }
                                            for (m = middleIndex; m <= endIndexes[j]; m++) {
                                                context.lineTo(iTopPoints[m].get2d().x, iTopPoints[m].get2d().y);
                                            }
                                            context.moveTo(iUnderPoints[startIndexes[j]].get2d().x, iUnderPoints[startIndexes[j]].get2d().y);
                                            for (m = startIndexes[j] + 1; m <= middleIndex; m++) {
                                                context.lineTo(iUnderPoints[m].get2d().x, iUnderPoints[m].get2d().y);
                                            }
                                            for (m = middleIndex; m >= startIndexes[j]; m--) {
                                                context.lineTo(iTopPoints[m].get2d().x, iTopPoints[m].get2d().y);
                                            }
                                        } else {
                                            for (m = endIndexes[j] - 1; m >= startIndexes[j]; m--) {
                                                context.lineTo(iUnderPoints[m].get2d().x, iUnderPoints[m].get2d().y);
                                            }
                                            for (m = startIndexes[j]; m <= endIndexes[j]; m++) {
                                                context.lineTo(iTopPoints[m].get2d().x, iTopPoints[m].get2d().y);
                                            }
                                        }
                                        context.fillStyle = GeoGlobe.Util.getShadeColor(colors[j], -20);
                                        context.fill();
                                    }
                                }
                            }

                            //4 绘制扇形外壁
                            for (j = angles.length - 1; j >= 0; j--) {
                                if (angles[j] > 0) {
                                    if (startIndexes[j] < middleIndex && endIndexes[j] > middleIndex) {
                                        context.globalCompositeOperation = "destination-over";
                                        context.beginPath();
                                        context.moveTo(oUnderPoints[endIndexes[j]].get2d().x, oUnderPoints[endIndexes[j]].get2d().y);
                                        for (m = endIndexes[j] - 1; m >= middleIndex; m--) {
                                            context.lineTo(oUnderPoints[m].get2d().x, oUnderPoints[m].get2d().y);
                                        }
                                        for (m = middleIndex; m <= endIndexes[j]; m++) {
                                            context.lineTo(oTopPoints[m].get2d().x, oTopPoints[m].get2d().y);
                                        }
                                        context.fillStyle = GeoGlobe.Util.getShadeColor(colors[j], -20);
                                        context.fill();

                                        context.globalCompositeOperation = "source-over";
                                        context.beginPath();
                                        context.moveTo(oUnderPoints[startIndexes[j]].get2d().x, oUnderPoints[startIndexes[j]].get2d().y);
                                        for (m = startIndexes[j] + 1; m <= middleIndex; m++) {
                                            context.lineTo(oUnderPoints[m].get2d().x, oUnderPoints[m].get2d().y);
                                        }
                                        for (m = middleIndex; m >= startIndexes[j]; m--) {
                                            context.lineTo(oTopPoints[m].get2d().x, oTopPoints[m].get2d().y);
                                        }
                                        context.fillStyle = GeoGlobe.Util.getShadeColor(colors[j], -20);
                                        context.fill();
                                    } else {
                                        context.globalCompositeOperation = "source-over";
                                        context.beginPath();
                                        context.moveTo(oUnderPoints[endIndexes[j]].get2d().x, oUnderPoints[endIndexes[j]].get2d().y);
                                        for (m = endIndexes[j] - 1; m >= startIndexes[j]; m--) {
                                            context.lineTo(oUnderPoints[m].get2d().x, oUnderPoints[m].get2d().y);
                                        }
                                        for (m = startIndexes[j]; m <= endIndexes[j]; m++) {
                                            context.lineTo(oTopPoints[m].get2d().x, oTopPoints[m].get2d().y);
                                        }
                                        context.fillStyle = GeoGlobe.Util.getShadeColor(colors[j], -20);
                                        context.fill();
                                    }
                                }
                            }

                            //5 绘制扇形顶面
                            for (j = angles.length - 1; j >= 0; j--) {
                                if (angles[j] > 0) {
                                    context.globalCompositeOperation = "source-over";
                                    context.beginPath();
                                    context.moveTo(oTopPoints[endIndexes[j]].get2d().x, oTopPoints[endIndexes[j]].get2d().y);
                                    for (m = endIndexes[j] - 1; m >= startIndexes[j]; m--) {
                                        context.lineTo(oTopPoints[m].get2d().x, oTopPoints[m].get2d().y);
                                    }

                                    //环状
                                    if (ring) {
                                        for (m = startIndexes[j]; m <= endIndexes[j]; m++) {
                                            context.lineTo(iTopPoints[m].get2d().x, iTopPoints[m].get2d().y);
                                        }
                                    } else {
                                        context.lineTo(tCentrePoint.get2d().x, tCentrePoint.get2d().y);
                                    }
                                    context.fillStyle = colors[j];
                                    context.fill();
                                }
                            }
                        }
                    }
                    break;
            }
        };
    },

    /**
     * 画布初始化
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @private
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));

        this.canvas[0].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);
        this.setVisible(this.visibility);
    },

    /**
     * 悬浮提示框初始化
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @private
     */
    _initTooltip: function () {
        if ((this._rendererOptions.markPoint.hoverable || this._rendererOptions.markPoint.clickable) && this._rendererOptions.tooltip.show) {
            this.tooltipDiv = this.tooltipDiv || this.div.appendChild(document.createElement('div'));
            this.tooltipDiv.style.position = "relative";
            this.tooltipDiv.style.display = "none";
            this.tooltipDiv.style.zIndex = 999;
            this.tooltipDiv.style.width = this._rendererOptions.tooltip.width + 'px';
            this.tooltipDiv.style.color = this._rendererOptions.tooltip.textStyle.color;
            this.tooltipDiv.style.padding = this._rendererOptions.tooltip.padding.toString().split(' ').join('px ') + 'px';
            this.tooltipDiv.style.font = this._rendererOptions.tooltip.textStyle.fontStyle + ' ' + this._rendererOptions.tooltip.textStyle.fontWeight + ' ' + this._rendererOptions.tooltip.textStyle.fontSize + 'px ' + this._rendererOptions.tooltip.textStyle.fontFamily;

            //(IE8-)不兼容rgba问题处理
            if (document.createElement('canvas').getContext) {
                this.tooltipDiv.style["background-color"] = this._rendererOptions.tooltip.backgroundColor;
            } else {
                this.tooltipDiv.style["background-color"] = GeoGlobe.Util.getRgbColor(this._rendererOptions.tooltip.backgroundColor);
            }

            this.tooltipDiv.style["border-width"] = this._rendererOptions.tooltip.borderWidth + "px";
            this.tooltipDiv.style["border-color"] = this._rendererOptions.tooltip.borderColor;
            this.tooltipDiv.style["border-radius"] = this._rendererOptions.tooltip.borderRadius + "px";
            this.tooltipDiv.style["border-style"] = "solid";
            this.tooltipDiv.style['white-space'] = "nowrap";
            this.tooltipDiv.style["box-shadow"] = "rgba(0, 0, 0, 0.2) 0px 10px 10px";
            this.tooltipDiv.style["transition"] = "left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)";

            this.tooltipDiv.innerHTML = '<h3 style="opacity:0.9;margin:0;padding-bottom:8px;border-bottom:1px solid ' + this._rendererOptions.tooltip.textStyle.color + ';overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"><span></span><span style="float: right;"></span></h3>' +
                '<ul style="list-style-type:none;opacity:0.8;margin:0;padding:6px 18px 0 0;"></ul>';
        }
    },

    /**
     * 渲染图层
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    render: function () {
        this._init_Legend();
        this._init_RendererOptions();
        this._initMarkPoint();
        this._initTooltip();
        this.setData(this.data);
        this.draw();
    },

    /**
     * 图层绘制
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    draw: function () {
        this.updateCountValueMinMaxSum();
        this.updateXY();
        this.drawCanvas();
        this.drawLegend();

        //动画
        this.frame && cancelAnimationFrame(this.frame);
        var _this = this;
        (function animate() {
            _this.frame = requestAnimationFrame(animate);

            //动画未完成，继续绘制
            !_this.DRAWDONE && _this.drawCanvas();
        })();
    },

    /**
     * 图层（地图）移动时触发
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    onMove: function () {
        this._rendererOptions.markPoint.slope = this._parent.map.getPitch() * Math.PI / 180;
        this.updateXY();
        this.drawCanvas();
    },

    /**
     * 图层（地图）移动结束触发
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    onMoveEnd: function () {
        this.redraw();
    },

    /**
     * 鼠标指针单击事件
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @param {Object} event 事件参数
     */
    onClick: function (event) {
        this._rendererOptions.markPoint.clickable && this.hoveredMarkPoint && this._parent.fire("overlayerclick", {
            layer: this,
            feature: this.hoveredMarkPoint,
            event: event
        });
    },

    /**
     * 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @param {Object} event 事件参数
     */
    onMouseMove: function (event) {
        if (this._rendererOptions.markPoint.hoverable && this.visibility && this.markPoints.length > 0 && !this._parent.map.moving) {
            this.hover(event.point.x, event.point.y);

            this.hoveredMarkPoint && this._parent.fire("overlayerhover", {
                layer: this,
                feature: this.hoveredMarkPoint,
                event: event
            });
        }
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    onResize: function () {
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this._parent.map.transform.height;
        this.redraw();
    },

    /**
     * 图层重绘
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    redraw: function () {
        this.clearCanvas();

        this.updateCountValueMinMaxSum();
        this.updateXY();
        this.drawCanvas();
        this.drawLegend();
    },

    /**
     * 重新计算标注的屏幕坐标
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    updateXY: function () {
        var i = this.markPoints.length;
        while (i--) {
            this.SWITCH && this.markPoints[i].init();
            !this.SWITCH && this.markPoints[i].updateXY();
            this.markPoints[i].updateSize();
            this.markPoints[i].updatePartXY();
        }
        this.SWITCH = false;
    },

    /**
     * 绘制标注到画布
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    drawCanvas: function () {
        this.cacheCanvas[0].width = this.width;

        var i = this.markPoints.length;
        while (i--) {
            this.markPoints[i].draw(this.cacheCanvasContext[0]);
        }

        this.canvas[0].width = this.width;
        this.canvasContext[0].drawImage(this.cacheCanvas[0], 0, 0);
    },

    /**
     * 绘制图例
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    drawLegend: function () {
        if (this._legend && this._legend.show) {
            //创建图例div
            if (!this.legendDiv) {

                //外层div
                this.legendDiv = document.createElement('div');
                this.legendDiv.style.display = this.visibility ? "block" : "none";//跟随图层默认显示隐藏
                this.legendDiv.style.zIndex = 9999;
                this.legendDiv.style.position = "absolute";
                this.legendDiv.style["background-color"] = this._legend.backgroundColor;
                this.legendDiv.style["border-color"] = this._legend.borderColor;
                this.legendDiv.style["border-width"] = this._legend.borderWidth + 'px';
                this.legendDiv.style["border-radius"] = this._legend.borderRadius + 'px';
                this.legendDiv.style["border-style"] = 'solid';
                this.legendDiv.style["box-shadow"] = this._legend.shadowOffsetX + 'px ' + this._legend.shadowOffsetY + 'px ' + this._legend.shadowBlur + 'px ' + this._legend.shadowColor;
                this.legendDiv.style.padding = this._legend.padding + 'px';

                //设置方位
                this.legendDiv.style.left = this._legend.left !== null ? this._legend.left + 'px' : null;
                this.legendDiv.style.right = this._legend.right !== null ? this._legend.right + 'px' : null;
                this.legendDiv.style.top = this._legend.top !== null ? this._legend.top + 'px' : null;
                this.legendDiv.style.bottom = this._legend.bottom !== null ? this._legend.bottom + 'px' : null;

                //内层canvas
                this.legendCanvas = document.createElement('canvas');
                this.legendCanvasContext = this.legendCanvas.getContext("2d");

                //解决底部有3px间距的问题
                this.legendCanvas.style.display = 'block';

                //设置好字体，以便测量canvas所需宽高
                this.legendCanvasContext.font = this._legend.textStyle.fontStyle + ' ' + this._legend.textStyle.fontWeight + ' ' + this._legend.textStyle.fontSize + 'px ' + this._legend.textStyle.fontFamily;

                this.legendDiv.appendChild(this.legendCanvas);
                this._parent.container.parentNode.parentNode.parentNode.appendChild(this.legendDiv);
            }

            //计算图例每列的最大宽度
            var legendColumnWidths = [];
            var legendColumnWidth = null;
            for (var i = 0, len1 = this._legend.vLegendLabels.length; i < len1; i++) {
                legendColumnWidth = this._legend.itemWidth + 10 + this.legendCanvasContext.measureText(this._legend.vLegendLabels[i].toString()).width;

                var len2 = this._legend.col;
                for (var j = 0; j < len2; j++) {
                    if (i % this._legend.col === j) {
                        (!legendColumnWidths[j] || legendColumnWidths[j] < legendColumnWidth) && (legendColumnWidths[j] = legendColumnWidth);
                    }
                }
            }

            //计算canvas大小
            var width = 10, height = 10;
            for (var i = 0, len = legendColumnWidths.length; i < len; i++) {
                width += legendColumnWidths[i] + 10;
            }
            height += ((this._legend.itemHeight < this._legend.textStyle.fontSize ? this._legend.textStyle.fontSize : this._legend.itemHeight) + 10) * (~~(this._legend.vLegendLabels.length / this._legend.col) + (this._legend.vLegendLabels.length % this._legend.col === 0 ? 0 : 1));

            //设置canvas的大小
            this.legendCanvas.width = width;
            this.legendCanvas.height = height;

            /**
             * @method
             * @desc 绘制图例
             * @param {String} mouseType 鼠标事件类型
             * @param {Number} mouseX 鼠标x位置
             * @param {Number} mouseY 鼠标y位置
             */
            var draw = function (mouseType, mouseX, mouseY) {
                this.legendCanvas.width = width;

                var hasHover = false;
                var hasClick = false;
                var x, y;
                for (var i = 0, len1 = this._legend.vLegendLabels.length; i < len1; i++) {
                    for (var j = 0, len2 = this._legend.col; j < len2; j++) {
                        if (i % this._legend.col === j) {
                            x = 10 + this._legend.itemWidth / 2;
                            for (var m = 0; m < j; m++) {
                                x += legendColumnWidths[m] + 10;
                            }
                        }
                    }

                    y = 10 + this._legend.itemHeight / 2 + ((this._legend.itemHeight < this._legend.textStyle.fontSize ? this._legend.textStyle.fontSize : this._legend.itemHeight) + 10) * ~~(i / this._legend.col);

                    //判断鼠标是否悬浮/是否点击在图例项/图例项标签上
                    var hover = false;
                    var click = false;
                    this.legendCanvasContext.beginPath();
                    this.legendCanvasContext.rect(x - this._legend.itemWidth / 2, y - this._legend.itemHeight / 2, this._legend.itemWidth, this._legend.itemHeight);
                    if (mouseType === "mousemove" && mouseX !== void 0 && mouseY !== void 0 && this.legendCanvasContext.isPointInPath(mouseX, mouseY)) hover = true, hasHover = true;
                    if (mouseType === "mousedown" && mouseX !== void 0 && mouseY !== void 0 && this.legendCanvasContext.isPointInPath(mouseX, mouseY)) click = true, hasClick = true;
                    this.legendCanvasContext.beginPath();
                    this.legendCanvasContext.font = this._legend.textStyle.fontStyle + ' ' + this._legend.textStyle.fontWeight + ' ' + this._legend.textStyle.fontSize + 'px ' + this._legend.textStyle.fontFamily;
                    this.legendCanvasContext.rect(x + this._legend.itemWidth / 2 + 10, y - this._legend.textStyle.fontSize / 2, this.legendCanvasContext.measureText(this._legend.vLegendLabels[i].toString()).width, this._legend.textStyle.fontSize);
                    if (mouseType === "mousemove" && mouseX !== void 0 && mouseY !== void 0 && this.legendCanvasContext.isPointInPath(mouseX, mouseY)) hover = true, hasHover = true;
                    if (mouseType === "mousedown" && mouseX !== void 0 && mouseY !== void 0 && this.legendCanvasContext.isPointInPath(mouseX, mouseY)) click = true, hasClick = true;

                    //切换图例项的开启与关闭，并与图层联动
                    if (click) {
                        this._legend.itemStatuses[i] = this._legend.itemStatuses[i] === 0 ? 1 : 0;
                        this.SWITCH = true;
                        this.redraw();
                    }

                    //更新图例项的颜色
                    var itemColor = this._legend.itemStatuses[i] === 0 ? '#808080' : this._legend.itemColors[i] ? this._legend.itemColors[i] : this._rendererOptions.markPoint.itemStyle.color;
                    var fontColor = this._legend.itemStatuses[i] === 0 ? '#808080' : this._legend.textStyle.color;
                    itemColor = hover || click ? GeoGlobe.Util.getShadeColor(itemColor, 20) : itemColor;
                    fontColor = hover || click ? GeoGlobe.Util.getShadeColor(fontColor, 20) : fontColor;

                    //绘制图例项
                    this.legendCanvasContext.beginPath();
                    this.legendCanvasContext.rect(x - this._legend.itemWidth / 2, y - this._legend.itemHeight / 2, this._legend.itemWidth, this._legend.itemHeight);
                    this.legendCanvasContext.fillStyle = itemColor;
                    this.legendCanvasContext.fill();

                    this.legendCanvasContext.font = this._legend.textStyle.fontStyle + ' ' + this._legend.textStyle.fontWeight + ' ' + this._legend.textStyle.fontSize + 'px ' + this._legend.textStyle.fontFamily;
                    this.legendCanvasContext.textAlign = 'left';
                    this.legendCanvasContext.textBaseline = 'middle';
                    this.legendCanvasContext.fillStyle = fontColor;
                    this.legendCanvasContext.fillText(this._legend.vLegendLabels[i], x + this._legend.itemWidth / 2 + 10, y);
                }

                //更新鼠标形状
                if (hasHover) {
                    this.legendCanvas.style.cursor = "pointer";
                } else {
                    this.legendCanvas.style.cursor = "default";
                }

                //todo 触发图例选中状态改变事件
                // hasClick && this._parent.fire('legendselectchanged', {
                //     layer: this,
                //     legend: {
                //         'hLegendLabels': this._legend.hLegendLabels,
                //         'vLegendLabels': this._legend.vLegendLabels,
                //         'statuses': this._legend.itemStatuses
                //     }
                // });
            }.bind(this);

            //鼠标按下
            this.legendCanvas.onmousedown = function (evt) {
                var mouseX = evt.offsetX || (evt.clientX - (evt.target || evt.srcElement).getBoundingClientRect().left);
                var mouseY = evt.offsetY || (evt.clientY - (evt.target || evt.srcElement).getBoundingClientRect().top);
                draw(evt.type, mouseX, mouseY);
            };

            //鼠标移动
            this.legendCanvas.onmousemove = function (evt) {
                var mouseX = evt.offsetX || (evt.clientX - (evt.target || evt.srcElement).getBoundingClientRect().left);
                var mouseY = evt.offsetY || (evt.clientY - (evt.target || evt.srcElement).getBoundingClientRect().top);
                draw(evt.type, mouseX, mouseY);
            };

            //绘制图例
            draw();
        }
    },

    /**
     * 根据图例项的状态更新各度量值合计
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    updateCountValueMinMaxSum: function () {
        this.measureValueMinSum = Infinity;
        this.measureValueMaxSum = -Infinity;

        var i, m, n, len, len1, len2;
        var measureValueSum;
        for (i = 0, len = this.markPoints.length; i < len; i++) {
            this.markPoints[i].measureValueSums = [];
            for (m = 0, len1 = this.markPoints[i].measureValues.length; m < len1; m++) {
                measureValueSum = 0;
                for (n = 0, len2 = this.markPoints[i].measureValues[m].length; n < len2; n++) {
                    this._legend.itemStatuses[n] !== 0 && (measureValueSum += this.markPoints[i].measureValues[m][n]);
                }
                this.markPoints[i].measureValueSums.push(measureValueSum);
                measureValueSum < this.measureValueMinSum && (this.measureValueMinSum = measureValueSum);
                measureValueSum > this.measureValueMaxSum && (this.measureValueMaxSum = measureValueSum);
            }
        }
    },

    /**
     * 画布清空
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    clearCanvas: function () {
        this.canvas[0].width = this.cacheCanvas[0].width = this.width;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    destroy: function () {
        //先停动画，再移Dom，再重置属性
        cancelAnimationFrame(this.frame);

        this._parent.container.removeChild(this.div);

        this.MarkPoint = null;
        this.markPoints = [];
        this.canvas = [];
        this.data = [];
        this.cacheCanvas = [];
        this.canvasContext = [];
        this.cacheCanvasContext = [];
        this._rendererOptions = {};
    },

    /**
     * 鼠标悬浮时触发
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @param {Number} x 鼠标在主画布上的位置（x轴方向）
     * @param {Number} y 鼠标在主画布上的位置（y轴方向）
     */
    hover: function (x, y) {
        this.lastHoveredMarkPoint = this.hoveredMarkPoint ? GeoGlobe.Util.clone(this.hoveredMarkPoint) : null;
        this.hoveredMarkPoint = null;

        for (var i = 0, len = this.markPoints.length; i < len; i++) {
            !this.hoveredMarkPoint && this.markPoints[i].isPointInPath(this.cacheCanvasContext[0], x, y);
        }

        this.drawCanvas();

        //显示悬浮提示框
        if (this.hoveredMarkPoint) {
            this.canvas[0].style.cursor = "pointer";
            this.showTooltip(this.hoveredMarkPoint, x, y);
        } else {
            this.canvas[0].style.cursor = "default";
            this.hideTooltip();
        }
    },

    /**
     * 显示悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @param {Object} markPoint 要提示的标注
     * @param {Number} x 鼠标在画布上的位置（x轴方向）
     * @param {Number} y 鼠标在画布上的位置（y轴方向）
     * @ignore
     */
    showTooltip: function (markPoint, x, y) {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.getElementsByTagName('span')[0].textContent = this._legend.hLegendLabels[markPoint.hActive];
            this.tooltipDiv.getElementsByTagName('span')[1].textContent = markPoint.name;

            var ul = this.tooltipDiv.getElementsByTagName('ul')[0];
            ul.innerHTML = '';
            for (var i = 0; i < this._legend.vLegendLabels.length; i++) {
                if (this._legend.itemStatuses[i] !== 0) {
                    ul.innerHTML += '<li style="line-height:20px;' + (i === markPoint.vActive ? '' : 'opacity:0.6;') + '">' +
                        '<div style="width: 12px;height: 12px;margin: 5px 5px 0 0;float: left;background-color: ' + (this._legend.itemColors[i] ? this._legend.itemColors[i] : this._rendererOptions.markPoint.itemStyle.color) + ';">' +
                        '</div><span style="font-weight: 600;">'
                        + this._legend.vLegendLabels[i] + '：</span><span>' + this._rendererOptions.tooltip.formatter.replace("{0}",markPoint.measureValues[markPoint.hActive][i])   + '</span></li>';
                }
            }
            this.tooltipDiv.style.top = (y - 15) + "px";
            this.tooltipDiv.style.left = (x + 15) + "px";
            this.tooltipDiv.style.display = "block";
        }
    },

    /**
     * 关闭悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     */
    hideTooltip: function () {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.style.display = "none";
        }
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this._parent.map.transform.height;
    },

    /**
     * 图层、图例的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = visibility ? "block" : "none";
        this.legendDiv && (this.legendDiv.style.display = visibility ? "block" : "none");
    },

    /**
     * 数据的处理，构造标注对象
     * @memberof GeoGlobe.Visuals.Custom.Proportion.prototype
     * @param {Array} data 数据
     */
    setData: function (data) {
        this.data = data;

        var markPoints = [];
        for (var i = 0; i < data.length; i++) {
            var measureValues = [];
            for (var m = 0; m < this._legend.hLegendLabels.length; m++) {
                measureValues[m] = [];
                for (var n = 0; n < this._legend.vLegendLabels.length; n++) {
                    measureValues[m][n] = Number(data[i].properties[this._legend.hLegendLabels[m]][this._legend.vLegendLabels[n]] || 0);
                }
            }
            markPoints.push(new this.MarkPoint(i, data[i].properties.name, measureValues, data[i].geometry.coordinates[0], data[i].geometry.coordinates[1]));
        }
        this.markPoints = markPoints;
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Custom.Voronoi
 * @classdesc 泰森多边形图层
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.dragdrawing 拖动图层时是否绘制
 * @param {Boolean} options.data 数据，geojson格式
 * @param {Object} options.boundsURL 边界数据url
 * @param {Object} options.rendererOptions 渲染配置
 * @param {Object} options.rendererOptions.markFace 标面
 * @param {Boolean} options.rendererOptions.markFace.hoverable 是否启用鼠标悬浮
 * @param {Boolean} options.rendererOptions.markFace.clickable 是否启用鼠标点击
 * @param {Object} options.rendererOptions.markFace.itemStyle 图形样式属性
 * @param {String} options.rendererOptions.markFace.itemStyle.color 颜色，支持单色和渐变色
 * @param {String} options.rendererOptions.markFace.itemStyle.borderColor 边框颜色
 * @param {Number} options.rendererOptions.markFace.itemStyle.borderWidth 边框宽度
 * @param {String} options.rendererOptions.markFace.itemStyle.shadowColor 阴影颜色
 * @param {Number} options.rendererOptions.markFace.itemStyle.shadowBlur 阴影模糊度
 * @param {Number} options.rendererOptions.markFace.itemStyle.shadowOffsetX 阴影偏移量X
 * @param {Number} options.rendererOptions.markFace.itemStyle.shadowOffsetY 阴影偏移量Y
 * @param {Object} options.rendererOptions.tooltip 悬浮提示
 * @param {Boolean} options.rendererOptions.tooltip.show 是否显示悬浮提示框
 * @param {String} options.rendererOptions.tooltip.backgroundColor 背景颜色
 * @param {String} options.rendererOptions.tooltip.borderColor 边框颜色
 * @param {Number} options.rendererOptions.tooltip.borderRadius 边框圆角
 * @param {Number} options.rendererOptions.tooltip.borderWidth 边框宽度
 * @param {Number} options.rendererOptions.tooltip.padding 内边距
 * @param {Object} options.rendererOptions.tooltip.textStyle 文字样式
 * @param {String} options.rendererOptions.tooltip.textStyle.color 颜色
 * @param {String} options.rendererOptions.tooltip.textStyle.fontFamily 字体系列
 * @param {Number} options.rendererOptions.tooltip.textStyle.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.tooltip.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.tooltip.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 *
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //通过jquery加载json数据
 $.getJSON('../../data/capital.json', function (result) {
    //构造泰森多边形图层
    var voronoi = new GeoGlobe.Visuals.Custom.Voronoi({
        id: "voronoi_1",
        visibility: true,
        data: result,
        boundsURL: "../../data/china.json",
        rendererOptions: {
            markFace: {
                itemStyle: {
                    color: {
                        '0': 'rgba(255, 0, 0, 0.3)',
                        '0.5': 'rgba(255, 128, 0, 0.3)',
                        '1': 'rgba(255, 255, 128, 0.3)'
                    },//'rgba(255,0,0,0)',
                    borderColor: 'rgba(255,255,255,0.5)'
                }
            }
        }
    });
    //添加到可视化定制图层
    voronoi.addTo(custom);
    //绘制
    custom.render();
 });
 */
GeoGlobe.Visuals.Custom.Voronoi = GeoGlobe.Class4OL({

    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @type {Array}
     */
    canvas: [],

    /**
     * 离屏画布集合
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @type {Array}
     */
    cacheCanvas: [],

    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @type {Array}
     */
    canvasContext: [],

    /**
     * 离屏画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @type {Array}
     */
    cacheCanvasContext: [],

    /**
     * 标面类
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @type {Function}
     */
    MarkFace: null,

    /**
     * 标面对象集
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @type {Array}
     */
    markFaces: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @private
     */
    _initContainer: function () {
        this.div = document.createElement("div");
        this.div.setAttribute("id", this.id);
        this.div.setAttribute("style", "position:absolute");
    },

    /**
     * 初始化渲染配置
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @private
     */
    _init_RendererOptions: function () {
        this._rendererOptions = GeoGlobe.Util.deepExtend({}, {
            markFace: {
                hoverable: true,
                clickable: true,
                itemStyle: {
                    color: 'rgba(255,0,0,0)',
                    borderColor: '#000',
                    borderWidth: 1,
                    shadowColor: '#000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                }
            },
            tooltip: {
                show: true,
                backgroundColor: '#fff',
                borderColor: '#333',
                borderRadius: 0,
                borderWidth: 0,
                padding: 10,
                textStyle: {
                    color: "#000",
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            }
        }, this.rendererOptions);
    },

    /**
     * 定义标面类
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @private
     */
    _initMarkFace: function () {
        var _this = this;

        var itemStyle = this._rendererOptions.markFace.itemStyle;
        if (typeof itemStyle.color === "object") {
            var gradientImageData = GeoGlobe.Util.getGradientImageData(itemStyle.color);
        }

        /**
         * 构造一个标面实例
         * @param {Number} index 索引号
         * @param {String} name 字段名
         * @param {Number} value 统计值
         * @param {Number} lon 经度
         * @param {Number} lat 纬度
         * @param {Array} polygons 泰森多边形顶点数据
         */
        this.MarkFace = function (index, name, value, lon, lat, polygons) {
            this.index = index;
            this.name = name;
            this.value = value;
            this.lon = lon;
            this.lat = lat;
            this.polygons = polygons;
            this.vertices = [];

            this.color = typeof itemStyle.color === "object" ? 'rgba(' + gradientImageData[parseInt(value * 255, 10) * 4] + ',' + gradientImageData[parseInt(value * 255, 10) * 4 + 1] + ',' + gradientImageData[parseInt(value * 255, 10) * 4 + 2] + ',' + gradientImageData[3] / 255 + ')' : itemStyle.color;
        };

        /**
         * 更新标面的位置
         * @memberof GeoGlobe.Visuals.Custom.Voronoi.MarkFace.prototype
         */
        this.MarkFace.prototype.updateXY = function () {
            var point = _this._parent.map.project([this.lon, this.lat]);
            this.x = point.x;
            this.y = point.y;

            var vertex;
            this.vertices = [];
            this.polygons.map(function (polygon) {
                polygon.geometry.coordinates.map(function (poly) {
                    vertex = [];

                    (polygon.geometry.type === "MultiPolygon" ? poly[0] : poly).map(function (p) {
                        point = _this._parent.map.project(p);
                        vertex.push([point.x, point.y]);
                    });

                    this.vertices.push(vertex);
                }.bind(this));
            }.bind(this));
        };

        /**
         * 判断鼠标是否悬浮在路径上
         * @memberof GeoGlobe.Visuals.Custom.Voronoi.MarkFace.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkFace.prototype.isPointInPath = function (context, x, y) {
            context.beginPath();
            this.vertices.map(function (vertices) {
                context.moveTo(vertices[0][0], vertices[0][1]);
                vertices.map(function (vertex) {
                    context.lineTo(vertex[0], vertex[1]);
                });
            });
            context.closePath();

            if (context.isPointInPath(x, y)) {
                _this.hoveredMarkFace = this;
            }
        };

        /**
         * 将标注绘制到离屏画布
         * @memberof GeoGlobe.Visuals.Custom.Voronoi.MarkFace.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkFace.prototype.draw = function (context) {
            context.shadowColor = itemStyle.shadowColor;
            context.shadowBlur = itemStyle.shadowBlur;
            context.shadowOffsetX = itemStyle.shadowOffsetX;
            context.shadowOffsetY = itemStyle.shadowOffsetY;

            context.beginPath();
            this.vertices.map(function (vertices) {
                context.moveTo(vertices[0][0], vertices[0][1]);
                vertices.map(function (vertex) {
                    context.lineTo(vertex[0], vertex[1]);
                });
            });
            context.closePath();

            context.fillStyle = _this.hoveredMarkFace === this ? GeoGlobe.Util.getShadeColor(this.color, 20) : this.color;
            context.strokeStyle = itemStyle.borderColor;
            context.lineWidth = itemStyle.borderWidth;
            context.stroke();
            context.fill();

            // context.beginPath();
            // context.arc(this.x, this.y, 1, 0, Math.PI * 2, false);
            // context.fillStyle = "#fff";
            // context.fill();
        };
    },

    /**
     * 加载边界数据
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @private
     */
    _initBounds: function () {
        var me = this;
        var xhr = new XMLHttpRequest();
        xhr.open("GET", this.boundsURL, true);
        xhr.responseType = "json";
        xhr.onload = function (e) {
            switch (this.response.features[0].geometry.type) {
                case "Polygon":
                    me.bounds = this.response.features;
                    break;
                case "MultiPolygon":
                    me.bounds = [];
                    var polygons = this.response.features[0].geometry.coordinates;
                    for (var i = 0; i < polygons.length; i++) {
                        me.bounds.push(turf.polygon(polygons[i]));
                    }
                    break;
            }
        };
        xhr.send();
    },

    /**
     * 画布初始化
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @private
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));

        this.canvas[0].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);
        this.setVisible(this.visibility);
    },

    /**
     * 悬浮提示框初始化
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @private
     */
    _initTooltip: function () {
        if ((this._rendererOptions.markFace.hoverable || this._rendererOptions.markFace.clickable) && this._rendererOptions.tooltip.show) {
            this.tooltipDiv = this.tooltipDiv || this.div.appendChild(document.createElement('div'));
            this.tooltipDiv.style.position = "relative";
            this.tooltipDiv.style.display = "none";
            this.tooltipDiv.style.zIndex = 999;
            this.tooltipDiv.style.color = this._rendererOptions.tooltip.textStyle.color;
            this.tooltipDiv.style.padding = this._rendererOptions.tooltip.padding + "px";
            this.tooltipDiv.style.font = this._rendererOptions.tooltip.textStyle.fontStyle + ' ' + this._rendererOptions.tooltip.textStyle.fontWeight + ' ' + this._rendererOptions.tooltip.textStyle.fontSize + 'px ' + this._rendererOptions.tooltip.textStyle.fontFamily;

            //(IE8-)不兼容rgba问题处理
            if (document.createElement('canvas').getContext) {
                this.tooltipDiv.style["background-color"] = this._rendererOptions.tooltip.backgroundColor;
            } else {
                this.tooltipDiv.style["background-color"] = GeoGlobe.Util.getRgbColor(this._rendererOptions.tooltip.backgroundColor);
            }

            this.tooltipDiv.style["border-width"] = this._rendererOptions.tooltip.borderWidth + "px";
            this.tooltipDiv.style["border-color"] = this._rendererOptions.tooltip.borderColor;
            this.tooltipDiv.style["border-radius"] = this._rendererOptions.tooltip.borderRadius + "px";
            this.tooltipDiv.style["border-style"] = "solid";
            this.tooltipDiv.style['white-space'] = "nowrap";
            this.tooltipDiv.style["box-shadow"] = "rgba(0, 0, 0, 0.2) 0px 10px 10px";
            this.tooltipDiv.style["transition"] = "left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)";
        }
    },

    /**
     * 渲染图层
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    render: function () {
        this._init_RendererOptions();
        this._initTooltip();
        this._initMarkFace();
        this._initBounds();
        this.setData(this.data);
        this.draw();
    },

    /**
     * 图层绘制
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    draw: function () {
        this.updateXY();
        this.drawCanvas();

        //动画
        this.frame && cancelAnimationFrame(this.frame);
        var _this = this;
        (function animate() {
            //todo
        })();
    },

    /**
     * 图层（地图）移动时触发
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    onMove: function () {
        this.updateXY();
        this.drawCanvas();
    },

    /**
     * 图层（地图）移动结束触发
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    onMoveEnd: function () {
        this.redraw();
    },

    /**
     * 鼠标指针单击事件
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @param {Object} event 事件参数
     */
    onClick: function (event) {
        this._rendererOptions.markFace.clickable && this.hoveredMarkFace && this._parent.fire("overlayerclick", {
            layer: this,
            feature: this.hoveredMarkFace,
            event: event
        });
    },

    /**
     * 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @param {Object} event 事件参数
     */
    onMouseMove: function (event) {
        if (this._rendererOptions.markFace.hoverable && this.visibility && this.markFaces.length > 0 && !this._parent.map.moving) {
            this.hover(event.point.x, event.point.y);

            this.hoveredMarkFace && this._parent.fire("overlayerhover", {
                layer: this,
                feature: this.hoveredMarkFace,
                event: event
            });
        }
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    onResize: function () {
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this._parent.map.transform.height;
        this.redraw();
    },

    /**
     * 图层重绘
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    redraw: function () {
        this.clearCanvas();

        this.updateXY();
        this.drawCanvas();
    },

    /**
     * 重新计算标面的屏幕坐标
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    updateXY: function () {
        var i = this.markFaces.length;
        while (i--) {
            this.markFaces[i].updateXY();
        }
    },

    /**
     * 将标面绘制到画布
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    drawCanvas: function () {
        this.cacheCanvas[0].width = this.width;

        var i = this.markFaces.length;
        while (i--) {
            this.markFaces[i].draw(this.cacheCanvasContext[0]);
        }
        this.canvas[0].width = this.width;
        this.canvasContext[0].drawImage(this.cacheCanvas[0], 0, 0);
    },

    /**
     * 画布清空
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    clearCanvas: function () {
        this.canvas[0].width = this.cacheCanvas[0].width = this.width;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    destroy: function () {
        //先停动画，再移Dom，再重置属性
        cancelAnimationFrame(this.frame);

        this._parent.container.removeChild(this.div);

        this.MarkPoint = null;
        this.markPoints = [];
        this.canvas = [];
        this.data = [];
        this.cacheCanvas = [];
        this.canvasContext = [];
        this.cacheCanvasContext = [];
        this._rendererOptions = {};
    },

    /**
     * 鼠标悬浮时触发
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @param {Number} x 鼠标在主画布上的位置（x轴方向）
     * @param {Number} y 鼠标在主画布上的位置（y轴方向）
     */
    hover: function (x, y) {
        this.lastHoveredMarkFace = this.hoveredMarkFace ? GeoGlobe.Util.clone(this.hoveredMarkFace) : null;
        this.hoveredMarkFace = null;

        for (var i = 0, len = this.markFaces.length; i < len; i++) {
            !this.hoveredMarkFace && this.markFaces[i].isPointInPath(this.cacheCanvasContext[0], x, y);
        }

        this.drawCanvas();

        //显示悬浮提示框
        if (this.hoveredMarkFace) {
            this.canvas[0].style.cursor = "pointer";
            this.showTooltip(this.hoveredMarkFace.name, x, y);
        } else {
            this.canvas[0].style.cursor = "default";
            this.hideTooltip();
        }
    },

    /**
     * 显示悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @param {String} text 要提示的文本
     * @param {Number} x 鼠标在画布上的位置（x轴方向）
     * @param {Number} y 鼠标在画布上的位置（y轴方向）
     * @ignore
     */
    showTooltip: function (text, x, y) {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.textContent = text;
            this.tooltipDiv.style.top = (y - 15) + "px";
            this.tooltipDiv.style.left = (x + 15) + "px";
            this.tooltipDiv.style.display = "block";
        }
    },

    /**
     * 关闭悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     */
    hideTooltip: function () {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.style.display = "none";
        }
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this._parent.map.transform.height
    },

    /**
     * 图层的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = visibility ? "block" : "none";
    },

    /**
     * 使用turf.js框架生成泰森多边形
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @param {Object} points
     * @return {Object} voronoi 泰森多边形顶点数据
     */
    getVoronoi: function (points) {
        var copy = GeoGlobe.Util.clone(points);
        copy.features.map(function (feature) {
            feature.geometry.coordinates = GeoGlobe.Util.transferToMercator(feature.geometry.coordinates);
        });

        var voronoi = turf.voronoi(copy, {bbox: GeoGlobe.Util.transferToMercator([-180, -90]).concat(GeoGlobe.Util.transferToMercator([180, 90]))});
        voronoi = GeoGlobe.Util.clone(voronoi);
        voronoi.features.map(function (feature) {
            feature.geometry.coordinates[0].map(function (point, j) {
                feature.geometry.coordinates[0][j] = GeoGlobe.Util.transferToLonLat(point);
            });
        });
        return voronoi;
    },

    /**
     * 数据的处理，构造标注对象
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @param {FeatureCollection} data 数据
     */
    setData: function (data) {
        this.data = data;

        // 边界数据加载完成后构造标面
        var me = this;
        var fun = function () {
            if (me.bounds) {
                clearInterval(interval);

                me.markFaces = [];
                me.hoveredMarkFace = null;

                var voronoi = me.getVoronoi(data).features;
                var bounds = me.bounds;

                var polygons, polygon;
                for (var i = 0; i < voronoi.length; i++) {
                    polygons = [];
                    for (var j = 0; j < bounds.length; j++) {
                        polygon = turf.intersect(voronoi[i], bounds[j]);
                        polygon && polygons.push(polygon);
                    }
                    me.markFaces.push(new me.MarkFace(i, data.features[i].properties.name, Math.random(), data.features[i].geometry.coordinates[0], data.features[i].geometry.coordinates[1], polygons));
                }

                me.redraw();
            }
        };
        var interval = setInterval(fun, 1);
    }
});/**
 * @class GeoGlobe.Visuals.Custom.Delaunay
 * @classdesc Delaunay三角形
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.dragdrawing 拖动图层时是否绘制
 * @param {Boolean} options.data 数据，geojson格式
 * @param {String} options.boundsURL 边界数据url
 * @param {Object} options.rendererOptions 渲染配置
 * @param {Object} options.rendererOptions.markFace 标面
 * @param {Boolean} options.rendererOptions.markFace.hoverable 是否启用鼠标悬浮
 * @param {Boolean} options.rendererOptions.markFace.clickable 是否启用鼠标点击
 * @param {Object} options.rendererOptions.markFace.itemStyle 图形样式属性
 * @param {String} options.rendererOptions.markFace.itemStyle.color 颜色，支持单色和渐变色
 * @param {String} options.rendererOptions.markFace.itemStyle.borderColor 边框颜色
 * @param {Number} options.rendererOptions.markFace.itemStyle.borderWidth 边框宽度
 * @param {String} options.rendererOptions.markFace.itemStyle.shadowColor 阴影颜色
 * @param {Number} options.rendererOptions.markFace.itemStyle.shadowBlur 阴影模糊度
 * @param {Number} options.rendererOptions.markFace.itemStyle.shadowOffsetX 阴影偏移量X
 * @param {Number} options.rendererOptions.markFace.itemStyle.shadowOffsetY 阴影偏移量Y
 * @param {Object} options.rendererOptions.tooltip 悬浮提示
 * @param {Boolean} options.rendererOptions.tooltip.show 是否显示悬浮提示框
 * @param {String} options.rendererOptions.tooltip.backgroundColor 背景颜色
 * @param {String} options.rendererOptions.tooltip.borderColor 边框颜色
 * @param {Number} options.rendererOptions.tooltip.borderRadius 边框圆角
 * @param {Number} options.rendererOptions.tooltip.borderWidth 边框宽度
 * @param {Number} options.rendererOptions.tooltip.padding 内边距
 * @param {Object} options.rendererOptions.tooltip.textStyle 文字样式
 * @param {String} options.rendererOptions.tooltip.textStyle.color 颜色
 * @param {String} options.rendererOptions.tooltip.textStyle.fontFamily 字体系列
 * @param {Number} options.rendererOptions.tooltip.textStyle.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.tooltip.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.tooltip.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 *
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: "map",
    zoom: 16,
    bearing: 0,
    pitch: 0,
    units: "degree",
    center: [114.20509630753577, 30.776055193053764]
    });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //通过jquery加载json数据
 $.getJSON("../../data/capital.json", function (result) {
      //构造Delaunay三角网图层
    var delaunay = new GeoGlobe.Visuals.Custom.Delaunay({
        id: "delaunay_1",
        visibility: true,
        data: result,
        boundsURL: "../../data/china.json",
        rendererOptions: {
            markFace: {
                itemStyle: {
                    color: {
                        '0': 'rgba(255, 0, 0, 0.3)',
                        '0.5': 'rgba(255, 128, 0, 0.3)',
                        '1': 'rgba(255, 255, 128, 0.3)'
                    },//'rgba(255,0,0,0)',
                    borderColor: 'rgba(255,255,255,0.5)'
                }
            }
        }
    });
    //添加到可视化定制图层
    delaunay.addTo(custom);
    //绘制
    custom.render();
 });
 */
GeoGlobe.Visuals.Custom.Delaunay = GeoGlobe.Class4OL({

    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @type {Array}
     */
    canvas: [],

    /**
     * 离屏画布集合
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @type {Array}
     */
    cacheCanvas: [],

    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @type {Array}
     */
    canvasContext: [],

    /**
     * 离屏画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @type {Array}
     */
    cacheCanvasContext: [],

    /**
     * 标面类
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @private
     * @type {Function}
     */
    MarkFace: null,

    /**
     * 标面对象集
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @type {Array}
     */
    markFaces: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @private
     * @param {Object} options 参数对象
     */

    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @private
     */
    _initContainer: function () {
        this.div = document.createElement("div");
        this.div.setAttribute("id", this.id);
        this.div.setAttribute("style", "position:absolute");
    },

    /**
     * 初始化渲染配置
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @private
     */
    _init_RendererOptions: function () {
        this._rendererOptions = GeoGlobe.Util.deepExtend({}, {
            markFace: {
                hoverable: true,
                clickable: true,
                itemStyle: {
                    color: 'rgba(255,0,0,0.5)',
                    borderColor: '#000',
                    borderWidth: 1,
                    shadowColor: '#000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                }
            },
            tooltip: {
                show: true,
                backgroundColor: '#fff',
                borderColor: '#333',
                borderRadius: 0,
                borderWidth: 0,
                padding: 10,
                textStyle: {
                    color: "#000",
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            }
        }, this.rendererOptions);
    },

    /**
     * @desc 定义标面类
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @private
     */
    _initMarkFace: function () {
        var _this = this;

        var itemStyle = this._rendererOptions.markFace.itemStyle;
        if (typeof itemStyle.color === "object") {
            var gradientImageData = GeoGlobe.Util.getGradientImageData(itemStyle.color);
        }

        /**
         * @method
         * @desc 构造一个标面实例
         * @memberof GeoGlobe.Visuals.Custom.Delaunay.MarkFace.prototype
         * @param {Number} index 索引号
         * @param {Number} count 统计值
         * @param {Object} attributes 属性
         * @param {Array} triangle Delaunay三角形顶点数据
         */
        this.MarkFace = function (index, count, attributes, triangle) {
            this.index = index;
            this.count = count;
            this.attributes = attributes;
            this.triangle = triangle;
            this.vertices = [];

            this.color = typeof itemStyle.color === "object" ? 'rgba(' + gradientImageData[parseInt(count * 255, 10) * 4] + ',' + gradientImageData[parseInt(count * 255, 10) * 4 + 1] + ',' + gradientImageData[parseInt(count * 255, 10) * 4 + 2] + ',' + gradientImageData[3] / 255 + ')' : itemStyle.color;
        };

        /**
         * 更新标面的位置
         * @memberof GeoGlobe.Visuals.Custom.Delaunay.MarkFace.prototype
         */
        this.MarkFace.prototype.updateXY = function () {
            for (var j = 4; j--;) {
                var point = _this._parent.map.project(this.triangle.geometry.coordinates[0][j]);
                this.x = point.x;
                this.y = point.y;
                this.vertices[j] = [this.x, this.y];
            }
        };

        /**
         * 判断鼠标是否悬浮在路径上
         * @memberof GeoGlobe.Visuals.Custom.Delaunay.MarkFace.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkFace.prototype.isPointInPath = function (context, x, y) {
            context.beginPath();
            context.moveTo(this.vertices[3][0], this.vertices[3][1]);
            for (var j = 3; j--;) {
                context.lineTo(this.vertices[j][0], this.vertices[j][1]);
            }
            context.closePath();

            if (context.isPointInPath(x, y)) {
                _this.hoveredMarkFace = this;
            }
        };

        /**
         * @method
         * @desc 将标注绘制到离屏画布
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @ignore
         */
        this.MarkFace.prototype.draw = function (context) {
            context.shadowColor = itemStyle.shadowColor;
            context.shadowBlur = itemStyle.shadowBlur;
            context.shadowOffsetX = itemStyle.shadowOffsetX;
            context.shadowOffsetY = itemStyle.shadowOffsetY;

            context.beginPath();
            context.moveTo(this.vertices[3][0], this.vertices[3][1]);
            for (var j = 3; j--;) {
                context.lineTo(this.vertices[j][0], this.vertices[j][1]);
            }
            context.closePath();

            context.fillStyle = _this.hoveredMarkFace === this ? GeoGlobe.Util.getShadeColor(this.color, 20) : this.color;
            context.strokeStyle = itemStyle.borderColor;
            context.lineWidth = itemStyle.borderWidth;
            context.stroke();
            context.fill();

            context.beginPath();
            context.arc(this.x, this.y, 1, 0, Math.PI * 2, false);
            context.fillStyle = "#fff";
            context.fill();
        };
    },

    /**
     * @desc 画布初始化
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.MarkFace.prototype
     * @private
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));

        this.canvas[0].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);
        this.setVisible(this.visibility);
    },

    /**
     * 悬浮提示框初始化
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @private
     */
    _initTooltip: function () {
        if ((this._rendererOptions.markFace.hoverable || this._rendererOptions.markFace.clickable) && this._rendererOptions.tooltip.show) {
            this.tooltipDiv = this.tooltipDiv || this.div.appendChild(document.createElement('div'));
            this.tooltipDiv.style.position = "relative";
            this.tooltipDiv.style.display = "none";
            this.tooltipDiv.style.zIndex = 999;
            this.tooltipDiv.style.color = this._rendererOptions.tooltip.textStyle.color;
            this.tooltipDiv.style.padding = this._rendererOptions.tooltip.padding + "px";
            this.tooltipDiv.style.font = this._rendererOptions.tooltip.textStyle.fontStyle + ' ' + this._rendererOptions.tooltip.textStyle.fontWeight + ' ' + this._rendererOptions.tooltip.textStyle.fontSize + 'px ' + this._rendererOptions.tooltip.textStyle.fontFamily;

            //(IE8-)不兼容rgba问题处理
            if (document.createElement('canvas').getContext) {
                this.tooltipDiv.style["background-color"] = this._rendererOptions.tooltip.backgroundColor;
            } else {
                this.tooltipDiv.style["background-color"] = GeoGlobe.Util.getRgbColor(this._rendererOptions.tooltip.backgroundColor);
            }

            this.tooltipDiv.style["border-width"] = this._rendererOptions.tooltip.borderWidth + "px";
            this.tooltipDiv.style["border-color"] = this._rendererOptions.tooltip.borderColor;
            this.tooltipDiv.style["border-radius"] = this._rendererOptions.tooltip.borderRadius + "px";
            this.tooltipDiv.style["border-style"] = "solid";
            this.tooltipDiv.style['white-space'] = "nowrap";
            this.tooltipDiv.style["box-shadow"] = "rgba(0, 0, 0, 0.2) 0px 10px 10px";
            this.tooltipDiv.style["transition"] = "left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)";
        }
    },

    /**
     * 渲染图层
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    render: function () {
        this._init_RendererOptions();
        this._initMarkFace();
        this._initTooltip();
        this.setData(this.data);
        this.draw();
    },

    /**
     * 图层绘制
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    draw: function () {
        this.updateXY();
        this.drawCanvas();

        //动画
        this.frame && cancelAnimationFrame(this.frame);
        var _this = this;
        (function animate() {
            //todo
        })();
    },

    /**
     * 图层（地图）移动时触发
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    onMove: function () {
        this.updateXY();
        this.drawCanvas();
    },

    /**
     * 图层（地图）移动结束触发
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    onMoveEnd: function () {
        this.redraw();
    },

    /**
     * 鼠标指针单击事件
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @param {Object} event 事件参数
     */
    onClick: function (event) {
        this._rendererOptions.markFace.clickable && this.hoveredMarkFace && this._parent.fire("overlayerclick", {
            layer: this,
            feature: this.hoveredMarkFace,
            event: event
        });
    },

    /**
     * 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @param {Object} event 事件参数
     */
    onMouseMove: function (event) {
        if (this._rendererOptions.markFace.hoverable && this.visibility && this.markFaces.length > 0 && !this._parent.map.moving) {
            this.hover(event.point.x, event.point.y);

            this.hoveredMarkFace && this._parent.fire("overlayerhover", {
                layer: this,
                feature: this.hoveredMarkFace,
                event: event
            });
        }
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    onResize: function () {
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this.parentMap.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this.parentMap.height;
        this.redraw();
    },

    /**
     * 图层重绘
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    redraw: function () {
        this.clearCanvas();

        this.updateXY();
        this.drawCanvas();
    },

    /**
     * 重新计算标面的屏幕坐标
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    updateXY: function () {
        var i = this.markFaces.length;
        while (i--) {
            this.markFaces[i].updateXY();
        }
    },

    /**
     * 画布清空
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    clearCanvas: function () {
        this.canvas[0].width = this.cacheCanvas[0].width = this.width;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    destroy: function () {
        //先停动画，再移Dom，再重置属性
        cancelAnimationFrame(this.frame);

        this._parent.container.removeChild(this.div);

        this.MarkPoint = null;
        this.markPoints = [];
        this.canvas = [];
        this.data = [];
        this.cacheCanvas = [];
        this.canvasContext = [];
        this.cacheCanvasContext = [];
        this._rendererOptions = {};
    },

    /**
     * 鼠标悬浮时触发
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @param {Number} x 鼠标在主画布上的位置（x轴方向）
     * @param {Number} y 鼠标在主画布上的位置（y轴方向）
     */
    hover: function (x, y) {
        this.lastHoveredMarkFace = this.hoveredMarkFace ? GeoGlobe.Util.clone(this.hoveredMarkFace, false) : null;
        this.hoveredMarkFace = null;

        for (var i = 0, len = this.markFaces.length; i < len; i++) {
            !this.hoveredMarkFace && this.markFaces[i].isPointInPath(this.cacheCanvasContext[0], x, y);
        }

        this.drawCanvas();

        //显示悬浮提示框
        if (this.hoveredMarkFace) {
            this.canvas[0].style.cursor = "pointer";
            this.showTooltip("[" + this.hoveredMarkFace.attributes["a"] + "," + this.hoveredMarkFace.attributes["b"] + "," + this.hoveredMarkFace.attributes["c"] + "]", x, y);
        } else {
            this.canvas[0].style.cursor = "default";
            this.hideTooltip();
        }
    },

    /**
     * 将标面绘制到画布
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    drawCanvas: function () {
        this.cacheCanvas[0].width = this.width;

        var i = this.markFaces.length;
        while (i--) {
            this.markFaces[i].draw(this.cacheCanvasContext[0]);
        }
        this.canvas[0].width = this.width;
        this.canvasContext[0].drawImage(this.cacheCanvas[0], 0, 0);
    },

    /**
     * 显示悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @param {String} text 要提示的文本
     * @param {Number} x 鼠标在画布上的位置（x轴方向）
     * @param {Number} y 鼠标在画布上的位置（y轴方向）
     * @ignore
     */
    showTooltip: function (text, x, y) {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.textContent = text;
            this.tooltipDiv.style.top = (y - 15) + "px";
            this.tooltipDiv.style.left = (x + 15) + "px";
            this.tooltipDiv.style.display = "block";
        }
    },

    /**
     * 关闭悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     */
    hideTooltip: function () {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.style.display = "none";
        }
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this._parent.map.transform.height
    },

    /**
     * 图层的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = visibility ? "block" : "none";
    },

    /**
     * 使用turf.js框架生成Delaunay三角网
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @param {Object} points
     * @return {Object} delaunay 泰森多边形顶点数据
     */
    // getDelaunay: function (points) {
    //     var copy = GeoGlobe.Util.clone(points);
    //     copy.features.map(function (feature) {
    //         feature.geometry.coordinates = GeoGlobe.Util.transferToMercator(feature.geometry.coordinates);
    //     });
    //
    //     var delaunay = turf.delaunay(copy, {bbox: GeoGlobe.Util.transferToMercator([-180, -90]).concat(GeoGlobe.Util.transferToMercator([180, 90]))});
    //     delaunay = GeoGlobe.Util.clone(delaunay);
    //     delaunay.features.map(function (feature) {
    //         feature.geometry.coordinates[0].map(function (point, j) {
    //             feature.geometry.coordinates[0][j] = GeoGlobe.Util.transferToLonLat(point);
    //         });
    //     });
    //     return delaunay;
    // },

    /**
     * 数据的处理，构造标注对象
     * @memberof GeoGlobe.Visuals.Custom.Delaunay.prototype
     * @param {FeatureCollection} data 数据
     */
    setData: function (data) {
        this.data = data;

        // 边界数据加载完成后构造标面
        var me = this;
        var fun = function () {
            clearInterval(interval);

            me.markFaces = [];
            me.hoveredMarkFace = null;

            // var delaunay = me.getDelaunay(data).features;

            var triangle;
            var triangles;
            triangles = turf.tin(data, "name");

            for (var i = 0; i < triangles.features.length; i++) {
                triangle = triangles.features[i];
                //     for (var g = 0; g < triangles.features[i].geometry.coordinates[0].length;g++) {
                //         for (var j = 0; j < points.features.length;j++) {
                //             if (points.features[j].geometry.coordinates[0] === triangles.features[i].geometry.coordinates[0][g][0]) {
                //                 if (points.features[j].geometry.coordinates[1] === triangles.features[i].geometry.coordinates[0][g][1])
                //                     triangles.features[i].properties[g] = points.features[j].properties.name;
                //                 break;
                //             }
                //         }
                //     }
                me.markFaces.push(new me.MarkFace(i, Math.random(), triangle.properties, triangle));
            }
            me.redraw();
        };
        var interval = setInterval(fun, 1);
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Custom.Network
 * @classdesc 关系网络图层
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.data 数据
 * @param {Object} options.rendererOptions 渲染配置
 * @param {Object} options.rendererOptions.markLine 标线
 * @param {Boolean} options.rendererOptions.markLine.hoverable 是否启用鼠标悬浮
 * @param {Object} options.rendererOptions.markLine.itemStyle 图形样式属性
 * @param {Number} options.rendererOptions.markLine.itemStyle.width 线宽
 * @param {Number} options.rendererOptions.markLine.itemStyle.color 颜色
 * @param {Object} options.rendererOptions.markPoint 标注
 * @param {Boolean} options.rendererOptions.markPoint.hoverable 是否启用鼠标悬浮
 * @param {Object} options.rendererOptions.markPoint.itemStyle 图形样式属性
 * @param {Array} options.rendererOptions.markPoint.itemStyle.images 图片资源集
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowColor 阴影颜色
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowBlur 阴影模糊度
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowOffsetX 阴影偏移量X
 * @param {String} options.rendererOptions.markPoint.itemStyle.shadowOffsetY 阴影偏移量Y
 * @param {Object} options.rendererOptions.tooltip 悬浮提示
 * @param {Boolean} options.rendererOptions.tooltip.show 是否显示悬浮提示框
 * @param {String} options.rendererOptions.tooltip.backgroundColor 背景颜色
 * @param {String} options.rendererOptions.tooltip.borderColor 边框颜色
 * @param {Number} options.rendererOptions.tooltip.borderRadius 边框圆角
 * @param {Number} options.rendererOptions.tooltip.borderWidth 边框宽度
 * @param {Number} options.rendererOptions.tooltip.padding 内边距
 * @param {Object} options.rendererOptions.tooltip.textStyle 文字样式
 * @param {String} options.rendererOptions.tooltip.textStyle.color 颜色
 * @param {String} options.rendererOptions.tooltip.textStyle.fontFamily 字体系列
 * @param {Number} options.rendererOptions.tooltip.textStyle.fontSize 字号 ，单位px
 * @param {String} options.rendererOptions.tooltip.textStyle.fontStyle 样式，可选为：'normal' | 'italic' | 'oblique'
 * @param {String/Number} options.rendererOptions.tooltip.textStyle.fontWeight 粗细，可选为：'normal' | 'bold' | 'bolder' | 'lighter' | 100 | 200 |... | 900
 *
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造可视化定制图层
 var custom = new GeoGlobe.Visuals.Custom();
 //添加到地图中
 custom.addTo(map);
 //构造关系网络图层
 var network = new GeoGlobe.Visuals.Custom.Network({
    id: "network_1",
    visibility: true,
    data: {
        points: [{
            id: '1',
            name: '冯宝宝',
            symbol: 0,
            lon: 114.06044483184814,
            lat: 22.54109841178252
        }, {
            id: '2',
            name: '工作地址',
            symbol: 1,
            lon: 114.0464973449707,
            lat: 22.538284169039656
        }, {
            id: '3',
            name: '就医地址',
            symbol: 2,
            lon: 114.0834903717041,
            lat: 22.56892065261958
        }, {
            id: '4',
            name: '帮扶人',
            symbol: 3,
            lon: 114.03907299041748,
            lat: 22.55069018837554
        }],
        links: [{
            source: '1',
            target: '2'
        }, {
            source: '1',
            target: '3'
        }, {
            source: '1',
            target: '4'
        }]
    },
    rendererOptions: {
        markLine: {
            hoverable: true,
            itemStyle: {
                width: 2
            }
        },
        markPoint: {
            hoverable: true
        }
    }
 });
 //添加到可视化定制图层
 network.addTo(custom);
 //绘制
 custom.render();
 */
GeoGlobe.Visuals.Custom.Network = GeoGlobe.Class4OL({

    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @type {Array}
     */
    canvas: [],

    /**
     * 离屏画布集合
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @type {Array}
     */
    cacheCanvas: [],

    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @type {Array}
     */
    canvasContext: [],

    /**
     * 离屏画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @type {Array}
     */
    cacheCanvasContext: [],

    /**
     * 标注类
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @type {Function}
     */
    MarkPoint: null,

    /**
     * 标线类
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @type {Function}
     */
    MarkLine: null,

    /**
     * 标注对象集
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @type {Array}
     */
    markPoints: [],

    /**
     * 标线对象集
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @type {Array}
     */
    markLines: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     */
    _initContainer: function () {
        this.div = document.createElement("div");
        this.div.setAttribute("id", this.id);
        this.div.setAttribute("style", "position:absolute");
    },

    /**
     * 初始化渲染配置
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     */
    _init_RendererOptions: function () {
        this._rendererOptions = GeoGlobe.Util.deepExtend({}, {
            markLine: {
                hoverable: true,
                itemStyle: {
                    color: "#0095ff",
                    width: 2
                }
            },
            markPoint: {
                hoverable: true,
                itemStyle: {
                    images: [
                        "../../images/symbol/00.png",
                        "../../images/symbol/01.png",
                        "../../images/symbol/02.png",
                        "../../images/symbol/03.png"
                    ],
                    shadowColor: '#000000',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                }
            },
            tooltip: {
                show: true,
                backgroundColor: '#fff',
                borderColor: '#333',
                borderRadius: 0,
                borderWidth: 0,
                padding: 10,
                textStyle: {
                    color: "#000",
                    fontFamily: 'serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                }
            }
        }, this.rendererOptions);
    },

    /**
     * 加载标注图片资源
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     */
    _initMarkPointImages: function () {
        this.markPointImages = [];

        var _this = this;
        var images = this._rendererOptions.markPoint.itemStyle.images;
        images.forEach(function (image) {
            var img = new Image();
            img.src = image;
            img.onload = function () {
                _this.drawCanvas1();
            };
            _this.markPointImages.push(img);
        });
    },

    /**
     * 定义标注类
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     */
    _initMarkPoint: function () {
        var _this = this;

        var itemStyle = this._rendererOptions.markPoint.itemStyle;

        /**
         * 标注类
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         * @param {Number} index 索引号
         * @param {String} id 唯一标识
         * @param {String} name 名
         * @param {Number} value 值
         * @param {Number} symbol 符号，对应images配置中的索引号
         * @param {Number} lon 经度
         * @param {Number} lat 纬度
         * @param {Object} attributes 属性
         */
        this.MarkPoint = function (index, id, name, value, symbol, lon, lat, attributes) {
            this.index = index;
            this.id = id;
            this.name = name;
            this.value = value;
            this.symbol = symbol;
            this.lon = lon;
            this.lat = lat;
            this.attributes = attributes;

            this.width = 50;//width和height适用于符号0
            this.height = 68;
            this.radius = 30;//radius适用于其他符号
        };

        /**
         * 初始化
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         */
        this.MarkPoint.prototype.init = function () {

        };

        /**
         * 重新计算标注的位置
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         */
        this.MarkPoint.prototype.updateXY = function () {
            var tmp = _this._parent.map.project([this.lon, this.lat]);
            this.x = tmp.x;
            this.y = tmp.y;
        };

        /**
         * 更新标注的大小
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         */
        this.MarkPoint.prototype.update = function () {

        };

        /**
         * 判断鼠标是否悬浮在路径上
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkPoint.prototype.isPointInPath = function (context, x, y) {
            context.beginPath();

            if (this.symbol === 0) {
                context.rect(this.x - this.width / 2, this.y - this.height + 5, this.width, this.height);
            } else {
                context.arc(this.x, this.y, this.radius, 0, Math.PI * 2, true);
            }

            if (context.isPointInPath(x, y)) {
                _this.hoveredMarkPoint = this;
            }
        };

        /**
         * 将标注静态部分绘制到离屏画布1
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkPoint.prototype.draw1 = function (context) {
            var isHovered = false;
            if (_this.hoveredMarkPoint === this || (_this.hoveredMarkLine && (_this.hoveredMarkLine.source === this || _this.hoveredMarkLine.target === this))) {
                isHovered = true;
            }

            context.globalAlpha = _this.energy;
            context.shadowColor = itemStyle.shadowColor;
            context.shadowBlur = itemStyle.shadowBlur;
            context.shadowOffsetX = itemStyle.shadowOffsetX;
            context.shadowOffsetY = itemStyle.shadowOffsetY;

            context.save();
            context.translate(this.x, this.y);
            if (isHovered) {
                context.scale(1.1, 1.1);
            }
            if (this.symbol === 0) {
                context.drawImage(_this.markPointImages[this.symbol], -this.width / 2, -this.height + 5);
            } else {
                context.drawImage(_this.markPointImages[this.symbol], -this.radius, -this.radius);
            }
            context.restore();
        };

        /**
         * 将标注动画部分、中心数字绘制到离屏画布3
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkPoint.prototype.draw2 = function (context) {

        };
    },

    /**
     * 定义标线类
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     */
    _initMarkLine: function () {
        var _this = this;

        var itemStyle = this._rendererOptions.markLine.itemStyle;

        /**
         * 标线类
         * @param {Number} index 索引号
         * @param {GeoGlobe.Visuals.Custom.Network.MarkPoint} source 源标注
         * @param {GeoGlobe.Visuals.Custom.Network.MarkPoint} target 目标标注
         */
        this.MarkLine = function (index, source, target) {
            this.index = index;
            this.source = source;
            this.target = target;

            this.width = itemStyle.width;
            this.color = itemStyle.color;
        };

        /**
         * 更新起点、终点和控制点的位置
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         */
        this.MarkLine.prototype.updateXY = function () {

        };

        /**
         * 判断鼠标是否悬浮在路线上
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         * @param {Number} x 鼠标在画布上的位置（x轴方向）
         * @param {Number} y 鼠标在画布上的位置（y轴方向）
         */
        this.MarkLine.prototype.isPointInStroke = function (context, x, y) {
            context.beginPath();
            context.moveTo(this.source.x, this.source.y);
            context.lineTo(this.target.x, this.target.y);
            if (context.isPointInStroke(x, y)) {
                _this.hoveredMarkLine = this;
            }
        };

        /**
         * 绘制标线
         * @memberof GeoGlobe.Visuals.Custom.Network.MarkPoint.prototype
         * @param {CanvasRenderingContext2D} context 要绘制到的画布上下文
         */
        this.MarkLine.prototype.draw = function (context) {
            var color = this.color;
            if (_this.hoveredMarkLine === this || _this.hoveredMarkPoint === this.source || _this.hoveredMarkPoint === this.target) {
                color = GeoGlobe.Util.getShadeColor(color, 20);
            }

            context.beginPath();
            context.moveTo(this.source.x, this.source.y);
            context.lineTo(this.source.x + (this.target.x - this.source.x) * _this.energy, this.source.y + (this.target.y - this.source.y) * _this.energy);
            context.lineWidth = this.width;
            context.strokeStyle = color;
            context.stroke();
        }
    },

    /**
     * 画布初始化
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));
        this.canvasContext.push(this.canvas[1].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));
        this.cacheCanvasContext.push(this.cacheCanvas[1].getContext("2d"));

        this.canvas[0].style.position = "absolute";
        this.canvas[1].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);
        this.div.appendChild(this.canvas[1]);
        this.setVisible(this.visibility);
    },

    /**
     * 悬浮提示框初始化
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @private
     */
    _initTooltip: function () {
        if ((this._rendererOptions.markLine.hoverable || this._rendererOptions.markPoint.hoverable) && this._rendererOptions.tooltip.show) {
            this.tooltipDiv = this.tooltipDiv || this.div.appendChild(document.createElement('div'));
            this.tooltipDiv.style.position = "relative";
            this.tooltipDiv.style.display = "none";
            this.tooltipDiv.style.zIndex = 999;
            this.tooltipDiv.style.color = this._rendererOptions.tooltip.textStyle.color;
            this.tooltipDiv.style.padding = this._rendererOptions.tooltip.padding + "px";
            this.tooltipDiv.style.font = this._rendererOptions.tooltip.textStyle.fontStyle + ' ' + this._rendererOptions.tooltip.textStyle.fontWeight + ' ' + this._rendererOptions.tooltip.textStyle.fontSize + 'px ' + this._rendererOptions.tooltip.textStyle.fontFamily;

            //(IE8-)不兼容rgba问题处理
            if (document.createElement('canvas').getContext) {
                this.tooltipDiv.style["background-color"] = this._rendererOptions.tooltip.backgroundColor;
            } else {
                this.tooltipDiv.style["background-color"] = GeoGlobe.Util.getRgbColor(this._rendererOptions.tooltip.backgroundColor);
            }

            this.tooltipDiv.style["border-width"] = this._rendererOptions.tooltip.borderWidth + "px";
            this.tooltipDiv.style["border-color"] = this._rendererOptions.tooltip.borderColor;
            this.tooltipDiv.style["border-radius"] = this._rendererOptions.tooltip.borderRadius + "px";
            this.tooltipDiv.style["border-style"] = "solid";
            this.tooltipDiv.style['white-space'] = "nowrap";
            this.tooltipDiv.style["box-shadow"] = "rgba(0, 0, 0, 0.2) 0px 10px 10px";
            this.tooltipDiv.style["transition"] = "left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)";
        }
    },

    /**
     * 渲染图层
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    render: function () {
        this._init_RendererOptions();
        this._initMarkPointImages();
        this._initMarkPoint();
        this._initMarkLine();
        this._initTooltip();
        this.setData(this.data);
        this.draw();
    },

    /**
     * 图层绘制
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    draw: function () {
        this.updateXY();
        this.drawCanvas1();

        //动画
        this.energy = 0;
        this.animation = true;
        this.frame && cancelAnimationFrame(this.frame);
        var _this = this;
        (function animate() {
            if (_this.energy < 1) {
                _this.frame = requestAnimationFrame(animate);
                _this.energy += 0.05;
                _this.energy > 1 && (_this.energy = 1);
                _this.drawCanvas1();
            }
        })();
    },

    /**
     * 图层（地图）移动时触发
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    onMove: function () {
        this.animation = false;
        this.updateXY();
        this.drawCanvas1();
        this.drawCanvas2();
    },

    /**
     * 图层（地图）移动结束触发
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    onMoveEnd: function () {
        this.redraw();
    },

    /**
     * 鼠标指针悬停事件
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @param {Object} event 事件参数
     */
    onMouseMove: function (event) {
        if ((this._rendererOptions.markLine.hoverable || this._rendererOptions.markPoint.hoverable) && this.visibility && this.markPoints.length > 0 && !this._parent.map.moving) {
            this.hover(event.point.x, event.point.y);

            this.hoveredMarkPoint && this._parent.fire("overlayerhover", {
                layer: this,
                feature: this.hoveredMarkPoint,
                event: event
            });
        }
    },

    /**
     * 图层自适应
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    onResize: function () {
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.canvas[1].height = this.cacheCanvas[0].height = this.cacheCanvas[1].height = this.height = this._parent.map.transform.height;
        this.redraw();
    },

    /**
     * 图层重绘
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    redraw: function () {
        this.clearCanvas();

        this.updateXY();
        this.drawCanvas1();
        this.drawCanvas2();
    },

    /**
     * 重新计算标注的屏幕坐标
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    updateXY: function () {
        this.markPoints.forEach(function (markPoint) {
            markPoint.updateXY();
        });
    },

    /**
     * 将静态部分绘制到画布1
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    drawCanvas1: function () {
        this.cacheCanvas[0].width = this.width;

        var _this = this;
        this.markLines.forEach(function (markLine) {
            markLine.draw(_this.cacheCanvasContext[0]);
        });
        this.markPoints.forEach(function (markPoint) {
            markPoint.draw1(_this.cacheCanvasContext[0]);
        });

        this.canvas[0].width = this.width;
        this.canvasContext[0].drawImage(this.cacheCanvas[0], 0, 0);
    },

    /**
     * 将动画部分绘制到画布2
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    drawCanvas2: function () {

    },

    /**
     * 画布清空
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    clearCanvas: function () {
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    destroy: function () {
        //先停动画，再移Dom，再重置属性
        cancelAnimationFrame(this.frame);

        this._parent.container.removeChild(this.div);

        this.markPointImages = [];
        this.MarkPoint = null;
        this.markPoints = [];
        this.MarkLine = null;
        this.markLines = [];
        this.canvas = [];
        this.data = [];
        this.cacheCanvas = [];
        this.canvasContext = [];
        this.cacheCanvasContext = [];
        this._rendererOptions = {};
    },

    /**
     * 鼠标悬浮时触发
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @param {Number} x 鼠标在主画布上的位置（x轴方向）
     * @param {Number} y 鼠标在主画布上的位置（y轴方向）
     */
    hover: function (x, y) {
        this.hoveredMarkLine = null;
        this.hoveredMarkPoint = null;

        var _this = this;
        this.markPoints.forEach(function (markPoint) {
            !_this.hoveredMarkPoint && markPoint.isPointInPath(_this.cacheCanvasContext[0], x, y);
        });
        this.markLines.forEach(function (markLine) {
            !_this.hoveredMarkLine && markLine.isPointInStroke(_this.cacheCanvasContext[0], x, y);
        });

        this.drawCanvas1();

        //显示悬浮提示框
        if (this.hoveredMarkLine || this.hoveredMarkPoint) {
            this.showTooltip(this.hoveredMarkLine ? this.hoveredMarkLine.source.name + ' > ' + this.hoveredMarkLine.target.name : this.hoveredMarkPoint.name, x, y);
            this.canvas[1].style.cursor = "pointer";
        } else {
            this.hideTooltip();
            this.canvas[1].style.cursor = "-webkit-grab";
        }
    },

    /**
     * 显示悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @param {String} text 要提示的文本
     * @param {Number} x 鼠标在画布上的位置（x轴方向）
     * @param {Number} y 鼠标在画布上的位置（y轴方向）
     * @ignore
     */
    showTooltip: function (text, x, y) {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.textContent = text;
            this.tooltipDiv.style.top = (y - 15) + "px";
            this.tooltipDiv.style.left = (x + 15) + "px";
            this.tooltipDiv.style.display = "block";
        }
    },

    /**
     * 关闭悬浮提示
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     */
    hideTooltip: function () {
        if (this._rendererOptions.tooltip.show) {
            this.tooltipDiv.style.display = "none";
        }
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.canvas[1].width = this.cacheCanvas[0].width = this.cacheCanvas[1].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.canvas[1].height = this.cacheCanvas[0].height = this.cacheCanvas[1].height = this.height = this._parent.map.transform.height;
    },

    /**
     * 图层的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = this.canvas[1].style.display = visibility ? "block" : "none";
    },

    /**
     * 根据节点id获取MarkPoint对象
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @param id 节点id
     * @return {GeoGlobe.Visuals.Custom.Network.MarkPoint} markPoint 标注对象
     */
    getMarkPointById: function (id) {
        var markPoint;
        for (var i = 0, len = this.markPoints.length; i < len; i++) {
            if (this.markPoints[i].id === id) {
                markPoint = this.markPoints[i];
                break;
            }
        }
        return markPoint;
    },

    /**
     * 数据的处理，构造标注、标线对象
     * @memberof GeoGlobe.Visuals.Custom.Network.prototype
     * @param {Array} data 数据
     * @example {
     *  points:[{
            id: '1',
            name: '节点1',
            symbol: 1,
            lon: 114.06044483184814,
            lat: 22.54109841178252
        }, {
            id: '2',
            name: '节点2',
            symbol: 2,
            lon: 114.0464973449707,
            lat: 22.538284169039656
        }],
        links:[{
            source: '2',
            target: '1'
        }]
       }
     */
    setData: function (data) {
        this.hoveredMarkPoint = null;
        this.hoveredMarkLine = null;
        this.markPoints = [];
        this.markLines = [];

        var _this = this;
        var markPoint;
        var markLine;
        data = data || {};
        data.points = data.points || [];
        data.points.forEach(function (point, i) {
            markPoint = new _this.MarkPoint(i, point.id, point.name, point.value, point.symbol, point.lon, point.lat, point);
            _this.markPoints.push(markPoint);
        });
        data.links = data.links || [];
        data.links.forEach(function (link, i) {
            markLine = new _this.MarkLine(i, _this.getMarkPointById(link.source), _this.getMarkPointById(link.target));
            _this.markLines.push(markLine);
        });

        this.data = data;
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.Grid
 * @classdesc 基于Grid的可视化图层
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造Grid可视化图层
 var Grid = new GeoGlobe.Visuals.Grid();
 //添加到地图中
 Grid.addTo(map);
 //绑定鼠标点击事件
 Grid.on('overlayerclick', function(e){
	console.info(e);
 });
 //绑定鼠标移动事件
 Grid.on('overlayerhover', function(e){
	console.info(e);
 });
 //构造简单图层
 var simple = new GeoGlobe.Visuals.Grid.Simple({
    id: 'simple_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        fillStyle: 'rgba(55, 50, 250, 0.2)',
        globalCompositeOperation: "lighter",
        size: 15,
        animation: {
            type: 'time',
            stepsRange: {
                start: 0,
                end: 100
            },
            trails: 10,
            duration: 5
        }
    }
 });
 //添加到Grid可视化图层
 simple.addTo(Grid);
 //绘制
 Grid.render();
 */
GeoGlobe.Visuals.Grid = GeoGlobe.Class4OL(GeoGlobe.Visuals, {

    /**
     * 地图对象
     * @memberof GeoGlobe.Visuals.Grid.prototype
     * @type {GeoGlobe.Map}
     * @default null
     */
    map: null,

    /**
     * map的容器
     * @memberof GeoGlobe.Visuals.Grid.prototype
     * @type {Object}
     */
    container: null,

    /**
     * 图层集合
     * @memberof GeoGlobe.Visuals.Grid.prototype
     * @type {Array}
     */
    layers: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Grid.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        GeoGlobe.Visuals.prototype.initialize.apply(this, arguments);
        this.layers= [];
    },

    /**
     * 与地图对象关联
     * @function addTo
     * @memberof GeoGlobe.Visuals.Grid.prototype
     * @public
     * @param {Object} map 地图对象
     */
    addTo: function (map) {
        GeoGlobe.Visuals.prototype.addTo.apply(this, arguments);

        this.container.className = "geoglobe-Grid-container";
    },

    /**
     * 绘制图层
     * @function render
     * @memberof GeoGlobe.Visuals.Grid.prototype
     */
    render: function () {
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i].render();
        }
    },

    /**
     * 向可视化图层中添加子图层
     * @function addLayer
     * @memberof GeoGlobe.Visuals.Grid.prototype
     * @param {Object} layer 子图层对象
     */
    addLayer: function (layer) {
        if (!layer.id) {
            console.error("图层id属性不能为空！");
            return;
        }
        var oldLayer = this.getLayer(layer.id);
        if (oldLayer) {
            oldLayer = layer;
        } else {
            this.layers.push(layer);
        }
    },

    /**
     * 移除图层
     * @function removeLayer
     * @memberof GeoGlobe.Visuals.Grid.prototype
     * @param {String} id 图层id
     */
    removeLayer: function (id) {
        var array = [];
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                continue;
            }
            array.push(this.layers[i]);
        }
        this.layers = array;
    },

    /**
     * 移动图层
     * @function moveLayer
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @param {String} id 图层id
     */
    moveLayer: function moveLayer (id, before) {
        var layer = this.getLayer(id);
        if (!layer) {
            this.fire('error', {
                error: new Error(
                    "The layer '" + id + "' does not exist in " +
                    "the map's style and cannot be moved."
                )
            });
            return;
        }

        this._order = this.layers.map(function (Layer) { return Layer.id; });
        var index = this._order.indexOf(id);
        this._order.splice(index, 1);

        var newIndex = before ? this._order.indexOf(before) : this._order.length;
        if (before && newIndex === -1) {
            this.fire('error', { error: new Error(("Layer with id \"" + before + "\" does not exist on this map."))});
            return;
        }
        this._order.splice(newIndex, 0, id);
        for(var j = 0; j < this._order.length; j++) {
            for (var i = 0; i < this.layers.length; i++) {
                if (this._order[j] === this.layers[i].id) {
                    this.layers[i].div.style.zIndex = j
                }
            }
        }
    },

    /**
     * 获取指定id图层
     * @function getLayer
     * @memberof GeoGlobe.Visuals.Grid.prototype
     * @param {String} id 图层id
     * @returns {Object} layer 图层对象
     */
    getLayer: function (id) {
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                return this.layers[i];
            }
        }
    }
});/**
 * @class GeoGlobe.Visuals.Grid.Typhoon
 * @classdesc 台风图层
 * @param {Object} options
 * @param {String} options.id 图层id
 * @param {Boolean} options.visibility 图层默认是否显示
 * @param {Boolean} options.dragdrawing 拖动图层时是否绘制
 * @param {String} options.data  数据,json格式
 */

GeoGlobe.Visuals.Grid.Typhoon = GeoGlobe.Class4OL(GeoGlobe.Visuals, {
    /**
     * 可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Grid.Typhoon.prototype
     * @private
     * @type {GeoGlobe.Visuals.Custom}
     */
    _parent: null,

    /**
     * 画布集合，使用分层画布分别绘制
     * @memberof GeoGlobe.Visuals.Grid.Typhoon.prototype
     * @type {Array}
     */
    canvas: [],


    /**
     * 画布的上下文集合
     * @memberof GeoGlobe.Visuals.Custom.Voronoi.prototype
     * @type {Array}
     */
    canvasContext: [],


    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.Custom.Typhoon.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);


        this._initContainer();
        this._initCanvas();
    },

    /**
     * 初始化图层容器
     * @memberof GeoGlobe.Visuals.Custom.Bubble.prototype
     * @private
     */
    _initContainer:function(){
        this.div = document.createElement("div");
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute")
    },


    initParticles: function () {
        var _this = this;

        /**
         * 棋子共有的属性
         * @memberof GeoGlobe.Visuals.Custom.Typhoon.prototype
         * @private
         */
        this.Particle = function (x, y, age) {
            this.x = x;
            this.y = y;
            this.oldX = -1;
            this.oldY = -1;
            this.age = age;
            this.opacity = 1;
        };
        /**
         * @method
         * @desc 重新计算标注的位置
         * @ignore
         */
        this.Particle.prototype.updateXY = function (lon, lat, opt_result) {
            var point = _this._parent.map.project([this.x, this.y]);
            var x = point.x;
            var y = point.y;
            if (opt_result) {
                opt_result.x = x;
                opt_result.y = y;
                return opt_result
            }
            return new _this.Vector(x, y);
        };
    },


    /**
     * @method
     * @desc 画布初始化
     * @ignore
     */
    _initCanvas: function () {
        this.canvas = [];
        this.canvasContext = [];
        this.canvas.push(document.createElement('canvas'));
        this.canvasContext.push(this.canvas[0].getContext("2d"));

        this.cacheCanvas = [];
        this.cacheCanvasContext = [];
        this.cacheCanvas.push(document.createElement('canvas'));
        this.cacheCanvasContext.push(this.cacheCanvas[0].getContext("2d"));

        this.canvas[0].style.position = "absolute";

        this.div.appendChild(this.canvas[0]);

        this.setVisible(this.visibility);
    },

    /**
     * 图层的显示与隐藏
     * @memberof GeoGlobe.Visuals.Custom.delaunay.prototype
     * @param {Boolean} visibility 可见性
     */
    setVisible: function (visibility) {
        this.visibility = visibility;
        this.canvas[0].style.display = visibility ? "block" : "none";
    },


    /**
     * @method
     * @desc 渲染台风图层
     * @ignore
     */
    render: function () {
        this.particles = [];
        this.initParticles();
        //todo 请求本地数据
        this.setData(this.data);

        var i;
        var _this = this;
        (function loop() {
            requestAnimationFrame(loop);
            //地图变换（平移、缩放、旋转、倾斜）时 || 加载数据后 || 图层自适应后
            if (_this._parent.map.moving || _this.RELOADED || _this.RESIZE) {
                i = _this.particles.length;
                var proj = new _this.Vector(0, 0);
                while (i--) {
                    _this.particles[i].updateXY(_this.particles[i].x, _this.particles[i].y, proj);
                }

                _this.canvas[0].width = _this.width;//清除残影

                _this.RELOADED && (_this.RELOADED = false);
                _this.RESIZE && (_this.RESIZE = false);
            }

            //一直重绘画布
            _this.moveThings();
            _this.draw();
        })();
        this.RENDERED = true;
    },


    moveThings: function () {
        var speed = 0.01;
        var particles = this.particles;
        for (var i = 0; i < particles.length; i++) {
            if (particles[i].age > 0 && this.inBounds(particles[i].x, particles[i].y)) {
                var a = this.getValue(particles[i].x, particles[i].y);
                particles[i].x += speed * a.x;
                particles[i].y += speed * a.y;
                particles[i].age--;
            } else {
                particles[i] = this.makeParticle();
            }
        }
    },


    /**
     * @method
     * @desc 绘制
     * @ignore
     */
    draw: function () {
        var _this = this;
        this.colors = [];
        this.rgb = '0, 0, 0';
        this.background = 'rgb(' + this.rgb + ')';
        this.backgroundAlpha = 'rgba(' + this.rgb + ', .02)';
        var particles = this.particles;
        this.canvasContext[0].globalCompositeOperation = "destination-out";
        if (this.first) {
            this.canvasContext[0].fillStyle = this.background;
            this.first = false;
        } else {
            this.canvasContext[0].fillStyle = this.backgroundAlpha;
        }
        this.canvasContext[0].fillRect(0, 0, this.canvas[0].width, this.canvas[0].height);
        this.canvasContext[0].globalCompositeOperation = "source-over";

        this.canvasContext[0].lineWidth = 1;
        this.canvasContext[0].strokeStyle = "rgba(138,43,226,1)";
        var proj = new _this.Vector(0, 0);

        for (var i = 0; i < particles.length; i++) {
            var p = this.particles[i];
            this.particles[i].updateXY(p.x, p.y, proj);
            if (p.oldX != -1) {
                this.canvasContext[0].beginPath();
                this.canvasContext[0].moveTo(proj.x, proj.y);
                this.canvasContext[0].lineTo(p.oldX, p.oldY);
                this.canvasContext[0].stroke();
            }
            p.oldX = proj.x;
            p.oldY = proj.y;
        }
    },

    /**
     * 关联可视化定制图层对象
     * @memberof GeoGlobe.Visuals.Custom.delaunay.prototype
     * @param {GeoGlobe.Visuals.Custom} custom
     */
    addTo: function (custom) {
        this._parent = custom;
        this._parent.addLayer(this);
        this._parent.container.appendChild(this.div);
        this.canvas[0].width = this.cacheCanvas[0].width = this.width = this._parent.map.transform.width;
        this.canvas[0].height = this.cacheCanvas[0].height = this.height = this._parent.map.transform.height;
    },

    /**
     * @method
     * @desc 本地数据的处理
     * @private
     */
    setData: function (data) {
        this.data = data;
        var _this = this;

        /**
         * 判断棋子是不是超出了棋盘的界限
         * @memberof GeoGlobe.Visuals.Grid.Typhoon.prototype
         * @param {Number} x- x坐标。
         * @param {Number} y- y坐标。
         * @returns {Boolean} 返回布尔值。
         */
        this.inBounds = function (x, y) {
            return x >= this.field.x0 && x < this.field.x1 && y >= this.field.y0 && y < this.field.y1;
        };

        /**
         * @desc 本地数据的处理
         * @private
         */
        this.bilinear = function (coord, a, b) {
            var na = Math.floor(a);
            var nb = Math.floor(b);
            var ma = Math.ceil(a);
            var mb = Math.ceil(b);
            var fa = a - na;
            var fb = b - nb;

            return this.Data[na][nb][coord] * (1 - fa) * (1 - fb) +
                this.Data[ma][nb][coord] * fa * (1 - fb) +
                this.Data[na][mb][coord] * (1 - fa) * fb +
                this.Data[ma][mb][coord] * fa * fb;
        };

        this.getValue = function (x, y) {
            var a = (this.field.gridWidth - 1 - 1e-6) * (x - this.field.x0) / (this.field.x1 - this.field.x0);
            var b = (this.field.gridHeight - 1 - 1e-6) * (y - this.field.y0) / (this.field.y1 - this.field.y0);
            var vx = this.bilinear("x", a, b);
            var vy = this.bilinear("y", a, b);
            return new _this.Vector(vx, vy);
        };


        /**
         * 二维向量
         * @memberof GeoGlobe.Visuals.Grid.Typhoon.prototype
         * @param {Number} x- x坐标。
         * @param {Number} y- y坐标。
         */
        this.Vector = function (x, y) {
            this.x = x;
            this.y = y;
        };

        this.Vector.prototype.length = function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        };


        /**
         * 在棋盘里随机构造棋子
         * @memberof GeoGlobe.Visuals.Grid.Typhoon.prototype
         * @returns {GeoGlobe.Visuals.Grid.Typhoon.Particle} 棋子位置。
         */
        this.makeParticle = function () {
            var a = Math.random();
            var b = Math.random();
            var x = a * this.field.x0 + (1 - a) * this.field.x1;
            var y = b * this.field.y0 + (1 - b) * this.field.y1;
            return new this.Particle(x, y, 1 + 40 * Math.random());
        };


        /**
         * Reads data from raw object in form:
         * {
         * x0: 73.666667,
         * y0: 3.866667,
         * x1: 135.041667,
         * y1: 53.550000,
         *gridWidth: 501.0,
         * gridHeight: 237.0,
         * field:[
         *   0,0,
         *   0,0,
         *   ...(list of vectors)
         *  ]
         * }
         **/
        var field = [];
        var w = data.gridWidth;
        var h = data.gridHeight;
        var i = 0;

        for (var x = 0; x < w; x++) {
            field[x] = [];
            for (var y = 0; y < h; y++) {
                var vx = data.field[i++];
                var vy = data.field[i++];
                var v = new this.Vector(vx, vy);
                field[x][y] = v;
            }
        }
        this.field = data;
        this.numParticles = 5000;
        for (var i = 0; i < this.numParticles; i++) {
            this.particles.push(this.makeParticle());
        }
        this.Data = field;
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV
 * @classdesc 基于MapV的可视化图层
 * @example
 //构造地图对象
 var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 16,
    bearing: 0,
	pitch: 0,
    units: "degrees",
    center: [114.20509630753577, 30.776055193053764]
 });
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //绑定鼠标点击事件
 mapV.on('overlayerclick', function(e){
	console.info(e);
 });
 //绑定鼠标移动事件
 mapV.on('overlayerhover', function(e){
	console.info(e);
 });
 //构造简单图层
 var simple = new GeoGlobe.Visuals.MapV.Simple({
    id: 'simple_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        fillStyle: 'rgba(55, 50, 250, 0.2)',
        globalCompositeOperation: "lighter",
        size: 15,
        animation: {
            type: 'time',
            stepsRange: {
                start: 0,
                end: 100
            },
            trails: 10,
            duration: 5
        }
    }
 });
 //添加到MapV可视化图层
 simple.addTo(mapV);
 //绘制
 mapV.render();
 */
GeoGlobe.Visuals.MapV = GeoGlobe.Class4OL(GeoGlobe.Visuals, {

    /**
     * 地图对象
     * @memberof GeoGlobe.Visuals.MapV.prototype
     * @type {GeoGlobe.Map}
     * @default null
     */
    map: null,

    /**
     * map的容器
     * @memberof GeoGlobe.Visuals.MapV.prototype
     * @type {Object}
     */
    container: null,

    /**
     * 图层集合
     * @memberof GeoGlobe.Visuals.MapV.prototype
     * @type {Array}
     */
    layers: [],

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        GeoGlobe.Visuals.prototype.initialize.apply(this, arguments);
        this.layers= [];
        if(!window.mapv){
            console.error("使用MapV可视化图层前，需引入mapv库！");
        }
    },

    /**
     * 与地图对象关联
     * @function addTo
     * @memberof GeoGlobe.Visuals.MapV.prototype
     * @public
     * @param {Object} map 地图对象
     */
    addTo: function (map) {
        GeoGlobe.Visuals.prototype.addTo.apply(this, arguments);

        this.container.className = "geoglobe-mapv-container";
    },

    /**
     * 绘制图层
     * @function render
     * @memberof GeoGlobe.Visuals.MapV.prototype
     */
    render: function () {
        for (var i = 0; i < this.layers.length; i++) {
            this.layers[i].render();
        }
    },

    /**
     * 向可视化图层中添加子图层
     * @function addLayer
     * @memberof GeoGlobe.Visuals.MapV.prototype
     * @param {Object} layer 子图层对象
     */
    addLayer: function (layer) {
        if (!layer.id) {
            console.error("图层id属性不能为空！");
            return;
        }
        var oldLayer = this.getLayer(layer.id);
        if (oldLayer) {
            oldLayer = layer;
        } else {
            this.layers.push(layer);
        }
    },

    /**
     * 移除图层
     * @function removeLayer
     * @memberof GeoGlobe.Visuals.MapV.prototype
     * @param {String} id 图层id
     */
    removeLayer: function (id) {
        var array = [];
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                this.layers[i].destroy && this.layers[i].destroy();
                continue;
            }
            array.push(this.layers[i]);
        }
        this.layers = array;
    },

    /**
     * 移动图层
     * @function moveLayer
     * @memberof GeoGlobe.Visuals.Custom.prototype
     * @param {String} id 图层id
     */
    moveLayer: function moveLayer (id, before) {
        var layer = this.getLayer(id);
        if (!layer) {
            this.fire('error', {
                error: new Error(
                    "The layer '" + id + "' does not exist in " +
                    "the map's style and cannot be moved."
                )
            });
            return;
        }

        this._order = this.layers.map(function (Layer) { return Layer.id; });
        var index = this._order.indexOf(id);
        this._order.splice(index, 1);

        var newIndex = before ? this._order.indexOf(before) : this._order.length;
        if (before && newIndex === -1) {
            this.fire('error', { error: new Error(("Layer with id \"" + before + "\" does not exist on this map."))});
            return;
        }
        this._order.splice(newIndex, 0, id);
        for(var j = 0; j < this._order.length; j++) {
            for (var i = 0; i < this.layers.length; i++) {
                if (this._order[j] === this.layers[i].id) {
                    this.layers[i].div.style.zIndex = j
                }
            }
        }
    },

    /**
     * 获取指定id图层
     * @function getLayer
     * @memberof GeoGlobe.Visuals.MapV.prototype
     * @param {String} id 图层id
     * @returns {Object} layer 图层对象
     */
    getLayer: function (id) {
        for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                return this.layers[i];
            }
        }
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.Bubble
 * @classdesc 基于MapV的气泡图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造气泡图层
 var bubble = new GeoGlobe.Visuals.MapV.Bubble({
    id: 'bubble_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        fillStyle: 'rgba(255, 50, 50, 0.6)',
        maxSize: 20,
        max: 30
    }
 });
 //添加到MapV可视化图层
 bubble.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.Bubble = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.Bubble.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.Bubble.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.Bubble.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.Bubble.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.Bubble.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "bubble";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");
        //todo events
        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this._layer.canvasLayer.canvas);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.Bubble.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.Bubble.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.Category
 * @classdesc 基于MapV的分类图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造分类图层
 var category = new GeoGlobe.Visuals.MapV.Category({
    id: 'category_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        splitList:{
            other: "#FFC0CB",
            1 : "#00FF00",
            2: "yellow",
            3 : "red"
        },
        size: 2,
        max: 30
    }
 });
 //添加到MapV可视化图层
 category.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.Category = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.Category.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.Category.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.Category.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.Category.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.Category.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "category";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");

        //todo events
        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this._layer.canvasLayer.canvas);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.Category.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.Category.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.Choropleth
 * @classdesc 基于MapV的分级统计图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造分级统计图层
 var choropleth = new GeoGlobe.Visuals.MapV.Choropleth({
    id: 'choropleth_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {"id": "13", "name": "河北", "cp": [115.4004, 37.9688], "childNum": 11, "count": 48.53010858521839},
        "geometry": {
            "type": "MultiPolygon",
            "coordinates": [[[[114.5215, 39.5068], [114.3457, 39.8584], [113.9941, 39.9902], [114.5215, 40.3418], [114.3457, 40.3857], [114.2578, 40.6055], [114.082, 40.7373], [113.9063, 41.1328], [113.9941, 41.2207], [113.9063, 41.4404], [114.2578, 41.5723], [114.1699, 41.792], [114.5215, 42.1436], [114.873, 42.0996], [114.9609, 41.6162], [115.2246, 41.5723], [115.9277, 41.9238], [116.0156, 41.792], [116.2793, 42.0117], [116.8066, 42.0117], [116.8945, 42.4072], [117.334, 42.4512], [117.5098, 42.583], [117.7734, 42.627], [118.0371, 42.4072], [117.9492, 42.2314], [118.125, 42.0557], [118.3008, 42.0996], [118.3008, 41.792], [118.125, 41.748], [118.3887, 41.3086], [119.2676, 41.3086], [118.8281, 40.8252], [119.2676, 40.5176], [119.5313, 40.5615], [119.707, 40.1221], [119.8828, 39.9463], [119.5313, 39.6826], [119.4434, 39.4189], [118.916, 39.0674], [118.4766, 38.9355], [118.125, 39.0234], [118.0371, 39.1992], [118.0371, 39.2432], [117.8613, 39.4189], [117.9492, 39.5947], [117.6855, 39.5947], [117.5098, 39.7705], [117.5098, 39.9902], [117.6855, 39.9902], [117.6855, 40.0781], [117.4219, 40.21], [117.2461, 40.5176], [117.4219, 40.6494], [116.9824, 40.6934], [116.6309, 41.0449], [116.3672, 40.9131], [116.4551, 40.7813], [116.1914, 40.7813], [116.1035, 40.6055], [115.752, 40.5615], [115.9277, 40.2539], [115.4004, 39.9463], [115.4883, 39.6387], [115.752, 39.5068], [116.1914, 39.5947], [116.3672, 39.4629], [116.543, 39.5947], [116.8066, 39.5947], [116.8945, 39.1113], [116.7188, 38.9355], [116.7188, 38.8037], [117.2461, 38.54], [117.5977, 38.6279], [117.9492, 38.3203], [117.4219, 37.8369], [116.8066, 37.8369], [116.4551, 37.4854], [116.2793, 37.5732], [116.2793, 37.3535], [116.0156, 37.3535], [115.752, 36.9141], [115.3125, 36.5186], [115.4883, 36.167], [115.3125, 36.0791], [115.1367, 36.2109], [114.9609, 36.0791], [114.873, 36.123], [113.7305, 36.3428], [113.4668, 36.6504], [113.7305, 36.8701], [113.7305, 37.1338], [114.1699, 37.6611], [113.9941, 37.7051], [113.8184, 38.1445], [113.5547, 38.2764], [113.5547, 38.54], [113.8184, 38.8037], [113.8184, 38.9355], [113.9063, 39.0234], [114.3457, 39.0674], [114.5215, 39.5068]]], [[[117.2461, 40.0781], [117.1582, 39.8145], [117.1582, 39.6387], [116.8945, 39.6826], [116.8945, 39.8145], [116.8066, 39.9902], [117.2461, 40.0781]]]]
        }
    }, {
        "type": "Feature",
        "properties": {"id": "42", "name": "湖北", "cp": [112.2363, 31.1572], "childNum": 17, "count": 35.46388778327547},
        "geometry": {
            "type": "Polygon",
            "coordinates": [[[110.2148, 31.1572], [110.127, 31.377], [109.6875, 31.5527], [109.7754, 31.6846], [109.5996, 31.7285], [109.5117, 32.4316], [109.6875, 32.6074], [110.127, 32.6074], [110.127, 32.7393], [109.7754, 32.915], [109.7754, 33.0469], [109.4238, 33.1348], [109.5996, 33.2666], [110.3027, 33.1787], [110.5664, 33.2666], [110.7422, 33.1348], [111.0059, 33.2666], [111.5332, 32.6074], [112.3242, 32.3438], [113.2031, 32.4316], [113.4668, 32.2998], [113.7305, 32.4316], [113.8184, 31.8604], [113.9941, 31.7725], [114.1699, 31.8604], [114.5215, 31.7725], [114.6094, 31.5527], [114.7852, 31.4648], [115.1367, 31.5967], [115.2246, 31.4209], [115.4004, 31.4209], [115.5762, 31.2012], [116.0156, 31.0254], [115.752, 30.6738], [116.1035, 30.1904], [116.1035, 29.8389], [115.9277, 29.707], [115.4883, 29.7949], [114.873, 29.3994], [114.2578, 29.3555], [113.9063, 29.0479], [113.7305, 29.0918], [113.6426, 29.3115], [113.7305, 29.5752], [113.5547, 29.707], [113.5547, 29.8389], [113.0273, 29.4434], [112.9395, 29.4873], [113.0273, 29.751], [112.9395, 29.7949], [112.6758, 29.5752], [112.5, 29.6191], [112.2363, 29.5313], [111.7969, 29.9268], [110.8301, 30.1465], [110.4785, 30.0146], [110.6543, 29.751], [110.4785, 29.6631], [109.7754, 29.751], [109.6875, 29.6191], [109.5117, 29.6191], [109.248, 29.1357], [109.0723, 29.3555], [108.9844, 29.3115], [108.6328, 29.8389], [108.457, 29.7949], [108.5449, 30.2344], [108.457, 30.4102], [108.6328, 30.5859], [108.8086, 30.498], [109.0723, 30.6299], [109.1602, 30.542], [109.248, 30.6299], [109.4238, 30.542], [109.8633, 30.8936], [110.0391, 30.8057], [110.2148, 31.1572]]]
        }
    }],
    rendererOptions: {
        splitList: [
            {
                start: 0,
                end: 10,
                value: '#f1eef6'
            },{
                start: 10,
                end: 20,
                value: '#d5bad9'
            },{
                start: 20,
                end: 30,
                value: '#cc97c7'
            },{
                start: 30,
                end: 40,
                value: '#e469af'
            },{
                start: 40,
                end: 50,
                value: '#ee3387'
            },{
                start: 50,
                end: 60,
                value: '#d61e53'
            },{
                start: 60,
                value: '#960b3d'
            }
        ],
        globalAlpha: 0.8
    }
 });
 //添加到MapV可视化图层
 choropleth.addTo(mapV);
 //绘制
 mapV.render();
 */
GeoGlobe.Visuals.MapV.Choropleth = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.Choropleth.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.Choropleth.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.Choropleth.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.Choropleth.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.Choropleth.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "choropleth";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");

        //todo events
        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this._layer.canvasLayer.canvas);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.Choropleth.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.Choropleth.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.Grid
 * @classdesc 基于MapV的格网图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造格网图层
 var grid = new GeoGlobe.Visuals.MapV.Grid({
    id: 'grid_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        fillStyle: 'rgba(55, 50, 250, 0.8)',
        shadowColor: 'rgba(255,250,250,1)',
        shadowBlur: 20,
        size: 40,
        globalAlpha: 0.5,
        label: {
              show: true,
              fillStyle: 'white'
        },
        gradient: {0.25:"rgb(0,0,255)",0.55:"rgb(0,255,0)",0.85:"yellow",1.0:"rgb(255,0,0)"}
    }
 });
 //添加到MapV可视化图层
 grid.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.Grid = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.Grid.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.Grid.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.Grid.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.Grid.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.Grid.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "grid";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");

        //todo events
        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this._layer.canvasLayer.canvas);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.Grid.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.Grid.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.HeatMap
 * @classdesc 基于MapV的热力图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造热力图层
 var heatMap = new GeoGlobe.Visuals.MapV.HeatMap({
    id: 'heatMap_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        size: 13,
        gradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)" },
        max: 60,
        animation: {
            type: 'time',
            stepsRange: {
                start: 0,
                end: 100
            },
            trails: 10,
            duration: 4
        }
    }
 });
 //添加到MapV可视化图层
 heatMap.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.HeatMap = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.HeatMap.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.HeatMap.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.HeatMap.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.HeatMap.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.HeatMap.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "heatmap";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");

        //todo events
        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this._layer.canvasLayer.canvas);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.HeatMap.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.HeatMap.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.HoneyComb
 * @classdesc 基于MapV的蜂巢图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造蜂巢图层
 var honeyComb = new GeoGlobe.Visuals.MapV.HoneyComb({
    id: 'honeyComb_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        fillStyle: 'rgba(55, 50, 250, 0.8)',
        shadowColor: "rgba(255,250,50,1)",
        shadowBlur: 20,
        max: 100,
        size: 50,
        label: {
           show: true,
           fillStyle:'white'
        },
        globalAlpha: 0.5,
        gradient: {0.25:"rgb(0,0,255)",0.55:"rgb(0,255,0)",0.85: "yellow", 1.0: "rgb(255,0,0)"}
    }
 });
 //添加到MapV可视化图层
 honeyComb.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.HoneyComb = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.HoneyComb.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.HoneyComb.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.HoneyComb.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.HoneyComb.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.HoneyComb.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "honeycomb";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");

        //todo events
        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this._layer.canvasLayer.canvas);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.HoneyComb.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.HoneyComb.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.Icon
 * @classdesc 基于MapV的图标图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造图标图层
 var icon = new GeoGlobe.Visuals.MapV.Icon({
    id: 'icon_1',
    visibility: true,
    dragdrawing: true,
    icon: '../../images/flag.png',
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        width: 50,
        height: 50,
        deg: 360 * Math.random()
    }
 });
 //添加到MapV可视化图层
 icon.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.Icon = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.Icon.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.Icon.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.Icon.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.Icon.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.Icon.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        var icon = new Image();
        icon.src = this.icon;
        icon.onload = function () {
            options.icon = icon;
            options.draw = "icon";
            options.dragdrawing = _this.dragdrawing;
            if (this.RENDERED) {
                this._parent.container.removeChild(this.div);
            }
            options.container = _this._parent.container;
            this.div = document.createElement("div");
            this._parent.container.appendChild(this.div);
            this.div.setAttribute("id",this.id);
            this.div.setAttribute("style","position:absolute");

            //todo events
            _this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
            this.div.appendChild(this._layer.canvasLayer.canvas);
        };
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.Icon.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.Icon.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.Intensity
 * @classdesc 基于MapV的强度图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造强度图层
 var intensity = new GeoGlobe.Visuals.MapV.Intensity({
    id: 'intensity_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        gradient: {
            0: 'blue',
            0.5: 'yellow',
            1: 'red'
        },
        max: 30
    }
 });
 //添加到MapV可视化图层
 intensity.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.Intensity = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.Intensity.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.Intensity.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.Intensity.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.Intensity.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.Intensity.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "intensity";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");

        //todo events
        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this._layer.canvasLayer.canvas);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.Intensity.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.Intensity.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.Simple
 * @classdesc 基于MapV的简单图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造简单图层
 var simple = new GeoGlobe.Visuals.MapV.Simple({
    id: 'simple_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {count:5.516636266964161,time:16.231042218116176},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        fillStyle: 'rgba(55, 50, 250, 0.2)',
        globalCompositeOperation: "lighter",
        size: 15,
        animation: {
            type: 'time',
            stepsRange: {
                start: 0,
                end: 100
            },
            trails: 10,
            duration: 5
        }
    }
 });
 //添加到MapV可视化图层
 simple.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.Simple = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.Simple.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.Simple.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.Simple.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.Simple.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.Simple.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "simple";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");
        options.methods = {};
        options.methods.click = function (feature, event) {
            feature && _this._parent.fire("overlayerclick", {
                layer: _this,
                feature: feature,
                event: event
            });
        };
        options.methods.mousemove = function (feature, event) {
            feature && _this._parent.fire("overlayerhover", {
                layer: _this,
                feature: feature,
                event: event
            });
        };

        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this._layer.canvasLayer.canvas);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.Simple.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this.div);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.Simple.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author kz
 * @class GeoGlobe.Visuals.MapV.Text
 * @classdesc 基于MapV的文本图层
 *
 * @example
 //构造MapV可视化图层
 var mapV = new GeoGlobe.Visuals.MapV();
 //添加到地图中
 mapV.addTo(map);
 //构造文本图层
 var text = new GeoGlobe.Visuals.MapV.Text({
    id: 'text_1',
    visibility: true,
    dragdrawing: true,
    data: [{
        "type": "Feature",
        "properties": {"text":"￥4.89"},
        "geometry": {
            "type": "Point",
            "coordinates": [123.3192464663197, 43.91886355937628]
        }
    }],
    rendererOptions: {
        fillStyle: 'yellow',
        avoid: true,
        size: 12,
        font: "18px Arial",
        shadowColor: "yellow",
        shadowBlur: 10
    }
 });
 //添加到MapV可视化图层
 text.addTo(mapV);
 //绘制
 mapV.render();
 */

GeoGlobe.Visuals.MapV.Text = GeoGlobe.Class4OL({
    /**
     * MapV可视化对象
     * @memberof GeoGlobe.Visuals.MapV.Text.prototype
     * @private
     * @type {GeoGlobe.Visuals.MapV}
     */
    _parent: null,

    /**
     * 构造函数
     * @function initialize
     * @memberof GeoGlobe.Visuals.MapV.Text.prototype
     * @private
     * @param {Object} options 参数对象
     */
    initialize: function (options) {
        this.options = options;
        GeoGlobe.Util.extend(this, options);

        this.setData(this.data);
    },

    /**
     * 关联mapV
     * @memberof GeoGlobe.Visuals.MapV.Text.prototype
     * @param {GeoGlobe.Visuals.MapV} mapV
     */
    addTo: function (mapV) {
        this._parent = mapV;
        this._parent.addLayer(this);
    },

    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.MapV.Text.prototype
     */
    remove: function () {
        this._parent.removeLayer(this.id);
    },

    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.MapV.Text.prototype
     */
    render: function () {
        var _this = this;
        var map = this._parent.map;
        var dataSet = new mapv.DataSet(this.data);
        var options = this.rendererOptions;
        options.draw = "text";
        options.dragdrawing = this.dragdrawing;
        if (this.RENDERED) {
            this._parent.container.removeChild(this.div);
        }
        options.container = this._parent.container;
        this.div = document.createElement("div");
        this._parent.container.appendChild(this.div);
        this.div.setAttribute("id",this.id);
        this.div.setAttribute("style","position:absolute");

        //todo events
        this._layer = new mapv.mapboxGLMapLayer(map, dataSet, options);
        this.div.appendChild(this.div);
        this.RENDERED = true;
    },

    /**
     * 销毁图层
     * @memberof GeoGlobe.Visuals.MapV.Text.prototype
     */
    destroy: function () {
        this._parent.container.removeChild(this._layer.canvasLayer.canvas);

        this._parent = null;
        this.options = null;
        this.dataSet = [];
    },

    /**
     * 数据的处理
     * @memberof GeoGlobe.Visuals.MapV.Text.prototype
     * @param {Array} data 数据，geojson格式
     */
    setData: function (data) {
        this.data = data.map(function (feature) {
            return GeoGlobe.Util.extend(feature.properties, {geometry: feature.geometry});
        })
    }
});/**
 * @author liuck
 * @class GeoGlobe.Visuals.DeckGL
 * @classdesc 基于DeckGL的可视化图层。
 * @example
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 6.6,
    bearing: -27.396674584323023,
    pitch: 40.5,
    units: "degrees",
    center: [-1.4157267858730052,52.232395363869415]
});
//构造DeckGL可视化图层
var deckgl = new GeoGlobe.Visuals.DeckGL();
//绑定初始构建事件
deckgl.on('overlayerinit', function(e){

});
//绑定鼠标点击事件
deckgl.on('overlayerclick', function(e,a,b){

});
//绑定鼠标移动事件
deckgl.on('overlayerhover', function(e,a,b){

})
//添加到地图中
deckgl.addTo(map);
 */

GeoGlobe.Visuals.DeckGL = GeoGlobe.Class4OL(GeoGlobe.Visuals, {
	
	/**
     * 地图对象
	 * @memberof GeoGlobe.Visuals.DeckGL.prototype
	 * @type {GeoGlobe.Map}
	 * @default null
     */
    map: null,
	
    /**
     * map的容器
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     * @type {Object}

     */
    container: null,
    
    /**
     * 图层容器
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     * @type {Array}
     */
    layers: [],
    
    /**
     * @member DeckGL在GL地图上的适配器
     * @type {Object}
     * @private 
     */
    _deckgl: null,
	
    /**
     * @function initialize
     * @description  GeoGlobe.Visuals.EchartsGL构造函数。
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
        GeoGlobe.Visuals.prototype.initialize.apply(this, arguments);
        this.layers= [];
		if(!window.deck){
			console.error("使用DeckGL可视化图层前，需引入deckgl库！");
			return;
		}
    },
    
    /**
     * @function addTo
     * @description 与gl地图对象关联
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     * @public 
     * @param {Object} map -  gl地图对象
     */
    addTo: function (map){
    	GeoGlobe.Visuals.prototype.addTo.apply(this, arguments);
		
		this.container.className = "geoglobe-deckgl-container";
		
		var _this = this;
		this._deckgl = new deck.DeckGL({
			container : this.container,
			geoMap : this.map,
			onWebGLInitialized : function(gl) {
				_this.fire("overlayerinit", {param: gl});
			},
			onLayerClick : function(info, pickedInfos, event) {
				_this.fire("overlayerclick", {param: {info: info, pickedInfos: pickedInfos, event: event}});
			},
			onLayerHover : function(info, pickedInfos, event) {
				_this.fire("overlayerhover", {param: {info: info, pickedInfos: pickedInfos, event: event}});
			},
			layers: []
		});
    },
    
    /**
     * @function render
     * @description 绘制图层，包含子图层
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     */
    render: function(){
    	var layers = [];
        if (this._order) {
            for (var p = 0; p < this._order.length; p++) {
                for (var i = 0; i < this.layers.length; i++) {
                    if (this.layers[i].id == this._order[p]) {
                        layers.push(this.layers[i].getInnerLayer());
                    }
                }
            }
        } else {
            for (var i = 0; i < this.layers.length; i++) {
                layers.push(this.layers[i].getInnerLayer());
            }
        }
    	this._deckgl.props.layers = layers;
    	this._deckgl.setProps();
    },
    
    /**
     * @function addLayer
     * @description 向DeckGLjs可视化图层中添加子图层
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     * @param {Object} layer - DeckGL命名空间下的子图层对象
     */
    addLayer: function(layer){
    	if(!layer.id){
    		console.error("图层id属性不能为空！"); 
    		return;
    	}
    	var oldLayer = this.getLayer(layer.id);
    	if(oldLayer){
    		oldLayer = layer;
    	}else{
    		this.layers.push(layer);
    	}
    },
    
    /**
     * @function removeLayer
     * @description 移除图层
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     * @param {string} id - 图层id
     */
    removeLayer: function(id) {
    	var array = [];
    	for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                continue;
            }
            array.push(this.layers[i]);
        }
    	this.layers = array;
    },

    /**
     * 移动图层
     * @function moveLayer
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     * @param {String} id 图层id
     */
    moveLayer: function moveLayer(id, before) {
        var layer = this.getLayer(id);
        if (!layer) {
            this.fire('error', {
                error: new Error(
                    "The layer '" + id + "' does not exist in " +
                    "the map's style and cannot be moved."
                )
            });
            return;
        }

        this._order = this.layers.map(function (Layer) {
            return Layer.id;
        });
        var index = this._order.indexOf(id);
        this._order.splice(index, 1);

        var newIndex = before ? this._order.indexOf(before) : this._order.length;
        if (before && newIndex === -1) {
            this.fire('error', {error: new Error(("Layer with id \"" + before + "\" does not exist on this map."))});
            return;
        }
        this._order.splice(newIndex, 0, id);
    },
    
    /**
     * @function getLayer
     * @description 获取指定id图层
     * @memberof GeoGlobe.Visuals.DeckGL.prototype
     * @param {string} id - 图层id.
     * @returns Layer
     */
    getLayer: function(id) {
    	for (var i = 0; i < this.layers.length; i++) {
            if (id === this.layers[i].id) {
                return this.layers[i];
            }
        }
    }
    
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.DeckGL.HexagonLayer
 * @classdesc 基于DeckGL的六角柱图
 * @example
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 6.6,
    bearing: -27.396674584323023,
    pitch: 40.5,
    units: "degrees",
    center: [-1.4157267858730052,52.232395363869415]
});
//构造DeckGL可视化图层
var deckgl = new GeoGlobe.Visuals.DeckGL();
//绑定初始构建事件
deckgl.on('overlayerinit', function(e){

});
//绑定鼠标点击事件
deckgl.on('overlayerclick', function(e,a,b){

});
//绑定鼠标移动事件
deckgl.on('overlayerhover', function(e,a,b){

})
//添加到地图中
deckgl.addTo(map);
//构造六角柱图层
var hexagonLayer = new GeoGlobe.Visuals.DeckGL.HexagonLayer({
	id: '3D六角柱',
    data: [
    	{ "type": "Feature", "properties": { "id": 10001, "name": "1号柱" }, "geometry": { "type": "Point", "coordinates": [114.20257245367856, 30.773372078561778] } }
	],
    visible: true,
    pickable: true,
    fp64: false,
    extruded: true,
    opacity: 1,
    elevationScale: 50,
    radius: 2000,
	upperPercentile: 100,
	coverage:1,
	elevationRange: [0, 3000]
});
//添加到DeckGL图层
hexagonLayer.addTo(deckgl);
//绘制
deckgl.render();
 */

GeoGlobe.Visuals.DeckGL.HexagonLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 图层名称
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {String}
	 * @default ''
	 */
	name: '',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否开启鼠标拾取
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 是否开启高精度64位模式
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	fp64: false,
	
	/**
	 * 透明度 0-1
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Float}
	 * @default 1.0
	 */
	opacity: 1.0,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @description geojson结构
	 * @type {Array}
	 * @example 
	 * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "1号柱"
	 * 	},
	 * "geometry": {
	 * 		"type": "Point",
	 * 		"coordinates": [114.20257245367856, 30.773372078561778]
	 * 	}
	 * }]
	 */
	data: [],
	
	/**
	 * 色标输入域
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Array}
	 * @default null
	 * @description 色标图将数字域继续到离散的颜色范围。 如果未提供，该图层将colorDomain设置为每个六边形中的计数范围。 您可以通过传入任意颜色域来控制六边形的颜色如何映射到计数数。 当您想要使用相同的颜色映射呈现不同的数据输入以进行比较时，此属性非常方便。
	 */
	colorDomain: null,
	
	/**
	 * 颜色范围
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Array}
	 * @default [[255, 255, 178],[254, 217, 118],[254, 178, 76],[253, 141, 60],[240, 59, 32],[189, 0, 38]]
	 * @description 六边形颜色范围为格式为[[255,255,255,255]]的颜色数组。 默认为colorbrewer 6级YlOrRd。
	 */
	colorRange: [
	  [255, 255, 178],
	  [254, 217, 118],
	  [254, 178, 76],
	  [253, 141, 60],
	  [240, 59, 32],
	  [189, 0, 38]
	],
	
	/**
	 * 最低百分位数
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Int}
	 * @default 0
	 * @description 过滤垃圾箱并通过lowerPercentile重新计算颜色。 颜色值小于lowerPercentile的六边形将被隐藏。
	 */
	lowerPercentile: 0,
	
	/**
	 * 最高百分位数
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Int}
	 * @default 100
	 * @description 过滤垃圾箱并通过upperPercentile重新计算颜色。 颜色值大于upperPercentile的六边形将被隐藏。
	 */
	upperPercentile: 100,
	
	/**
	 * 高程比例输入域
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Array}
	 * @default null
	 * @description 高程比例是一个线性比例，它将计数数量映射到高程。 默认情况下，它设置为每个六边形中0到最大点数之间。 当您想要使用相同的高程比例渲染不同的数据输入以进行比较时，此属性非常方便。
	 */
	elevationDomain: null,
	
	/**
	 * 高程值域
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Array}
	 * @default [0, 1000]
	 * @description 高程刻度输出范围
	 */
	elevationRange: [0, 1000],
	
	/**
	 * 最低海拔百分位数
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Int}
	 * @default 0
	 * @description 过滤垃圾箱并通过elevationLowerPercentile重新计算高程。 高程值小于elevationLowerPercentile的六边形将被隐藏。
	 */
	elevationLowerPercentile: 0,
	
	/**
	 * 最高海拔百分位数
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Int}
	 * @default 100
	 * @description 过滤垃圾箱并通过elevationUpperPercentile重新计算高程。 高程值大于elevationUpperPercentile的六边形将被隐藏。
	 */
	elevationUpperPercentile: 100,
	
	/**
	 * 六角高程倍数
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 实际高程由elevationScale * getElevation（d）计算。 elevationScale是一个方便的属性，可以在不更新数据的情况下缩放所有六边形。
	 */
	elevationScale: 1,
	
	/**
	 * 六角形槽的半径
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Int}
	 * @default 1000
	 * @description 六角形槽的半径，以米为单位。 六边形是尖顶（而不是平顶）。
	 */
	radius: 1000,
	
	/**
	 * 六角半径倍数
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 六角半径乘数，夹在0-1之间。六边形的最终半径由coverage * radius计算。 注意：覆盖范围不会影响点的分区方式。 bin的半径仅由radius属性确定。
	 */
	coverage: 1,
	
	/**
	 * 六角半径倍数
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 是否启用单元格提升。 通过每个细胞中的点数计数细胞高度。 如果设置为false，则所有单元格将保持平坦。
	 */
	extruded: false,
	
	/**
	 * 聚合为六边形区间的函数， 暂不支持自定义
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description hexagonAggregator是将数据聚合为六边形区间的函数。 hexagonAggregator将图层和当前视口的道具作为参数。 输出应为{hexagons：[]，hexagonVertices：[]}。 六边形是{centroid：[]，points：[]}的数组，其中centroid是六边形的中心，points是由它包含的点数组。 hexagonVertices（可选）是一个定义六边形几何体的点数组。
	 */
	
	/**
	 * 灯光设置
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @type {Object}
	 * @default {}
	 * @description 这是一个包含拉伸多边形的灯光设置的对象
	 */
	lightSettings: {},

	/**
	 * 位置GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} coordinates
	 * @default data.properties.coordinates
	 */
	getPosition: function(data){
		if (data.geometry.type === 'Point') {
            return data.geometry.coordinates;
        } else {
            return null;
        }
	},

	/**
	 * 颜色GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @param {Array} points
	 * @returns {Int} count
	 * @default points.length
	 * @description getColorValue是获取bin颜色所基于的值的访问器函数。 它将每个bin中的一组点作为参数，返回一个数字。 例如，您可以传入getColorValue，以通过每个点的特定属性的avg / mean / max为区域着色。 默认情况下，getColorValue返回points数组的长度。注意：六边形图层比较getColorValue是否已更改为重新计算其颜色所基于的每个bin的值。 您应该传递在render函数之外定义的函数，这样它就不会在每个渲染过程中创建一个新函数。
	 */
	getColorValue: function(points){
        return points.length;
    },
	
	/**
	 * 高程GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 * @param {Array} points
	 * @returns {Int} count
	 * @default points.length
	 * @description 与getColorValue类似，getElevationValue是获取bin高程所基于的值的访问器函数。 它将每个bin中的一组点作为参数，返回一个数字。 默认情况下，getElevationValue返回points数组的长度。注意：六边形图层比较getElevationValue是否已更改为重新计算每个bin的值以进行提升。 您应该传递在render函数之外定义的函数，这样它就不会在每个渲染过程中创建一个新函数。
	 */
    getElevationValue: function(points){
        return points.length;
    },
	
    /**
	 * 计算bin颜色域时将调用此回调
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 */
    onSetColorDomain: function() {},
	
    /**
	 * 计算bin高程域时将调用此回调
	 * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
	 */
    onSetElevationDomain: function() {},

    /**
     * DeckGL可视化对象
     * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.DeckGL}
     */
	_parent: null,
	
    /**
     * @name 构造函数。
     * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.options = options;
        GeoGlobe.Util.extend(this, options);
    },
	
    /**
     * 关联DeckGL
     * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
     * @param {GeoGlobe.Visuals.DeckGL} deckgl 
     */
    addTo: function(deckgl){
    	this._parent = deckgl;
    	this._parent.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
     */
    remove: function(){
    	this._parent.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
     */
    render: function(){
    	this._parent.render();
    },
    
    /**
     * 获取deckgl内部layer实例
     * @memberof GeoGlobe.Visuals.DeckGL.HexagonLayer.prototype
     * @returns {Object} layer
     */
    getInnerLayer: function(){
    	var option = {};
    	GeoGlobe.Util.extend(option, this);
    	return new deck.HexagonLayer(option);
    }
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.DeckGL.ScatterplotLayer
 * @classdesc 基于DeckGL的散点图层
 * @example
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 6.6,
    bearing: -27.396674584323023,
    pitch: 40.5,
    units: "degrees",
    center: [-1.4157267858730052,52.232395363869415]
});
//构造DeckGL可视化图层
var deckgl = new GeoGlobe.Visuals.DeckGL();
//绑定初始构建事件
deckgl.on('overlayerinit', function(e){

});
//绑定鼠标点击事件
deckgl.on('overlayerclick', function(e,a,b){

});
//绑定鼠标移动事件
deckgl.on('overlayerhover', function(e,a,b){

})
//添加到地图中
deckgl.addTo(map);
//构造散点图层
var scatterplotLayer = new GeoGlobe.Visuals.DeckGL.ScatterplotLayer({
	id: 'scatterplot-layer',
    data: [
    	{ "type": "Feature", "properties": { "id": 10001, "name": "散点1" }, "geometry": { "type": "Point", "coordinates": [114.20257245367856, 30.773372078561778] } }
	],
    visible: true,
    pickable: true,
    fp64: false,
    opacity: 0.8,
    radiusScale: 6,
    radiusMinPixels: 1,
    radiusMaxPixels: 100,
    getRadius: function(d){ return Math.random()*100 },
    getColor: function(d){ return [255, 140, 0] }
});
//添加到DeckGL图层
scatterplotLayer.addTo(deckgl);
//绘制
deckgl.render();
 */

GeoGlobe.Visuals.DeckGL.ScatterplotLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 图层名称
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {String}
	 * @default ''
	 */
	name: '',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否开启鼠标拾取
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 是否开启高精度64位模式
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	fp64: false,
	
	/**
	 * 透明度 0-1
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Float}
	 * @default 1.0
	 */
	opacity: 1.0,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @description geojson结构
	 * @type {Array}
	 * @example 
	 * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "1号柱"
	 * 	},
	 * "geometry": {
	 * 		"type": "Point",
	 * 		"coordinates": [114.20257245367856, 30.773372078561778]
	 * 	}
	 * }]
	 */
	data: [],
	
	/**
	 * 用于所有点的全局半径乘法器
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 半径倍数
	 */
	radiusScale: 1,
	
	/**
	 * 是否只画点的轮廓
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 是否只画点的轮廓
	 */
	outline: false,
	
	/**
	 * 轮廓的宽度
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 轮廓的宽度，以像素为单位。要求大纲是真实的。
	 */
	strokeWidth: 1,
	
	/**
	 * 像素的最小半径
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Int}
	 * @default 0
	 * @description 像素的最小半径。
	 */
	radiusMinPixels: 0,
	
	/**
	 * 像素的最大半径
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @type {Int}
	 * @default Number.MAX_SAFE_INTEGER
	 * @description 像素的最大半径。
	 */
	radiusMaxPixels: Number.MAX_SAFE_INTEGER,

	/**
	 * 位置GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} coordinates
	 * @default data.properties.coordinates
	 */
	getPosition: function(data){
		if (data.geometry.type === 'Point') {
            return data.geometry.coordinates;
        } else {
            return null;
        }
	},

	/**
	 * 颜色GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @param {Object} data
	 * @returns {Array} color
	 * @default [0, 0, 0, 255]
	 * @description RGBA每个对象的色系，在R，G，B [一]。每个分量在0到255的范围。
	 */
	getColor: function(data){
		return data.color || [0, 0, 0, 255];			
    },
	
	/**
	 * 半径GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
	 * @param {Array} points
	 * @returns {Int} count
	 * @default points.length
	 * @description 半径，以米为单位。
	 */
    getRadius: function(data){
    	return data.radius || 1;    		
    },

    /**
     * DeckGL可视化对象
     * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.DeckGL}
     */
	_parent: null,
	
    /**
     * @name 构造函数。
     * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.options = options;
        GeoGlobe.Util.extend(this, options);
    },
	
    /**
     * 关联DeckGL
     * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
     * @param {GeoGlobe.Visuals.DeckGL} deckgl 
     */
    addTo: function(deckgl){
    	this._parent = deckgl;
    	this._parent.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
     */
    remove: function(){
    	this._parent.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
     */
    render: function(){
    	this._parent.render();
    },
    
    /**
     * 获取deckgl内部layer实例
     * @memberof GeoGlobe.Visuals.DeckGL.ScatterplotLayer.prototype
     * @returns {Object} layer
     */
    getInnerLayer: function(){
    	var option = {};
    	GeoGlobe.Util.extend(option, this);
    	return new deck.ScatterplotLayer(option);
    }
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.DeckGL.GeoJsonLayer
 * @classdesc 基于DeckGL的GeoJSON图层
 * @example
//构造地图对象
var map = new GeoGlobe.Map({
    style: Cfg.style,
    container: 'map',
    zoom: 6.6,
    bearing: -27.396674584323023,
    pitch: 40.5,
    units: "degrees",
    center: [-1.4157267858730052,52.232395363869415]
});
//构造DeckGL可视化图层
var deckgl = new GeoGlobe.Visuals.DeckGL();
//绑定初始构建事件
deckgl.on('overlayerinit', function(e){

});
//绑定鼠标点击事件
deckgl.on('overlayerclick', function(e,a,b){

});
//绑定鼠标移动事件
deckgl.on('overlayerhover', function(e,a,b){

})
//添加到地图中
deckgl.addTo(map);
//构造图层
var geoJsonLayer = new GeoGlobe.Visuals.DeckGL.GeoJsonLayer({
	id: 'geojson-layer',
	data: [
		{ "type": "Feature", "properties": {}, "geometry": { "type": "Polygon", "coordinates": [ [ [ 114.22313690185547, 30.51213917605451 ], [ 114.29986953735351, 30.51213917605451 ], [ 114.29986953735351, 30.5665474527005 ], [ 114.22313690185547, 30.5665474527005 ], [ 114.22313690185547, 30.51213917605451 ] ] ] } }
	],
	visible: true,
	pickable: true,
	fp64: false,
	stroked: false,
	filled: true,
	extruded: true,
	wireframe: true,
	getElevation: function(f){return Math.sqrt(f.properties.valuePerSqm) * 10;},
	getFillColor: function(f){return [f.properties.growth * 255, 140, 200 * (1 - f.properties.growth)];},
	getLineColor: function(f){return [255, 255, 255];}
});
//添加到DeckGL图层
geoJsonLayer.addTo(deckgl);
//绘制
deckgl.render();
 */

GeoGlobe.Visuals.DeckGL.GeoJsonLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 图层名称
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {String}
	 * @default ''
	 */
	name: '',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否开启鼠标拾取
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 是否开启高精度64位模式
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	fp64: false,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @description geojson结构
	 * @type {Array}
	 * @example 
	 * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "1号柱"
	 * 	},
	 * "geometry": {
	 * 		"type": "Point",
	 * 		"coordinates": [114.20257245367856, 30.773372078561778]
	 * 	}
	 * }]
	 */
	data: [],
	
	/**
	 * 是否绘制填充多边形
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 * @description 是否绘制填充多边形（固体填充）。请注意，对于每个多边形，只有外部多边形和任何孔之间的区域将被填充。只有当多边形没有被挤压时，这个支柱才是有效的。
	 */
	filled: true,
	
	/**
	 * 是否在多边形周围绘制轮廓
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 是否在多边形周围绘制轮廓（实心填充）。 注意对于复杂多边形，外部多边形以及外部多边形将绘制任何洞。
	 */
	stroked: false,
	
	/**
	 * 是否拉伸面
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 如果设置为true，则沿z轴挤出Polygon和MultiPolygon要素。 使用getElevation访问器获取绘制要素的高度。
	 */
	extruded: false,
	
	/**
	 * 是否生成六边形的线框
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 是否生成六边形的线框。 轮廓将具有关闭顶部和底部多边形的“水平”线以及多边形上每个顶点的垂直线（“支柱”）。备注：这些线条用GL.LINE渲染，因此总是1像素宽。线框和实体挤出是独占的，如果您想要组合渲染效果，则需要使用相同的数据创建两个图层。这仅在挤出的prop设置为true时有效。
	 */
	wireframe: false,
	
	/**
	 * 线宽倍数
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 如果stroked属性为true，则线宽乘数乘以所有线，包括LineString和MultiLineString要素以及Polygon和MultiPolygon要素的轮廓。
	 */
	lineWidthScale: 1,
	
	/**
	 * 最小线宽
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Int}
	 * @default 0
	 * @description 最小线宽（以像素为单位）。
	 */
	lineWidthMinPixels: 0,
	
	/**
	 * 最大线宽
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Int}
	 * @default Number.MAX_SAFE_INTEGER
	 * @description 最大线宽（以像素为单位）。
	 */
	lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
	
	/**
	 * 关节类型
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 关节类型。 如果是，则绘制圆形关节。 否则绘制斜接接头。
	 */
	lineJointRounded: false,
	
	/**
	 * 关节的最大范围与笔划宽度的比率
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Int}
	 * @default 4
	 * @description 关节的最大范围与笔划宽度的比率。 仅在lineJointRounded为false时有效。
	 */
	lineMiterLimit: 4,
	
	/**
	 * 高程乘数
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 高程乘数。 最终高程由elevationScale * getElevation（d）计算。 elevationScale是一个方便的属性，可以在不更新数据的情况下缩放所有多边形高程。
	 */
	elevationScale: 1,
	
	/**
	 * 高程乘数
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 高程乘数。 最终高程由elevationScale * getElevation（d）计算。 elevationScale是一个方便的属性，可以在不更新数据的情况下缩放所有多边形高程。
	 */
	pointRadiusScale: 1,
	
	/**
	 * 点的最小半径
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 最小半径（像素）。
	 */
	pointRadiusMinPixels: 0,
	
	/**
	 * 点的最大半径
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Int}
	 * @default Number.MAX_SAFE_INTEGER
	 * @description 最大半径（像素）。
	 */
	pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,

	/**
	 * 灯光设置
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @type {Object}
	 * @default {}
	 * @description 灯光设置的对象
	 */
	lightSettings: {},

	/**
	 * 线颜色GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} [0, 0, 0, 255]
	 * @default data.properties.lineColor
	 */
	getLineColor:function(data){
		return data.properties.lineColor || [0, 0, 0, 255];
	},
	
	/**
	 * 填充颜色GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} [0, 0, 0, 255]
	 * @default data.properties.fillColor
	 */
	getFillColor: function(data){
		return data.properties.fillColor || [0, 0, 0, 255];
	},
	
	/**
	 * 半径GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Int} radius
	 * @default data.properties.radius | data.properties.size
	 * @description 半径，以米为单位。
	 */
    getRadius: function(data){
    	return data.properties.radius || data.properties.size || 1;   		
    },
	
	/**
	 * 线宽度GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Int} lineWidth
	 * @default data.properties.lineWidth
	 */
    getLineWidth: function(data){
    	return data.properties.lineWidth || 1;
    },
    
	/**
	 * 高程GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Int} elevation
	 * @default data.properties.elevation
	 */
    getElevation: function(data){
    	return data.properties.elevation || 1000;
    },

    /**
     * DeckGL可视化对象
     * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.DeckGL}
     */
	_parent: null,
	
    /**
     * @name 构造函数。
     * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.options = options;
        GeoGlobe.Util.extend(this, options);
    },
	
    /**
     * 关联DeckGL
     * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
     * @param {GeoGlobe.Visuals.DeckGL} deckgl 
     */
    addTo: function(deckgl){
    	this._parent = deckgl;
    	this._parent.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
     */
    remove: function(){
    	this._parent.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
     */
    render: function(){
    	this._parent.render();
    },
    
    /**
     * 获取deckgl内部layer实例
     * @memberof GeoGlobe.Visuals.DeckGL.GeoJsonLayer.prototype
     * @returns {Object} layer
     */
    getInnerLayer: function(){
    	var option = {};
    	GeoGlobe.Util.extend(option, this);
    	return new deck.GeoJsonLayer(option);
    }
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.DeckGL.PolygonLayer
 * @classdesc 基于DeckGL的多边形图层
 * @example
//构造地图对象
var map = new GeoGlobe.Map({
	style: Cfg.style,
	container: 'map',
	zoom: 11,
	bearing: 0,
	pitch: 45,
	units: "degrees",
	center: [-123.13,49.254]
});
//构造DeckGL可视化图层
var deckgl = new GeoGlobe.Visuals.DeckGL();
//绑定初始构建事件
deckgl.on('overlayerinit', function(o){
	o.param.enable(o.param.DEPTH_TEST);
	o.param.depthFunc(o.param.LEQUAL);
});
//绑定鼠标点击事件
deckgl.on('overlayerclick', function(e,a,b){

});
//绑定鼠标移动事件
deckgl.on('overlayerhover', function(o,a,b){

})
//添加到地图中
deckgl.addTo(map);
//构造图层
var polygonLayer = new GeoGlobe.Visuals.DeckGL.PolygonLayer({
	id: 'polygon-layer',
	data: [
		{ "type": "Feature", "properties": {}, "geometry": { "type": "Polygon", "coordinates": [ [ [ 114.22313690185547, 30.51213917605451 ], [ 114.29986953735351, 30.51213917605451 ], [ 114.29986953735351, 30.5665474527005 ], [ 114.22313690185547, 30.5665474527005 ], [ 114.22313690185547, 30.51213917605451 ] ] ] } }
	],
	visible: true,
	pickable: true,
	fp64: false,
	stroked: false,
	filled: true,
	extruded: true,
	wireframe: false,
	getFillColor: function(d){if(d.height>380){return [255,10,10];} else{return [240,143,96];}}
});
 */

GeoGlobe.Visuals.DeckGL.PolygonLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 图层名称
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {String}
	 * @default ''
	 */
	name: '',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否开启鼠标拾取
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 是否开启高精度64位模式
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	fp64: false,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @description geojson结构
	 * @type {Array}
	 * @example 
	 * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "正方形"
	 * 	},
	 * "geometry": {
	 * 		"type": "Polygon",
	 * 		"coordinates": [ [ [ 114.22313690185547, 30.51213917605451 ], [ 114.29986953735351, 30.51213917605451 ], [ 114.29986953735351, 30.5665474527005 ], [ 114.22313690185547, 30.5665474527005 ], [ 114.22313690185547, 30.51213917605451 ] ] ]
	 * 	}
	 * }]
	 */
	data: [],
	
	/**
	 * 是否绘制填充多边形
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Boolean}
	 * @default true
	 * @description 是否绘制填充多边形（固体填充）。请注意，对于每个多边形，只有外部多边形和任何孔之间的区域将被填充。只有当多边形没有被挤压时，这个支柱才是有效的。
	 */
	filled: true,
	
	/**
	 * 是否在多边形周围绘制轮廓
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 是否在多边形周围绘制轮廓（实心填充）。 注意对于复杂多边形，外部多边形以及外部多边形将绘制任何洞。
	 */
	stroked: false,
	
	/**
	 * 是否拉伸面
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 如果设置为true，则沿z轴挤出Polygon和MultiPolygon要素。 使用getElevation访问器获取绘制要素的高度。
	 */
	extruded: false,
	
	/**
	 * 是否生成六边形的线框
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 是否生成六边形的线框。 轮廓将具有关闭顶部和底部多边形的“水平”线以及多边形上每个顶点的垂直线（“支柱”）。备注：这些线条用GL.LINE渲染，因此总是1像素宽。线框和实体挤出是独占的，如果您想要组合渲染效果，则需要使用相同的数据创建两个图层。这仅在挤出的prop设置为true时有效。
	 */
	wireframe: false,
	
	/**
	 * 线宽倍数
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 如果stroked属性为true，则线宽乘数乘以所有线，包括LineString和MultiLineString要素以及Polygon和MultiPolygon要素的轮廓。
	 */
	lineWidthScale: 1,
	
	/**
	 * 最小线宽
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Int}
	 * @default 0
	 * @description 最小线宽（以像素为单位）。
	 */
	lineWidthMinPixels: 0,
	
	/**
	 * 最大线宽
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Int}
	 * @default Number.MAX_SAFE_INTEGER
	 * @description 最大线宽（以像素为单位）。
	 */
	lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
	
	/**
	 * 关节类型
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Boolean}
	 * @default false
	 * @description 关节类型。 如果是，则绘制圆形关节。 否则绘制斜接接头。
	 */
	lineJointRounded: false,
	
	/**
	 * 关节的最大范围与笔划宽度的比率
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Int}
	 * @default 4
	 * @description 关节的最大范围与笔划宽度的比率。 仅在lineJointRounded为false时有效。
	 */
	lineMiterLimit: 4,
	
	/**
	 * 高程乘数
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Int}
	 * @default 1
	 * @description 高程乘数。 最终高程由elevationScale * getElevation（d）计算。 elevationScale是一个方便的属性，可以在不更新数据的情况下缩放所有多边形高程。
	 */
	elevationScale: 1,
	
	/**
	 * 灯光设置
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @type {Object}
	 * @default {}
	 * @description 灯光设置的对象
	 */
	lightSettings: {},

	/**
	 * 多边形GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} Polygon
	 * @default ata.geometry.coordinates
	 */
	getPolygon: function(data){
		if (data.geometry.type === 'Polygon') {
            return data.geometry.coordinates;
        } else {
            return null;
        }
	},
	
	/**
	 * 线颜色GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} [0, 0, 0, 255]
	 * @default data.properties.lineColor
	 */
	getLineColor:function(data){
		return data.properties.lineColor || [0, 0, 0, 255];
	},
	
	/**
	 * 填充颜色GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} [0, 0, 0, 255]
	 * @default data.properties.fillColor
	 */
	getFillColor: function(data){
		return data.properties.fillColor || [0, 0, 0, 255];
	},
	
	/**
	 * 线宽度GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Int} lineWidth
	 * @default data.properties.lineWidth
	 */
    getLineWidth: function(data){
    	return data.properties.lineWidth || 1;
    },
    
	/**
	 * 高程GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Int} elevation
	 * @default data.properties.elevation
	 */
    getElevation: function(data){
    	return data.properties.elevation || 1000;
    },

    /**
     * DeckGL可视化对象
     * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.DeckGL}
     */
	_parent: null,
	
    /**
     * @name 构造函数。
     * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.options = options;
        GeoGlobe.Util.extend(this, options);
    },
	
    /**
     * 关联DeckGL
     * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
     * @param {GeoGlobe.Visuals.DeckGL} deckgl 
     */
    addTo: function(deckgl){
    	this._parent = deckgl;
    	this._parent.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
     */
    remove: function(){
    	this._parent.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
     */
    render: function(){
    	this._parent.render();
    },
    
    /**
     * 获取deckgl内部layer实例
     * @memberof GeoGlobe.Visuals.DeckGL.PolygonLayer.prototype
     * @returns {Object} layer
     */
    getInnerLayer: function(){
    	var option = {};
    	GeoGlobe.Util.extend(option, this);
    	return new deck.PolygonLayer(option);
    }
})/**
 * @author liuck
 * @class GeoGlobe.Visuals.DeckGL.LineLayer
 * @classdesc 基于DeckGL的线图层
 * @example
//构造地图对象
var map = new GeoGlobe.Map({
	style: Cfg.style,
	container: 'map',
	zoom: 4.5,
	bearing: 27.2,
	pitch: 50,
	units: "degrees",
	center: [-0.244029,51.517662]
});
//构造DeckGL可视化图层
var deckgl = new GeoGlobe.Visuals.DeckGL();
//绑定初始构建事件
deckgl.on('overlayerinit', function(o){
	o.param.enable(o.param.DEPTH_TEST);
	o.param.depthFunc(o.param.LEQUAL);
});
//绑定鼠标点击事件
deckgl.on('overlayerclick', function(e,a,b){

});
//绑定鼠标移动事件
deckgl.on('overlayerhover', function(o,a,b){

})
//添加到地图中
deckgl.addTo(map);
//构造图层
var lineLayer = new GeoGlobe.Visuals.DeckGL.LineLayer({
	id: 'line-layer',
	data: [
		{ "type": "Feature", "properties": {}, "geometry": { "type": "LineString", "coordinates": [[114.27467721499235,30.61823619840472],[114.29877951124801,30.64353276353745]] } }
	],
	visible: true,
	pickable: true,
	fp64: false,
	opacity: 0.6,
	strokeWidth: 10,
	getColor: function(){return [255,0,0]}
});
//添加到DeckGL图层
lineLayer.addTo(deckgl);
//绘制
deckgl.render();
*/
GeoGlobe.Visuals.DeckGL.LineLayer = GeoGlobe.Class4OL({
    /**
     * 图层id
     * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
     * @type {String}
     * @default '1'
     */
	id: '1',
	
	/**
	 * 图层名称
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @type {String}
	 * @default ''
	 */
	name: '',
	
	/**
	 * 可见性
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	visible: true,
	
	/**
	 * 是否开启鼠标拾取
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	pickable: true,
	
	/**
	 * 是否开启高精度64位模式
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @type {Boolean}
	 * @default true
	 */
	fp64: false,
	
	/**
	 * 数据
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @description geojson结构
	 * @type {Array}
	 * @example 
	 * [{
	 * "type": "Feature",
	 * "properties": {
	 * 		"id": 10001,
	 *		"name": "1号线"
	 * 	},
	 * "geometry": {
	 * 		"type": "LineString",
	 * 		"coordinates": [[114.27467721499235,30.61823619840472],[114.29877951124801,30.64353276353745]]
	 * 	}
	 * }]
	 */
	data: [],
	
	/**
	 * 起始点GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} 
	 * @default data.geometry.coordinates[0]
	 */
	getSourcePosition: function(data){
		if (data.geometry.type === 'LineString') {
            return data.geometry.coordinates[0];
        } else {
            return null;
        }
	},
	
	/**
	 * 终止点GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} 
	 * @default data.geometry.coordinates[1]
	 */
	getTargetPosition: function(data){
		if (data.geometry.type === 'LineString') {
            return data.geometry.coordinates[1];
        } else {
            return null;
        }
	},
	
	/**
	 * 颜色GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Array} [0, 0, 0, 255]
	 * @default data.properties.color
	 */
	getColor: function(data){
		return data.properties.color || [0, 0, 0, 255];
	},
	
	/**
	 * 宽度GET属性
	 * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
	 * @param {Feature} data - geojson中的一个Feature
	 * @returns {Int} 1
	 * @default 1
	 */
	getStrokeWidth: function(data){
		return 1;
	},

    /**
     * DeckGL可视化对象
     * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
     * @private 
     * @type {GeoGlobe.Visuals.DeckGL}
     */
	_parent: null,
	
    /**
     * @name 构造函数。
     * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
     * @private 
     * @param {Object}  options -  参数对象
     */
    initialize: function(options){
    	this.options = options;
        GeoGlobe.Util.extend(this, options);
    },
	
    /**
     * 关联DeckGL
     * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
     * @param {GeoGlobe.Visuals.DeckGL} deckgl 
     */
    addTo: function(deckgl){
    	this._parent = deckgl;
    	this._parent.addLayer(this);
    },
    
    /**
     * 从父对象中移除自己
     * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
     */
    remove: function(){
    	this._parent.removeLayer(this.id);
    },
    
    /**
     * 绘制
     * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
     */
    render: function(){
    	this._parent.render();
    },
    
    /**
     * 获取deckgl内部layer实例
     * @memberof GeoGlobe.Visuals.DeckGL.LineLayer.prototype
     * @returns {Object} layer
     */
    getInnerLayer: function(){
    	var option = {};
    	GeoGlobe.Util.extend(option, this);
    	return new deck.LineLayer(option);
    }
})